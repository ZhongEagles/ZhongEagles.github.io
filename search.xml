<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux-keepalived-05 keepalived+HAProxy+Mysql（双主）部署]]></title>
    <url>%2Fkeepalived-05%2F</url>
    <content type="text"><![CDATA[linux-keepalived-05 keepalived+HAProxy+Mysql（双主）部署环境准备node1（HAProxy1+keepalived主）：192.168.141.53node2（HAProxy2+keepalived从）：192.168.141.69node3（Mysql1主）：192.168.141.12node4（Mysql2主）：192.168.141.132VIP：192.168.10.100 Mysql部署（双主）node3 1234567891011121314151617181920212223242526272829303132333435363738394041[root@node3 ~]# vim node3.sh[root@node3 ~]# cat node3.sh #!/bin/bashIp_addr=&quot;192.168.141.132&quot; # 修改为对端的node地址User_pwd=&quot;000000&quot;systemctl stop firewalldsetenforce 0yum install mariadb-server -ysed -i &apos;/^\[mysqld\]$/a\binlog-ignore = information_schema&apos; /etc/my.cnf.d/server.cnfsed -i &apos;/^\[mysqld\]$/a\binlog-ignore = mysql&apos; /etc/my.cnf.d/server.cnfsed -i &apos;/^\[mysqld\]$/a\skip-name-resolve&apos; /etc/my.cnf.d/server.cnfsed -i &apos;/^\[mysqld\]$/a\auto-increment-increment = 1&apos; /etc/my.cnf.d/server.cnf # 注意node4节点上必须不同sed -i &apos;/^\[mysqld\]$/a\log-bin = mysql-bin&apos; /etc/my.cnf.d/server.cnfsed -i &apos;/^\[mysqld\]$/a\auto_increment_offset = 1&apos; /etc/my.cnf.d/server.cnf # 注意node4节点上必须不同sed -i &apos;/^\[mysqld\]$/a\server-id = 1&apos; /etc/my.cnf.d/server.cnf # 注意node4节点上必须不同systemctl restart mariadbmysql -uroot -e &quot;grant replication slave on *.* to &apos;repuser&apos;@&apos;$Ip_addr&apos; identified by &apos;$User_pwd&apos;;&quot;[root@node3 ~]# chmod +x node3.sh [root@node3 ~]# ./node3.sh node4:[root@node4 ~]# vim node4.sh[root@node4 ~]# cat node4.sh #!/bin/bashIp_addr=&quot;192.168.141.12&quot; # 修改为对端的node地址User_pwd=&quot;000000&quot;systemctl stop firewalldsetenforce 0yum install mariadb-server -ysed -i &apos;/^\[mysqld\]$/a\binlog-ignore = information_schema&apos; /etc/my.cnf.d/server.cnfsed -i &apos;/^\[mysqld\]$/a\binlog-ignore = mysql&apos; /etc/my.cnf.d/server.cnfsed -i &apos;/^\[mysqld\]$/a\skip-name-resolve&apos; /etc/my.cnf.d/server.cnfsed -i &apos;/^\[mysqld\]$/a\auto-increment-increment = 2&apos; /etc/my.cnf.d/server.cnf # 注意node3节点上必须不同sed -i &apos;/^\[mysqld\]$/a\log-bin = mysql-bin&apos; /etc/my.cnf.d/server.cnfsed -i &apos;/^\[mysqld\]$/a\auto_increment_offset = 2&apos; /etc/my.cnf.d/server.cnf # 注意node3节点上必须不同sed -i &apos;/^\[mysqld\]$/a\server-id = 2&apos; /etc/my.cnf.d/server.cnf # 注意node3节点上必须不同systemctl restart mariadbmysql -uroot -e &quot;grant replication slave on *.* to &apos;repuser&apos;@&apos;$Ip_addr&apos; identified by &apos;$User_pwd&apos;;&quot;[root@node4 ~]# chmod +x node4.sh [root@node4 ~]# ./node4.sh 初始化数据库，初始密码为空，直接回车即可。然后设置数据库root密码为123456，之后一路敲y回车即可。node3如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[root@node3 ~]# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&apos;ll need the currentpassword for the root user. If you&apos;ve just installed MariaDB, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] yNew password: Re-enter new password: Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from &apos;localhost&apos;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] y ... Success!By default, MariaDB comes with a database named &apos;test&apos; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you&apos;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB![root@node3 ~]# node4如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[root@node4 ~]# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&apos;ll need the currentpassword for the root user. If you&apos;ve just installed MariaDB, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] yNew password: Re-enter new password: Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from &apos;localhost&apos;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] y ... Success!By default, MariaDB comes with a database named &apos;test&apos; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you&apos;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB![root@node4 ~]# 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576[root@node3 ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 12Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; show master status;+------------------+----------+--------------+--------------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+--------------------------+| mysql-bin.000003 | 1642 | | mysql,information_schema |+------------------+----------+--------------+--------------------------+1 row in set (0.00 sec)MariaDB [(none)]&gt; 查询node4节点master状态[root@node4 ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 11Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; show master status;+------------------+----------+--------------+--------------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+--------------------------+| mysql-bin.000003 | 1721 | | mysql,information_schema |+------------------+----------+--------------+--------------------------+1 row in set (0.00 sec)MariaDB [(none)]&gt;在node3节点执行连接命令：MariaDB [(none)]&gt; change master to master_host=&apos;192.168.141.132&apos;,master_port=3306,master_user=&apos;repuser&apos;,master_password=&apos;000000&apos;,master_log_file=&apos;mysql-bin.000003&apos;,master_log_pos=1642;Query OK, 0 rows affected (0.01 sec)MariaDB [(none)]&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [mysql]&gt; start slave;Query OK, 0 rows affected (0.00 sec)MariaDB [mysql]&gt; 在node4节点执行连接命令：MariaDB [(none)]&gt; change master to master_host=&apos;192.168.141.12&apos;,master_port=3306,master_user=&apos;repuser&apos;,master_password=&apos;000000&apos;,master_log_file=&apos;mysql-bin.000003&apos;,master_log_pos=1721;Query OK, 0 rows affected (0.02 sec)MariaDB [(none)]&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [mysql]&gt; start slave;Query OK, 0 rows affected (0.00 sec)MariaDB [mysql]&gt; 注意：master_user=’repuser’,master_password=’000000’设置的用户名密码， master_log_file=’mysql-bin.000003’,master_log_pos=1721中的值对应的是上面的File和Position的值。 HAProxy部署在node1和node2上执行以下脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667[root@node1 ~]# vim node1_haproxy.sh[root@node1 ~]# cat node1_haproxy.sh #!/bin/bashyum install haproxy -ymv /etc/haproxy/haproxy.cfg&#123;,.bak&#125;cat &gt; /etc/haproxy/haproxy.cfg &lt;&lt; EOFglobal log 127.0.0.1 local2 chroot /var/lib/haproxy pidfile /var/run/haproxy.pid maxconn 4000 user haproxy group haproxy daemon stats socket /var/lib/haproxy/statslisten mysql_proxy bind 0.0.0.0:3306 mode tcp balance source server mysqldb1 192.168.141.12:3306 weight 1 check server mysqldb2 192.168.141.132:3306 weight 2 checklisten stats mode http bind 0.0.0.0:8080 stats enable stats uri /dbs stats realm haproxy\ statistics stats auth admin:adminEOFsystemctl start haproxy[root@node1 ~]# chmod +x node1_haproxy.sh [root@node1 ~]# ./node1_haproxy.sh node2和node1脚本内容是一样的[root@node2 ~]# vim node2_haproxy.sh[root@node2 ~]# cat node2_haproxy.sh #!/bin/bashyum install haproxy -ymv /etc/haproxy/haproxy.cfg&#123;,.bak&#125;cat &gt; /etc/haproxy/haproxy.cfg &lt;&lt; EOFglobal log 127.0.0.1 local2 chroot /var/lib/haproxy pidfile /var/run/haproxy.pid maxconn 4000 user haproxy group haproxy daemon stats socket /var/lib/haproxy/statslisten mysql_proxy bind 0.0.0.0:3306 mode tcp balance source server mysqldb1 192.168.141.12:3306 weight 1 check server mysqldb2 192.168.141.132:3306 weight 2 checklisten stats mode http bind 0.0.0.0:8080 stats enable stats uri /dbs stats realm haproxy\ statistics stats auth admin:adminEOFsystemctl start haproxy[root@node2 ~]# chmod +x node2_haproxy.sh [root@node2 ~]# ./node2_haproxy.sh 注意：bind 0.0.0.0:8080指的是8080端口 stats auth admin:admin表示haproxy的用户名密码均为admin 测试haproxy的可用性 node1 node2 测试成功，成功登录上了haproxy的服务界面 Keepalived部署这个脚本建立在node1上即可，node2不需要。 12345678910111213[root@node1 ~]# vim /usr/local/src/check_proxy_pid.sh[root@node1 ~]# cat /usr/local/src/check_proxy_pid.sh#!/bin/bashA=`ps -C haproxy --no-header |wc -l` if [ $A == 0 ];then exit 1 else exit 0 fi[root@node1 ~]# cd /usr/local/src/[root@node1 src]# chmod +x check_proxy_pid.sh [root@node1 src]# cd[root@node1 ~]# 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071node1上执行脚本：[root@node1 ~]# vim node1_keepalived.sh [root@node1 ~]# cat node1_keepalived.sh #!/bin/bashyum install keepalived -ymv /etc/keepalived/keepalived.conf&#123;,.bak&#125;cat &gt; /etc/keepalived/keepalived.conf &lt;&lt; EOF! Configuration File for keepalivedglobal_defs &#123; router_id node1&#125;vrrp_script chk_http_port &#123; script &quot;/usr/local/src/check_proxy_pid.sh&quot; interval 1 weight -20&#125;vrrp_instance VI_1 &#123; state MASTER interface ens33 virtual_router_id 10 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; track_script &#123; chk_http_port &#125; virtual_ipaddress &#123; 192.168.141.100 &#125;&#125;EOFsystemctl start keepalivedsystemctl stop firewalld[root@node1 ~]# chmod +x node1_keepalived.sh [root@node1 ~]# ./node1_keepalived.sh node2上执行脚本：[root@node2 ~]# vim node2_keepalived.sh[root@node2 ~]# cat node2_keepalived.sh #!/bin/bashyum install keepalived -ymv /etc/keepalived/keepalived.conf&#123;,.bak&#125;cat &gt; /etc/keepalived/keepalived.conf &lt;&lt; EOF! Configuration File for keepalivedglobal_defs &#123; router_id node2&#125;vrrp_instance VI_1 &#123; state MASTER interface ens33 virtual_router_id 10 priority 90 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.141.100 &#125;&#125;EOFsystemctl start keepalivedsystemctl stop firewalld[root@node2 ~]# chmod +x node2_keepalived.sh [root@node2 ~]# ./node2_keepalived.sh 测试测试vip的可用性，访问http://192.168.141.100:8080/dbs 用户名密码均为admin 可以看到vip是可用的。 检测keepalived的vip是否可以正常漂移 首先记住要关闭node1和node2的防火墙！ 12[root@node1 ~]# systemctl stop firewalld[root@node2 ~]# systemctl stop firewalld node1 12345678910111213141516[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# node2 1234567891011121314[root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 停止node1的Keepalived服务，观察VIP是否漂移，访问正常 123456789101112131415[root@node1 ~]# systemctl stop keepalived[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# 可以看到vip现在已经转移到了node2上面 12345678910111213141516[root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 测试漂移后的vip的可用性 由于keepalived主设备的选举默认是抢占模式的，所以我们重启node1的keepalived之后，vip能够重新自node2上面漂移回到node1上面。 1234567891011121314151617[root@node1 ~]# systemctl restart keepalived[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# 可以看到vip已经漂移回到node1上了 1234567891011121314[root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 停止node1节点上的HAProxy服务，观察VIP是否漂移，vip是否还能正常访问 123456789101112131415161718192021222324252627282930313233[root@node1 ~]# systemctl stop haproxy[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# [root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 可以看到vip正常漂移到了node2上面，而且vip仍然可以正常访问 然后重启node1节点上的HAProxy服务，观察VIP是否漂移回来，vip是否还能正常访问 1234567891011121314151617181920212223242526272829303132333435[root@node1 ~]# systemctl restart haproxy[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# [root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 可以看到vip漂移回到了node1上面，而且vip仍然可以正常访问。 现在开始检测haproxy对后端两台mysql服务器的监控 开启node3的mariadb服务 12[root@node3 ~]# systemctl restart mariadb[root@node3 ~]# systemctl enable mariadb 再看监控界面，可以看到mysqldb1那一行变成了绿色 同理，将node4的mariadb服务也开启一下 12[root@node4 ~]# systemctl restart mariadb[root@node4 ~]# systemctl enable mariadb 再看监控界面，可以看到mysqldb2那一行也变成了绿色 因此，当node3或者node4的mariadb服务发生异常的时候，我们可以通过监控界面及时发现。 接下来进行mysql远程连接测试 先在360软件管家下载一个navicat 可以看到它的有效期是14天，很鸡肋，这是百度经验上如何激活navicat的教程，亲测有效 https://jingyan.baidu.com/article/495ba841b239e638b20ede4a.html 先在node3上的mysql里创建test用户 12345678910111213141516171819202122232425262728[root@node3 ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 6Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; create user test@localhost identified by &apos;123456&apos;;MariaDB [(none)]&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [mysql]&gt; select Host,User,Password from user where User= &apos;test&apos;;+-----------+------+-------------------------------------------+| Host | User | Password |+-----------+------+-------------------------------------------+| localhost | test | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |+-----------+------+-------------------------------------------+1 row in set (0.01 sec)MariaDB [mysql]&gt; MariaDB [mysql]&gt; quitBye[root@node3 ~]# 授权允许任意远程主机以test的身份连接node3的数据库 123456789101112131415161718192021[root@node3 ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 7Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; update mysql.user set host = &apos;%&apos; where user =&apos;test&apos; limit 1;Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 1MariaDB [(none)]&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; quitBye[root@node3 ~]# systemctl restart mariadb.service [root@node3 ~]# 再使用远程主机连接192.168.141.12的3306端口，这里我们的windows对于node3就算是远程主机了。 可以看到连接是成功的 测试完这个连接，我们现在需要把它删除掉 然后测试远程主机连接192.168.141.100的3306端口，可以发现被拒了，是不是很难受？分析一下，可以发现拒绝我们的并非是node3，而是当前vip所在主机也就是node1。 我们之前已经关闭了node1的防火墙和selinux，可以通过vip正常访问haproxy监控页面，可以正常连接node3的数据库，然而通过远程连接vip的3306端口来连接后端数据库居然是被拒绝的，为什么？ 因为，在这种服务体系架构中，一旦别人可以通过远程连接vip的3306端口来连接后端数据库，那还了得？那还有什么安全性可言呢？ 例如现在咱们在node3后node4上面都搭建了一个wordpress博客，博客所用数据库就放在node3和node4上面。我们的node1和node2通过反向代理，让别人通过访问node1和node2来访问后端的node3和node4上面的wordpress博客，可以避免我们的后端数据库直接暴露在访问者的面前。现在我们实现了高可用，别人访问我们的wordpress博客，看到的只是vip：192.168.141.100，他们不会知道后端node3和node4的具体存在，这让我们得以保护好弄得3和node4上面的数据库，然后又不妨碍我们内部人员知道node3和node4这些后端具体服务器ip的人去连接数据库。 所以，远程主机连接192.168.141.100的3306端口被拒绝是正常的，这是我们对后端数据库的保护措施。 接下来，重新使用远程主机连接node3也就是192.168.141.12的3306端口，可以看到连接成功。 现在关闭node3上的mariadb服务，再次查看连接可以看到连接失败。 1[root@node3 ~]# systemctl stop mariadb 现在重启node3上的mariadb服务，再次查看连接可以看到连接成功。 1[root@node3 ~]# systemctl restart mariadb 还记得我们初始化数据库时设置的root密码吗？往上翻翻可以看到是123456。接下来我们使用root用户来连接一下node3的数据库，可以看到连接失败。 现在我们要让root用户也可以连接node3的数据库。 123456789101112131415161718192021[root@node3 ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 6Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; update mysql.user set host = &apos;%&apos; where user =&apos;root&apos; limit 1;Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 1MariaDB [(none)]&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; quitBye[root@node3 ~]# systemctl restart mariadb.service [root@node3 ~]# 再次使用root用户来连接一下node3的数据库，可以看到连接成功。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-keepalived-04 keepalived+Nginx+Apache部署]]></title>
    <url>%2Fkeepalived-04%2F</url>
    <content type="text"><![CDATA[linux-keepalived-04 keepalived-+Nginx+Apache部署实验要求：node1、node2作为nginx代理服务器 node3、node4作为web服务器接，搭建apache服务即可。 在nginx配置中使用 修改日志格式，加上客户端的源ip，让web能知道是谁访问了他 初始准备实验环境node1（nginx1+keepalived主）：192.168.141.53node2（nginx2+keepalived从）：192.168.141.69node3（web1）：192.168.141.12node4（web2）：192.168.141.132VIP：192.168.10.100 node1、node2 注意：node1、node2的防火墙必须关闭掉，不能像noed3、node4一样仅仅添加策略放行相应端口。如果node1、node2的防火墙没有关闭掉，那么会出现Nginx + keepalived高可用主备服务器均有VIP的问题。另外，如果二者keepalived的配置文件中virtual_router_id不同的话，也会出现Nginx + keepalived高可用主备服务器均有VIP的问题。 123456789101112[root@node1 ~]# systemctl stop firewalld[root@node1 ~]# vim /etc/selinux/config [root@node1 ~]# cat /etc/selinux/config |grep SELINUX# SELINUX= can take one of these three values:SELINUX=disabled# SELINUXTYPE= can take one of three two values:SELINUXTYPE=targeted [root@node1 ~]#[root@node1 ~]# setenforce 0[root@node1 ~]# getenforce Permissive[root@node1 ~]# noed3、node4 12345678910111213141516[root@node3 ~]# firewall-cmd --add-port=&#123;80,8080&#125;/tcp --permanentsuccess[root@node3 ~]# firewall-cmd --reloadsuccess[root@node3 ~]# [root@node3 ~]# vim /etc/selinux/config [root@node3 ~]# cat /etc/selinux/config |grep SELINUX# SELINUX= can take one of these three values:SELINUX=disabled# SELINUXTYPE= can take one of three two values:SELINUXTYPE=targeted [root@node3 ~]#[root@node3 ~]# setenforce 0[root@node3 ~]# getenforce Permissive[root@node3 ~]# nginx部署node1、node2 12[root@node2 ~]# yum install epel-release -y[root@node2 ~]# yum install nginx -y node1 123456789101112131415161718[root@node1 ~]# cd /etc/nginx/conf.d/[root@node1 conf.d]# vim proxy.conf [root@node1 conf.d]# cat proxy.conf upstream websers&#123; server 192.168.141.12; server 192.168.141.132;&#125;server&#123; listen 8080; server_name 192.168.141.53; location / &#123; proxy_pass http://websers; &#125;&#125;[root@node1 conf.d]# [root@node1 conf.d]# systemctl restart nginx[root@node1 conf.d]# nginx -s reload[root@node1 conf.d]# node2 123456789101112131415161718[root@node1 ~]# cd /etc/nginx/conf.d/[root@node1 conf.d]# vim proxy.conf [root@node1 conf.d]# cat proxy.conf upstream websers&#123; server 192.168.141.12; server 192.168.141.132;&#125;server&#123; listen 8080; server_name 192.168.141.69; location / &#123; proxy_pass http://websers; &#125;&#125;[root@node1 conf.d]# [root@node1 conf.d]# systemctl restart nginx[root@node1 conf.d]# nginx -s reload[root@node1 conf.d]# 注意：这里也可以设置权重和端口号 1234upstream websers &#123;server 192.168.141.12:8080 weight=3;# 可以加上weight=5; 这样的语法设置权重server 192.168.141.132:8080 down;&#125; node3 1234[root@node3 ~]# yum install httpd -y[root@node3 ~]# echo &quot;i am web1&quot; &gt; /var/www/html/index.html[root@node3 ~]# systemctl restart httpd[root@node3 ~]# systemctl enable httpd node4 1234[root@node4 ~]# yum install httpd -y[root@node3 ~]# echo &quot;i am web2&quot; &gt; /var/www/html/index.html[root@node4 ~]# systemctl restart httpd[root@node4 ~]# systemctl enable httpd 检查node3、node4的apache服务是否正常 检查node1、node2的nginx服务是否正常 node1 node2 检测完毕，如上图，apache和nginx服务都是正常的。 Keepalived部署node1 12345678910111213141516171819202122232425262728[root@node1 conf.d]# cd[root@node1 ~]# vim keepalive.sh[root@node1 ~]# cat keepalive.sh #!/bin/bashyum install keepalived -ymv /etc/keepalived/keepalived.conf&#123;,.bak&#125;cat &gt; /etc/keepalived/keepalived.conf &lt;&lt; EOF! Configuration File for keepalivedglobal_defs &#123; router_id node1 # node2修改&#125;vrrp_instance VI_1 &#123; state MASTER # node2节点BACKUP interface ens33 virtual_router_id 10 priority 100 # node2节点小于100 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.141.100 &#125;&#125;EOF[root@node1 ~]# chmod +x keepalive.sh [root@node1 ~]# ./keepalive.sh node2 12345678910111213141516171819202122232425262728[root@node2 conf.d]# cd[root@node2 ~]# vim keepalive.sh[root@node2 ~]# cat keepalive.sh #!/bin/bashyum install keepalived -ymv /etc/keepalived/keepalived.conf&#123;,.bak&#125;cat &gt; /etc/keepalived/keepalived.conf &lt;&lt; EOF! Configuration File for keepalivedglobal_defs &#123; router_id node2&#125;vrrp_instance VI_1 &#123; state BACKUP interface ens33 virtual_router_id 10 priority 90 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.141.100 &#125;&#125;EOF[root@node2 ~]# chmod +x keepalive.sh [root@node2 ~]# ./keepalive.sh keepalived+nginx实现高可用的特点 如上图，我们需要自定义脚本检测nginx服务是否正常 node1 123456789101112131415161718192021222324252627282930313233给keepalived配置文件增加script内容[root@node1 ~]# vim /etc/keepalived/keepalived.conf[root@node1 ~]# cat /etc/keepalived/keepalived.conf! Configuration File for keepalivedglobal_defs &#123; router_id node1 # node2修改&#125;# 定义scriptvrrp_script chk_http_port &#123; script &quot;/usr/local/src/check_nginx_pid.sh&quot; interval 1 weight -20 # 优先级-20&#125;vrrp_instance VI_1 &#123; state MASTER # node2节点BACKUP interface ens33 virtual_router_id 10 priority 100 # node2节点小于100 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; # 调用script脚本 track_script &#123; chk_http_port &#125; virtual_ipaddress &#123; 192.168.141.100 &#125;&#125;[root@node1 ~]# script解析： 123456789# 定义scriptvrrp_script chk_http_port &#123; script &quot;/usr/local/src/check_nginx_pid.sh&quot; #check_nginx_pid.sh是判断nginx是否正常的脚本，值为1执行 weight -20，否则不执行weight -20 interval 1 #每秒钟检测一次check_nginx_pid.sh的返回值，或者说每秒执行一次脚本 weight -20 # 优先级-20&#125; 注意：优先级减少之后需不需要加回来？不需要，从起nginx后自动回到初始值，也就是把nginx关了重启之后其优先级自动恢复到100，不需要你手动去加。 node1定义判断nginx是否正常的脚本，down的话返回1，正常的话返回0 12345678910111213[root@node1 ~]# vim /usr/local/src/check_nginx_pid.sh[root@node1 ~]# cat /usr/local/src/check_nginx_pid.sh#!/bin/bashA=`ps -C nginx --no-header |wc -l` if [ $A == 0 ];then exit 1 else exit 0 fi[root@node1 ~]# cd /usr/local/src/[root@node1 src]# chmod +x check_nginx_pid.sh [root@node1 src]# cd[root@node1 ~]# systemctl restart keepalived node2不需要上述改动，因为总共就两台nginx服务器，所以检测nginx运行是否正常的机器只需要一台就够了。 1[root@node2 ~]# systemctl restart keepalived 测试keepalived的vip是否在主服务器上 node1 12345678910111213141516[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# node2 1234567891011121314[root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 检测vip是否可用 解析：这里curl vip:8080，之所以要加上端口，是因为keepalived只将vip转换为真实ip：192.168.141.53&amp;69，而之前我们定义的nginx反向代理所监听的端口是8080，所以就要加上端口才能访问了。但是这个访问到的并非是web上的80端口，例如直接访问：192.168.141.12:8080是打不开页面的。我们之前做的反向代理是将web服务器上的192.168.141.12:80和192.168.141.132:80反向代理成192.168.141.53:8080或者192.168.141.69:8080。 停止node1的Keepalived服务，观察VIP是否漂移，访问正常 123456789101112131415[root@node1 ~]# systemctl stop keepalived[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# 可以看到vip现在已经转移到了node2上面 12345678910111213141516[root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 测试漂移后的vip的可用性 由于keepalived主设备的选举默认是抢占模式的，所以我们重启node1的keepalived之后，vip能够重新自node2上面漂移回到node1上面。 1234567891011121314151617[root@node1 ~]# systemctl restart keepalived[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# 1234567891011121314[root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 可以看到vip已经漂移回到node1上了 我们解析一下之前用来判断nginx是否关闭的脚本 123456789[root@node1 ~]# cat /usr/local/src/check_nginx_pid.sh#!/bin/bashA=`ps -C nginx --no-header |wc -l` if [ $A == 0 ];then exit 1 else exit 0 fi[root@node1 ~]# 这个脚本里有个变量A=ps -C nginx –no-header |wc -l 停止node1的nginx服务，查看一下变量A的值，可以看到关闭了nginx的话，A=0。 1234[root@node1 ~]# systemctl stop nginx[root@node1 ~]# ps -C nginx --no-header |wc -l0[root@node1 ~]# 对比与node1，我们来看看node2这台nginx并未关闭时A的值，可以看到A!=0 123[root@node2 ~]# ps -C nginx --no-header |wc -l2[root@node2 ~]# 停止node1的nginx服务，观察VIP是否漂移，访问正常 123456789101112131415[root@node1 ~]# systemctl stop nginx[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# 可以看到vip已经漂移到了node2 12345678910111213141516[root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 测试漂移后的vip的可用性 现在将node1的nginx服务器重启，看看vip能都漂移回来 1234567891011121314151617[root@node1 ~]# systemctl restart nginx[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# node2 1234567891011121314[root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 可以看到vip已经漂移回node1上面了 最终测试一下漂移回来的vip的可用性 将node3上的httpd服务关闭 12[root@node3 ~]# systemctl stop httpd[root@node3 ~]# 访问vip 重新启动node3的httpd服务 12[root@node3 ~]# systemctl restart httpd[root@node3 ~]# 再次访问vip 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-keepalived-03 Nginx+Apache部署]]></title>
    <url>%2Fkeepalived-03%2F</url>
    <content type="text"><![CDATA[linux-keepalived-03 Nginx+Apache部署说明 本篇做一个小实验，主要是为后面keepalived+Nginx+Apache部署做准备，所以把这篇文章归类为keepalived一类里面。 实验要求 完成nginx代理服务器 在nginx配置中使用proxy_set_header X-Real-IP $remote_addr;并且去httpd服务器定义日志格式 LogFormat “ \”%{X-Real-IP}i\” %h %l %u %t \”%r\” %&gt;s %b \”%{Referer}i\” \”%{User-Agent}i\”” combined 最后观察日志前后是否有客户端访问的真实IP地址 实验环境node1（nginx）：192.168.141.53node3（web1）：192.168.141.12node4（web2）：192.168.141.132 实验准备node1 123456789101112[root@node1 ~]# systemctl stop firewalld[root@node1 ~]# vim /etc/selinux/config [root@node1 ~]# cat /etc/selinux/config |grep SELINUX# SELINUX= can take one of these three values:SELINUX=disabled# SELINUXTYPE= can take one of three two values:SELINUXTYPE=targeted [root@node1 ~]#[root@node1 ~]# setenforce 0[root@node1 ~]# getenforce Permissive[root@node1 ~]# noed3、node4 12345678910111213141516[root@node3 ~]# firewall-cmd --add-port=80/tcp --permanentsuccess[root@node3 ~]# firewall-cmd --reloadsuccess[root@node3 ~]# [root@node3 ~]# vim /etc/selinux/config [root@node3 ~]# cat /etc/selinux/config |grep SELINUX# SELINUX= can take one of these three values:SELINUX=disabled# SELINUXTYPE= can take one of three two values:SELINUXTYPE=targeted [root@node3 ~]#[root@node3 ~]# setenforce 0[root@node3 ~]# getenforce Permissive[root@node3 ~]# 实验步骤nginx部署node1 123456789101112131415161718192021[root@node1 ~]# yum install epel-release -y[root@node1 ~]# yum install nginx -y[root@node1 ~]# cd /etc/nginx/conf.d/[root@node1 conf.d]# vim proxy.conf [root@node1 conf.d]# cat proxy.conf upstream websers&#123; server 192.168.141.12; server 192.168.141.132;&#125;server&#123; listen 80; server_name 192.168.141.53; location / &#123; proxy_pass http://websers; &#125;&#125;[root@node1 conf.d]# [root@node1 conf.d]# systemctl restart nginx[root@node1 conf.d]# systemctl enable nginx[root@node1 conf.d]# nginx -s reload[root@node1 conf.d]# apache部署node3 1234[root@node3 ~]# yum install httpd -y[root@node3 ~]# echo &quot;i am web1&quot; &gt; /var/www/html/index.html[root@node3 ~]# systemctl restart httpd[root@node3 ~]# systemctl enable httpd node4 1234[root@node4 ~]# yum install httpd -y[root@node3 ~]# echo &quot;i am web2&quot; &gt; /var/www/html/index.html[root@node4 ~]# systemctl restart httpd[root@node4 ~]# systemctl enable httpd 检查node3、node4的apache服务是否正常 用cmd检查node1的nginx服务是否正常 查看apache服务日志 12345678910111213141516171819[root@node3 ~]# cat /var/log/httpd/access_log192.168.141.1 - - [09/Apr/2019:07:25:13 -0400] &quot;GET / HTTP/1.1&quot; 200 10 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0&quot;192.168.141.1 - - [09/Apr/2019:07:25:13 -0400] &quot;GET /favicon.ico HTTP/1.1&quot; 404 209 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0&quot;192.168.141.53 - - [09/Apr/2019:07:28:21 -0400] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;192.168.141.53 - - [09/Apr/2019:07:28:23 -0400] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;192.168.141.53 - - [09/Apr/2019:07:28:24 -0400] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;192.168.141.53 - - [09/Apr/2019:07:28:25 -0400] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;192.168.141.53 - - [09/Apr/2019:07:28:25 -0400] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;[root@node3 ~]# [root@node4 ~]# cat /var/log/httpd/access_log192.168.141.1 - - [09/Apr/2019:19:25:26 +0800] &quot;GET / HTTP/1.1&quot; 200 10 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0&quot;192.168.141.1 - - [09/Apr/2019:19:25:26 +0800] &quot;GET /favicon.ico HTTP/1.1&quot; 404 209 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0&quot;192.168.141.53 - - [09/Apr/2019:19:28:22 +0800] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;192.168.141.53 - - [09/Apr/2019:19:28:23 +0800] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;192.168.141.53 - - [09/Apr/2019:19:28:24 +0800] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;192.168.141.53 - - [09/Apr/2019:19:28:25 +0800] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;[root@node4 ~]# 可以看到，node3与node4日志记录里，访问自己的是node1：192.168.141.53。那么问题来了，如果某用户通过node1的代理在node3上登录了我们的网站，他刷新网页的时候，万一刷新的网页数据被node1负载均衡转发给了node4，然而node4上面是没有其对应session的，这样的话，该用户就不得不再次输入账号和密码，是很荒唐的一件事情。但是其实呢，nginx用的七层代理可以避免这种情况的发生，所以不需要进行手动干预，这些在我前几篇博客中有详细的介绍，这里只是提一下。 为了方便我们运维人员来观察是谁访问了我们的apache服务器，我们需要修改一下日志格式。 首先看一下官方文档： http://httpd.apache.org/docs/2.2/mod/mod_log_config.html 查看当前apache服务日志格式 12345[root@node3 ~]# cat /etc/httpd/conf/httpd.conf | grep LogFormat LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot;&quot; combined LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b&quot; common LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot; %I %O&quot; combinedio[root@node3 ~]# 可以看到，若要在apache日志文件中看到客户端ip，需要加一个 \”%{X-Real-IP}i\” ，其中X-Real-IP是我们在nginx定义的变量，气质为客户端的真实ip地址。 这也就是我们的第二个实验要求： 在nginx配置中使用proxy_set_header X-Real-IP $remote_addr;并且去httpd服务器定义日志格式LogFormat “ \”%{X-Real-IP}i\” %h %l %u %t \”%r\” %&gt;s %b \”%{Referer}i\” \”%{User-Agent}i\”” combined node1上： 12345678910111213[root@node1 ~]# cd /etc/nginx/conf.d/[root@node1 conf.d]# vim proxy.conf 在location / &#123; proxy_pass http://websers; &#125;里面加上：proxy_set_header X-Real-IP $remote_addr;保存退出[root@node1 ~]# systemctl restart nginx[root@node1 ~]# nginx -s reload[root@node1 ~]# node3上 1234567[root@node3 ~]# vim /etc/httpd/conf/httpd.conf将196行修改为：LogFormat &quot; \&quot;%&#123;X-Real-IP&#125;i\&quot; %h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot;&quot; combined保存退出[root@node3 ~]# systemctl restart httpd node4上 1234567[root@node4 ~]# vim /etc/httpd/conf/httpd.conf将196行修改为：LogFormat &quot; \&quot;%&#123;X-Real-IP&#125;i\&quot; %h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot;&quot; combined保存退出[root@node4 ~]# systemctl restart httpd 同上。 现在再次用cmd来访问192.168.141.53 然后回到node3上查看日志： 1[root@node3 ~]# cat /var/log/httpd/access_log 然后回到node4上查看日志： 1[root@node4 ~]# cat /var/log/httpd/access_log 可以看到相比于之前的日志，日志条目最前面多了一个ip，这个ip显然就是我的电脑的ip，如下： 这样我们修改apache日志格式的目的就已经达到了。 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-keepalived-02 keepalived+LVS+Apache部署]]></title>
    <url>%2Fkeepalived-02%2F</url>
    <content type="text"><![CDATA[linux-keepalived-02 keepalived-+LVS+Apache部署概念解析 LVS是Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。 可伸缩网络服务的几种结构，它们都需要一个前端的负载调度器（或者多个进行主从备份）。我们先分析实现虚拟网络服务的主要技术，指出IP负载均衡技术是在负载调度器的实现技术中效率最高的。在已有的IP负载均衡技术中，主要有通过网络地址转换（Network Address Translation）将一组服务器构成一个高性能的、高可用的虚拟服务器，我们称之为VS/NAT技术（Virtual Server via Network Address Translation）。在分析VS/NAT的缺点和网络服务的非对称性的基础上，我们提出了通过IP隧道实现虚拟服务器的方法VS/TUN （Virtual Server via IP Tunneling），和通过直接路由实现虚拟服务器的方法VS/DR（Virtual Server via Direct Routing），它们可以极大地提高系统的伸缩性。VS/NAT、VS/TUN和VS/DR技术是LVS集群中实现的三种IP负载均衡技术。 lvs官网：http://www.linuxvirtualserver.org 如下图： 当web服务器太多时，RS就压力很大，所以引入DS。 重要参数：arp_announcearp_ignore 优点1、开源，免费2、在网上能找到一些相关技术资源3、具有软件负载均衡的一些优点 缺点1、最核心的就是没有可靠的支持服务，没有人对其结果负责；2、功能比较简单，支持复杂应用的负载均衡能力较差，如算法较少等；3、开启隧道方式需重编译内核；4、配置复杂；5、主要应用于LINUX，目前没有专门用于WINDOWS的版本，不过可以通过配置，使windows成为LVS集群中的real server（win2003、win2008中）。 LVS相关概念ipvs：ipvs称之为IP虚拟服务器（IP Virtual Server，简写为IPVS），是运行在LVS下的提供负载平衡功能的一种技术。工作于内核当中，定义转发规则。ipvsadm：工作于用户空间，是一个工具，同时它也是一条命令，用于管理LVS的策略规则。DS：前端负载均衡节点 direct-serverRS：后端真实节点 real-serverDIP：负载均衡节点的IP地址VIP：虚拟IP地址，必须要与RS在同一网段RIP：真实节点的IP地址CIP：客户端IP地址 LVS/NAT模型 RS的网关必须为DIP DIP要和RIP处于同一网络 RS支持任意操作系统 RIP必须为私网地址 DS支持端口映射 LVS/DR模型 前端路由必须发送给DS VIP要和RIP处于同一网络 RS的网关不能够指向DIP 不支持端口映射 RS响应报文绝不通过DS 在环回口上配置VIP地址，因为环回口本来没有ip LVS/TUN模型 主要是解决DR转发到不同数据中心的RS lvs负载均衡算法 rr：轮询 wrr：加权轮询 lc：最少连接数 wlc：加权最少连接数 ip hash：源地址哈希 sip hash：目的地址哈希 实验环境DR1:192.168.141.53DR2:192.168.141.69RS1：192.168.141.12RS2:192.168.141.132VIP：192.168.141.99（单主模型） RS部署12345678910111213141516171819202122232425262728293031323334353637383940在rs1和执行下面的脚本：[root@rs1 ~]# vim rs1.sh[root@rs1 ~]# cat rs1.sh #!/bin/bashyum install net-tools httpd -ysystemctl stop firewalldsetenforce 0vip=&quot;192.168.141.99&quot;mask=&quot;255.255.255.255&quot;ifconfig lo:0 $vip broadcast $vip netmask $mask uproute add -host $vip lo:0echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignoreecho &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announceecho &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignoreecho &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announceecho &quot;&lt;h1&gt;This is RS1&lt;/h1&gt;&quot; &gt; /var/www/html/index.htmlsystemctl restart httpdsystemctl enable httpd[root@rs1 ~]# . rs1.sh 在rs2和执行下面的脚本：[root@rs2 ~]# vim rs2.sh[root@rs2 ~]# cat rs2.sh #!/bin/bashyum install net-tools httpd -ysystemctl stop firewalldsetenforce 0vip=&quot;192.168.141.99&quot;mask=&quot;255.255.255.255&quot;ifconfig lo:0 $vip broadcast $vip netmask $mask uproute add -host $vip lo:0echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignoreecho &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announceecho &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignoreecho &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announceecho &quot;&lt;h1&gt;This is RS2&lt;/h1&gt;&quot; &gt; /var/www/html/index.htmlsystemctl restart httpdsystemctl enable httpd[root@rs2 ~]# . rs2.sh DR部署123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144dr1设置为主，dr2设置为从，二者配置文件的差异在于：dr1state MASTER priority 100router_id node1dr2state BACKUPpriority 90router_id node2[root@dr1 ~]# yum install keepalived ipvsadm -y[root@dr1 ~]# systemctl stop firewalld[root@dr1 ~]# setenforce 0[root@dr1 ~]# cd /etc/keepalived/[root@dr1 keepalived]# [root@dr1 keepalived]# mv keepalived.conf&#123;,.bak&#125;[root@dr1 keepalived]# vim keepalived.conf[root@dr1 keepalived]# cat keepalived.conf! Configuration File for keepalivedglobal_defs &#123; router_id node1 # 设置lvs的id，一个网络中应该唯一&#125;vrrp_instance VI_1 &#123; state MASTER # 指定Keepalived的角色，主是MASTER，从是BACKUP interface ens33 # 网卡 virtual_router_id 10 # 虚拟路由器ID，主备需要一样 priority 100 # 优先级越大越优，backup路由器需要设置比这小！可以设置为90 advert_int 1 # 检查间隔1s authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.141.99 # 定义虚拟IP地址，可以定义多个 &#125;&#125;# 定义虚拟主机，对外服务的IP和portvirtual_server 192.168.141.99 80 &#123; delay_loop 6 # 设置健康检查时间，单位是秒 lb_algo wrr # 负责调度算法 lb_kind DR # LVS负载均衡机制 persistence_timeout 0 protocol TCP# 指定RS主机IP和port real_server 192.168.141.12 80 &#123; weight 2 # 定义TCP健康检查 TCP_CHECK &#123; connect_timeout 10 nb_get_retry 3 delay_before_retry 3 connect_port 80 &#125; &#125; real_server 192.168.141.132 80 &#123; weight 1 TCP_CHECK &#123; connect_timeout 10 nb_get_retry 3 delay_before_retry 3 connect_port 80 &#125; &#125;&#125;[root@dr1 keepalived]# systemctl restart keepalived[root@dr1 keepalived]# ipvsadm -lnIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 192.168.141.99:80 wrr -&gt; 192.168.141.12:80 Route 2 0 0 -&gt; 192.168.141.132:80 Route 1 0 0 [root@dr1 keepalived]# dr2按照上面的同样配置，唯一差异在于：state BACKUP priority 90[root@dr2 ~]# yum install keepalived ipvsadm -y[root@dr2 ~]# systemctl stop firewalld[root@dr2 ~]# setenforce 0[root@dr2 ~]# cd /etc/keepalived/[root@dr2 keepalived]# [root@dr2 keepalived]# mv keepalived.conf&#123;,.bak&#125;[root@dr2 keepalived]# vim keepalived.conf[root@dr2 keepalived]# cat keepalived.conf! Configuration File for keepalivedglobal_defs &#123; router_id node2 # 设置lvs的id，一个网络中应该唯一&#125;vrrp_instance VI_1 &#123; state BACKUP # 指定Keepalived的角色，主是MASTER，从是BACKUP interface ens33 # 网卡 virtual_router_id 10 # 虚拟路由器ID，主备需要一样 priority 90 # 优先级越大越优，backup路由器需要设置比这小！ advert_int 1 # 检查间隔1s authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.141.99 # 定义虚拟IP地址，可以定义多个 &#125;&#125;# 定义虚拟主机，对外服务的IP和portvirtual_server 192.168.141.99 80 &#123; delay_loop 6 # 设置健康检查时间，单位是秒 lb_algo wrr # 负责调度算法 lb_kind DR # LVS负载均衡机制 persistence_timeout 0 protocol TCP# 指定RS主机IP和port real_server 192.168.141.12 80 &#123; weight 2 # 定义TCP健康检查 TCP_CHECK &#123; connect_timeout 10 nb_get_retry 3 delay_before_retry 3 connect_port 80 &#125; &#125; real_server 192.168.141.132 80 &#123; weight 1 TCP_CHECK &#123; connect_timeout 10 nb_get_retry 3 delay_before_retry 3 connect_port 80 &#125; &#125;&#125;[root@dr2 keepalived]# systemctl restart keepalived[root@dr2 keepalived]# ipvsadm -lnIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 192.168.141.99:80 wrr -&gt; 192.168.141.12:80 Route 2 0 0 -&gt; 192.168.141.132:80 Route 1 0 0 [root@dr2 keepalived]# 如果用浏览器测试的话，因为有缓存的原因，现象就不是那么的准确。所以我们这里采用windows的cmd来进行测试，多次输入命令：curl 192.168.141.99即可。 1234567891011121314151617181920212223242526C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS2&lt;/h1&gt;C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS1&lt;/h1&gt;C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS1&lt;/h1&gt;C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS2&lt;/h1&gt;C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS1&lt;/h1&gt;C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS1&lt;/h1&gt;C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS2&lt;/h1&gt;C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS1&lt;/h1&gt;C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS1&lt;/h1&gt; 可以看到，访问同一个ip：192.168.141.99得到的却是不同的结果，而且访问到RS1和RS2主页的比例正如我们在上面配置文件里设置好的那样，是2:1。 验证keepalive的健康检查功能将RS1的httpd关掉，查看dr1上转发目的主机列表，列表里已经没有RS1了 1234567891011[root@rs1 ~]# systemctl stop httpd[root@rs1 ~]# [root@dr1 keepalived]# ipvsadm -lnIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 192.168.141.99:80 wrr -&gt; 192.168.141.132:80 Route 1 0 3 [root@dr1 keepalived]# 将RS1的httpd重新开启，再次查看dr1上转发目的主机列表，列表里又有RS1了 12345678910[root@rs1 ~]# systemctl restart httpd[root@dr1 keepalived]# ipvsadm -lnIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 192.168.141.99:80 wrr -&gt; 192.168.141.12:80 Route 2 0 0 -&gt; 192.168.141.132:80 Route 1 0 0 [root@dr1 keepalived]# 验证keepalive的vip切换功能分别查看DR1和DR2的ip，可以看到vip：192.168.141.99在DR1的ens33网卡上 1234567891011121314151617181920212223242526272829303132[root@dr1 keepalived]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.99/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@dr1 keepalived]# [root@dr2 keepalived]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@dr2 keepalived]# 关掉dr1的keepalived 1[root@dr1 keepalived]# systemctl stop keepalived 再次查看DR1和DR2的ip，可以看到vip：192.168.141.99在DR2的ens33网卡上，切换成功！ 123456789101112131415161718192021222324252627282930313233[root@dr1 keepalived]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@dr1 keepalived]# [root@dr2 keepalived]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.99/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@dr2 keepalived]# 重启DR1的keepalived 1[root@dr1 keepalived]# systemctl restart keepalived 再次查看DR1和DR2的ip，可以看到vip：192.168.141.99在DR1的ens33网卡上，切换成功！ 123456789101112131415161718192021222324252627282930313233[root@dr1 keepalived]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.99/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@dr1 keepalived]# [root@dr2 keepalived]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@dr2 keepalived]# 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-keepalived-01 keepalived-基础学习]]></title>
    <url>%2Fkeepalived-01%2F</url>
    <content type="text"><![CDATA[linux-keepalived-01 keepalived-基础学习简介 Keepalived是Linux下一个轻量级别的高可用解决方案，Keepalived起初是为LVS设计的，专门用来监控集群系统中各个服务节点的状态，如果某个服务器节点出现故障，Keepalived将检测到后自动将节点从集群系统中剔除。 后来Keepalived又加入了VRRP的功能，VRRP（VritrualRouterRedundancyProtocol,虚拟路由冗余协议)出现的目的是解决静态路由出现的单点故障问题，通过VRRP可以实现网络不间断稳定运行，因此Keepalvied一方面具有服务器状态检测和故障隔离功能，另外一方面也有HAcluster功能。 健康检查和失败切换是keepalived的两大核心功能。所谓的健康检查，就是采用tcp三次握手，icmp请求，http请求，udp echo请求等方式对负载均衡器后面的实际的服务器(通常是承载真实业务的服务器)进行保活；而失败切换主要是应用于配置了主备模式的负载均衡器，利用VRRP维持主备负载均衡器的心跳，当主负载均衡器出现问题时，由备负载均衡器承载对应的业务，从而在最大限度上减少流量损失，并提供服务的稳定性。 VRRP协议 VRRP协议是一种容错的主备模式的协议，保证当主机的下一跳路由出现故障时，由另一台路由器来代替出现故障的路由器进行工作，通过VRRP可以在网络发生故障时透明的进行设备切换而不影响主机之间的数据通信。 虚拟路由器：VRRP组中所有的路由器，拥有虚拟的IP+MAC(00-00-5e-00-01-VRID)地址 主路由器：虚拟路由器内部通常只有一台物理路由器对外提供服务，主路由器是由选举算法产生，对外提供各种网络功能。 备份路由器：VRRP组中除主路由器之外的所有路由器，不对外提供任何服务，只接受主路由的通告，当主路由器挂掉之后，重新进行选举算法接替master路由器。 VRRP选举机制 三种状态： Initialize状态：系统启动后进入initialize状态 Master状态 Backup状态 选举机制： 优先级 抢占模式下，一旦有优先级高的路由器加入，即成为Master 非抢占模式下，只要Master不挂掉，优先级高的路由器只能等待 工作原理 网络层：通过ICMP协议向后端服务器集群中发送数据报文 传输层：利用TCP协议的端口连接和扫描技术检测后端服务器集群是否正常 应用层：自定义keepalived工作方式（脚本） 体系结构 SchedulerI/OMultiplexer是一个I/O复用分发调度器，它负载安排Keepalived所有内部的任务请求 Memory Mngt是一个内存管理机制，这个框架提供了访问内存的一些通用方法； Control Plane 是keepalived的控制版面，可以实现对配置文件编译和解析； Core componets Watchdog：是计算机可靠领域中极为简单又非常有效的检测工具，Keepalived正是通过它监控Checkers和VRRP进程的。 Checkers:这是Keepalived最基础的功能，也是最主要的功能，可以实现对服务器运行状态检测和故障隔离。 VRRP Stack:这是keepalived后来引用VRRP功能，可以实现HA集群中失败切换功能。负责负载均衡器之间的失败切换FailOver IPVS wrapper:这个是IPVS功能的一个实现，IPVSwarrper模块将可以设置好的IPVS规则发送的内核空间并且提供给IPVS模块，最终实现IPVS模块的负载功能。 Netlink Reflector：用来实现高可用集群Failover时虚拟IP(VIP)的设置和切换 keepalived运行时，会启动3个进程： core：负责主进程的启动，维护和全局配置文件的加载； check：负责健康检查 vrrp：用来实现vrrp协议 对比 Keepalived的目的是模拟路由器的高可用 Heartbeat或Corosync的目的是实现Service的高可用 Keepalived是实现前端高可用，常用的前端高可用的组合有，就是我们常见的LVS+Keepalived、Nginx+Keepalived、HAproxy+Keepalived Heartbeat或Corosync是实现服务的高可用，常见的组合有Heartbeat v3(Corosync)+Pacemaker+NFS+Httpd 实现Web服务器的高可用、Heartbeat v3(Corosync)+Pacemaker+NFS+MySQL 实现MySQL服务器的高可用。 keepalived相关路径/etc/keepalived/keepalived.conf # 主配置文件/etc/sysconfig/keepalived # 系统进程/usr/bin/genhash # hash计算工具/usr/lib/systemd/system/keepalived.service # 守护进程/usr/sbin/keepalived # 命令工具 keepalived主从选举 keepalived默认采用抢占模式，谁的优先级最高，谁就可以抢占到vip。例如node1的优先级是100，node2的优先级是90，一开始vip在node1上面。关闭node1上面的keepalived后，vip会漂移到node2上，可是一旦node1的keepalived再次开启，那么vip还是会漂移回到node1的。 选举机制： ​ 通过优先级​ 设置抢占和非抢占的参数：nopreempt keepalived组件netlink reflector：控制高可用集群当即后的vip切换和设置 keepalived三种状态在/etc/keepalived/keepalived.conf # 主配置文件中，有一行： state BACKUP # 指定Keepalived的角色，主是MASTER，从是BACKUP init：初始状态 master：主服务节点 backup：从服务节点 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-git-05 搭建Git服务器]]></title>
    <url>%2Fgit-05%2F</url>
    <content type="text"><![CDATA[linux-git-05 搭建Git服务器GitLab GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务，安装方法可以参考GitLab在GitHub上的Wiki页面。 实验准备一台干净的虚拟机的内存给4G以上，建议使用方案2，这里也用方案2来演示。 方案1： 12345678910[root@node2 ~]# yum install git -y[root@node2 ~]# adduser git[root@node2 git]# mkdir .ssh/放入公钥并初始化：[root@node2 git]# vim .ssh/authorized_keys[root@node2 git]# cd /srv/[root@node2 srv]# git init --bare sample.git[root@node2 srv]# chown -R git:git sample.git/克隆仓库：[root@node1 ~]# git clone git@node2:/srv/sample.git 方案2： GitLab安装 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849环境准备：[root@localhost ~]# yum install -y curl policycoreutils-python openssh-server[root@localhost ~]# systemctl enable sshd[root@localhost ~]# systemctl start sshd[root@localhost ~]# firewall-cmd --add-port=&#123;8090,80&#125;/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# 邮箱服务：[root@localhost ~]# yum install postfix -y[root@localhost ~]# systemctl enable postfix[root@localhost ~]# systemctl start postfix[root@localhost ~]# 配置YUM源：[root@localhost ~]# vim /etc/yum.repos.d/gitlab_ce.repo[root@localhost ~]# cat /etc/yum.repos.d/gitlab_ce.repo[gitlab-ce]name=Gitlab CE Repositorybaseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/gpgcheck=0enabled=1[root@localhost ~]# yum makecache[root@localhost ~]# yum install gitlab-ce -y[root@localhost ~]# sed -i &quot;s/^external_url.*/external_url &apos;http:\/\/192.168.141.132:8090&apos;/g&quot; /etc/gitlab/gitlab.rb[root@localhost ~]#注意：192.168.141.132是虚拟机ip注意：\/\/是//的转义注意：s/^external_url.*/external_url中的s表示替换注意：gitlab本身采用80端口，如安装前服务器有启用80，安装完访问会报错，需更改gitlab的默认端口。注意：unicorn本身采用8080端口，如安装前服务器有启用8080，安装完访问会报错，需更改unicorn的默认端口。每次更改后使配置生效：[root@localhost ~]# gitlab-ctl reconfiguregitlab 日常管理命令： gitlab-ctl start gitlab-ctl stop gitlab-ctl status gitlab-ctl restart gitlab-ctl reconfigure最后通过浏览器：http://$Host_IP:8090默认root用户，并且重置密码 注意， gitlab-ctl reconfigure敲完之后，需要等待较久的时间，如下图，我等了3分13秒。然后，登完之后在开始打开浏览器进行验证，才能看到效果。 验证 如下图，gitlab功能和git是基本一样的，搭建在公司内部服务器上，就成为了一个私有的开源git平台。刚开始，需要你设置root管理员的密码，密码长度至少8个字符。 设置好密码后，现在就可以用root用户名和你刚刚设置好的密码登录了。 如下图，登录上来是这个样子的，也github大差不差，功能齐全，操作简单，剩下的这里不再赘述，其中妙处需要自己体验。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-git-04 git分支管理]]></title>
    <url>%2Fgit-04%2F</url>
    <content type="text"><![CDATA[linux-git-04 git分支管理 问题：假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 分支的作用：创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 我们依然用本地仓库：firstgit来演示，首先看看里面的已有文件内容 123456789[root@localhost firstgit]# ls1.txt readme.txt[root@localhost firstgit]# cat readme.txt hello readme[root@localhost firstgit]# cat 1cat: 1: 没有那个文件或目录[root@localhost firstgit]# cat 1.txt i am first[root@localhost firstgit]# 快速合并 12345678910111213141516171819202122232425262728293031323334353637383940创建分支“dev”，合并分支[root@localhost firstgit]# git checkout -b devM readme.txt切换到一个新分支 &apos;dev&apos;[root@localhost firstgit]# git branch* dev master[root@localhost firstgit]# cat 1.txt i am first[root@localhost firstgit]# echo &quot;This is dev operation&quot; &gt; 1.txt [root@localhost firstgit]# git add 1.txt[root@localhost firstgit]# git commit -m &quot;modify 1.txt&quot;[dev a0d7502] modify 1.txt 1 file changed, 1 insertion(+), 1 deletion(-)[root@localhost firstgit]# git checkout masterM readme.txt切换到分支 &apos;master&apos;[root@localhost firstgit]# cat 1.txt i am first[root@localhost firstgit]# git merge dev更新 6f7081e..a0d7502Fast-forward 1.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)[root@localhost firstgit]# cat 1.txt This is dev operation[root@localhost firstgit]# git branch -d dev已删除分支 dev（曾为 a0d7502）。[root@localhost firstgit]# cat 1.txt This is dev operation[root@localhost firstgit]# 命令解释：查看分支：git branch创建分支：git branch &lt;name&gt;切换分支：git checkout &lt;name&gt;创建+切换分支：git checkout -b &lt;name&gt;合并某分支到当前分支：git merge &lt;name&gt;删除分支：git branch -d &lt;name&gt; 在上面这个例子中，主分支没有修改1.txt，只有dev分支修改了1.txt，那么主分支与dev分支合并的时候就不会产生冲突。与其说是合并，倒不如理解成没有主见的主分支采取了dev分支的意见，可以完成快速合并。 那么，如果除了dev分支，还有主分支对1.txt也进行了修改，导致二者之间各抒己见，就会产生冲突，这时候就没有办法快速合并了，你得手动解决二者之间的冲突之后，才能完成合并，下面我们新建一个test分支来测试一下如何进行冲突合并。 冲突合并 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495[root@localhost firstgit]# git checkout -b testM readme.txt切换到一个新分支 &apos;test&apos;[root@localhost firstgit]# cat 1.txt This is dev operation[root@localhost firstgit]# echo &quot;test1&quot; &gt;&gt; 1.txt [root@localhost firstgit]# cat 1.txt This is dev operationtest1[root@localhost firstgit]# git add 1.txt[root@localhost firstgit]# git commit -m &quot;add test1&quot; [test 11e4e6b] add test1 1 file changed, 1 insertion(+)[root@localhost firstgit]# git checkout master M readme.txt切换到分支 &apos;master&apos;您的分支领先 &apos;origin/master&apos; 共 1 个提交。 （使用 &quot;git push&quot; 来发布您的本地提交）[root@localhost firstgit]# echo &quot;test2&quot; &gt;&gt; 1.txt [root@localhost firstgit]# cat 1.txt This is dev operationtest2[root@localhost firstgit]# git add 1.txt[root@localhost firstgit]# git commit -m &quot;add test2&quot; [master bbf9686] add test2 1 file changed, 1 insertion(+)[root@localhost firstgit]# git merge test自动合并 1.txt冲突（内容）：合并冲突于 1.txt自动合并失败，修正冲突然后提交修正的结果。[root@localhost firstgit]# 合并失败：因为现在test分支和master分支同级，而且二者之间产生了冲突！解决办法：[root@localhost firstgit]# git status# 位于分支 master# 您的分支领先 &apos;origin/master&apos; 共 2 个提交。# （使用 &quot;git push&quot; 来发布您的本地提交）## 您有尚未合并的路径。# （解决冲突并运行 &quot;git commit&quot;）## 未合并的路径：# （使用 &quot;git add &lt;file&gt;...&quot; 标记解决方案）## 双方修改： 1.txt## 尚未暂存以备提交的变更：# （使用 &quot;git add &lt;file&gt;...&quot; 更新要提交的内容）# （使用 &quot;git checkout -- &lt;file&gt;...&quot; 丢弃工作区的改动）## 修改： readme.txt#修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）[root@localhost firstgit]# [root@localhost firstgit]# cat 1.txt This is dev operation&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADtest2=======test1&gt;&gt;&gt;&gt;&gt;&gt;&gt; test[root@localhost firstgit]# 上面这个echo显示出来的结果表示，主分支写的是test2但是test分支写的是test1，那么二者之间就产生了冲突。这里需要我们手动修改1.txt冲突的内容，然后再次添加和提交[root@localhost firstgit]# vim 1.txt [root@localhost firstgit]# cat 1.txt This is dev operationtest12[root@localhost firstgit]# [root@localhost firstgit]# git add 1.txt[root@localhost firstgit]# git commit -m &quot;test12&quot;[master 6caac74] test12[root@localhost firstgit]# cat 1.txt This is dev operationtest12[root@localhost firstgit]# 上面重新对1.txt进行了修改和提交之后，冲突得到了解决，那么合并过程到此彻底完成。查看分支合并情况：[root@localhost firstgit]# git log --graph --pretty=oneline --abbrev-commit* 6caac74 test12|\ | * 11e4e6b add test1* | bbf9686 add test2|/ * a0d7502 modify 1.txt* 6f7081e add 1.txt* 01633f9 change messages* c391307 write something[root@localhost firstgit]# Bug分支 环境：当我们正在dev开发新功能的时候，突然有个紧急bug111需要修复，这是我们就需要将当前dev分支通过git stash命令打快照，然后假设去修改master分支上的bug，然后就需要先切换到master分支，然后再创建并切换到issue-111分支，进行修复，修复后将issue-111分支合并到master分支即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081在test分支，修改1.txt文件，然后stash将现场快照[root@localhost firstgit]# git checkout testM readme.txt切换到分支 &apos;test&apos;[root@localhost firstgit]# cat 1.txt This is dev operationtest1[root@localhost firstgit]# echo &quot;111&quot; &gt; 1.txt[root@localhost firstgit]# cat 1.txt 111[root@localhost firstgit]# git stash # 打快照Saved working directory and index state WIP on test: 11e4e6b add test1HEAD 现在位于 11e4e6b add test1[root@localhost firstgit]#创建issue-111分支，修复bug（修改1.txt）的内容，然后add，commit[root@localhost firstgit]# git checkout -b issue-111切换到一个新分支 &apos;issue-111&apos;[root@localhost firstgit]# echo &quot;11111&quot; &gt; 1.txt [root@localhost firstgit]# git add 1.txt [root@localhost firstgit]# git commit -m &quot;change 11111&quot;[issue-111 93d8aa1] change 111 1 file changed, 1 insertion(+) create mode 100644 money.txt[root@localhost firstgit]# git status# 位于分支 issue-111无文件要提交，干净的工作区[root@localhost firstgit]# 将issue-111分支合并到master分支[root@localhost firstgit]# git checkout master 切换到分支 &apos;master&apos;您的分支领先 &apos;origin/master&apos; 共 6 个提交。 （使用 &quot;git push&quot; 来发布您的本地提交）[root@localhost firstgit]# git merge issue-111自动合并 1.txt冲突（内容）：合并冲突于 1.txt自动合并失败，修正冲突然后提交修正的结果。[root@localhost firstgit]# vim 1.txt [root@localhost firstgit]# cat 1.txt This is dev operationtest1211111[root@localhost firstgit]# [root@localhost firstgit]# git add 1.txt[root@localhost firstgit]# git commit -m &quot;11111&quot;[master bfd7bf0] 11111[root@localhost firstgit]# git checkout test切换到分支 &apos;test&apos;[root@localhost firstgit]# git status# 位于分支 test无文件要提交，干净的工作区[root@localhost firstgit]# git stash liststash@&#123;0&#125;: WIP on test: 11e4e6b add test1[root@localhost firstgit]# git stash pop # 恢复快照# 位于分支 test# 尚未暂存以备提交的变更：# （使用 &quot;git add &lt;file&gt;...&quot; 更新要提交的内容）# （使用 &quot;git checkout -- &lt;file&gt;...&quot; 丢弃工作区的改动）## 修改： 1.txt# 修改： readme.txt#修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）丢弃了 refs/stash@&#123;0&#125; (0fe7895c82dba8d77ed308963093c362ce5edfe6)[root@localhost firstgit]# [root@node1 Shell]# cat 1.txt 111然后继续在test分支上进行工作。删除分支命令：git branch -d (branchname)若要删除一个还未合并的feature分支，可以通过git branch -D &lt;name&gt;强行删除！ 多人协作 查看远程库信息，使用git remote -v 本地新建的分支如果不推送到远程，对其他人就是不可见的 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 rebase作用 rebase操作可以把本地未push的分叉提交历史整理成直线 rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比 标签管理创建标签 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a -m “blablabla…”可以指定标签信息； 命令git tag可以查看所有标签。 管理标签 命令git push origin 可以推送一个本地标签； 命令git push origin –tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-git-03 git远程仓库]]></title>
    <url>%2Fgit-03%2F</url>
    <content type="text"><![CDATA[linux-git-03 git远程仓库添加远程仓库 Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。有一台机器有一个原始版本库，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 步骤12341.注册Github账号2.创建SSH Key$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;3.登陆Github将id_rsa.pub文件的内容添加到SHH Key页面中 GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 添加远程仓库1.注册Github账号，官网：https://github.com 2.打开一台centos7的虚拟机，创建SSH Key，下面youremail@example.com这里可以填的你邮箱，然后直接敲三个回车即可，存放密钥用的是默认的文件夹，而且没有为密钥设置密码。 1234567891011ssh-keygen -t rsa -C &quot;youremail@example.com&quot;[root@localhost ~]# ls /root/.ssh/id_rsa id_rsa.pub[root@localhost ~]# cat /root/.ssh/id_rsa.pub 这里会显示公钥内容，把公钥复制下来[root@localhost ~]# 3.登录github，如下图，将上面复制好的ssh key公钥添加到你的github中。 复制上去后，给密钥起个名字，如下图我的是“myfirstkey”，然后点击Add SSH Key即可。 添加完成 仓库的创建1.先远程再本地（建议使用） 最佳选择是先创建远程库然后克隆到本地，但是创建远程库的时候选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。 创建远程仓库：testgit 复制仓库链接：https://github.com/ZhongEagles/testgit.git 123456789101112[root@localhost ~]# git clone 你刚刚复制的仓库链接正克隆到 &apos;testgit&apos;...remote: Enumerating objects: 3, done.remote: Counting objects: 100% (3/3), done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.[root@localhost ~]# lsanaconda-ks.cfg firstgit testgit[root@localhost ~]# cd testgit/[root@localhost testgit]# lsREADME.md[root@localhost testgit]# 然后你就可以在你的本地仓库进行开发了，例如我们写一个a.txt，然后同步到远程仓库。 123456789101112[root@localhost testgit]# vim a.txt[root@localhost testgit]# cat a.txt hello my testgit![root@localhost testgit]# [root@localhost testgit]# git add a.txt[root@localhost testgit]# git commit -m &quot;write a.txt&quot;[master 4e2168d] write a.txt 1 file changed, 1 insertion(+) create mode 100644 a.txt[root@localhost testgit]# git push -u origin master -u是update的意思，master是主分支的意思，这里需要你输入github账户名密码。 到网页上刷新一下，可以看到你推送上来的a.txt已经在这个远程仓库里面了。 2.先本地再远程（不建议使用）继续我们上一篇文章中用到的本地仓库firstgit。 12345[root@localhost testgit]# cd ..[root@localhost ~]# cd firstgit/[root@localhost firstgit]# ls1.txt readme.txt[root@localhost firstgit]# 在远程也创建一个仓库：firstgit 现在我们需要把这个仓库与远程仓库进行关联，复制仓库链接 1234[root@localhost firstgit]# git remote add origin https://github.com/ZhongEagles/firstgit.git[root@localhost firstgit]# git push -u origin master 输入账号密码 刷新一下网页，可以看到推送上去的俩文件。 总结 根据提示信息： 在命令行中创建新的仓库并关联 在命令行中关联已经存在的仓库 git push命令：把当前分支master推送到远程 从远程库克隆 最佳选择是先创建远程库然后克隆到本地，但是创建远程库的时候选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。 其他 github的pull requests是指在本地修改了别人的代码之后，请求别人的同意，别人同意就能同步，不同意就被驳回。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-git-02 git版本控制系统]]></title>
    <url>%2Fgit-02%2F</url>
    <content type="text"><![CDATA[linux-git-02 git版本控制系统集中式vs分布式 集中式CVS、SVN 速度慢，必须联网，开源精神不符 版本库集中放在中央服务器，工作时，获取最新版本，工作完成后，再推送给中央服务器！ 分布式 无中央服务器，每个人的电脑都是一个完整的版本库 安全性能更高 通常有一台充当“中央服务器”的电脑，仅仅作为方便“交换”大家的修改 安装使用Yum安装： 1[root@localhost ~]# yum install git -y 为node1上所有的git仓库设置用户名和Email 12[root@node1 ~]# git config --global user.name &quot;Your Name&quot;[root@node1 ~]# git config --global user.email &quot;email@example.com&quot; 创建并初始化版本库 12345678910[root@localhost ~]# mkdir firstgit[root@localhost ~]# cd firstgit/[root@localhost firstgit]# git init初始化空的 Git 版本库于 /root/firstgit/.git/[root@localhost firstgit]# ls[root@localhost firstgit]# ls -ah. .. .git.git目录作用：跟踪管理版本库 所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 常规操作1.把文件添加到仓库中 123456[root@localhost firstgit]# echo &quot;hello world&quot; &gt; readme.txt[root@localhost firstgit]# git add readme.txt [root@localhost firstgit]# git commit -m &quot;write something&quot; [master（根提交） c391307] write something 1 file changed, 1 insertion(+) create mode 100644 readme.txt 2.修改文件内容，查询内容和状态并提交 1234567891011121314151617181920212223242526272829303132333435363738394041[root@localhost firstgit]# echo &quot;hello eagleslab&quot; &gt; readme.txt[root@localhost firstgit]# git status# 位于分支 master# 尚未暂存以备提交的变更：# （使用 &quot;git add &lt;file&gt;...&quot; 更新要提交的内容）# （使用 &quot;git checkout -- &lt;file&gt;...&quot; 丢弃工作区的改动）## 修改： readme.txt#修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）[root@localhost firstgit]# git diff readme.txt diff --git a/readme.txt b/readme.txtindex 3b18e51..8d0e700 100644--- a/readme.txt+++ b/readme.txt@@ -1 +1 @@-hello world+hello eagleslab[root@localhost firstgit]# git add readme.txt [root@localhost firstgit]# git status# 位于分支 master# 要提交的变更：# （使用 &quot;git reset HEAD &lt;file&gt;...&quot; 撤出暂存区）## 修改： readme.txt#[root@localhost firstgit]# git commit -m &quot;change messages&quot;[master 01633f9] change messages 1 file changed, 1 insertion(+), 1 deletion(-)[root@localhost firstgit]# git status# 位于分支 master无文件要提交，干净的工作区[root@localhost firstgit]# [root@localhost firstgit]# lsreadme.txt其中git status # 查询当前git仓库状态 git diff readme.txt # 查询发生变化的内容 -hello world 表示删减了hello world+hello eagleslab 表示增加了hello eagleslab 3.查询历史记录并版本退回 123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@node1 firstgit]# git logcommit 3efa7f0fc058f00b0a98171fb77b44ab31481c87 # 版本IDAuthor: Cokeku &lt;1154283293@qq.com&gt;Date: Mon Mar 18 22:42:38 2019 -0400 add zjcommit 7b92afbb9f118f7ae10c49abc3114e4ee91ed26aAuthor: Cokeku &lt;1154283293@qq.com&gt;Date: Mon Mar 18 22:37:05 2019 -0400 change messagescommit e380d2cc936e01e17065408000c42c21f114321aAuthor: Cokeku &lt;1154283293@qq.com&gt;Date: Mon Mar 18 22:31:25 2019 -0400 write a readme.txt file[root@node1 firstgit]# git reset --hard e380d2cc936e01e17065408000c42c21f114321a HEAD is now at e380d2c write a readme.txt file[root@node1 firstgit]# cat readme.txt hello world[root@node1 firstgit]# git reset --hard 3efa7f0fc058f00b0a98171fb77b44ab31481c87HEAD is now at 3efa7f0 add zj[root@node1 firstgit]# cat readme.txt hello eagleslab zhengjiang![root@localhost firstgit]# git logcommit 01633f92603eea86884e9ba4cc181fee859016adAuthor: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 15:07:06 2019 +0800 change messagescommit c3913073a08501d652624c2a0ccbe32e2aa70014Author: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 15:05:58 2019 +0800 write something[root@localhost firstgit]# cat readme.txt hello eagleslab[root@localhost firstgit]# git reset --hard c3913073a08501d652624c2a0ccbe32e2aa70014HEAD 现在位于 c391307 write something[root@localhost firstgit]# cat readme.txt hello world[root@localhost firstgit]# 其中git reset --hard 版本ID # 退回指定版本 4.回滚失误怎么办？记录每一次的命令： 123456789[root@localhost firstgit]# git reflogc391307 HEAD@&#123;0&#125;: reset: moving to c3913073a08501d652624c2a0ccbe32e2aa7001401633f9 HEAD@&#123;1&#125;: commit: change messagesc391307 HEAD@&#123;2&#125;: commit (initial): write something[root@localhost firstgit]# git reset --hard 01633f9HEAD 现在位于 01633f9 change messages[root@localhost firstgit]# cat readme.txt hello eagleslab[root@localhost firstgit]# 控制版本历史记录：因为git内部有个Head指针指向当前的版本，如果需要退回版本，只需要将Head指针指向相对应的版本号id，并且更新工作区文件。版本号不用写全，如图复制粘贴即可。 工作区和暂存区 工作区：当前所在的firstgit目录就是一个工作区 .git不算工作区，只是Git的版本库 版本库中有暂存区和自动创建的master分支及指向master的一个指针HEAD git add将文件放到缓存区（暂存区）中，git commit将缓存区内的文件提交到仓库中，提交到仓库中之后我们用git status才能看到working directory clean工作区域变空，我们的仓库的内容才是最新的，所以每次工作对仓库内容进行更改之后，要git add并且git commit。 git add：将修改后文件添加到暂存区 git commit：将暂存区的所有文件提交到master分支上 git跟踪的是每次修改而不是文件，如果不将修改添加到暂存区是无法加入commit中的 撤销修改 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset –hard 版本id，就回到了场景1，第二步按场景1操作 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，版本退回即可，不过前提是没有推送到远程库 删除文件 123456[root@localhost firstgit]# git status# On branch master# Changes not staged for commit:# (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) # 先删除再提交# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) # 将版本库中的最新内容同步到工作区# deleted: readme.tx 实例测试12345678910[root@localhost firstgit]# echo &quot;i am first&quot; &gt; 1.txt[root@localhost firstgit]# git add 1.txt [root@localhost firstgit]# git commit -m &quot;add 1.txt&quot;[master 6f7081e] add 1.txt 1 file changed, 1 insertion(+) create mode 100644 1.txt[root@localhost firstgit]# git status# 位于分支 master无文件要提交，干净的工作区[root@localhost firstgit]# 场景1：当你改乱了1.txt的内容，想直接丢弃工作区的修改时，用命令git checkout – file 123456789[root@localhost firstgit]# vim 1.txt [root@localhost firstgit]# cat 1.txt i am firstasdiausdaushduahsdiuhiuasjdoaishd[root@localhost firstgit]# git checkout 1.txt [root@localhost firstgit]# cat 1.txt i am first[root@localhost firstgit]# 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset –hard 版本id ，就回到了场景1；第二步按场景1操作。 123456789101112131415161718192021222324252627282930313233[root@localhost firstgit]# vim 1.txt [root@localhost firstgit]# cat 1.txt i am firstiauhdiusa&apos;asdhausddoaushdiau[root@localhost firstgit]# git add 1.txt [root@localhost firstgit]# git logcommit 6f7081e1b06730504533015604d51e55e21c175aAuthor: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 15:52:47 2019 +0800 add 1.txtcommit 01633f92603eea86884e9ba4cc181fee859016adAuthor: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 15:07:06 2019 +0800 change messagescommit c3913073a08501d652624c2a0ccbe32e2aa70014Author: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 15:05:58 2019 +0800 write something[root@localhost firstgit]# git reset --hard 6f7081e1b06730504533015604d51e55e21c175aHEAD 现在位于 6f7081e add 1.txt[root@localhost firstgit]# git checkout 1.txt [root@localhost firstgit]# cat 1.txt i am first[root@localhost firstgit]# git status# 位于分支 master无文件要提交，干净的工作区[root@localhost firstgit]# 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，版本退回即可，不过前提是没有推送到远程库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[root@localhost firstgit]# vim 1.txt [root@localhost firstgit]# cat 1.txt i am firstduasgiu\aasdasdasdasdasd[root@localhost firstgit]# git add 1.txt [root@localhost firstgit]# git commit -m &quot;add trash 1.txt&quot;[master ec3d8c4] add trash 1.txt 1 file changed, 7 insertions(+)[root@localhost firstgit]# git status# 位于分支 master无文件要提交，干净的工作区[root@localhost firstgit]# git logcommit ec3d8c40f68aa9928d7294c61866be82a2b8f81dAuthor: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 16:03:03 2019 +0800 add trash 1.txtcommit 6f7081e1b06730504533015604d51e55e21c175aAuthor: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 15:52:47 2019 +0800 add 1.txtcommit 01633f92603eea86884e9ba4cc181fee859016adAuthor: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 15:07:06 2019 +0800 change messagescommit c3913073a08501d652624c2a0ccbe32e2aa70014Author: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 15:05:58 2019 +0800 write something[root@localhost firstgit]# git reset --hard 6f7081e1b06730504533015604d51e55e21c175aHEAD 现在位于 6f7081e add 1.txt[root@localhost firstgit]# cat 1.txt i am first[root@localhost firstgit]# git status# 位于分支 master无文件要提交，干净的工作区[root@localhost firstgit]# 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-git-01 git基础学习]]></title>
    <url>%2Fgit-01%2F</url>
    <content type="text"><![CDATA[linux-git-01 git基础学习概念引入在一个游戏公司里面有若干个部门，游戏中增加了一个新英雄，正常的开发流程是： 当前版本1.0的游戏–&gt;设计人物模型–&gt;设计技能模型–&gt;代码开发–&gt;测试–&gt;运维部署–&gt;版本升级为2.0 但是，不用部门开发效率不同，例如游戏人物模型设计好了但是技能模型没写完，二技能三技能都有了但是大招还没设计好，这时后面的所有部门就需要等待，等技能模型全部设计完成之后才能发布到第二版开发环境，测试时发现bug，等的时间就浪费了。 于是这里就有了持续集成： 不同部门开发出某一技能或某一皮肤模型就提交到第一版集成环境测试，看看会不会出错，不用等到第二版再测试；代码开发好之后，交付测试人员，持续交付；测试人员测试好之后给部署人员，持续部署。 这样做的好处就是，例如开发出一个二技能，就先测试这个二技能，在测试部门测试这个二技能的同时，技能设计部门还可以继续设计三技能，这样测试部门无需等到设计部门把新英雄的所有技能都设计出来就可以开始测试，所以称之为持续交付测试。同样的道理，测试人员测试某一技能没有问题的话，先把这个技能给运维部门先部署好，不用等到所有的技能都测好才进行部署，这样运维部门也能同时运作起来而不是傻傻地等。 总之，一个串行的开发流程，变成了半串行半并行的开发流程，如下图： 由上图可得，无论从时间还是效率上来看，都是持续交付的模式更优。那么，如何做到高效的版本管理呢？答案呼之欲出：git 概念解析GIT （分布式版本控制系统） Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 是用于 Linux内核开发的版本控制工具。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持（wingeddevil注：这得分是用什么样的服务端，使用http协议或者git协议等不太一样。并且在push和pull的时候和服务器端还是有交互的。），使源代码的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux kernel 这样的大项目来说自然很重要。 Git 最为出色的是它的合并跟踪（merge tracing）能力。 gitHub gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。 gitHub于2008年4月10日正式上线，除了git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。 GitHub可以托管各种git库，并提供一个web界面，但它与外国的SourceForge、Google Code或中国的coding的服务不同，GitHub的独特卖点在于从另外一个项目进行分支的简易性。为一个项目贡献代码非常简单：首先点击项目站点的“fork”的按钮，然后将代码检出并将修改加入到刚才分出的代码库中，最后通过内建的“pull request”机制向项目负责人申请代码合并。已经有人将GitHub称为代码玩家的MySpace。 GitLab GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务，安装方法可以参考GitLab在GitHub上的Wiki页面。 举例分析 例如，我在github上放了一个公开项目abc，初始版本是abc1.0，那么其他所有人都可以看到我的这个abc项目，并且可以对它进行下载或者克隆等。现在有甲乙丙丁四个人，甲看到我的项目还不错，但是有些地方需要修改完善一下，于是他下载了一份abc1.0到他们自己的电脑上对之进行修改。甲修改了abc1.0里面一张叫做a.jpg的图片，然后提交给我，请求采用他修改后的项目，我看到甲的确把a.jpg修改得更漂亮了，那么我就采用了甲修改后的项目，并将版本更新为abc2.0。 过了几天，乙和丙下载了我的项目abc2.0， 乙修改了abc2.0里面的b.jpg和c.jpg，丙修改了abc2.0里面的c.jpg和d.jpg，然后，两人都请求我采用他修改后的项目。这样一来，乙丙二人的修改之间就产生了冲突，这就是两个不同的项目分支。这时候我就需要做分支合并了，我会对两人的项目进行对比，发现二人之间冲突的是图片c.jpg，那么我会选择其中一个人修改后的c.jpg到新版项目里。另外，乙改好的b.jpg和丙改好的d.jpg也会被加到新版项目里。最终，分支合并完成，项目升级到了abc3.0。 后来又过了几天，丁下载了abc3.0，觉得其实可以省略所有图片，于是删除了a.jpg、b.jpg、c.jpg、d.jpg，然后请求我采用他修改后的项目。我觉得他的想法不错，就采用了其项目，于是就有了abc4.0。 这样的话，如果公司要赶项目，可以在最基础的1.0版本的项目上，多人同时开发，每做出一步改动就可以先同步到仓库中，不断地分之与合并，可以高效快速地吸取所有人的优秀改动到项目中。即使后面发现有些改动并不合适，也可以进行版本回滚，相当于对于每一次改动都做了备份，不会出现辛辛苦苦几十年，一夜回到解放前的尴尬状况。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-ansible-06 ansible-playbook部署LNMP]]></title>
    <url>%2Fansible-06%2F</url>
    <content type="text"><![CDATA[linux-ansible-06 ansible-playbook部署LNMP实验准备实验涉及到了unarchive模块，这个模块之前没有学到，这里加以补充。 ansible unarchive模块unarchive模块：http://docs.ansible.com/ansible/unarchive_module.html 功能：解压缩 用法： 1、将ansible主机上的压缩包在本地解压缩后传到远程主机上，这种情况下，copy=yes. 本地解压缩,解压缩位置不是默认的目录,没找到或传完删了 后传到远程主机 2、将远程主机上的某个压缩包解压缩到指定路径下。这种情况下，需要设置copy=no 远程主机上面的操作,不涉及ansible服务端 参数： copy：默认为yes，当copy=yes，那么拷贝的文件是从ansible主机复制到远程主机上的，如果设置为copy=no，那么会在远程主机上寻找src源文件 src：源路径，可以是ansible主机上的路径，也可以是远程主机上的路径，如果是远程主机上的路径，则需要设置copy=no dest：远程主机上的目标路径 mode：设置解压缩后的文件权限 实验环境准备两台干净的虚拟机 node1（ansible管理机）：192.168.141.53 node2（客户端）：192.168.141.69 配置准备node1安装ansible 12[root@node1 ~]# yum install epel-release -y[root@node1 ~]# yum install ansible -y 服务端修改主机清单配置文件host 123456[root@node1 ~]# vim /etc/ansible/hosts#在文档末尾加上一下这几行[node]node2 服务端修改host文件 12345[root@node1 ~]# vim /etc/hosts#在文档中加入下列一行192.168.141.69 node2 实现管理机对所有客户端的免密钥登录—ssh-key在node1生成密钥#提示生成的密钥放在/root/.ssh/id_dsa #提示是否给生成的密钥再加密一次，回车即可 #让你再确认一次，回车即可。 1234567891011121314151617181920212223242526272829[root@node1 ~]# ssh-keygen -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): #直接回车Created directory &apos;/root/.ssh&apos;.Enter passphrase (empty for no passphrase): #直接回车Enter same passphrase again: #直接回车Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:ekKryIWOOpY+BnW5QhineRozN2nLqYz1EEwM8fa1BoE root@node1The key&apos;s randomart image is:+---[RSA 2048]----+|o+ .. ||..E . || Oo.... ||B.@.oo . || % *..+ S ||o B..o o ||+oo+. + . ||+X o.. o ||Bo= . |+----[SHA256]-----+[root@node1 ~]# ll /root/.ssh/总用量 8-rw-------. 1 root root 1675 4月 11 11:30 id_rsa #生成后的私钥文件-rw-r--r--. 1 root root 392 4月 11 11:30 id_rsa.pub #公钥文件[root@node1 ~]# 把公钥发送到客户端机器上，第一次连接要输入yes，记录主机名跟IP，然后输出对方的密码即可 1[root@node1 ~]# ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.141.69 #公钥发送过去之后，登录对方的机器不用密码了。 1234567[root@node1 ~]# ssh 192.168.141.69Last login: Thu Apr 11 11:24:30 2019 from 192.168.141.1[root@node2 ~]# [root@node2 ~]# exit登出Connection to 192.168.141.69 closed.[root@node1 ~]# ansible测试第一次执行ansible的命令需要加yes回车，但是之后就可以直接执行了。 12345678910111213[root@node1 ~]# ansible node2 -m command -a &quot;echo hello&quot;The authenticity of host &apos;node2 (192.168.141.69)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:cFZVkPh6j57TyfDgnCxFrAXPxeifK3T2cUCZGde78uE.ECDSA key fingerprint is MD5:74:27:63:2b:dd:8e:28:b5:a0:fa:01:5d:75:5d:8e:b1.Are you sure you want to continue connecting (yes/no)? yesnode2 | CHANGED | rc=0 &gt;&gt;hello[root@node1 ~]# ansible node2 -m command -a &quot;echo hello&quot;node2 | CHANGED | rc=0 &gt;&gt;hello[root@node1 ~]# 实验步骤node1上roles文件夹里定义文件结构tree 123456789101112131415161718192021222324252627282930313233343536[root@node1 ~]# yum install tree -y[root@node1 ~]# mkdir -pv /etc/ansible/roles/&#123;mysql,php,web&#125;/&#123;files,templates,tasks,handlers,vars,meta,default&#125;[root@node1 ~]# cd /etc/ansible/roles/[root@node1 roles]# lsmysql php web[root@node1 roles]# tree.├── mysql│ ├── default│ ├── files│ ├── handlers│ ├── meta│ ├── tasks│ ├── templates│ └── vars├── php│ ├── default│ ├── files│ ├── handlers│ ├── meta│ ├── tasks│ ├── templates│ └── vars└── web ├── default ├── files ├── handlers ├── meta ├── tasks ├── templates └── vars24 directories, 0 files[root@node1 roles]# 可以看到roles文件夹下主要有三个文件夹：web、php、mysql。 web在files文件夹准备好wordpress的安装包，准备好web.conf作为配置文件 1234567891011121314151617181920212223242526272829303132333435363738[root@node1 roles]# cd web/[root@node1 web]# lsdefault files handlers meta tasks templates vars[root@node1 web]# cd files[root@node1 files]# wget http://wordpress.org/latest.tar.gz[root@node1 files]# vim web.conf[root@node1 files]# cat web.conf worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; server &#123; listen 80; server_name www.static.com; location / &#123; root html; index index.php index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; location ~ \.php$ &#123; root /usr/share/nginx/html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; &#125;&#125;[root@node1 files]# lslatest.tar.gz web.conf[root@node1 files]# 在tasks、handlers文件夹下创建编辑main.yml 12345678910111213141516171819202122232425262728293031323334353637[root@node1 files]# cd ..[root@node1 web]# lsdefault files handlers meta tasks templates vars[root@node1 web]# cd tasks[root@node1 tasks]# vim main.yml[root@node1 tasks]# cat main.yml - name: add user nginx user: name=nginx group=root uid=666- name: install epel-release yum: name=epel-release state=latest- name: disable selinux selinux: state=disabled- name: firewalld enabled ports firewalld: port=80/tcp state=enabled permanent=yes- name: firewalld reload command: firewall-cmd --reload- name: install nginx yum: name=nginx state=latest notify: restart nginx- name: install conf copy: src=web.conf dest=/etc/nginx/nginx.conf tags: conf- name: copy and unzip blog unarchive: src=latest.tar.gz dest=/usr/share/nginx/html/- name: set mode file: name=/usr/share/nginx/html/wordpress recurse=yes owner=nginx group=nginx- name: start nginx service: name=nginx state=started enabled=yes[root@node1 tasks]# cd ..[root@node1 web]# cd handlers/[root@node1 handlers]# vim main.yml[root@node1 handlers]# cat main.yml - name: restart nginx service: name=nginx state=restarted[root@node1 handlers]# cd ..[root@node1 web]# cd ..[root@node1 roles]# php在tasks文件夹下创建编辑main.yml 12345678910111213141516171819202122232425[root@node1 roles]# cd php/tasks/[root@node1 tasks]# vim main.yml[root@node1 tasks]# cat main.yml - name: install php yum: name=&#123;&#123; item &#125;&#125; state=present with_items: - php-mysql - php-fpm- name: start php-fpm service: name=php-fpm state=started enabled=yes[root@node1 tasks]# cd ..[root@node1 php]# tree.├── default├── files├── handlers├── meta├── tasks│ └── main.yml├── templates└── vars7 directories, 1 file[root@node1 php]# cd ..[root@node1 roles]# mysql在tasks文件夹下创建编辑main.yml，在files文件夹下创建编辑my.cnf。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[root@node1 roles]# cd mysql[root@node1 mysql]# vim tasks/main.yml[root@node1 mysql]# cat tasks/main.yml - name: install mariadb yum: name=&#123;&#123; item &#125;&#125; state=present with_items: - mariadb - mariadb-server- name: install conf copy: src=my.cnf dest=/etc/my.cnf- name: start mariadb service: name=mariadb state=started enabled=yes- name: mysql command: mysql -e &quot;create database wordpress;grant all on wordpress.* to wordpress@&apos;192.168.141.69&apos; identified by &apos;123456&apos;;&quot;- name: command command: mysql -e &quot;grant replication slave,replication client on *.* to &apos;backuper&apos;@&apos;192.168.141.69&apos; identified by &apos;backuper&apos;;&quot;[root@node1 mysql]# [root@node1 mysql]# vim files/my.cnf[root@node1 mysql]# cat files/my.cnf [mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.socksymbolic-links=0log_bin=master_binserver_id=1innodb_file_per_table=ONskip_name-resolve=ON[mysqld_safe]log-error=/var/log/mariadb/mariadb.logpid-file=/var/run/mariadb/mariadb.pid[root@node1 mysql]# tree.├── default├── files│ └── my.cnf├── handlers├── meta├── tasks│ └── main.yml├── templates└── vars7 directories, 2 files[root@node1 mysql]# cd ..[root@node1 roles]# roles在roles文件夹创建编辑调用role的文件lnmp.yml。 123456789[root@node1 roles]# vim lnmp.yml[root@node1 roles]# cat lnmp.yml - hosts: node2 remote_user: root roles: - php - web - mysql[root@node1 roles]# 部署 1[root@node1 roles]# ansible-playbook lnmp.yml 结果如下图，警告不用管，没有报错，执行完毕。 接下来我们到node2上验证一下防火墙和selinux状态 12345[root@node2 ~]# firewall-cmd --list-ports80/tcp[root@node2 ~]# getenforce Permissive[root@node2 ~]# 接下来验证lnmp架构的可用性 浏览器打开http://192.168.141.69/wordpress ，即可看到wordpress的安装界面了，其中192.168.141.69是node2的ip地址。 至于后面在这个网页端安装wordpress就省略了，本次验证已经完毕，结果是我们通过ansible的playbook成功部署出了一个采用LNMP架构的网站。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-ansible-05 ansible-playbook-roles]]></title>
    <url>%2Fansible-05%2F</url>
    <content type="text"><![CDATA[linux-ansible-05 ansible-playbook-roles通过playbook角色目录（roles）安装apache 前面写过了ansible常用的模块介绍，熟悉这些模块是基础，接下来我们通过一个实例来介绍playbook，playbook通过灵活的组装这些基础模块组件，可以适应各种复杂的业务操作场景。 在上一篇文章中，我们给出了角色目录文件结构tree的官方案例，现在我们将它实现出来自己做一个案例，具体如下： 12345678910111213141516171819202122[root@test ~]# cd /etc/ansible/[root@test ansible]# [root@test ansible]# yum install tree -y[root@test ansible]# tree roles/roles/├── httpd│ ├── defaults│ ├── files│ │ └── index.html│ ├── handlers│ │ └── main.yaml│ ├── metas│ ├── tasks│ │ └── main.yaml│ ├── templates│ │ └── vhost1.conf.j2│ └── vars│ └── main.yaml└── httpd.yaml8 directories, 6 files[root@test ansible]# 在roles文件夹里，创建httpd文件夹以及httpd.yaml，编辑httpd.yaml内容如下 1234567891011121314[root@test ~]# cd /etc/ansible/roles[root@test roles]# [root@test roles]# ls[root@test roles]# mkdir httpd[root@test roles]# vim httpd.yaml[root@test roles]# cat httpd.yaml - hosts: node3 remote_user: root roles: - httpd[root@test roles]# lshttpd httpd.yaml[root@test roles]# 在httpd目录下创建所需要的所有目录 12345678910111213[root@test roles]# cd httpd[root@test httpd]# ls[root@test httpd]# mkdir &#123;defaults,tasks,vars,templates,handlers,files,metas&#125; -pvmkdir: created directory ‘defaults’mkdir: created directory ‘tasks’mkdir: created directory ‘vars’mkdir: created directory ‘templates’mkdir: created directory ‘handlers’mkdir: created directory ‘files’mkdir: created directory ‘metas’[root@test httpd]# lsdefaults files handlers metas tasks templates vars[root@test httpd]# 在files目录下创建默认页面，里面随便写一句话就好，我写的是hello ansible ! 123456[root@test httpd]# cd files/[root@test files]# vim index.html[root@test files]# cat index.html hello ansible ![root@test files]# cd ..[root@test httpd]# 在handlers目录下创建并且编辑main.yaml，如下 12345678[root@test httpd]# cd handlers/[root@test handlers]# ls[root@test handlers]# vim main.yaml[root@test handlers]# cat main.yaml - name: reload httpd service: name=httpd state=reloaded[root@test handlers]# cd ..[root@test httpd]# 在tasks目录下创建并且编辑main.yaml，如下 1234567891011121314151617181920212223242526[root@test httpd]# cd tasks/[root@test tasks]# ls[root@test tasks]# vim main.yaml[root@test tasks]# cat main.yaml - name: config hostname command: hostnamectl set-hostname &#123;&#123; hostname &#125;&#125;- name: config resolv file copy: src=/etc/resolv.conf dest=/etc/resolv.conf- name: install service httpd yum: name=httpd state=latest- name: config httpdconf template: src: vhost1.conf.j2 dest: /etc/httpd/conf.d/vhost1.conf notify: - reload httpd- name: disable selinux selinux: state=disabled- name: config vhost1 index.html copy: src=index.html dest=/var/www/- name: firewalld ports command: firewall-cmd --add-port=&#123;&#123; port &#125;&#125;/tcp - name: start httpd service: name=httpd state=started enabled=yes[root@test tasks]# cd ..[root@test httpd]# 在templates目录下创建并且编辑vhost1.conf.j2，如下 1234567891011[root@test httpd]# cd templates/[root@test templates]# ls[root@test templates]# vim vhost1.conf.j2[root@test templates]# cat vhost1.conf.j2 Listen &#123;&#123; port &#125;&#125;&lt;VirtualHost *:&#123;&#123; port &#125;&#125;&gt; Servername &#123;&#123; hostname &#125;&#125; DocumentRoot &quot;/var/www/&quot;&lt;/VirtualHost&gt;[root@test templates]# cd ..[root@test httpd]# 在vars目录下创建并且编辑main.yaml，如下 123456789[root@test httpd]# cd vars/[root@test vars]# ls[root@test vars]# vim main.yaml[root@test vars]# cat main.yaml port: 8080hostname: node3[root@test vars]# cd ..[root@test httpd]# 回到roles目录下，执行httpd.yaml，可以看到执行成功 123456789101112131415161718192021222324252627282930313233343536373839404142[root@test httpd]# cd ..[root@test roles]# lshttpd httpd.yaml[root@test roles]# ansible-playbook httpd.yaml [WARNING]: Found variable using reserved name: portPLAY [node3] *********************************************************************************************************TASK [Gathering Facts] ***********************************************************************************************ok: [node3]TASK [httpd : config hostname] ***************************************************************************************changed: [node3]TASK [httpd : config resolv file] ************************************************************************************ok: [node3]TASK [httpd : install service httpd] *********************************************************************************ok: [node3]TASK [httpd : config httpdconf] **************************************************************************************ok: [node3]TASK [httpd : disable selinux] *************************************************************************************** [WARNING]: SELinux state change will take effect next rebootok: [node3]TASK [httpd : config vhost1 index.html] ******************************************************************************ok: [node3]TASK [httpd : firewalld ports] ***************************************************************************************changed: [node3]TASK [httpd : start httpd] *******************************************************************************************ok: [node3]PLAY RECAP ***********************************************************************************************************node3 : ok=9 changed=2 unreachable=0 failed=0 [root@test roles]# 注意：2.4版本的ansible的task/main.yaml的notify配置时，因为dict不可哈希，所以采用 12notify:- name: restart apache 时会报错： ERROR! Unexpected Exception, this is probably a bug: unhashable type: ‘dict’如何遇到此类问题，是因为dict不可哈希，所以notify在配置下，使用可哈希数据类型即可 12notify:- restart apache 上面的配置使用的是不报错的- restart apache，能够一次性执行成功！如下图： 测试给node3安装apache后的结果，浏览器访问node3的主页，可以看到我们之前给node3的index.html内写入的hello ansible ！ 1http://192.168.141.69:8080/ 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-ansible-04 ansible-playbook]]></title>
    <url>%2Fansible-04%2F</url>
    <content type="text"><![CDATA[linux-ansible-04 ansible-playbook概念解析playbook Playbooks俗称”剧本“，是一种高效运用Ansible的方式，也是系统ansible命令的集合。playbook利用yaml语言编写，其命令根据自上而下的顺序依次执行。 简单来说，Playbooks 是一种简单的配置管理系统与多机器部署系统的基础。与现有的其他系统有不同之处，且非常适合于复杂应用的部署。 同时，Playbooks开创了很多特性，它可以允许你传输某个命令的状态到后面的指令，如你可以从一台机器的文件中抓取内容并附为变量，然后在另一台机器中使用，这使得你可以实现一些复杂的部署机制，这是ansible命令无法实现的。 Playbooks可用于声明配置，更强大的地方在于，在Playbooks中可以编排有序的执行过程，甚至于做到在多组机器间，来回有序的执行特别指定的步骤。并且可以同步或异步的发起任务。 我们完成一个任务，例如安装部署一个httpd服务，我们需要多个模块（一个模块也可以称之为task）提供功能来完成。而playbook就是组织多个task的容器，他的实质就是一个文件，有着特定的组织格式，它采用的语法格式是YAML（Yet Another Markup Language）。YAML语法能够简单的表示散列表，字典等数据结构，详情可参考：YAML详细语法 。 YAML YAML是“YAML不是一种标记语言”的外语缩写，又被称为“另外一种标记语言”，但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名。它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。 playbook基础组件Hosts：运行执行任务（task）的目标主机 remote_user：在远程主机上执行任务的用户 tasks：任务列表，由模块定义的操作列表 handlers：任务，和nogity结合使用，为条件触发操作，满足条件方才执行，否则不执行；与tasks不同的是只有在接受到通知时才会被触发。 templates：使用模板语言的文本文件，使用jinja2语法。 variables：变量，变量替换{{ variable_name }}，内置变量或自定义变量在playbook中调用 roles: 角色 整个playbook是以task为中心，表明要执行的任务；hosts和remote_user表明在哪些远程主机以何种身份执行；其他组件让其能够更加灵活。 官方实例12345678910111213141516171819202122232425- hosts: webservers vars: http_port: 80 max_clients: 200 remote_user: root tasks: - name: ensure apache is at the latest version yum: name: httpd state: latest - name: write the apache config file template: #作用：将变量在远程主机上变成指定的值，应用变量传参 src: /srv/httpd.j2 #源文件必须以j2结尾 dest: /etc/httpd.conf notify: - restart apache - name: ensure apache is running service: name: httpd state: started handlers: - name: restart apache service: name: httpd state: restarted 1234567运行： -t Tag 指定运行特定的任务 --skip-tags=SKIP_TAGS 跳过指定的标签 --start-at-task=START_AT 从哪个任务后执行 使用 -e选项传入参数，例如： ansible-playbook 192.168.200.136 -e &quot;httpd_port=808&quot; httpd04.yml 实例解析webservers是官方对其管理机所管理服务器的统称，我们这里用的是node。 vars: #在playbook中定义变量 http_port: 80 max_clients: 200 变量的引用： 变量变量的来源： ansible setup facts远程主机的所有变量都可以用 自定义变量 优先级： 通过命令行指定变量，优先级最高 在/etc/ansible/hosts 定义变量，在主机组中的主机单独定义 在/etc/ansible/hosts 定义变量，针对主机组中的所有主机集中定义变量 在Playbook中定义变量（建议使用这种方法） 模版 使用模板语言的文本文件内部嵌套有模板语言脚本（使用模板语言编写） Jinja2 是由python编写的。在我们打算使用基于文本的模板语言时，jinja2是很好的解决方案。yaml是写playbook，jinja2是写配置文件模板的。 功能：将模板的文件的变量值转换成对应的本地主机的确定值。例如：ansible端写一个内建变量，当这个文件被复制到对应主机时会自动生成对应主机 cpu的颗数的结果替换之。 templates文件必须存放在templates目录下 yaml文件需要和templates目录平级 template只能在palybook中使用。 Jinja2语法 123456789101112字面量： 字符串：使用单引号或双引号； 数字：整数、浮点数； 列表：[item1, item2, ...] 元组：(item1, item2, ...) 字典：&#123;key1:value1, key2:value2, ...&#125; 布尔型：true/false算术运算： +, -, *, /, //, %, **比较操作： ==, !=, &gt;, &lt;, &gt;=, &lt;=逻辑运算：and, or, not 实例123456789101112131415161718192021[root@node1 templates]# cat nginxconf.j2.bak &#123;% for vhost in nginx_vhosts %&#125;server &#123; listen &#123;&#123; vhost &#125;&#125;# listen &#123;&#123; vhost.listen &#125;&#125;&#125;&#123;% endfor %&#125;worker_processes &#123;&#123; ansible_processor_vcpus &#125;&#125;;[root@node1 tmp]# cat nginxtemp.yam- hosts: mageduweb remote_user: root vars: nginx_vhosts: - web1 - web2 - web3# nginx_vhosts:# - listen: 8080 tasks: - name: template config to remote hosts template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf 条件判断一般通过when或者迭代循环 123- name: restart Nginx service: name=nginx state=restarted when: ansible_distribution_major_version == &quot;6&quot; 循环迭代迭代列表或者键值对 12345678910111213141516171819#基于字符串列表 tasks: - name: create rsyncd file copy: src=&#123;&#123; item &#125;&#125; dest=/tmp/&#123;&#123; item &#125;&#125; with_items: - a - b - c - d*with_itmes 嵌套子变量*#基于字典列表- hosts: eagleslab remote_user: root tasks: - name: add several users user: name=&#123;&#123; item.name &#125;&#125; state=present groups=&#123;&#123; item.groups &#125;&#125; with_items: - &#123; name: &apos;testuser1&apos; , groups: &apos;wheel&apos;&#125; - &#123; name: &apos;testuser2&apos; , groups: &apos;root&apos; &#125; 角色roles12345678910[root@node1 ~]# tree /etc/ansible/roles//etc/ansible/roles/└── http ├── defaults ├── files ├── headlers ├── meta ├── tasks ├── template └── varsfiles/：存储由copy或script等模块调用的文件； tasks/：此目录中至少应该有一个名为main.yml的文件，用于定义各task；其它的文件需要由main.yml进行“包含”调用； handlers/：此目录中至少应该有一个名为main.yml的文件，用于定义各handler；其它的文件需要由main.yml进行“包含”调用； vars/：此目录中至少应该有一个名为main.yml的文件，用于定义各variable；其它的文件需要由main.yml进行“包含”调用； templates/：存储由template模块调用的模板文本； meta/：此目录中至少应该有一个名为main.yml的文件，定义当前角色的特殊设定及其依赖关系；其它的文件需要由main.yml进行“包含”调用； default/：此目录中至少应该有一个名为main.yml的文件，用于设定默认变量； files目录：存放由copy或script等模块调用的文件； 调用roles12345[root@node1 ~]# cat /etc/ansible/roles/site.yml- hosts: abc remote_user: root roles: - httpd 实例分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677[root@node1 ansible]# tree roles/roles/├── http│ ├── defaults│ │ └── main.yaml│ ├── files│ │ └── index.html│ ├── headlers│ │ └── main.yaml│ ├── meta│ │ └── main.yaml│ ├── tasks│ │ └── main.yaml│ ├── templates│ │ └── httpd.conf.j2│ └── vars│ └── main.yaml└── site.yaml[root@node1 roles]# cat site.yaml - hosts: node2 remote_user: root# vars:# httpd_ports: 8080 roles: - http[root@node1 http]# cat files/index.html hello eagleslab![root@node1 http]# cat tasks/main.yaml - name: installed httpd service yum: name=httpd state=latest when: ansible_os_family == &quot;RedHat&quot;- name: start httpd server service: name=httpd state=restarted - name: write httpd config template: src=httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf notify: - restart httpd- name: config httpd index copy: src=index.html dest=/var/www/html/index.html[root@node1 http]# cat templates/httpd.conf.j2 | grep -Ev &quot;^[[:space:]]|^#&quot;ServerRoot &quot;/etc/httpd&quot;Listen &#123;&#123; httpd_ports &#125;&#125;Include conf.modules.d/*.confUser apacheGroup apacheServerAdmin root@localhost&lt;Directory /&gt;&lt;/Directory&gt;DocumentRoot &quot;/var/www/html&quot;&lt;Directory &quot;/var/www&quot;&gt;&lt;/Directory&gt;&lt;Directory &quot;/var/www/html&quot;&gt;&lt;/Directory&gt;&lt;IfModule dir_module&gt;&lt;/IfModule&gt;&lt;Files &quot;.ht*&quot;&gt;&lt;/Files&gt;ErrorLog &quot;logs/error_log&quot;LogLevel warn&lt;IfModule log_config_module&gt;&lt;/IfModule&gt;&lt;IfModule alias_module&gt;&lt;/IfModule&gt;&lt;Directory &quot;/var/www/cgi-bin&quot;&gt;&lt;/Directory&gt;&lt;IfModule mime_module&gt;&lt;/IfModule&gt;AddDefaultCharset UTF-8&lt;IfModule mime_magic_module&gt;&lt;/IfModule&gt;EnableSendfile onIncludeOptional conf.d/*.conf[root@node1 http]# cat headlers/main.yaml - name: restart httpd service: name=httpd state=restarted[root@node1 http]# cat vars/main.yaml httpd_ports: 8000 任务tasks执行的模块命令 12345678910111213格式： action：模块参数（此种方式只在较新的版本中出现） module：参数(已键值对的形式出现)每一个task都有一个名称，用于标记此任务。任务示例： name: install httpd yum: name=httpd state=present注意：shell和command没有参数，可在后面直接跟命令 shell: ss -tnl | grep :80（1）某任务的运行状态为changed后，可通过相应的notify通知相应的handlers（2）任务可以通过tags打标签，然后通过palybook命令-t选项调用. playbook调用方式1234567891011用法：ansible-playbook &lt;filename.yml&gt; ... [options] &lt;filename.yml&gt;:yaml格式的playbook文件路径，必须指明 [options]: 选项 -C, --check：并不在远程主机上执行，只是测试。 -i PATH, --inventory=PATH：资产的文件路径 --flush-cache：清楚fact缓存 --list-hosts：列出匹配的远程主机，并不执行任何动作 -t, TAGS, --tags=TAGS：运行指定的标签任务 --skip-tags:跳过指定的notify，后面详细介绍。 palybook实验实验准备下述实验环境和之前的一样，无需改动即可。 在服务端安装ansible 12[root@localhost ~]# yum install epel-release -y[root@localhost ~]# yum install ansible -y 服务端修改主机清单配置文件host 1234567[root@localhost ~]# vim /etc/ansible/hosts#在文档末尾加上一下这几行[node]node2node3 服务端修改host文件 123456[root@localhost ~]# vim /etc/hosts#在文档中加入下列两行192.168.141.53 node2192.168.141.69 node3 通过playbook添加用户示例（1）给远程主机node3添加用户test 12345678910111213141516171819202122232425[root@test ~]# vim user.yml[root@test ~]# cat user.yml - hosts: node3 remote_user: root gather_facts: False vars: - user: test tasks: - name: create user user: name=&#123;&#123; user &#125;&#125;[root@test ~]# ansible-playbook user.ymlPLAY [node3] *********************************************************************************************************TASK [create user] ***************************************************************************************************changed: [node3]PLAY RECAP ***********************************************************************************************************node3 : ok=1 changed=1 unreachable=0 failed=0 [root@test ~]# ansible node3 -a &quot;id test&quot;node3 | CHANGED | rc=0 &gt;&gt;uid=1000(test) gid=1000(test) groups=1000(test)[root@test ~]# 上面的playbook 实现的功能是新增一个用户： 123456name：对该playbook实现的功能做一个概述，后面执行过程中，会打印name变量的值hosts：指定了对哪些主机进行参作remote_user：指定了使用什么用户登录远程主机操作gather_facts：指定了在以下任务部分执行前，是否先执行setup模块获取主机相关信息，这在后面的task会使用到setup获取的信息时用到vars：指定了变量，这里指定了一个user变量，其值为test，需要注意的是，变量值一定要用引号引起来tasks：指定了一个任务，其下面的name参数同样是对任务的描述，在执行过程中会打印出来。user提定了调用user模块，name是user模块里的一个参数，而增加的用户名字调用了上面user变量的值 （2）删除远程主机test的账号只需改一行： user: name=”“ state=absent remove=yes 1234567891011121314151617181920212223242526272829[root@test ~]# vim user.yml[root@test ~]# cat user.yml - hosts: node3 remote_user: root gather_facts: False vars: - user: test tasks: - name: create user user: name=&#123;&#123; user &#125;&#125; state=absent remove=yes[root@test ~]# ansible node3 -a &quot;id test&quot;node3 | CHANGED | rc=0 &gt;&gt;uid=1000(test) gid=1000(test) groups=1000(test)[root@test ~]# ansible-playbook user.ymlPLAY [node3] *********************************************************************************************************TASK [create user] ***************************************************************************************************changed: [node3]PLAY RECAP ***********************************************************************************************************node3 : ok=1 changed=1 unreachable=0 failed=0 [root@test ~]# ansible node3 -a &quot;id test&quot;node3 | FAILED | rc=1 &gt;&gt;id: test: no such usernon-zero return code[root@test ~]# 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-ansible-03 ansible常用模块命令实例]]></title>
    <url>%2Fansible-03%2F</url>
    <content type="text"><![CDATA[linux-ansible-03 ansible常用模块命令实例user模块创建一个用户：feng1[root@test ~]# ansible node2 -m user -a &quot;name=feng uid=1024 password=000000 shell=/bin/bash group=root&quot; 可以到node2上查看这个用户的uid，如下，uid确实是1024 12[root@node2 ~]# id fenguid=1024(feng) gid=0(root) 组=0(root) 删除用户123456789[root@test ~]# ansible node2 -m user -a &quot;name=feng state=absent force=yes&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;force&quot;: true, &quot;name&quot;: &quot;feng&quot;, &quot;remove&quot;: false, &quot;state&quot;: &quot;absent&quot;&#125;[root@test ~]# group模块给node2创建一个组fenggroup 123456789[root@test ~]# ansible node2 -m group -a &quot;gid=1024 name=fenggroup system=yes&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;gid&quot;: 1024, &quot;name&quot;: &quot;fenggroup&quot;, &quot;state&quot;: &quot;present&quot;, &quot;system&quot;: true&#125;[root@test ~]# 给node2创建一个用户feng，其主组root，加入到fenggroup附属组 12345678910111213141516171819202122232425[root@test ~]# ansible node2 -m user -a &quot;name=feng uid=1024 password=000000 shell=/bin/bash group=root groups=fenggroup&quot; [WARNING]: The input password appears not to have been hashed. The &apos;password&apos; argument must be encrypted for thismodule to work properly.node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;comment&quot;: &quot;&quot;, &quot;create_home&quot;: true, &quot;group&quot;: 0, &quot;groups&quot;: &quot;fenggroup&quot;, &quot;home&quot;: &quot;/home/feng&quot;, &quot;name&quot;: &quot;feng&quot;, &quot;password&quot;: &quot;NOT_LOGGING_PASSWORD&quot;, &quot;shell&quot;: &quot;/bin/bash&quot;, &quot;state&quot;: &quot;present&quot;, &quot;stderr&quot;: &quot;useradd: warning: the home directory already exists.\nNot copying any file from skel directory into it.\nCreating mailbox file: File exists\n&quot;, &quot;stderr_lines&quot;: [ &quot;useradd: warning: the home directory already exists.&quot;, &quot;Not copying any file from skel directory into it.&quot;, &quot;Creating mailbox file: File exists&quot; ], &quot;system&quot;: false, &quot;uid&quot;: 1024&#125;[root@test ~]# 到node2上查看这个用户的信息，可以看到一切无误 12[root@node2 ~]# id fenguid=1024(feng) gid=0(root) 组=0(root),1024(fenggroup) 删除fenggroup组 1234567[root@test ~]# ansible node2 -m group -a &quot;name=fenggroup state=absent&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;name&quot;: &quot;fenggroup&quot;, &quot;state&quot;: &quot;absent&quot;&#125;[root@test ~]# 此时再到node2上查看这个用户的信息，可以看到它不再从属于fenggroup组了，因为fenggroup组已被删除 12[root@node2 ~]# id fenguid=1024(feng) gid=0(root) 组=0(root) selinux模块首先到node2上查看node2的selinux状态 12[root@node2 ~]# getenforce Enforcing 在test上将node2的selinux关闭掉 12345678910111213[root@test ~]# ansible node2 -m selinux -a &quot;state=disabled&quot; [WARNING]: SELinux state temporarily changed from &apos;enforcing&apos; to &apos;permissive&apos;. State change will take effect nextreboot.node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;configfile&quot;: &quot;/etc/selinux/config&quot;, &quot;msg&quot;: &quot;Config SELinux state changed from &apos;enforcing&apos; to &apos;disabled&apos;&quot;, &quot;policy&quot;: &quot;targeted&quot;, &quot;reboot_required&quot;: true, &quot;state&quot;: &quot;disabled&quot;&#125;[root@test ~]# 再到node2上查看node2的selinux状态，可以看到关闭成功 123456789101112131415161718[root@node2 ~]# getenforce Permissive[root@node2 ~]# cat /etc/selinux/config # This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=disabled# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection.SELINUXTYPE=targeted [root@node2 ~]# firewalld模块放行node2的8080端口，并在node2上进行验证。 12345678910111213141516[root@node1 roles]# ansible node2 -m firewalld -a &quot;port=8080/tcp state=enabled permanent=yes&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;msg&quot;: &quot;Permanent operation, Changed port 8080/tcp to enabled&quot;&#125;[root@node1 roles]#[root@node1 roles]# ansible node2 -m command -a &quot;firewall-cmd --reload&quot;node2 | CHANGED | rc=0 &gt;&gt;success[root@node1 roles]# [root@node2 ~]# firewall-cmd --list-ports8080/tcp[root@node2 ~]# copy模块先在test上创建一个文件user.txt 1[root@test ~]# touch user.txt 将这个文件传送给node2的/tmp目录下 1234567891011121314151617181920212223242526[root@test ~]# ansible node2 -m copy -a &quot;src=/root/user.txt dest=/tmp&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;checksum&quot;: &quot;da39a3ee5e6b4b0d3255bfef95601890afd80709&quot;, &quot;dest&quot;: &quot;/tmp/user.txt&quot;, &quot;gid&quot;: 0, &quot;group&quot;: &quot;root&quot;, &quot;md5sum&quot;: &quot;d41d8cd98f00b204e9800998ecf8427e&quot;, &quot;mode&quot;: &quot;0644&quot;, &quot;owner&quot;: &quot;root&quot;, &quot;secontext&quot;: &quot;unconfined_u:object_r:admin_home_t:s0&quot;, &quot;size&quot;: 0, &quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1553334220.5-91381585251620/source&quot;, &quot;state&quot;: &quot;file&quot;, &quot;uid&quot;: 0&#125;[root@test ~]# ansible node2 -a &quot;ls /tmp&quot;node2 | CHANGED | rc=0 &gt;&gt;ansible_command_payload_ZUXpXhks-script-NiyyISsystemd-private-60d307935d5b4b589a7ba7fb1e063954-chronyd.service-kxndmtuser.txtvmware-rootyum.log[root@test ~]# 往node2的/tmp目录下的user.txt里写入：”hello“ 123456789101112131415161718192021[root@test ~]# ansible node2 -m copy -a &quot;dest=/tmp/user.txt content=hello&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;checksum&quot;: &quot;aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d&quot;, &quot;dest&quot;: &quot;/tmp/user.txt&quot;, &quot;gid&quot;: 0, &quot;group&quot;: &quot;root&quot;, &quot;md5sum&quot;: &quot;5d41402abc4b2a76b9719d911017c592&quot;, &quot;mode&quot;: &quot;0644&quot;, &quot;owner&quot;: &quot;root&quot;, &quot;secontext&quot;: &quot;unconfined_u:object_r:admin_home_t:s0&quot;, &quot;size&quot;: 5, &quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1553334393.04-135202047372696/source&quot;, &quot;state&quot;: &quot;file&quot;, &quot;uid&quot;: 0&#125;[root@test ~]# ansible node2 -a &quot;cat /tmp/user.txt&quot;node2 | CHANGED | rc=0 &gt;&gt;hello[root@test ~]# file模块给node2的/tmp目录下创建一个名为user.test的文件 123456789101112131415161718192021222324252627[root@test ~]# ansible node2 -m file -a &quot;path=/tmp/user.test state=touch owner=root group=root mode=777&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;dest&quot;: &quot;/tmp/user.test&quot;, &quot;gid&quot;: 0, &quot;group&quot;: &quot;root&quot;, &quot;mode&quot;: &quot;0777&quot;, &quot;owner&quot;: &quot;root&quot;, &quot;size&quot;: 0, &quot;state&quot;: &quot;file&quot;, &quot;uid&quot;: 0&#125;[root@test ~]# ansible node2 -a &quot;ls /tmp&quot;node2 | CHANGED | rc=0 &gt;&gt;ansible_command_payload_7oz5ZRks-script-NiyyISsystemd-private-521b915097e843e2a1cd732f94d50984-chronyd.service-sTxtbhuser.testuser.txtvmware-rootyum.log[root@test ~]# ansible node2 -a &quot;ls -l /tmp/user.test&quot;node2 | CHANGED | rc=0 &gt;&gt;-rwxrwxrwx 1 root root 0 Mar 23 21:23 /tmp/user.test[root@test ~]# 给node2的/tmp目录下创建一个名为test的文件夹 1234567891011121314151617181920212223242526272829[root@test ~]# ansible node2 -m file -a &quot;path=/tmp/test state=directory owner=root group=root mode=644&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;gid&quot;: 0, &quot;group&quot;: &quot;root&quot;, &quot;mode&quot;: &quot;0644&quot;, &quot;owner&quot;: &quot;root&quot;, &quot;path&quot;: &quot;/tmp/test&quot;, &quot;size&quot;: 6, &quot;state&quot;: &quot;directory&quot;, &quot;uid&quot;: 0&#125;[root@test ~]# ansible node2 -a &quot;ls -l /tmp/test&quot;node2 | CHANGED | rc=0 &gt;&gt;total 0[root@test ~]# ansible node2 -a &quot;ls -l /tmp&quot;node2 | CHANGED | rc=0 &gt;&gt;total 8drwx------ 2 root root 80 Mar 23 21:30 ansible_command_payload_dUhGn0-rwx------. 1 root root 836 Mar 16 22:08 ks-script-NiyyISdrwx------ 3 root root 17 Mar 23 21:16 systemd-private-521b915097e843e2a1cd732f94d50984-chronyd.service-sTxtbhdrw-r--r-- 2 root root 6 Mar 23 21:29 test-rwxrwxrwx 1 root root 0 Mar 23 21:23 user.test-rw-r--r--. 1 root root 5 Mar 23 17:46 user.txtdrwx------. 2 root root 6 Mar 16 22:18 vmware-root-rw-------. 1 root root 0 Mar 16 22:01 yum.log[root@test ~]# 删除/tmp目录下一个名为user.test的文件 12345678910111213141516171819202122232425262728[root@test ~]# ansible node2 -a &quot;ls /tmp&quot;node2 | CHANGED | rc=0 &gt;&gt;ansible_command_payload_cRmbqnks-script-NiyyISsystemd-private-521b915097e843e2a1cd732f94d50984-chronyd.service-sTxtbhtestuser.testuser.txtvmware-rootyum.log[root@test ~]# ansible node2 -m file -a &quot;path=/tmp/user.test state=absent&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;path&quot;: &quot;/tmp/user.test&quot;, &quot;state&quot;: &quot;absent&quot;&#125;[root@test ~]# ansible node2 -a &quot;ls /tmp&quot;node2 | CHANGED | rc=0 &gt;&gt;ansible_command_payload_SabNhtks-script-NiyyISsystemd-private-521b915097e843e2a1cd732f94d50984-chronyd.service-sTxtbhtestuser.txtvmware-rootyum.log[root@test ~]# cron(计划任务)模块给node2指定一个计划任务，*/1表示每一分钟，date显示日期时间 123456789[root@test ~]# ansible node2 -m cron -a &quot;name=showdate minute=*/1 job=date state=present&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;envs&quot;: [], &quot;jobs&quot;: [ &quot;showdate&quot; ]&#125;[root@test ~]# 删除上面指定的计划任务 1234567[root@test ~]# ansible node2 -m cron -a &quot;name=showdate state=absent&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;envs&quot;: [], &quot;jobs&quot;: []&#125;[root@test ~]# setup模块查看node2的系统信息（该系统信息篇幅很长） 1[root@test ~]# ansible node2 -m setup | less yum模块 给node2安装和卸载lrzsz，其中state为install、present表示安装，为latest表示安装到最新版，为absent、removed表示卸载。 1[root@test ~]# ansible node2 -m yum -a &quot;name=lrzsz state=latest&quot; 1[root@test ~]# ansible node2 -m yum -a &quot;name=lrzsz state=removed&quot; 如果yum报错的话：可以尝试以下命令： 1ansible node2 -m copy -a &quot;src=/etc/resolv.conf dest=/etc/resolv.conf force=yes&quot; service模块先给node2安装httpd 1[root@test ~]# ansible node2 -m yum -a &quot;name=httpd state=latest&quot; 给node2重启httpd服务，设置其开机自启 1[root@test ~]# ansible node2 -m service -a &quot;name=httpd state=restarted enabled=yes&quot; 给node2停止httpd服务 1[root@test ~]# ansible node2 -m service -a &quot;name=httpd state=stopped&quot; 查看node2的httpd状态，可以看到是关闭的 1[root@test ~]# ansible node2 -m command -a &quot;systemctl status httpd&quot; command不支持管道，变量及重定向等，如果是带有管道，变量及重定向符号，请用shell模块 12345678[root@test ~]# ansible node2 -m shell -a &quot;cat /etc/httpd/conf/httpd.conf | grep Listen&quot;node2 | CHANGED | rc=0 &gt;&gt;# Listen: Allows you to bind Apache to specific IP addresses and/or# Change this to Listen on specific IP addresses as shown below to #Listen 12.34.56.78:80Listen 80[root@test ~]# 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-ansible-02 ansible常用模块]]></title>
    <url>%2Fansible-02%2F</url>
    <content type="text"><![CDATA[linux-ansible-02 ansible常用模块参数解析ansible命令常用参数：-a指定模块参数-m指定模块名称-M指定模块路径–list-hosts：列出主机清单–f FORKS：指定进程并发量，默认为5 其中，常用-a与-m配合完成一条ansible命令 默认使用的模块是command，也就是说，你不指定模块是，默认使用的是command模块 举例分析在上一篇文章中，我们改了主机名，命令如下 12345678910111213141516171819[root@localhost ~]# ansible node2 -m command -a &quot;hostnamectl set-hostname node2&quot;node2 | CHANGED | rc=0 &gt;&gt;[root@localhost ~]# ansible node3 -m command -a &quot;hostnamectl set-hostname node3&quot;node3 | CHANGED | rc=0 &gt;&gt;[root@localhost ~]# ssh 192.168.141.53Last login: Sat Mar 23 16:01:20 2019 from 192.168.141.12[root@node2 ~]# exitlogoutConnection to 192.168.141.53 closed.[root@localhost ~]# ssh 192.168.141.69Last login: Sat Mar 23 16:01:28 2019 from 192.168.141.12[root@node3 ~]# exitlogoutConnection to 192.168.141.69 closed.[root@localhost ~]# 其中，-m command表示指定使用command模块，-a “hostnamectl set-hostname node3”表示指定的模块参数是”hostnamectl set-hostname node3”，整个命令连起来就是用command模块将node3更改主机名称为node3的意思。 ansible的执行状态绿色：执行成功并且不需要做改变的操作黄色：执行成功并且对目标主机做变更红色：执行失败 常用模块在介绍常用模块之前，必须要掌握的命令是ansible-doc命令。 ansible-doc -l 查看当前支持的所有模块ansible-doc -s 模块名 查看当前指定模块使用方法ansible-doc -h 该命令使用方法ansible-doc -M 指定模块路径 例如，查看command模块如何使用 1ansible-doc -s command ansible-doc -s 模块名之后如何退出： 如下图，此时按q即可退出。 ping如下，可以看到 1234567[root@test ~]# ansible-doc -s ping- name: Try to connect to host, verify a usable python and return `pong&apos; on success ping: data: # Data to return for the `ping&apos; return value. If this parameter is set to `crash&apos;, the module will cause an exception.[root@test ~]# user123456789101112131415161718[root@test ~]# ansible-doc -s user- name: Manage user accounts user: comment: # 用户的描述信息 create_home: # 是否创建家目录 force: # 在使用`state=absent&apos;时, 行为与`userdel --force&apos;一致 group: # 指定基本组（主组） groups: # 指定附加组，如果指定为(&apos;groups=&apos;)表示删除所有附加组 home: # 指定用户家目录 name: # 指定用户名 password: # 指定用户密码 password_lock: # 是否锁定用户的密码 remove: # 在使用 `state=absent&apos;时, 行为与 `userdel --remove&apos;一致. shell: # 指定默认shell state: # 设置帐号状态，不指定为创建，指定值为absent表示删除 system: # 当创建一个用户，设置这个用户是系统用户。这个设置不能更改现有用户。 uid: # 指定用户的uid update_password: # `always&apos; will update passwords if they differ. `on_create&apos; will only set the password group12345678[root@test ~]# ansible-doc -s group- name: Add or remove groups group: gid: # Optional `GID&apos; to set for the group. name: # (required) Name of the group to manage. state: # 指定组状态，默认为创建，设置值为absent为删除 system: # If `yes&apos;, indicates that the group created is a system group. command1.command是默认使用的模块 2.不支持管道，变量及重定向等，如果是带有管道，变量及重定向符号，请用shell模块 123456789101112131415[root@test ~]# ansible-doc -s command- name: Executes a command on a remote node command: argv: # Allows the user to provide the command as a list vs. a string. Only the string or the list form can be provided, not both. One or the other must be provided. chdir: # Change into this directory before running the command. creates: # A filename or (since 2.0) glob pattern. If it already exists, this step *won&apos;t* be run. free_form: # (required) The command module takes a free form command to run. There is no parameter actually named &apos;free form&apos;. See the examples! removes: # A filename or (since 2.0) glob pattern. If it already exists, this step *will* be run. stdin: # Set the stdin of the command directly to the specified value. warn: # If command_warnings are on in ansible.cfg, do not warn about this particular line if set to `no&apos;. shell1.调用bash执行命令 2.但是某些复杂的操作即使使用shell也可能会失败 解决方法：将操作写到脚本中，通过script模块 3.command不支持管道，变量及重定向等，如果是带有管道，变量及重定向符号，请用shell模块 12345678910111213141516[root@test ~]# ansible-doc -s shell- name: Execute commands in nodes. shell: chdir: # cd into this directory before running the command creates: # a filename, when it already exists, this step will *not* be run. executable: # change the shell used to execute the command. Should be an absolute path to the executable. free_form: # (required) The shell module takes a free form command to run, as a string. There&apos;s not an actual option named &quot;free form&quot;. See the examples! removes: # a filename, when it does not exist, this step will *not* be run. stdin: # Set the stdin of the command directly to the specified value. warn: # if command warnings are on in ansible.cfg, do not warn about this particular line if set to no/false.[root@test ~]# script123456789101112[root@test ~]# ansible-doc -s script- name: Runs a local script on a remote node after transferring it script: chdir: # Change into this directory on the remote node before running the script. creates: # A filename on the remote node, when it already exists, this step will *not* be run. decrypt: # This option controls the autodecryption of source files using vault. executable: # Name or path of a executable to invoke the script with. free_form: # (required) Path to the local script file followed by optional arguments. There is no parameter actually named &apos;free form&apos;, see the examples! removes: # A filename on the remote node, when it does not exist, this step will *not* be run.[root@test ~]# copy1234567891011[root@test ~]# ansible-doc -s copy- name: Copies files to remote locations copy: backup: # 在覆盖之前，将源文件备份，备份文件包含时间信息。 content: # 用于替代“src”，可以直接设定指定文件的值 dest: # 必选项。要将源文件复制到的远程主机的绝对路径 directory_mode: # 递归设定目录的权限，默认为系统默认权限 force: # 强制覆盖目的文件内容，默认为yes others: # 所有的file模块里的选项都可以在这里使用 src: #被复制到远程主机的本地文件，可以是绝对路径，也可以是相对路径。如果路径是一个目录，它将递归复制。 file12345678910111213141516171819[root@test ~]# ansible-doc -s file- name: Sets attributes of files file: force: # 需要在两种情况下强制创建软链接，一种是源文件不存在，但之后会建立的情况下；另一种是目标软链接已存在，需要先取消之前的软链，然后创建新的软链，有两个选项：yes|no group: # 定义文件/目录的所属组 mode: # 定义文件/目录的权限 owner: # 定义文件/目录的所属用户 path: # 必选项，定义文件/目录的路径 recurse: # 递归设置文件的属性，只对目录有效 src: # 被链接的源文件路径，只应用于state=link的情况 dest: # 被链接到的路径，只应用于state=link的情况 state： directory：如果目录不存在，就创建目录 file：即使文件不存在，也不会被创建 link：创建软链接 hard：创建硬链接 touch：如果文件不存在，则会创建一个新的文件，如果文件或目录已存在，则更新其最后修改时间 absent：删除目录、文件或者取消链接文件 cron1234567891011121314151617181920212223242526272829303132333435363738394041424344[root@test ~]# ansible-doc -s cron- name: Manage cron.d and crontab entries cron: backup: # If set, create a backup of the crontab before it is modified. The location of the backup is returned in the `backup_file&apos; variable by this module. cron_file: # If specified, uses this file instead of an individual user&apos;s crontab. If this is a relative path, it is interpreted with respect to /etc/cron.d. (If it is absolute, it will typically be /etc/crontab). Many linux distros expect (and some require) the filename portion to consist solely of upper- and lower-case letters, digits, underscores, and hyphens. To use the `cron_file&apos; parameter you must specify the `user&apos; as well. day: # Day of the month the job should run ( 1-31, *, */2, etc ) disabled: # If the job should be disabled (commented out) in the crontab. Only has effect if `state=present&apos;. env: # If set, manages a crontab&apos;s environment variable. New variables are added on top of crontab. &quot;name&quot; and &quot;value&quot; parameters are the name and the value of environment variable. hour: # Hour when the job should run ( 0-23, *, */2, etc ) insertafter: # Used with `state=present&apos; and `env&apos;. If specified, the environment variable will be inserted after the declaration of specified environment variable. insertbefore: # Used with `state=present&apos; and `env&apos;. If specified, the environment variable will be inserted before the declaration of specified environment variable. job: # The command to execute or, if env is set, the value of environment variable. The command should not contain line breaks. Required if state=present. minute: # Minute when the job should run ( 0-59, *, */2, etc ) month: # Month of the year the job should run ( 1-12, *, */2, etc ) name: # Description of a crontab entry or, if env is set, the name of environment variable. Required if state=absent. Note that if name is not set and state=present, then a new crontab entry will always be created, regardless of existing ones. reboot: # If the job should be run at reboot. This option is deprecated. Users should use special_time. special_time: # Special time specification nickname. state: # Whether to ensure the job or environment variable is present or absent. user: # The specific user whose crontab should be modified. weekday: # Day of the week that the job should run ( 0-6 for Sunday-Saturday, *, etc )(END) yum1234567891011[root@test ~]# ansible-doc -s yum- name: Manages packages with the `yum&apos; package manager yum: conf_file: # 定远程yum安装时所依赖的配置文件。如配置文件没有在默认的位置。 disable_gpg_check: # 是否禁止GPG checking，只用于`present&apos; or `latest&apos;。 disablerepo: # 临时禁止使用yum库。 只用于安装或更新时。 enablerepo: # 临时使用的yum库。只用于安装或更新时。 name: # 所安装的包的名称 state: # present安装， latest安装最新的, absent 卸载软件。 update_cache: # 强制更新yum的缓存。 service12345678910[root@test ~]# ansible-doc -s service- name: Manage services service: arguments: # 命令行提供额外的参数 enabled: # 设置开机启动。 name: # 服务名称 runlevel: # 开机启动的级别，一般不用指定。 sleep: # 在重启服务的过程中，是否等待。如在服务关闭以后等待2秒再启动。 state: # started启动服务， stopped停止服务， restarted重启服务， reloaded重载配置 setup12345678910111213141516171819202122232425[root@test ~]# ansible-doc -s setup- name: Gathers facts about remote hosts setup: fact_path: # path used for local ansible facts (`*.fact&apos;) - files in this dir will be run (if executable) and their results be added to `ansible_local&apos; facts if a file is not executable it is read. Check notes for Windows options. (from 2.1 on) File/results format can be json or ini-format filter: # if supplied, only return facts that match this shell-style (fnmatch) wildcard. gather_subset: # if supplied, restrict the additional facts collected to the given subset. Possible values: `all&apos;, `min&apos;, `hardware&apos;, `network&apos;, `virtual&apos;, `ohai&apos;, and `facter&apos;. Can specify a list of values to specify a larger subset. Values can also be used with an initial `!&apos; to specify that that specific subset should not be collected. For instance: `!hardware,!network,!virtual,!ohai,!facter&apos;. If `!all&apos; is specified then only the min subset is collected. To avoid collecting even the min subset, specify `!all,!min&apos;. To collect only specific facts, use `!all,!min&apos;, and specify the particular fact subsets. Use the filter parameter if you do not want to display some collected facts. gather_timeout: # Set the default timeout in seconds for individual fact gathering[root@test ~]# selinux123456789[root@test ~]# ansible-doc -s selinux- name: Change policy and state of SELinux selinux: conf: # path to the SELinux configuration file, if non-standard policy: # name of the SELinux policy to use (example: `targeted&apos;) will be required if state is not `disabled&apos; state: # (required) The SELinux mode[root@test ~]# firewalld12345678910111213141516171819202122232425262728[root@test ~]# ansible-doc -s firewalld- name: Manage arbitrary ports/services with firewalld firewalld: immediate: # Should this configuration be applied immediately, if set as permanent interface: # The interface you would like to add/remove to/from a zone in firewalld masquerade: # The masquerade setting you would like to enable/disable to/from zones within firewalld permanent: # Should this configuration be in the running firewalld configuration or persist across reboots. As of Ansible version 2.3, permanent operations can operate on firewalld configs when it&apos;s not running (requires firewalld &gt;= 3.0.9). (NOTE: If this is false, immediate is assumed true.) port: # Name of a port or port range to add/remove to/from firewalld. Must be in the form PORT/PROTOCOL or PORT-PORT/PROTOCOL for port ranges. rich_rule: # Rich rule to add/remove to/from firewalld. service: # Name of a service to add/remove to/from firewalld - service must be listed in output of firewall-cmd --get-services. source: # The source/network you would like to add/remove to/from firewalld state: # (required) Enable or disable a setting. For ports: Should this port accept(enabled) or reject(disabled) connections. The states &quot;present&quot; and &quot;absent&quot; can only be used in zone level operations (i.e. when no other parameters but zone and state are set). timeout: # The amount of time the rule should be in effect for when non-permanent. zone: # The firewalld zone to add/remove to/from (NOTE: default zone can be configured per system but &quot;public&quot; is default from upstream. Available choices can be extended based on per-system configs, listed here are &quot;out of the box&quot; defaults).[root@test ~]# setup123456789101112131415161718192021222324[root@test ~]# ansible-doc -s setup- name: Gathers facts about remote hosts setup: fact_path: # path used for local ansible facts (`*.fact&apos;) - files in this dir will be run (if executable) and their results be added to `ansible_local&apos; facts if a file is not executable it is read. Check notes for Windows options. (from 2.1 on) File/results format can be json or ini-format filter: # if supplied, only return facts that match this shell-style (fnmatch) wildcard. gather_subset: # if supplied, restrict the additional facts collected to the given subset. Possible values: `all&apos;, `min&apos;, `hardware&apos;, `network&apos;, `virtual&apos;, `ohai&apos;, and `facter&apos;. Can specify a list of values to specify a larger subset. Values can also be used with an initial `!&apos; to specify that that specific subset should not be collected. For instance: `!hardware,!network,!virtual,!ohai,!facter&apos;. If `!all&apos; is specified then only the min subset is collected. To avoid collecting even the min subset, specify `!all,!min&apos;. To collect only specific facts, use `!all,!min&apos;, and specify the particular fact subsets. Use the filter parameter if you do not want to display some collected facts. gather_timeout: # Set the default timeout in seconds for individual fact gathering[root@test ~]#]]></content>
      <categories>
        <category>linux</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-ansible-01 ansible基础学习]]></title>
    <url>%2Fansible-01%2F</url>
    <content type="text"><![CDATA[linux-ansible-01 ansible基础学习概念引入假如我们要管理几十台刚买来的服务器，步骤如下：1.给每一台服务器装系统，可采用PXE+kickstart无人值守安装，亦或是云端镜像服务。2.给每一台服务器配置网络。3.给每一台服务器安装服务所需软件包 。4.给每一台服务器修改配置文件5.给每一台服务器启动服务6.其他… 那么，如果上述步骤，我们全部手动操作，一台一台服务器去弄，效率必然很低。我们嫌弃效率太慢，那么可以写脚本，一个脚本下去一步到位。但是，每一台服务器都要去手动执行一次这个脚本，是很麻烦的，如果后面有了新的服务需要部署，那么你既要写新的脚本，又要到每台服务器上手动执行一次新脚本，不胜其烦。所以，我们需要额外搭建一台服务器，在上面弄个任务清单，让其他服务器照着这个任务清单完成任务即可。当我们想要对服务器群做其他新的配置或搭建新的服务时，只需要在控制机上再写一个任务清单，让其他服务器照做即可，这就需要引入自动化运维的概念了。 概念解析自动化运维 随着信息时代的持续发展，IT运维已经成为IT服务内涵中重要的组成部分。面对越来越复杂的业务，面对越来越多样化的用户需求，不断扩展的IT应用需要越来越合理的模式来保障IT服务能灵活便捷、安全稳定地持续保障，这种模式中的保障因素就是IT运维（其他因素是更加优越的IT架构等）。从初期的几台服务器发展到庞大的数据中心，单靠人工已经无法满足在技术、业务、管理等方面的要求，那么标准化、自动化、架构优化、过程优化等降低IT服务成本的因素越来越被人们所重视。其中，自动化最开始作为代替人工操作为出发点的诉求被广泛研究和应用。 IT运维从诞生发展至今，自动化作为其重要属性之一已经不仅仅只是代替人工操作，更重要的是深层探知和全局分析，关注的是在当前条件下如何实现性能与服务最优化，同时保障投资收益最大化。自动化对IT运维的影响，已经不仅仅是人与设备之间的关系，已经发展到了面向客户服务驱动IT运维决策的层面，IT运维团队的构成，也从各级技术人员占大多数发展到业务人员甚至用户占大多数的局面。 因此，IT运维自动化是一组将静态的设备结构转化为根据IT服务需求动态弹性响应的策略，目的就是实现IT运维的质量，降低成本。可以说自动化一定是IT运维最高层面的重要属性之一，但不是全部。 ansible ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。ansible是基于模块工作的，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。 ansible框架1、连接插件connection plugins：负责和被监控端实现通信；2、host inventory：指定操作的主机，是一个配置文件里面定义监控的主机；3、各种模块核心模块、command模块、自定义模块；4、借助于插件完成记录日志邮件等功能；5、playbook：剧本执行多个任务时，非必需可以让节点一次性运行多个任务。 ansible核心组件 Ansible：核心程序 Modules：包括Ansible自带的核心模块及自定义模块 Plugins：完成模块功能的补充，包括连接插件、邮箱插件 Playbooks：剧本；定义Ansible多任务配置文件，由Ansible自动执行 Inventory：定义Ansible管理主机的清单 Connection Plugins：负责和被监控端实现通信 ansible特性1、no agents：不需要在被管控主机上安装任何客户端；2、no server：无服务器端，使用时直接运行命令即可；3、modules in any languages：基于模块工作，可使用任意语言开发模块；4、yaml，not code：使用yaml语言定制剧本playbook；5、ssh by default：基于SSH工作；6、strong multi-tier solution：可实现多级指挥。 ansible优点1、轻量级，无需在客户端安装agent，更新时，只需在操作机上进行一次更新即可；2、批量任务执行可以写成脚本，而且不用分发到远程就可以执行；3、使用python编写，维护更简单4、支持sudo。 ansible命令执行过程 加载自己的配置文件 默认/etc/ansible/ansible.cfg 加载自己对应的模块文件，如command 通过ansible将模块或命令生成对应的临时py文件，并将该文件传输至远程服务器的 对应执行用户的家目录的.ansible/tmp/XXX/XXX.PY文件。 给文件+x执行 执行并返回结果 删除临时py文件，sleep 0 退出 ansible安装部署 pip安装 二进制 yum安装 ansible程序文件/etc/ansible/roles：角色目录 /etc/ansible/ansible.cfg：主配置文件 /etc/ansible/hosts：主机清单配置文件 基本配置1、密钥登录 2、定义主机清单 实验准备三台虚拟机 服务端Test（管理机）：192.168.141.12 客户端node2：192.168.141.53 客户端node3：192.168.141.69 ansible安装与配置在服务端安装ansible 12[root@localhost ~]# yum install epel-release -y[root@localhost ~]# yum install ansible -y 服务端修改主机清单配置文件host 1234567[root@localhost ~]# vim /etc/ansible/hosts#在文档末尾加上一下这几行[node]node2node3 服务端修改host文件 123456[root@localhost ~]# vim /etc/hosts#在文档中加入下列两行192.168.141.53 node2192.168.141.69 node3 实现管理机对所有客户端的免密钥登录—ssh-key1ssh-keygen -t rsa #提示生成的密钥放在/root/.ssh/id_dsa #提示是否给生成的密钥再加密一次，回车即可 #让你再确认一次，回车即可。 123456[root@localhost ~]# ll /root/.ssh/total 12-rw-------. 1 root root 1679 Mar 23 02:50 id_rsa #生成后的私钥文件-rw-r--r--. 1 root root 408 Mar 23 02:50 id_rsa.pub #公钥文件 -rw-r--r--. 1 root root 519 Mar 23 03:13 known_hosts[root@localhost ~]# 把公钥发送到客户端机器上，第一次连接要输入yes，记录主机名跟IP，然后输出对方的密码即可 12[root@localhost ~]# ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.141.69[root@localhost ~]# ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.141.53 #公钥发送过去之后，登录对方的机器不用密码了。 1234567891011[root@localhost ~]# ssh 192.168.141.69Last login: Sat Mar 23 15:47:08 2019 from 192.168.141.1[root@localhost ~]# exitlogoutConnection to 192.168.141.69 closed.[root@localhost ~]# ssh 192.168.141.53Last login: Sat Mar 23 15:46:03 2019 from 192.168.141.1[root@localhost ~]# exitlogoutConnection to 192.168.141.53 closed.[root@localhost ~]# ansible测试我们先改好三台虚拟机的主机名 1234567891011121314151617181920[root@localhost ~]# hostnamectl set-hostname Test[root@localhost ~]# ansible node2 -m command -a &quot;hostnamectl set-hostname node2&quot;node2 | CHANGED | rc=0 &gt;&gt;[root@localhost ~]# ansible node3 -m command -a &quot;hostnamectl set-hostname node3&quot;node3 | CHANGED | rc=0 &gt;&gt;[root@localhost ~]# ssh 192.168.141.53Last login: Sat Mar 23 16:01:20 2019 from 192.168.141.12[root@node2 ~]# exitlogoutConnection to 192.168.141.53 closed.[root@localhost ~]# ssh 192.168.141.69Last login: Sat Mar 23 16:01:28 2019 from 192.168.141.12[root@node3 ~]# exitlogoutConnection to 192.168.141.69 closed.[root@localhost ~]# 可以看到上面三台虚拟机的主机名都已经改好，当然，Test的主机名你需要再次登录才能看到，如下 123456789101112131415161718[root@localhost ~]# exitlogoutConnection closing...Socket close.Connection closed by foreign host.Disconnected from remote host(Test) at 16:03:19.Type `help&apos; to learn how to use Xshell prompt.[C:\~]$ Connecting to 192.168.141.12:22...Connection established.To escape to local shell, press &apos;Ctrl+Alt+]&apos;.WARNING! The remote SSH server rejected X11 forwarding request.Last login: Sat Mar 23 02:44:34 2019 from 192.168.141.1[root@test ~]# 查看ansible帮助 12[root@test ~]# ansible --helpUsage: ansible &lt;host-pattern&gt; [options] 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computer-07 C盘空间不足解决办法]]></title>
    <url>%2Fcomputer-07%2F</url>
    <content type="text"><![CDATA[computer-07 C盘空间不足解决办法C盘装满的原因：1、硬盘本身容量过小 2、装系统时给C盘分配容量太小导致 3、C盘作为系统盘，在使用电脑过程中会产生大量的系统缓存和垃圾文件，时间久了会把C盘填满。 为C盘瘦身方法：1、 使用系统自带磁盘管理扩大C盘容量（适用装系统时给C盘分配容量太小的情况） 这种方法很方便，但是有个要求，就是C盘和D盘物理上必须是同一块磁盘才可以，不然就无法增加C盘的容量，是在一块磁盘上的分区。比如C盘是120GB 的固态硬盘，而D盘则是1TB机械硬盘，所以C盘最大也只有120GB，不能借用D盘的空间来增大磁盘。 解决办法：通过windows自带的磁盘管理工具就可以解决 操作步骤： 鼠标右键开始菜单，选择磁盘管理 右键C盘，点击”压缩卷“，弹出窗口选择压缩卷，输入相应的容量，然后就会多出一个未分配的分区。 然后再右键点击C盘，选择扩展卷，输入未分配的分区容量，即可免格式化增加C盘容量。 （一次压缩卷，一次扩展卷） 1、 清理系统垃圾释放磁盘空间 安全卫士什么都存在一定的风险可能会导致系统崩溃，所以最好自己手动来清理这些缓存垃圾等等 （1）开始-&gt;程序-&gt;附件-&gt;系统工具-&gt;磁盘清理，选择C盘，确认后，选中所有的“口”再确认。 （2）系统工具-&gt;磁盘碎片整理程序（时间长，固态硬盘不需要进行磁盘碎片清理） （3）多次安装和反安装后，系统保留了很多无用的DLL 文件，应将其删除 （4）开始-&gt;运行-&gt;输入regedit，即打开注册表编辑器窗口 （5）打开这个LOCAL 的分支，在对话框右侧，其键值数据后面的括号中都有一个数字，如果数字为0，表示此DLL为垃圾文件，将其删除。 （6）将不要的程序卸载时，控制面板à添加/删除程序，选择确定删除，这个才是彻底的删除方法。 （碎片整理时，不要运行任何程序，最好也关闭一些自动运行的程序，不然整理起来会很缓慢，并且如果分区中有GHOST 的系统备份文件，千万不要对此盘进行整理，会使系统恢复出错） 3、 删除windows.old文件 低版本升级而来的高版本系统，或者执行自定义安装来安装系统的，没有在安装过程中格式化分区，以前的版本的windows中使用的文件存储在windows.old文件夹中，这个文件夹的文件是取决于自己的电脑的。新系统用一段时间，一两周，确定文件和设置都已经返回原位置，可以通过磁盘清理，删除这个Old文件了，这样可以安全的回收磁盘空间啦。 C盘-&gt;属性-&gt;磁盘清理-&gt;清理系统文件-&gt;勾选“以前的windows安装” 清理成功 这个操作不可撤销 4.关闭虚拟内存 5.调整为最佳设置 本篇到此结束]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>computer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computer-06 其它]]></title>
    <url>%2Fcomputer-06%2F</url>
    <content type="text"><![CDATA[computer-06 其它主板1.尺寸（长X宽，单位毫米）1)EATX加强型 305X330 拓展性最强 2)ATX标准型 305X244 3)M-ATX紧凑型 224X244 4)MINI-ITX迷你型 170X170 尺寸越大拓展性越好 2.芯片组1)分类 —AMD —INTER 2)芯片组决定了主板能够搭载的CPU主频 电池1.续航能力 2.充电速度 装系统 装系统时，有时候电脑明明装了两个硬盘，但是选择系统盘的时候却只显示了一个硬盘，可以在开机时进入到BIOS的SATA那里改为ACHI，然后重启电脑，再次装系统选择系统盘时，就可以看到电脑上所有硬盘了，想装在哪里就装在哪里。 注意事项1.家庭版的系统不适合我们学IT的，很鸡肋，建议买装好了专业版系统的电脑。 2.实体店坑太多防不胜防，而且百分百被宰或者被转型，建议在可以7天无理由退换的网上购买，如京东等。 3.京东被很多人称为“二手东”，究其原因，不乏有一些居心不良的顾客不停地买电脑用4天左右退换，稍微有瑕疵就重复退换，造成我们很有可能入手一个二手货。 —解决办法：跟客服沟通，先说明白自己绝对不会用二手货，电脑到货后一定会仔细检查外观并且用鲁大师等硬件检测工具对硬盘使用时间进行检测，若发现是二手货一概退换，直到入手的为新货为止。 4.查询出厂日期：win+r输入cmd，然后敲命令systeminfo查看系统信息 ，注意里面的BIOS Version参数 ，查看一下新买的电脑的BIOS版本是否为最近时间的，版本太老太旧的估计就是很旧的电脑改装的。 5.查询保修截止期：官网用S/N号（主机编号）查询，S/Y号一般在笔记本电脑的底部，下面以联想电脑查询保修截止期为例： 1.进入联想官网，选择”服务“选项 2.下拉，找到保修查询 3.输入主机编号即可查看保修截止期 本篇到此结束]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>computer</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computer-05 硬盘]]></title>
    <url>%2Fcomputer-05%2F</url>
    <content type="text"><![CDATA[computer-05 硬盘概念解析 硬盘是电脑主要的存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成。碟片外覆盖有铁磁性材料。 硬盘分类 硬盘有固态硬盘（SSD 盘，新式硬盘内有sata固态、m.2固态、pci-e固态，而m.2固态又有nvme的m.2和sata的m.2）、机械硬盘（HDD 传统硬盘内有3.5寸、2.5寸的，还有5400转和7200转）、混合硬盘（HHD 一块基于传统机械硬盘诞生出来的新硬盘）。SSD采用闪存颗粒来存储，HDD采用磁性碟片来存储，混合硬盘(HHD: Hybrid Hard Disk)是把磁性硬盘和闪存集成到一起的一种硬盘。绝大多数硬盘都是固定硬盘，被永久性地密封固定在硬盘驱动器中。 参数解析1.电脑处理信息的机制（如下图） —键盘鼠标输入信息到CPU —CPU处理成电脑明白的语言，告诉内存我需要XX —内存告诉硬盘我需要XX —硬盘将XX给内存，内存将XX给CPU —CPU将XX换成人类能识别的信息显示出来 2.硬盘分类 —机械硬盘 写速度70-100 —混合硬盘 读写速度100-150 (商家搞噱头的，不建议购买) —固态硬盘 读写速度500-3000 3.性能参数 1)读写速度对应开机速度: —100 MB/S 开机50秒 —150 MB/S 开机40秒 —500 MB/S 开机5秒 2)硬盘大小容量 3)接口 —SATA3 串口接口的读写速度理论极限750MB/S —PCIE3.0X4J接口的读写速度理论极限4GB/S 4)不同硬盘特点 —机械硬盘里面装着磁盘和磁头，工作噪音较大 —固态硬盘里面只有芯片组 —混合硬盘虽然比固态便宜，比机械快一丁点，但是还是太慢，购买混合硬盘是非常吃亏的 5)建议用固态硬盘做系统盘，机械硬盘储存文件以及做各个软件、游戏的安装路径。 实例解析 我们平时用电脑，所有的文件都存在硬盘里，需要的时候再从硬盘里拿出来用。其中，传统的机械硬盘长这样： 个人推荐固态硬盘（SSD），采用闪存作为存储介质，读取速度相对机械硬盘更快，而且有低功耗、无噪音、抗震动、低热量、体积小、工作温度范围大等优点。不过，SSD固态硬盘一般都比机械硬盘贵，所以小伙伴们还是要按需选购为妙。如果你的目标是一台轻巧便携、开机速度又快的超极本，建议选择固态硬盘版本。 本篇到此结束]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>computer</tag>
        <tag>硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computer-04 内存]]></title>
    <url>%2Fcomputer-04%2F</url>
    <content type="text"><![CDATA[computer-04 内存概念解析 内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。内存(Memory)也被称为内存储器，其作用是用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。只要计算机在运行中，CPU就会把需要运算的数据调到内存中进行运算，当运算完成后CPU再将结果传送出来，内存的运行也决定了计算机的稳定运行。 参数分析1）内存种类建议淘汰： DDR1 DDR2 建议使用（主流）： DDR3 DDR4 2)内存容量8G适中 两条4G内存条比一条8G好 3)内存频率（数值越高性能越强）1600mhz 2400mhz 3000mhz 不必过分追求这个数值 4)内存选购DDR3 1600 1866 DDR4 2133 2400 5)内存与主板的兼容—DDR4兼容主板： H170/270 B150/250 Z170/270 C232/236 X99 —其他都是插DDR3内存的 实例解析 内存是是与CPU进行沟通的桥梁，所有的程序软件都是在内存里运行的，所以内存的性能对电脑的效率影响非常大。 举个栗子 图中的内存条是台式机16G内存DDR4 2400MHz，其中我们要关注三个据：“16G”、“DDR4”和“2400MHz”。 “16G”代表容量，作为与CPU沟通的桥梁，当然是越宽越好，所以容量越大越好。 “DDR4”代表这是第4代产品，比第3代更好，另外“2400Mhz”代表主频率，频率越高越好。 本篇到此结束]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>computer</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computer-03 显存]]></title>
    <url>%2Fcomputer-03%2F</url>
    <content type="text"><![CDATA[computer-03 显存概念解析 显存，也被叫做帧缓存，它的作用是用来存储显卡芯片处理过或者即将提取的渲染数据。如同计算机的内存一样，显存是用来存储要处理的图形信息的部件。 显存，全称“显存内存”与运行内存类似，有大有小，大家都知道，显卡是负责繁重的图形渲染工作的，那么渲染完呢，你根本不知道它渲染了小哥哥还是小姐姐，还是要送到显示器才能观看啊，因此可以理解为显存是另一辆车（显存）把图像“运送”到显示器。在其他条件不变的情况下，显存越大，一次“运送”的图像越多，游戏性能（主要体现在帧数上）也就相对高一些。 查看显存1.打开任务管理器，切换到详细信息界面 2.点击左上角的“性能”选项卡，下拉，找到并点击GPU0或者GPU1，此时右上角可以看到我们的显卡型号。 GPU：图形处理器（英语：Graphics Processing Unit，缩写：GPU） 3.点击GPU1，对NVDIA的那个GPU进行查看，如下图，我的显存容量为2GB。 实例解析 一个1060 3GB和一个1060 6GB显卡，虽然显示核心基本相同，但是显存相差一倍，多了这3GB显存吃鸡可以特效全开60帧哦~所以，大家在选购电脑时可以留意下显存大小哦。 本篇到此结束]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>computer</tag>
        <tag>显存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computer-02 显卡]]></title>
    <url>%2Fcomputer-02%2F</url>
    <content type="text"><![CDATA[computer-02 显卡 显卡（英语：Video card、Display card、Graphics card、Video adapter），是个人计算机最基本组成部分之一，用途是将计算机系统所需要的显示信息进行转换驱动显示器，并向显示器提供逐行或隔行扫描信号，控制显示器的正确显示，是连接显示器和个人计算机主板的重要组件，是“人机对话”的重要设备之一。 基础概念1) 常识—全称：显示适配器/显示接口卡 —功能：进行数模信号转换，输出显示图形 —显卡决定了玩游戏的画质和流畅度 2)分类—集成显卡 十几年前的技术 只能显示最基本的图像 —核心显卡 把显示核心做进CPU的技术 适合魂斗罗等小游戏 —独立显卡 单独出来、自成一体，好的独显能玩大游戏 3)参数LOGO PCB 外形 尺寸 风扇个数 默认频率 接口 电容 信仰 4)公版与非公版—公版 原汁原味百分百原装 —非公版 在公版基础上改装，性能比公版好10% ##### 2.显示核心部分1)显卡频率—显示核心工作的速度 2)流处理器—类似CPU核心数 3.显存 （显示频率）1)显卡显存处理速度可以超频但意义不是很大 2)显存类型 GDDR5 HBM2 3)显存容量 越高的分辨率需要越高的显存容量 4)显存位宽&amp;显存带宽 小位宽：magnet:?xt=1 大位宽：magnet:?xt=123456789 显存带宽：显存与显示核心之间通道的宽度 5)补充： —光栅单元 光影效果 —纹理单元 条纹细节清晰度 显卡知识集显、核显、独显、双显有什么区别？ 显卡负责显示器画面显示，电脑没有显卡，就不会有画面显示。显卡，又叫做显示接口卡或显示适配器，是计算机最基本、最重要、也是必备的配件之一。 集显（部分老式主板才有，如今已经淘汰）位置：集成在主板上的显卡， 优点：价格低，兼容性好和升级成本低 缺点：没有独立的显存，要占用系统内存，使CPU可用的物理内存减少，在与系统交互的过程中总是占用总线周期和CPU 周期，所以会在某些方面影响电脑性能。 升级：必须更新主板BIOS 核显（核心显卡）位置：集成在CPU当中，CPU自带，其实目前的智能手机也都是CPU内置GPU，也就是核心显卡方案 优点：性能好，选择一款内置好一些的核心显卡即可满足不少网络游戏需求，无需搭配独立显卡即可满足不少网络游戏需求。 ​ 低能耗，价格相对便宜 独立显卡位置：需要插在主板的PCI 显卡插槽 优点：高性价比，配备单独的散热风扇，所以性能要比集显和核显出众 ​ 本身带有独立显存，不会占用系统内存 ​ 独显可在电脑内部组成多显卡，拥有强大的图像处理能力。 缺点：贵 升级：一般都是购买显存更大的显卡，升级方便但成本高，更适合主流游戏用户推荐。 双显卡一台电脑上包含2块显卡 比如：CPU 既内置了核心显卡，用户又单独购买了独立显卡，这样的电脑就配置了双显卡，目前大多数独显电脑其实都配置了双显卡，电脑会根据需求，智能进行切换使用。 双独显（双卡交火） 核显，独显（混合交火） 显卡选购建议：多数用户的电脑都是配置了 核显+独显双显卡 实例解析 显卡这里我们主要说 NVIDIA（俗称 N 卡），以NVIDIA GTX 1080Ti 11G举例。GTX代表它是“发烧级”，此外还有GT“入门级”。最重要的数据是最后的“11G”，它代表显卡的显存，显存越大，显卡性能越好。 本篇到此结束]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>computer</tag>
        <tag>显卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computer-01 CPU]]></title>
    <url>%2Fcomputer-01%2F</url>
    <content type="text"><![CDATA[computer-01 CPU初识CPU 对于需要购买笔记本电脑的朋友们来说，不同的用途，对电脑CPU的要求也是不一样的。需要玩吃鸡等大型游戏、视频处理剪辑、大数据分析的同学适合选择标压处理器。对性能要求不高，但是经常需要经常出差，背着笔记本到处跑，想要长时间续航，你就需要低压CPU产品。 CPU又叫中央处理器，相当于我们的大脑，是计算机的运算核心。如今的CPU两大阵营，也就是Intel和AMD，几乎垄断了CPU市场。其中以Intel更为主流，现在我们来了解一下笔记本上的Intel处理器。 举个栗子： 如上图，分析如下： 品牌标识符：i7代表高端，i3代表入门，i5代表主流 代际：6920中的“6”代表着第6代，这个数字当然是越大越好，“9”代表它的市场定位，同样是越大越好，后面两位数字往往表示同型号处理器的不同的升级版本。 字母后缀： U——低电压 省电 M——移动版，笔记本专用 H——不能拆卸 产品线后缀： Q——四核 K——无锁，可以倍频超频，玩大型游戏 X——极致性能 CPU具体参数以下排序越靠前越优先考虑：1)主频—主频越高，单位时间内处理数据越多。（主频单位：Ghz） —主频越高，发热越大。主频越大越好，但需要强大的散热功能与之对应。 —主频超过临界值后卡顿感才会消失。（临界值指玩某游戏需要的最大主频） —睿频，英特尔酷睿i5/i7处理器独有技术，（频率大小根据任务多少变化）。 2)核心—核心数越多，能同时处理的任务数就越多。 —核心数越多，发热越大。 —对于渲染建模（3D建造虚拟模型），核心多有优势。 —核心与线程，例如4C8T指4核8线程，模拟了比4C4T多一倍的核心数。 （线程是核心的2倍指超线程或线程分裂，性能提升一倍） 3)针脚—针脚传输性能要跟上 —可以由针脚看出它是哪个时代的CPU 4)架构—越新的架构带着越新的技术，旧架构相当于小水管，新架构即相当于大铁管。 5)缓存—缓存位于CPU内部，其读写速度是内存的不知道多少倍。 —CPU要处理的数据来自内存，如果CPU内没有缓存，那么CPU就不得不一直 等内存将数据发过来，导致电脑间歇性卡死。 —分级有：1级越快，2级次之，3级最慢。 6)制程—制程（目前均限制在14NM纳米数下）越小越好，耗电越少发热越小，体积越小。 举例：1.英特尔的I7-9980K—I7 厂商分级，I7为高端，可参考CPU天梯图 —第一个9 第九代 产品 —第二个9 性能排名 表示它在其性能梯队中最强 —50 区分用途 商业、民用、定制等 — K 特殊能力 K代表可以超频（相对的，U代表低电压，Y代表超低电压 ​ M代表移动版，X代表它是旗舰CPU也能超频，但一般不买） ​ 总之，K是最好的。 2.AMD的R7-1800XAMD全系列CPU都能超频，都能睿频 —R7 厂商分级 —1 —8 性能排名 —00 区分用途 —X 说明带满血XFR技术，只要散热到位，即可额外自动超频 CPU天梯图（2019年2月份） 实例参考1、型号中带Y的处理器 这个系列是性能较弱的，也就是名字中含有Y的处理器，这一系列采用的是超低电压的设计，使用场景一般为平板电脑，如i7-7Y75，虽然这是一款带有i7头衔的处理器，但是性能却比普通的i7弱很多，但是低电压带来性能低的同时，也带来了低功耗，满足了平板电脑所需较长的续航。 2、带有字母U 这个系列也是低电压系列，但是应用场景一般为超薄本，笔记本的运算需求较高一些，但是也要满足续航，因此这是较为折中的处理器系列，如I5-8250U，处于第8代I5处理器，性能比超低压CPU强上一大截，但是玩大型游戏仍然不是他们的强项，日常办公还是足够的。 3、带有字母H 这一系列CPU属于高性能的标压CPU，通常应用在游戏本上，如I5-8300H,I7-8750H等，图中就是拥有6核心12线程的强大的I7-8750H处理器。 4、带有字母Q 同样情况下末尾带有Q的则为4核处理器，Q一般和H同时出现，如7700HQ，7300HQ。 5、带有字母M 当然标压笔记本CPU也是有可拆卸的版本，一般字母代号为M，如3230M，3630QM等，是支持拆机更换处理器的。 6、带有字母K的处理器 带K的含义是不锁倍频，意思就是CPU可以超速“行驶”，这一类处理器一般为台式机或者顶级游戏本使用，追求高性能的同时发热量也是很高的。 本篇到此结束]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>computer</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-14 互联网信息服务IIS]]></title>
    <url>%2Fwindows-14%2F</url>
    <content type="text"><![CDATA[windows-运维-14 互联网信息服务IIS安装IIS IIS8.0是windows Server2012自带的服务器管理系统，和以往不同，IIS8.0安装和操作都比较简单，界面很简洁，安装也很迅速。 1、打开虚拟机桌面左下角的“服务器管理器”。在Windows 2012系统上，这个按钮一般位于左下角的第一个位置。我这边演示用的是Windows 2012 R2版，这套系统新增了白色的开始图标，因此“服务器管理器”按钮移到了第二个位置。 2、点击“添加角色和功能”，在弹出的安装对话框中，再点击两次“下一步”。 3、进入服务器角色安装对话框，勾选“Web服务器(IIS)”这项，会弹出提示询问你是否添加功能，我们点击“添加功能”按钮表示同意添加。然后点击三次“下一步”。直接点击“下一步”表示我们将采用系统提供的默认安装方式，有兴趣的朋友也可以仔细看一下这些默认步骤上的说明文字，以更一步增进对IIS系统的了解。 4、接下来，为Web服务器(IIS)选择要安装的角色服务。这里咱们由于后面要搭建wordpress网站和discuz论坛，所以咱们要选三样东西打钩，另外建议您展开第5项“应用程序开发”，安装常用的应用程序工具，如ASP/ASP.NET 3.5/ASP.NET 4.5等。在勾选的时候，系统会询问您是否安装所需的功能，我们一律点击“添加功能”。选择完毕后的示意图如下： 5、最后一步，我们选择“自动重新启动目标服务器”，然后点击“安装”按钮，等待系统完成安装。 注意，不同于IIS 6.0以前的版本，从IIS 7.0开始，安装Windows组件不再通过光盘或i386文件，而是直接从网络上下载。所以安装前请确保已经设置好了网络，并且可以正常浏览网页。 IIS8.0的Web Server 设置 ASP程序解析 （1）我们打算将ASP 应用程序拷贝到C 盘，当然，其他也可。所以要新建一个目录作为安装解析目录:c:\netexam （2）桌面左下角windows—〉往下翻一页—〉计算机管理—〉“服务和应用程序”，可以看 到 “Internet 信息服务” ，双击； （3）网站上右键—“添加网站” （4）按图中的内容填写吧，其中IP 地址，也可以填写你自己机器的真实的 IP 地址：127.0.0.1 确定后，会自动退出此窗口。 （5）选择，刚才建立的网站 netexam 显示： 双击 ASP 显示：将启用“父路径”右边的FALSE 改为True：如果你的网站程序使用了父路径，如../conn/db.asp这样的，..表示上层目录，就一定要开启父路径，否则系统不能正常识别..父路径，网页就无法正常显示。最后别忘了保存设置应用。 （6）点击：“默认文档” 查看可用的网页默认文档，例如：index.asp 也可以是default.aspx 或者等等 -————————————————————————————————- 编辑权限 （1）选择右上角的“编辑权限” 打开安全选项卡，选择【编辑】 选择【添加】 选 择【高级】 选择【立即查找】 找到 以 IIS_IUSERS 开头的名称；并选择它，一路确定从而退出刚刚打开的这些窗口。 赋予相应的权限： 点击确定即可 重新启动网站 可以看到安装解析目录:c:\netexam下多了一个配置文件 浏览器打开127.0.0.1访问本地网站，如下图是默认浏览页面。 我们到iis服务网站根目录下C:\inetpub\wwwroot，添加一个文件index.txt，用记事本在里面写上helloworld，然后将index.txt改为index.html，再次重启网站。 浏览器打开127.0.0.1访问本地网站，如下图是我们刚刚设置好的index.html里面的内容helloworld。 关机，保存快照。后面原计划是要在IIS服务的基础上配置mysql+php环境、搭建discuz论坛和wordpress博客的，但是由于网上下载winserver 2012 r2镜像装的虚拟机，总要安装许多补丁，而且在安装php的过程中容易出错，vc扩展也直接报错而安装不了，所以这里后续文章就不在虚拟机里面搭建discuz论坛和wordpress博客了，后面直接搭在腾讯云服务器即可。购买服务器装好windows server 2012 R2系统后，可以采用宝塔控制面板一键部署好环境，快速搭建discuz论坛和wordpress博客等，非常方便。如果不想一键部署，而是想要自己一步一步配置环境部署网站的话，可以参考腾讯云上的动态网站搭建教程，网址如下： https://cloud.tencent.com/developer/edu/learn-1064/1241 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-13 windows使用linux命令]]></title>
    <url>%2Fwindows-13%2F</url>
    <content type="text"><![CDATA[windows-运维-13 windows使用linux命令 Windows、Linux看似死敌一对，但其实微软对于开源实业还是相当支持的，Windows 10系统内就首次内置了一个Linux子系统(Windows Subsystem for Linux/WSL)，允许开发者模拟Linux环境，而且有需要的可以直接从Windows应用商店下载SUSE、Ubuntu。 如果你安装了Build 16237或者更新预览版的Windows Server 2016，就可以打开windows server通往Linux的大门了，本质上就是个Linux虚拟机，可以执行一般任务，比如SSHD、MySQL等等，但不能持续运行Linux后台服务。 注意：要在windows上用linux命令，用cmd不行，要用powershell。当然，在cmd里面敲powershell命令切换到powershell命令行模式后也是可以的。 现在在物理机上做实验，windows10操作系统中，打开控制面板，找到程序和功能 点击启用或关闭windows功能 勾选上适用于linux的windows子系统，确定 重启电脑，然后就可以使用linux命令了。 结果验证，如下图： 用cmd测试一下： 在cmd敲linux命令会报错，但是敲完powershell切换成powershell命令行模式后就不会报错了。 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-12 Windows 防火墙]]></title>
    <url>%2Fwindows-12%2F</url>
    <content type="text"><![CDATA[windows-运维-12 Windows 防火墙概念解析​ 防火墙(英文：firewall)是一项协助确保信息安全的设备或者软件，会依照特定的规则，允许或是限制传 输的数据通过。防火墙可以是一台专属的硬件也可以是架设在一般硬件上的一套软件。Windows防火墙 顾名思义就是在Windows操作系统中系统自带的软件防火墙。 ​ Windows防火墙是一个基于主机的准状态防火墙，防火墙安装在被保护的主机 上。它用来保护Windows Server单台服务器,而不是保护网络中其它的主机或者 设备。状态防火墙和传统的包过滤防火墙有明显的区别，使用状态防火墙的一个 典型特征是：被保护的计算机可以主动访问其它计算机，而如果没有例外，其它 计算机无法访问被保护的计算机。 常规防火墙的作用1、过滤进出网络的数据包 2、管理进出网络的访问行为 3、封堵某些禁止访问的行为 4、记录通过防火墙的信息内容和活动 5、对网络攻击进行检测和报警 6、过滤大部分的危险端口 7、设置严格的外向内的状态过滤规则 8、抵挡大部分的拒绝服务攻击 9、加强访问控制能力 防火墙的分类1、按照用户终端：分为企业防火墙和个人防火墙 2、按照实现方法：分为软件防火墙和硬件防火墙 3、检测技术——包过滤、状态检测防火墙 4、固定防火墙和移动防火墙 5、按照部署方式，分为单机防火墙和网络防火墙 防火墙配置 Windows防火墙这个在个人PC上的鸡肋，在服务器安全方面却能起到很大的作用。 以下介绍如何在 Windows Server 2008 R2 中开启防火墙，建立白名单，并允许回显 请求（不禁用Ping）。 1、打开虚拟机，开启Windows防火墙 1）打开 【控制面板】 2）依次进入 【系统和安全】 - 【Windows 防火墙】 3）左侧，点击进入 【打开或关闭 Windows 防火墙】 4）在专用网络、公用网络里 都 点选【启用 Windows 防火墙】 2、添加一个端口的白名单 开启防火墙后，除了系统默认开启的端口，其余端口均被拦截了，如果需要对外开放，就需要添加端口白名单。 1）在控制面板的【Windows 防火墙】项下，进入【高级设置】 2）【入站规则】 右侧 【新建规则】 3）点选【端口】 下一步 4）点选 TCP ，这里以 MySQL 添加远程端口白名单为例 ，端口为 3306 5）接下来为默认的下一步、下一步，名称 我这里填写testmysql 6）完成。 3、设置“开启Ping响应（回显请求）” 开启防火墙后，系统默认会禁止Ping响应，Ping服务器会返回“请求超时”，让我 们无法判断服务器的网络状态。 所以大多数情况下，我们都需要开启Ping响应。 在开启ping响应前，我们先用物理机ping一下服务器： 服务器ip：192.168.141.74 物理机ping服务器结果： 接下来开启Ping响应 【入站规则】 中 找到 “文件和打印机共享(回显请求 - ICMPv4-In)”，我用的 IPv4，故配置此项，如果您用的IPv6，配置“文件和打印机共享(回显请求 - ICMPv6-In)” 双击规则进入编辑状态勾选【已启用】 确定退出 测试完毕，Ping 之后能收到回显请求了。 4、添加一个程序的白名单 有些程序使用的端口不固定，我们无法通过设置端口白名单来放行，这个时候就可 以使用程序白名单来解决问题。 以使用程序白名单来解决问题： 1）【入站规则】 右侧 【新建规则】 2）点选【程序】 下一步 3）指定 程序路径，这里以微软FTP 添加白名单为例，路径为 %SystemRoot% \System32\inetsrv\InetMgr.exe 4）接下来为默认的下一步、下一步，名称 我这里填写testftp 5）完成。 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-11 windows小技巧]]></title>
    <url>%2Fwindows-11%2F</url>
    <content type="text"><![CDATA[windows-运维-11 windows小技巧cmd用不了ping命令在cmd中用PING命令时,出现’Ping’ 不是内部或外部命令，也不是可运行的程序或批处理文件。 先了解一下内容： 1、可执行文件、命令文件和批处理文件 以.exe或者.com或者.bat为扩展名的文件分别被称为可执行文件、命令文件和批处理文件。 2、外部命令和内部命令 DOS命令可以分为外部命令和内部命令，内部命令包含在一个名为command.com的文件，在系统启动时候驻留在内存中。外部命令是保存在c:\windows\system32中的一些可以直接有效的文件的文件，包括.exe文件，.com文件，.bat文件。 系统变量中path的作用是引导系统从path中设置的根目录开始，查找匹配的路径，并组成新的路径，从而执行文件。如果path变量设置不当就会使得系统无法查找到相关文件从而出错。系统默认的系统变量path的值是c:\windows\system32。也就是说用户在命令提示符后输入文件名后，系统会自动到c:\windows\system32的目录下去寻找文件，而不管用户在哪个命令提示符后输入。如果path的值中不包含c:\windows\system32,那么用户只能在命令提示符为c:\windows\system32后输入ping，才能执行ping文件。而你在任意一个命令提示符，比如在我的电脑上，在c:\Documents and Settings\lsr后输入ping，这是系统会认为ping这个文件位于c:\Documents and Settings\lsr目录下的。但是ping文件其实是位于c:\windows\system32目录下，这时候就出现找不到文件的错误。 解决方法： 右键单击我的电脑-&gt;属性-&gt;高级-&gt;环境变量-&gt;在系统变量中选中名字为path或者是PATH-&gt;编辑-&gt;在变量值中添加上c:\windows\system32 接下来就可以用ping命令了 powershell无法与cmd互相切换在系统变量里添加这两个路径后，就可以让powershell无法与cmd互相切换了 12C:\Windows\system32\C:\Windows\System32\WindowsPowerShell\v1.0\ 接下来就可以在powershell下输入cmd回车切换到cmd 也可以在cmd下输入powershell回车切换到powershell windows经常开启共享的话，可以用nsa免疫工具检查电脑防黑 进入本地组策略编辑器的方法win+r输入如下 1Gpedit.msc 连接到虚拟机的C盘的方法win+r输入如下，其中是虚拟机的ip 1\\192.168.16.30\c$ 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-10 文件和存储服务]]></title>
    <url>%2Fwindows-10%2F</url>
    <content type="text"><![CDATA[windows-运维-10 文件和存储服务​ Windows Server 2012中对于文件和存储的服务有了很大的改进，其中引入了SMB 2.2、存储池、重复数据删除、iSCSI Target等技术，使得Windows Server 2012能够提供更好的文件存储服务。使得Windows Server 2012 不仅可以作为文件共享服务器，还可以作为NFS存储和IP-SAN存储。 windows存储池这台服务器上总共安装了2块磁盘，一块磁盘是系统盘，另外一块磁盘作为数据盘（此磁盘没有经过初始化）。 打开虚拟机，右键开始菜单-&gt;磁盘管理，可以看到我们新增的磁盘未分配，所以在文件资源管理器里面也仅仅只有C盘而没有D盘。 添加文件和存储服务，如下图，之后正常安装即可 进入文件和存储服务 选择存储池-&gt;任务-&gt;重新扫描存储，然后新的磁盘就会显示出来了 新建存储池 起个名字，一直下一步即可。我这里新建了一个叫feng的存储池 新建虚拟磁盘 给虚拟磁盘起个名字叫vdisk1 对应关系 simple：普通的磁盘 mirrors：RAID-1 parity：RAID-5 我们这里选择simple就好 容量设置成5G，点击下一步，创建，即可完成。 虚拟磁盘创建完成，关闭新建虚拟磁盘向导后，自动弹出新建卷向导，或者你也可以右键vdisk1新建卷，接下来使用虚拟磁盘的空间新建卷。 新建一个3G的卷 选择文件系统设置 启用重复数据删除 确认没有问题之后点创建 最后在卷里面看见我们创建的卷 ISCSI前言：此为搭建共享磁盘的一种方式，并非唯一 目的：为IIS准备共享磁盘 操作系统：Windows Server 2012 R2、Windows10 准备： 准备两台服务器，能够通过网络ping通 一台用作磁盘服务器(安装Windows Server 2012，提供iSCSI磁盘服务) 一台用作客户机(安装Windows10，用于访问磁盘服务器提供的iSCSI磁盘服务）可以用咱们的物理机作为客户机 客户机可以使用多台，当设置多台客户机时，需要在磁盘服务器上增加多个访问服务器 相关知识： iSCSI，SCSI 术语： 访问服务器，访问目标，iSCSI目标，客户机，四个词为同一概念，即客户机 一、磁盘服务器上操作 1.安装iSCSI服务 1.1.打开服务器管理器&gt;&gt;添加角色和功能 1.2.基于角色或基于功能的安装 1.3.选择安装iSCSI服务的服务器，默认选择本机 1.4.选择iSCSI开头的两个选项和文件服务器 1.5.按需要选择功能，或者直接下一步 1.6.确认后安装 1.7.安装成功 2.创建iSCSI虚拟磁盘 2.1.打开服务器管理器&gt;&gt;文件和存储服务&gt;&gt;iSCSI&gt;&gt;任务&gt;&gt;新建iSCSI虚拟磁盘 2.2.选择服务器(默认本机），键入自定义路径（用于存放虚拟磁盘文件），也可以使用按卷选择 在C盘新建一个文件夹，自定义路径就写这个文件夹 2.3.填写虚拟磁盘名称，路径中可以看到是作为虚拟磁盘文件名的 2.4.设置磁盘大小及类型 2.5.新建iSCSI目标 2.6.填写目标名称 2.7.访问服务&gt;&gt;添加，访问服务器即客户机 这里使用ip的方式设置客户机，其他几种方式可以自己尝试一下，可以设置多个访问服务器 首先用cmd查看物理机ip，命令：ipconfig，选择和虚拟机同一网段那个ip，作为添加程序发起id。 2.8.启用身份验证，也可以不启用，直接下一步 确认后创建虚拟磁盘即可创建成功 二、在客户机上的操作打开iscsi发起程序 查看虚拟机ip： 将虚拟机ip作为目标，快速连接，然后会出来如下图的目标已连接。 右键开始菜单，打开磁盘管理，会自动跳出来一个窗口，让你初始化磁盘，这个Cinderella磁盘就是来自于虚拟机那边的共享磁盘。 现在可以看到，多出一块新的未分配的磁盘，大小2G正是我们之前创建的共享磁盘大小。 打开文件资源管理器，本来我电脑里只有这俩磁盘。 现在咱们把那块2G的新磁盘分配一下，右键新建简单卷，一直点击下一步即可 建好了就变成了新加卷 现在再次打开咱们的文件资源管理器 可以看到多了一个可以使用的新加卷。 到iscsi发起程序里，把之前连接好的断开连接 可以看到新加卷变成灰色，不可用了 然后，过了一会儿，那个新加卷就消失了，一切恢复原状。 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-09 更改计算机状态]]></title>
    <url>%2Fwindows-09%2F</url>
    <content type="text"><![CDATA[windows-运维-09 更改计算机状态更改计算机状态 若要在 Windows PowerShell 中重置计算机，请使用标准命令行工具或 WMI 类。 尽管你使用 Windows PowerShell 仅仅是为了运行该工具，但了解如何在 Windows PowerShell 中更改计算机的电源状态将阐明有关在 Windows PowerShell 中使用外部工具的一些重要详细信息。 锁定计算机使用标准可用工具直接锁定计算机的唯一方法是调用 user32.dll 中的 LockWorkstation() 函数： 1rundll32.exe user32.dll,LockWorkStation 此命令将立即锁定工作站。 它使用 rundll32.exe，后者运行 Windows DLL（并保存其库以便重复使用）以运行 user32.dll（Windows 管理函数的库）。 如果在启用了“快速用户切换”时锁定工作站（例如在 Windows XP 中），则计算机将显示用户登录屏幕，而不会启动当前用户的屏幕保护程序。 若要关闭终端服务器上的特定会话，请使用 tsshutdn.exe 命令行工具。 注销当前会话 可以使用多种不同的方法来注销本地系统上的会话。 最简单的方法是使用远程桌面/终端服务命令行工具 logoff.exe（若要了解有关详细信息，请在 Windows PowerShell 提示符处键入 logoff /?）。 若要注销当前活动会话，请键入 logoff 而不带参数。 你还可以使用具 shutdown.exe 工具及其 logoff 选项： 1shutdown.exe -l 第三个选项是使用 WMI。 Win32_OperatingSystem 类具有 Win32Shutdown 方法。 调用具有 0 标志的方法将启动注销： 1(Get-WmiObject -Class Win32_OperatingSystem -ComputerName .).Win32Shutdown(0) 若要了解有关详细信息和 Win32Shutdown 方法的其他功能，请参阅 MSDN 中的“Win32_OperatingSystem 类的 Win32Shutdown 方法”。 关闭或重启计算机 关闭和重启计算机通常是相同类型的任务。 关闭计算机的工具通常也可以重启计算机，反之亦然。 从 Windows PowerShell 重启计算机有两个直接的选项。 使用 Tsshutdn.exe 或 Shutdown.exe 及其相应参数。 你可以从 tsshutdn.exe /? 或 shutdown.exe /? 获取详细的使用情况信息。 也可以直接从 Windows PowerShell 执行关闭或重启操作。 若要关闭计算机，请使用 stop-computer 命令 1stop-computer 若要重启操作系统，请使用 restart-computer 命令 1restart-computer 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-08 执行文件和脚本]]></title>
    <url>%2Fwindows-08%2F</url>
    <content type="text"><![CDATA[windows-运维-08 执行文件和脚本执行文件和脚本 像运行可执行文件一样，Powershell运行文件和脚本，也必须使用绝对路径或者相对路径，或者要运行的文件必须定义在可受信任的环境变量中。 关于脚本脚本和批处理都属于伪可执行文件，它们只是包含了若干命令行解释器能够解释和执行的命令行代码。 执行批处理文件 批处理是扩展名为”.bat”的文本文件，它可以包含任何cmd控制台能够处理的命令。当批处理文件被打开，Cmd控制台会逐行执行每条命令。那Powershell能够直接执行批处理吗？将下列命令保存为ping.bat 1234@echo offecho batch File TestpauseDir %windir%/system 然后执行ping屏幕会打印ping命令帮助，说明调用的ping cmd 而不是ping.bat。改为： 1234567891011121314151617181920212223242526272829303132PS C:\PS&gt; ./pingbatch File TestPress any key to continue . . . Volume in drive C has no label. Volume Serial Number is 4E9B-D846 Directory of C:Windowssystem2009/06/11 05:21 69,584 avicap.dll2009/06/11 05:21 109,456 avifile.dll2009/07/14 05:41 32,816 COMMDLG.DLL2009/07/14 05:41 2,000 keyboard.drv2009/06/11 05:42 9,936 lzexpand.dll2009/06/11 05:21 73,376 mciavi.drv2009/06/11 05:21 25,264 mciseq.drv2009/06/11 05:21 28,160 mciwave.drv2009/07/14 05:41 68,992 MMSYSTEM.DLL2009/07/14 05:41 1,152 mmtask.tsk2009/07/14 05:41 2,032 mouse.drv2009/06/11 05:21 126,912 msvideo.dll2009/06/11 05:42 82,944 olecli.dll2009/07/14 05:41 24,064 OLESVR.DLL2009/07/14 05:41 5,120 SHELL.DLL2009/07/14 05:41 1,744 sound.drv2009/06/11 05:25 5,532 stdole.tlb2009/07/14 05:41 3,360 system.drv2009/07/14 05:41 4,048 TIMER.DRV2009/06/11 05:42 9,008 ver.dll2009/07/14 05:41 2,176 vga.drv2009/07/14 05:41 12,704 WFWNET.DRV 22 File(s) 700,380 bytes 2 Dir(s) 75,927,420,928 bytes free 通过cmd进入cmd控制台输入ping发现执行的不是ping命令，而是直接运行ping.bat ，也就是说可以通过.bat 覆盖cmd命令。这种机制很危险，如果有人侵入电脑，并将系统内部命令篡改成自己批处理，那就太悲剧了。 这种命令与脚本的混淆不会发生在powershell中，因为powershell有更安全的机制。 执行VB脚本文件12345Set wmi = GetObject(&quot;winmgmts:&quot;)Set collection = wmi.ExecQuery(&quot;select * from Win32_Process&quot;)For Each process in collectionWScript.Echo process.getObjectText_Next 执行 .\test.vbs 会遍历当前Win32进程，并把每个进程的详细信息通过窗口显示出来。怎样让VB脚本的通过控制台输出呢？Wscript //H:CScript怎样还原VB脚本通过窗口输出呢？WScript //H:WScript 在powershell中执行VB脚本123456789101112131415161718PS C:\PS&gt; cscript.exe .test.vbsMicrosoft (R) Windows Script Host Version 5.8Copyright (C) Microsoft Corporation. All rights reserved.instance of Win32_Process&#123; Caption = &quot;System Idle Process&quot;; CreationClassName = &quot;Win32_Process&quot;; CSCreationClassName = &quot;Win32_ComputerSystem&quot;; CSName = &quot;test-me-01&quot;; Description = &quot;System Idle Process&quot;; Handle = &quot;0&quot;; HandleCount = 0; KernelModeTime = &quot;484113379271&quot;; Name = &quot;System Idle Process&quot;; OSCreationClassName = &quot;Win32_OperatingSystem&quot;; OSName = &quot;Microsoft Windows 7 Enterprise ……………………………………以下省略很多进程信息 执行powershell脚本Powershell拥有自己的脚本，扩展名为“.ps1” 1234PS C:\PS&gt; echo &quot;dir;Get-PSProvider;help dir&quot; &gt;test.ps1PS C:\PS&gt; Get-Content ./test.ps1dir;Get-PSProvider;help dirPS C:\PS&gt; ./test.ps1 初次执行脚本时，可能会碰到一个异常： 12345File ” C:\PS\test.ps1″ cannot be loaded because theexecution of scripts is disabled on this system. Please see“get-help about_signing” for more details.At line:1 char:10\+ .test.ps1 &lt;&lt;&lt;&lt; 这是powershell的默认安全设置禁用了执行脚本，要启用这个功能需要拥有管理员的权限。]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-07 数组和哈希表]]></title>
    <url>%2Fwindows-07%2F</url>
    <content type="text"><![CDATA[windows-运维-07 数组和哈希表命令返回数组当我们把一个命令的执行结果保存到一个变量中，可能会认为变量存放的是纯文本。 但是，事实上Powershell会把文本按每一行作为元素存为数组。如果一个命令的返回值不止一个结果时，Powershell也会自动把结果存储为数组。 1234567891011121314151617181920212223PS C:Powershell&gt; $IPcfg=ipconfigPS C:Powershell&gt; $IPcfgWindows IP ConfigurationEthernet adapter Local Area Connection:Connection-specific DNS Suffix . : *** Link-local IPv6 Address . . . . . : *** IPv4 Address. . . . . . . . . . . : 192.168.140.128 Subnet Mask . . . . . . . . . . . : 255.255.252.0 Default Gateway . . . . . . . . . : 192.168.140.1Tunnel adapter isatap.eagleslab.com: Connection-specific DNS Suffix . : *** Link-local IPv6 Address . . . . . : *** Default Gateway . . . . . . . . . :***Tunnel adapter Teredo Tunneling Pseudo-Interface: Media State . . . . . . . . . . . : Media disconnected Connection-specific DNS Suffix . :PS C:Powershell&gt; $IPcfg.Count22 使用数组存储结果判断一个变量是否为数组 12345678PS C:Powershell&gt; $ip=ipconfigPS C:Powershell&gt; $ip -is [array]TruePS C:Powershell&gt; &quot;abac&quot; -is [array]FalsePS C:Powershell&gt; $str=&quot;字符串&quot;PS C:Powershell&gt; $str.ToCharArray() -is [array]True 查看数组的元素个数用$array.Count属性。访问第x个元素，使用$array[x-1]，因为数组是以0开始索引的。 123456PS C:Powershell&gt; ipconfig | Select-String &quot;IP&quot;Windows IP Configuration Link-local IPv6 Address . . . . . : *** IPv4 Address. . . . . . . . . . . : *** Link-local IPv6 Address . . . . . : *** 使用真实的对象操作 为什么不愿把IPconfig返回的结果称为对象，因为它不是真正Cmdlet命令，真正的Powershell命令返回的数组元素可不止一个字符串，它是一个内容丰富的对象。 12345678910111213141516171819202122232425262728PS C:Powershell&gt; ls Directory: C:PowershellMode LastWriteTime Length Name---- ------------- ------ ----d---- 2011/11/23 17:25 ABCd---- 2011/11/29 18:21 myscript-a--- 2011/11/24 18:30 67580 a.html-a--- 2011/11/24 20:04 26384 a.txt-a--- 2011/11/24 20:26 12060 alias-a--- 2011/11/24 20:27 12060 alias.ps1-a--- 2011/11/23 17:25 0 b.txt-a--- 2011/11/23 17:25 0 c.txt-a--- 2011/11/23 17:25 0 d.txt-a--- 2011/11/25 11:20 556 employee.xml-a--- 2011/11/29 19:23 21466 function.ps1-a--- 2011/11/28 11:12 186 LogoTestConfig.xml-a--- 2011/11/24 17:37 7420 name.html-a--- 2011/11/28 15:30 63 ping.bat-a--- 2011/11/24 17:44 735892 Powershell_Cmdlets.html-a--- 2011/11/30 16:04 2556 psdrive.html-a--- 2011/12/2 18:47 140 test.ps1-a--- 2011/11/23 17:37 242 test.txt-a--- 2011/11/28 16:42 170 test.vbsPS C:Powershell&gt; $result=lsPS C:Powershell&gt; $result.Count20 数组的每一个元素存放的是一个System.IO.DirectoryInfo对象。当我们输出这些对象时，Powershell会自动帮我们把它转换成友好的文本格式。 1234567PS C:Powershell&gt; $result[0].gettype().fullnameSystem.IO.DirectoryInfoPS C:Powershell&gt; $result[0] Directory: C:PowershellMode LastWriteTime Length Name---- ------------- ------ ----d---- 2011/11/23 17:25 ABC 对于任何一个对象都可以使用Format-List * 查看它所有的属性和方法。 1234567891011121314151617181920212223PS C:Powershell&gt; $result[0] | fl *PSPath : Microsoft.PowerShell.CoreFileSystem::C:PowershellABCPSParentPath : Microsoft.PowerShell.CoreFileSystem::C:PowershellPSChildName : ABCPSDrive : CPSProvider : Microsoft.PowerShell.CoreFileSystemPSIsContainer : TrueBaseName : ABCMode : d----Name : ABCParent : PowershellExists : TrueRoot : C:FullName : C:PowershellABCExtension :CreationTime : 2011/11/23 17:25:53CreationTimeUtc : 2011/11/23 9:25:53LastAccessTime : 2011/11/23 17:25:53LastAccessTimeUtc : 2011/11/23 9:25:53LastWriteTime : 2011/11/23 17:25:53LastWriteTimeUtc : 2011/11/23 9:25:53Attributes : Directory 创建数组在Powershell中创建数组可以使用逗号。 123456PS C:Powershell&gt; $nums=2,0,1,2PS C:Powershell&gt; $nums2012 对于连续的数字数组可以使用一个更快捷的方法 1234567PS C:Powershell&gt; $nums=1..5PS C:Powershell&gt; $nums12345 数组的多态像变量一样如果数组中元素的类型为弱类型，默认可以存储不同类型的值 123456789101112131415161718192021222324PS C:Powershell&gt; $array=1,&quot;2012世界末日&quot;,([System.Guid]::NewGuid()),(get-date)PS C:Powershell&gt; $array12012世界末日Guid----06a88783-a181-4511-9e41-2780ecbd7924DisplayHint : DateTimeDate : 2011/12/9 0:00:00Day : 9DayOfWeek : FridayDayOfYear : 343Hour : 14Kind : LocalMillisecond : 910Minute : 15Month : 12Second : 45Ticks : 634590369459101334TimeOfDay : 14:15:45.9101334Year : 2011DateTime : 2011年12月9日 14:15:45 空数组和单元素数组空数组 12345PS C:Powershell&gt; $a=@()PS C:Powershell&gt; $a -is [array]TruePS C:Powershell&gt; $a.Count0 1个元素的数组 12345PS C:Powershell&gt; $a=,&quot;moss&quot;PS C:Powershell&gt; $a -is [array]TruePS C:Powershell&gt; $a.Count1 访问数组 数组的元素可以使用索引寻址，第一个元素的索引为0，第i个元素的索引为i-1，最后一个元素的索引为Count-1，但是Powershell为了使用方便，直接可以将 -1 作为最后的一个元素的索引。 123456789PS C:Powershell&gt; $books=&quot;元素1&quot;,&quot;元素2&quot;,&quot;元素3&quot;PS C:Powershell&gt; $books[0]元素1PS C:Powershell&gt; $books[1]元素2PS C:Powershell&gt; $books[($book.Count-1)]元素3PS C:Powershell&gt; $books[-1]元素3 从数组中选择多个元素12345678910PS C:Powershell&gt; $result=lsPS C:Powershell&gt; $result[0,3,5,12] Directory: C:PowershellMode LastWriteTime Length Name---- ------------- ------ ----d---- 2011/11/23 17:25 ABC-a--- 2011/11/24 20:04 26384 a.txt-a--- 2011/11/24 20:27 12060 alias.ps1-a--- 2011/11/24 17:37 7420 name.html 将数组逆序输出 12345PS C:Powershell&gt; $books=&quot;元素1&quot;,&quot;元素2&quot;,&quot;元素3&quot;PS C:Powershell&gt; $books[($books.Count)..0]元素3元素2元素1 给数组添加和删除元素 因为Powershell数组在内存中是顺序存储的，所以数组的大小必须是确定的，这样才方便分配存储空间，所以给数组增加元素其实相当于创建一个新的数组，只不过之后会把原来的副本删除。在当前数组追加元素可以使用“+=”操作符。 1234567PS C:Powershell&gt; $books=&quot;元素1&quot;,&quot;元素2&quot;,&quot;元素3&quot;PS C:Powershell&gt; $books+=&quot;元素4&quot;PS C:Powershell&gt; $books元素1元素2元素3元素4 要删除第三个元素可以使用以下命令： 1234567891011PS C:Powershell&gt; $num=1..4PS C:Powershell&gt; $num1234PS C:Powershell&gt; $num=$num[0..1]+$num[3]PS C:Powershell&gt; $num124 复制数组 数组属于引用类型，使用默认的的赋值运算符在两个变量之间赋值只是复制了一个引用，两个变量共享同一份数据。这样的模式有一个弊病如果其中一个改变也会株连到另外一个。所以复制数组最好使用Clone()方法，除非有特殊需求。 1234567891011121314151617PS C:Powershell&gt; $chs=@(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)PS C:Powershell&gt; $chsBak=$chsPS C:Powershell&gt; $chsBak[1]=&quot;H&quot;PS C:Powershell&gt; $chsAHCPS C:Powershell&gt; $chs.Equals($chsBak)TruePS C:Powershell&gt; $chsNew=$chs.Clone()PS C:Powershell&gt; $chsNew[1]=&quot;Good&quot;PS C:Powershell&gt; $chs.Equals($chsNew)FalsePS C:Powershell&gt; $chsAHC 强类型数组 Powershell数组一般具有多态性，如果你不指定元素的具体类型，解释器会自动选择合适的类型存储每个元素。如果要统一限制所有元素的类型，可是使用类型名和一对方括号作为数组变量的类型。这样每当赋值时，会自动类型检查。如果目标数据类型不能转换成功，就会抛出一个异常。 12345678910PS C:Powershell&gt; [int[]] $nums=@()PS C:Powershell&gt; $nums+=2012PS C:Powershell&gt; $nums+=12.3PS C:Powershell&gt; $nums+=&quot;999&quot;PS C:Powershell&gt; $nums+=&quot;can not convert&quot;Cannot convert value &quot;can not convert&quot; to type &quot;System.Int32&quot;. Error: &quot;Input string was not in a correct format.&quot;At line:1 char:6+ $nums &lt;&lt;&lt;&lt; +=&quot;can not convert&quot; + CategoryInfo : MetadataError: (:) [], ArgumentTransformationMetadataException + FullyQualifiedErrorId : RuntimeException 使用哈希表 哈希表存放的是对，在哈希表中不再仅仅限制使用数字寻址，可以使用任意类型的数据类型寻址。创建哈希表 之前使用@()创建数组，现在使用@{}创建哈希表，使用哈希表的键访问对应的值。 1234567891011121314151617181920212223PS C:Powershell&gt; $stu=@&#123; Name = &quot;小明&quot;;Age=&quot;12&quot;;sex=&quot;男&quot; &#125;PS C:Powershell&gt; $stuName Value---- -----Name 小明Age 12sex 男PS C:Powershell&gt; $stu[&quot;Name&quot;]小明PS C:Powershell&gt; $stu[&quot;age&quot;]12PS C:Powershell&gt; $stu.Count3PS C:Powershell&gt; $stu.KeysNameAgesexPS C:Powershell&gt; $stu.Values小明12男 在哈希表中存储数组可以在创建哈希表时就使用数组，因为创建数组和哈希表的的元素关键字不冲突。一个是逗号，一个是分号。 123456789PS C:Powershell&gt; $stu=@&#123; Name = &quot;小明&quot;;Age=&quot;12&quot;;sex=&quot;男&quot;;Books=&quot;三国演义&quot;,&quot;围城&quot;,&quot;哈姆雷特&quot; &#125;PS C:Powershell&gt; $stuName Value---- -----Books &#123;三国演义, 围城, 哈姆雷特&#125;Name 小明Age 12sex 男 在哈希表中插入新的键值在哈希表中插入新的键值很方便，象定义变量一样，可以直接拿来使用 123456789PS C:Powershell&gt; $Student=@&#123;&#125;PS C:Powershell&gt; $Student.Name=&quot;令狐冲&quot;PS C:Powershell&gt; $Student.School=&quot;华山派&quot;PS C:Powershell&gt; $Student Name Value---- -----Name 令狐冲 School 华山派 哈希表值的更新和删除如果要更新键的值，可以直接重写。如果要删除这个键值对，可以使用Remove方法，参数为Key 1234567891011121314151617181920PS C:Powershell&gt; $stuName Value---- -----Books &#123;三国演义, 围城, 哈姆雷特&#125;Name 小明Age 12sex 男PS C:Powershell&gt; $stu.Name=&quot;赵强&quot;PS C:Powershell&gt; $stu.Name赵强PS C:Powershell&gt; $stu.Remove(&quot;Name&quot;)PS C:Powershell&gt; $stuName Value---- -----Books &#123;三国演义, 围城, 哈姆雷特&#125;Age 12sex 男 使用哈希表格式化输出 在Powershell中哈希表的一个有趣的应用可以用来格式化文本输出。Powershell许多命令的输出结果都是以表格的形式，当然可以使用Format-Table自定义表格格式，例如： 12345678910111213141516PS C:Powershell&gt; Dir | Format-Table Directory: C:PowershellMode LastWriteTime Length Name---- ------------- ------ ----d---- 2011/11/23 17:25 ABCd---- 2011/11/29 18:21 myscriptPS C:Powershell&gt; Dir | Format-Table FullName,ModeFullName Mode-------- ----C:PowershellABC d----C:Powershellmyscript d----C:Powershella.html 上述的命令只能限制表格输出那些列，隐藏那些列。但是对于列的宽度，列标题无能为力，但是有了哈希表就可以实现更多自定义了。 表格的每一个列包含四个属性：Expression:绑定的表达式Width:列宽度Label:列标题Alignment:列的对齐方式 123456789PS C:Powershell&gt; $column1 = @&#123;expression=&quot;Name&quot;; width=30;label=&quot;filename&quot;; alignment=&quot;left&quot;&#125;PS C:Powershell&gt; $column2 = @&#123;expression=&quot;LastWriteTime&quot;; width=40;label=&quot;last modification&quot;; alignment=&quot;right&quot;&#125;PS C:Powershell&gt; ls | Format-Table $column1, $column2filename last modification-------- -----------------ABC 2011/11/23 17:25:53myscript 2011/11/29 18:21:28a.html 2011/11/24 18:30:13]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-06 PowerShell别名]]></title>
    <url>%2Fwindows-06%2F</url>
    <content type="text"><![CDATA[windows-运维-06 PowerShell别名PowerShell别名 cmdlet 的名称由一个动词和一个名词组成，其功能对用户来讲一目了然。但是对于一个经常使用powershell命令的人每天敲那么多命令也很麻烦啊。能不能把命令缩短一点呢？于是“别名”就应运而生了。Powershell内部也实现了很多常用命令的别名。例如Get-ChildItem，列出当前的子文件或目录。它有两个别名：ls 和 dir，这两个别名来源于unix 的shell和windows的cmd。因此别名有两个作用： 继承：继承unix-shell和windows-cmd。 方便：方便用户使用。 处理别名：查询别名所指的真实cmdlet命令。 12345678910111213141516171819202122PS C:\&gt; Get-Alias -name dir CommandType Name Version Source ----------- ---- ------- ------ Alias dir -&gt; Get-ChildItem PS C:\&gt; Get-Alias -name ls CommandType Name Version Source ----------- ---- ------- ------ Alias ls -&gt; Get-ChildItem PS C:\&gt; Get-Alias -name ft CommandType Name Version Source ----------- ---- ------- ------ Alias ft -&gt; Format-Table PS C:\&gt; 查看可用的别名查看可用的别名，可以通过” ls alias:” 或者 ”Get-Alias“如何查看所有以Remove打头的cmdlet的命令的别名呢？ 12345678910111213141516171819PS C:\PS&gt; dir alias: | where &#123;$_.Definition.Startswith(&quot;Remove&quot;)&#125;CommandType Name Definition----------- ---- ----------Alias del Remove-ItemAlias erase Remove-ItemAlias rbp Remove-PSBreakpointAlias rd Remove-ItemAlias rdr Remove-PSDriveAlias ri Remove-ItemAlias rjb Remove-JobAlias rm Remove-ItemAlias rmdir Remove-ItemAlias rmo Remove-ModuleAlias rp Remove-ItemPropertyAlias rsn Remove-PSSessionAlias rsnp Remove-PSSnapinAlias rv Remove-VariableAlias rwmi Remove-WMIObject 说明：dir alias:获取的是别名的数组，通过where对数组元素进行遍历，$_代表当前元素，alias的Definition为String类型，因为powershell支持.net，.net中的string类有一个方法Startswith。通过where过滤集合在powershell中使用非常广泛。 有的cmdlet命令可能有2-3个别名，我们可以通过下面的命令查看所有别名和指向cmdlet的别名的个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111PS C:\PS&gt; ls alias: | Group-Object definition | sort -Descending CountCount Name Group----- ---- ----- 6 Remove-Item &#123;del, erase, rd, ri...&#125; 3 Set-Location &#123;cd, chdir, sl&#125; 3 Get-History &#123;ghy, h, history&#125; 3 Get-ChildItem &#123;dir, gci, ls&#125; 3 Get-Content &#123;cat, gc, type&#125; 3 Move-Item &#123;mi, move, mv&#125; 3 Copy-Item &#123;copy, cp, cpi&#125; 2 Start-Process &#123;saps, start&#125; 2 Set-Variable &#123;set, sv&#125; 2 Write-Output &#123;echo, write&#125; 2 Get-Process &#123;gps, ps&#125; 2 Invoke-History &#123;ihy, r&#125; 2 New-PSDrive &#123;mount, ndr&#125; 2 Stop-Process &#123;kill, spps&#125; 2 Rename-Item &#123;ren, rni&#125; 2 Get-Location &#123;gl, pwd&#125; 2 Compare-Object &#123;compare, diff&#125; 2 Where-Object &#123;?, where&#125; 2 ForEach-Object &#123;%, foreach&#125; 2 Clear-Host &#123;clear, cls&#125; 1 Out-Host &#123;oh&#125; 1 New-PSSession &#123;nsn&#125; 1 New-Variable &#123;nv&#125; 1 Out-GridView &#123;ogv&#125; 1 Pop-Location &#123;popd&#125; 1 Tee-Object &#123;tee&#125; 1 Remove-PSBreakpoint &#123;rbp&#125; 1 Receive-Job &#123;rcjb&#125; 1 Push-Location &#123;pushd&#125; 1 mkdir &#123;md&#125; 1 Measure-Object &#123;measure&#125; 1 help &#123;man&#125; 1 Remove-PSSnapin &#123;rsnp&#125; 1 Out-Printer &#123;lp&#125; 1 New-Item &#123;ni&#125; 1 New-Module &#123;nmo&#125; 1 New-Alias &#123;nal&#125; 1 Move-ItemProperty &#123;mp&#125; 1 Wait-Job &#123;wjb&#125; 1 Remove-PSDrive &#123;rdr&#125; 1 Start-Service &#123;sasv&#125; 1 Set-PSBreakpoint &#123;sbp&#125; 1 Set-ItemProperty &#123;sp&#125; 1 Start-Job &#123;sajb&#125; 1 Set-Alias &#123;sal&#125; 1 Start-Sleep &#123;sleep&#125; 1 Set-Item &#123;si&#125; 1 Select-Object &#123;select&#125; 1 Set-Content &#123;sc&#125; 1 Sort-Object &#123;sort&#125; 1 Remove-WMIObject &#123;rwmi&#125; 1 Remove-Module &#123;rmo&#125; 1 Rename-ItemProperty &#123;rnp&#125; 1 Stop-Service &#123;spsv&#125; 1 Set-WMIInstance &#123;swmi&#125; 1 Remove-Job &#123;rjb&#125; 1 Remove-Variable &#123;rv&#125; 1 Resolve-Path &#123;rvpa&#125; 1 Stop-Job &#123;spjb&#125; 1 Remove-ItemProperty &#123;rp&#125; 1 Remove-PSSession &#123;rsn&#125; 1 Exit-PSSession &#123;exsn&#125; 1 Format-Custom &#123;fc&#125; 1 Enter-PSSession &#123;etsn&#125; 1 Export-Csv &#123;epcsv&#125; 1 Export-PSSession &#123;epsn&#125; 1 Format-List &#123;fl&#125; 1 Get-PSBreakpoint &#123;gbp&#125; 1 Get-Command &#123;gcm&#125; 1 Get-Alias &#123;gal&#125; 1 Format-Table &#123;ft&#125; 1 Format-Wide &#123;fw&#125; 1 Export-Alias &#123;epal&#125; 1 Clear-History &#123;clhy&#125; 1 Clear-Item &#123;cli&#125; 1 Clear-Content &#123;clc&#125; 1 Add-Content &#123;ac&#125; 1 Add-PSSnapIn &#123;asnp&#125; 1 Clear-ItemProperty &#123;clp&#125; 1 Disable-PSBreakpoint &#123;dbp&#125; 1 Enable-PSBreakpoint &#123;ebp&#125; 1 Convert-Path &#123;cvpa&#125; 1 Clear-Variable &#123;clv&#125; 1 Copy-ItemProperty &#123;cpp&#125; 1 Invoke-Expression &#123;iex&#125; 1 Invoke-Item &#123;ii&#125; 1 Invoke-Command &#123;icm&#125; 1 Get-Variable &#123;gv&#125; 1 Get-WmiObject &#123;gwmi&#125; 1 Import-Alias &#123;ipal&#125; 1 powershell_ise.exe &#123;ise&#125; 1 Invoke-WMIMethod &#123;iwmi&#125; 1 Import-PSSession &#123;ipsn&#125; 1 Import-Csv &#123;ipcsv&#125; 1 Import-Module &#123;ipmo&#125; 1 Get-Unique &#123;gu&#125; 1 Get-Job &#123;gjb&#125; 1 Get-Member &#123;gm&#125; 1 Get-Item &#123;gi&#125; 1 Get-PSCallStack &#123;gcs&#125; 1 Get-PSDrive &#123;gdr&#125; 1 Get-Module &#123;gmo&#125; 1 Get-PSSnapIn &#123;gsnp&#125; 1 Get-Service &#123;gsv&#125; 1 Get-PSSession &#123;gsn&#125; 1 Get-ItemProperty &#123;gp&#125; 1 Group-Object &#123;group&#125; 创建自己的别名给记事本创建一个别名，并查看该别名； 1234PS C:\PS&gt; Set-Alias -Name Edit -Value notepadPS C:\PS&gt; EditPS C:\PS&gt; $alias:Editnotepad 删除自己的别名 别名不用删除，自定义的别名在powershell退出时会自动清除。但是请放心，powershell内置别名（诸如ls,dir,fl等）不会清除。如果你非得手工删除别名。请使用 1PS C:\PS&gt; del alias:Edit 保存自己的别名 可以使用Export-Alias将别名导出到文件，需要时再通过Import-Alias导入。但是导入时可能会有异常，提示别名已经存在无法导入： 12345678PS C:\PS&gt; Import-Alias alias.ps1Import-Alias : Alias not allowed because an alias with the name &apos;ac&apos; already exists.At line:1 char:13+ Import-Alias &lt;&lt;&lt;&lt; alias.ps1 + CategoryInfo : ResourceExists: (ac:String) [Import-Alias], SessionStateException + FullyQualifiedErrorId : AliasAlreadyExists,Microsoft.PowerShell.Commands.ImportAliasCommand 这时可以使用Force强制导入。 12PS C:\PS&gt; Export-Alias alias.ps1PS C:\PS&gt; Import-Alias -Force alias.ps1 通过函数扩展别名 在Powershell中设置别名的确方便快捷，但是在设置别名的过程中并设置参数的相关信息。尽管别名会自动识别参数，但是如何把经常使用的参数默认设定在别名里面呢？例如Test-Connection -Count 2 -ComputerName，让-“-Count 2” 固化在别名中。 这时简单的别名无法完成上述需求，可以通过函数来完成它，并且一旦把函数拉过来，定义别名会变得更加灵活。 12345678PS C:\PS&gt; function test-conn &#123; Test-Connection -Count 2 -ComputerName $args&#125;PS C:\PS&gt; Set-Alias tc test-connPS C:\PS&gt; tc localhostSource Destination IPV4Address IPV6Address Bytes Time(ms)------ ----------- ----------- ----------- ----- --------test-me-01 localhost 127.0.0.1 ::1 32 0test-me-01 localhost 127.0.0.1 ::1 32 0 有了函数牵线，别名可以完成更高级更强大的功能，其中$args为参数的占位符。 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-05 初识PowerShell]]></title>
    <url>%2Fwindows-05%2F</url>
    <content type="text"><![CDATA[windows-运维-05 初识PowerShell什么是PowerShell Powershell 是运行在windows机器上实现系统和应用程序管理自动化的命令行脚本环境。你可以把它看成是命令行提示符cmd.exe的扩充，不对，应当是颠覆。 powershell需要.NET环境的支持，同时支持.NET对象。微软之所以将Powershell 定位为Power，并不是夸大其词，因为它完全支持对象。其可读性，易用性，可以位居当前所有shell之首。 当前powershell有四版本，分别为1.0，2.0，3.0 ,4.0 如果您的系统是window7或者Windows Server 2008，那么PowerShell 2.0已经内置了，可以升级为3.0，4.0。 如果您的系统是Windows 8 或者Windows server 2012，那么PowerShell 3.0已经内置了，可以升级为4.0。 如果您的系统为Windows 8.1或者Windows server 2012 R2，那默认已经是4.0了。 Powershell 自定义控制台 打开虚拟机或者物理机，打开你powershell，右击powershell的标题栏选择”属性”弹出powershell控制台对话框。在这里有四个选项卡：选项、字体、布局和颜色。 Powershell 编辑模式powershell控制台有两种模式，一个是快速编辑模式，一个是标准模式。快速编辑模式和标准模式的切换可以通过控制台标题栏-&gt;鼠标右击-&gt;属性-&gt;选项-&gt;编辑选项 。 Powershell标准模式鼠标右击选择标记后才能实现复制和粘切功能。 Powershell快速编辑模式可以通过鼠标左键选择任意矩形区域内的文本，并且鼠标右击实现复制功能。 Powershell的快捷键 ALT+F7 清除命令的历史记录 PgUp PgDn 显示当前会话的第一个命令和最后一个命令 Enter 执行当前命令 End 将光标移至当前命令的末尾 Del 从右开始删除输入的命令字符 Esc 清空当前命令行 F2 自动补充历史命令至指定字符 (例如历史记录中存在Get-Process，按F2，提示”Enter char to copy up to”，键入‘s’，自动补齐命令:Get-Proce) F4 删除命令行至光标右边指定字符处 F7 对话框显示命令行历史记录 F8 检索包含指定字符的命令行历史记录 F9 根据命令行的历史记录编号选择命令，历史记录编号可以通过F7查看 左/右方向键 左右移动光标 上/下方向键 切换命令行的历史记录 Home 光标移至命令行最左端 Backspace 从右删除命令行字符 Ctrl+C 取消正在执行的命令 Ctrl+左/右方向键 在单词之间移动光标 Ctrl+Home 删除光标最左端的所有字符 Tab 自动补齐命令或者文件名 Powershell交互式Powershell 进行数学运算 我们可以把powershell当成一个计算器。象键入命令行那样输入数学表达式，回车，powershell会自动计算并把结果输出。常用的加减乘除模（+,-,*,/,%）运算和小括号表达式都支持。 12345678PS C:\pstest&gt; 1+2+36PS C:\pstest&gt; 0xABCD43981PS C:\pstest&gt; 3.14*10*10314PS C:\pstest&gt; 1+3-(2.4-5)*(7.899-4.444)12.983 PowerShell也能自动识别计算机容量单位,包括KB，MB，GB，TB，PB 12345678PS C:\pstest&gt; 1pb/1tb1024PS C:\pstest&gt; 1tb/1gb1024PS C:\pstest&gt; 1gb/1kb1048576PS C:\pstest&gt; 1gb/20mb*10kb524288 假如一个网站每个页面大小为80kb，统计显示每天的PV操作为800，1个月下来占用的带宽： 12PS C:\pstest&gt; 80kb*800*30/1gb1.8310546875 假如一个网站的每天人均PV操作为5，页面大小为80Kb，主机提供商限制的总流量为10G，那平均每天的最大访客数 为： 12PS C:pstest&gt; 10GB/(80KB*5)/30873.813333333333 Powershell变量定义变量变量可以临时保存数据，因此可以把数据保存在变量中，以便进一步操作。 12345678910#定义变量$a=10$b=4#计算变量$result=$a*$b$msg=&quot;保存文本&quot;#输出变量$result$msg powershell 不需要显示地去声明，可以自动创建变量，只须记住变量的前缀为$. 创建好了变量后，可以通过变量名输出变量，也可以把变量名存在字符串中。但是有个例外单引号中的字符串不会识别和处理变量名。 选择变量名 在powershell中变量名均是以美元符”$”开始，剩余字符可以是数字、字母、下划线的任意字符，并且powershell变量名大小写不敏感（$a和$A 是同一个变量)。 某些特殊的字符在powershell中有特殊的用途，一般不推荐使用这些字符作为变量名。当然你硬要使用，请把整个变量名后缀用花括号括起来。 123PS C:\test&gt; $&#123;&quot;I&quot;like $&#125;=&quot;mossfly&quot;PS C:\test&gt; $&#123;&quot;I&quot;like $&#125;mossfly 赋值和返回值 赋值操作符为“=”，几乎可以把任何数据赋值给一个变量，甚至一条cmdlet命令，为什么，因为Powershell支持对象，对象可以包罗万象。 1234567891011121314151617181920212223242526PS C:\test&gt; $item=Get-ChildItem .PS C:\test&gt; $item Directory: C:\testMode LastWriteTime Length Name---- ------------- ------ ----d---- 2011/11/23 17:25 ABC-a--- 2011/11/24 18:30 67580 a.html-a--- 2011/11/24 20:04 26384 a.txt-a--- 2011/11/24 20:26 12060 alias-a--- 2011/11/24 20:27 12060 alias.ps1-a--- 2011/11/23 17:25 0 b.txt-a--- 2011/11/23 17:25 0 c.txt-a--- 2011/11/23 17:25 0 d.txt-a--- 2011/11/25 11:20 556 employee.xml-a--- 2011/11/24 17:37 7420 name.html-a--- 2011/11/28 15:30 63 ping.bat-a--- 2011/11/24 17:44 735892 Powershell_Cmdlets.html-a--- 2011/11/28 17:03 60 test.ps1-a--- 2011/11/23 17:37 242 test.txt-a--- 2011/11/28 16:42 170 test.vbsPS C:\test&gt; $result=3000*(1/12+0.0075)PS C:\test&gt; $result272.5 给多个变量同时赋值赋值操作符不仅能给一个变量赋值，还可以同时给多个变量赋相同的值。 1234567PS C:\test&gt; $a=$b=$c=123PS C:\test&gt; $a123PS C:\test&gt; $b123PS C:\test&gt; $c123 交换变量的值要交换两个变量的值，传统的程序语言至少需要三步，并且还需定义一个中间临时变量。 12345$Value1 = 10$Value2 = 20$Temp = $Value1$Value1 = $Value2$Value2 = $Temp 在powershell中，交换两个变量的值，这个功能变得非常简单。 1234567PS C:\test&gt; $value1=10PS C:\test&gt; $value2=20PS C:\test&gt; $value1,$value2=$value2,$value1PS C:\test&gt; $value120PS C:\test&gt; $value210 查看正在使用的变量 Powershell将变量的相关信息的记录存放在名为variable:的驱动中。如果要查看所有定义的变量，可以直接遍历variable: 123456789101112131415161718PS C:\test&gt; ls variable:Name Value---- -----&quot;I&quot;like $ mossfly$ cls? True^ cls_1 1a 123args &#123;&#125;b 123c 123ConfirmPreference HighConsoleFileNameDebugPreference SilentlyContinue。。。 查找变量因为有虚拟驱动variable:的存在，可以象查找文件那样使用通配符查找变量。例如要查询以value打头的变量名。 123456PS C:\test&gt; ls variable:value*Name Value---- -----value1 20value2 10 验证变量是否存在 验证一个变量是否存在，仍然可以象验证文件系统那样，使用cmdlet Test-Path。为什么？因为变量存在变量驱动器中。 123456PS C:\test&gt; Test-Path variable:value1TruePS C:\test&gt; Test-Path variable:value2TruePS C:\test&gt; Test-Path variable:valueUnkonwFalse 删除变量 因为变量会在powershell退出或关闭时，自动清除。一般没必要删除，但是你非得删除，也可以象删除文件那样删除它 12345PS C:\test&gt; Test-Path variable:value1TruePS C:\test&gt; del variable:value1PS C:\test&gt; Test-Path variable:value1False 使用专用的变量命令 为了管理变量，powershell提供了五个专门管理变量的命令Clear-Variable，Get-Variable，New-Variable，Remove-Variable，Set-Variable。因为虚拟驱动器variable:的存在，clear，remove，set打头的命令可以被代替。但是Get-Variable，New-Variable。却非常有用new-variable可以在定义变量时，指定变量的一些其它属性，比如访问权限。同样Get-Variable也可以获取这些附加信息。 变量写保护(创建常量)可以使用New-Variable 的option选项 在创建变量时，给变量加上只读属性，这样就不能给变量重新赋值了。 1234567891011PS C:\test&gt; New-Variable num -Value 100 -Force -Option readonlyPS C:\test&gt; $num=101Cannot overwrite variable num because it is read-only or constant.At line:1 char:5+ $num &lt;&lt;&lt;&lt; =101 + CategoryInfo : WriteError: (num:String) [], SessionStateUnauthorizedAccessException + FullyQualifiedErrorId : VariableNotWritable PS C:\test&gt; del Variable:numRemove-Item : Cannot remove variable num because it is constant or read-only. If the variable is read-only,ration again specifying the Force option.At line:1 char:4+ del &lt;&lt;&lt;&lt; Variable:num + CategoryInfo : WriteError: (num:String) [Remove-Item], SessionStateUnauthorizedAccessExcepti + FullyQualifiedErrorId : VariableNotRemovable,Microsoft.PowerShell.Commands.RemoveItemCommand 但是可以通过删除变量，再重新创建变量更新变量内容。 1234PS C:\test&gt; del Variable:num -ForcePS C:\test&gt; $num=101PS C:\test&gt; $num101 有没有权限更高的变量，有，那就是：选项Constant，常量一旦声明，不可修改 123456789101112PS C:\test&gt; new-variable num -Value &quot;strong&quot; -Option constantPS C:\test&gt; $num=&quot;why? can not delete it.&quot;Cannot overwrite variable num because it is read-only or constant.At line:1 char:5+ $num &lt;&lt;&lt;&lt; =&quot;why? can not delete it.&quot; + CategoryInfo : WriteError: (num:String) [], SessionStateUnauthorizedAccessException + FullyQualifiedErrorId : VariableNotWritable PS C:\test&gt; del Variable:num -ForceRemove-Item : Cannot remove variable num because it is constant or read-only. If the variable is read-only,ration again specifying the Force option.At line:1 char:4+ del &lt;&lt;&lt;&lt; Variable:num -Force + CategoryInfo : WriteError: (num:String) [Remove-Item], SessionStateUnauthorizedAccessExcepti + FullyQualifiedErrorId : VariableNotRemovable,Microsoft.PowerShell.Commands.RemoveItemCommand 变量描述 在New-Variable 可以通过-description 添加变量描述，但是变量描述默认不会显示，可以通过Format-List 查看。 123456789101112131415PS C:\test&gt; new-variable name -Value &quot;me&quot; -Description &quot;This is my name&quot;PS C:\test&gt; ls Variable:name | fl *PSPath : Microsoft.PowerShell.CoreVariable::namePSDrive : VariablePSProvider : Microsoft.PowerShell.CoreVariablePSIsContainer : FalseName : nameDescription : This is my nameValue : meVisibility : PublicModule :ModuleName :Options : NoneAttributes : &#123;&#125; 执行外部命令 Powershell能像cmd一样执行外部命令 通过netstat查看网络端口状态12345678PS C:\PS&gt; netstatActive Connections Proto Local Address Foreign Address State TCP 192.168.0.100:3049 192.168.0.88:7575 ESTABLISHED TCP 192.168.0.100:3052 192.168.0.88:7575 ESTABLISHED TCP 192.168.0.100:3061 192.168.0.88:7575 ESTABLISHED route print 查看本机路由信息1234567891011121314151617181920212223242526272829303132333435PS C:\PS&gt; route printIPv4 Route Table===========================================================================Active Routes:Network Destination Netmask Gateway Interface Metric 0.0.0.0 0.0.0.0 192.168.140.1 192.168.140.100 20 192.0.0.0 255.0.0.0 On-link 192.0.0.1 306 192.0.0.1 255.255.255.255 On-link 192.0.0.1 306 192.255.255.255 255.255.255.255 On-link 192.0.0.1 306 192.168.140.0 255.255.252.0 On-link 192.168.140.100 276 192.168.140.100 255.255.255.255 On-link 192.168.140.100 276 192.168.143.255 255.255.255.255 On-link 192.168.140.100 276 224.0.0.0 240.0.0.0 On-link 192.0.0.1 306 224.0.0.0 240.0.0.0 On-link 192.168.140.100 276 255.255.255.255 255.255.255.255 On-link 192.0.0.1 306 255.255.255.255 255.255.255.255 On-link 192.168.140.100 276===========================================================================Persistent Routes: NoneIPv6 Route Table===========================================================================Active Routes: If Metric Network Destination Gateway 1 306 ::1/128 On-link 10 276 fe80::/64 On-link 11 281 fe80::5efe:192.168.140.100/128 On-link 10 276 fe80::b965:91f3:33a0:7285/128 On-link 1 306 ff00::/8 On-link 10 276 ff00::/8 On-link===========================================================================Persistent Routes: None 启动CMD控制台启动CMD控制台键入cmd或者cmd.exe,退出cmd可以通过命令exit。 123456PS C:\PS&gt; cmdMicrosoft Windows [Version 6.1.7601]Copyright (c) 2009 Microsoft Corporation. All rights reserved.C:\PS&gt;exitPS C:\PS&gt; 查找可用的Cmd控制台命令 Cmd.exe 通过 /c 来接收命令参数，在Cmd中help可以查看可用的命令，所以可以通过Cmd /c help 查找可用的Cmd控制台命令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091PS C:\PS&gt; cmd /c help有关某个命令的详细信息，请键入 HELP 命令名ASSOC 显示或修改文件扩展名关联。ATTRIB 显示或更改文件属性。BREAK 设置或清除扩展式 CTRL+C 检查。BCDEDIT 设置启动数据库中的属性以控制启动加载。CACLS 显示或修改文件的访问控制列表(ACL)。CALL 从另一个批处理程序调用这一个。CD 显示当前目录的名称或将其更改。CHCP 显示或设置活动代码页数。CHDIR 显示当前目录的名称或将其更改。CHKDSK 检查磁盘并显示状态报告。CHKNTFS 显示或修改启动时间磁盘检查。CLS 清除屏幕。CMD 打开另一个 Windows 命令解释程序窗口。COLOR 设置默认控制台前景和背景颜色。COMP 比较两个或两套文件的内容。COMPACT 显示或更改 NTFS 分区上文件的压缩。CONVERT 将 FAT 卷转换成 NTFS。您不能转换 当前驱动器。COPY 将至少一个文件复制到另一个位置。DATE 显示或设置日期。DEL 删除至少一个文件。DIR 显示一个目录中的文件和子目录。DISKCOMP 比较两个软盘的内容。DISKCOPY 将一个软盘的内容复制到另一个软盘。DISKPART 显示或配置磁盘分区属性。DOSKEY 编辑命令行、调用 Windows 命令并创建宏。DRIVERQUERY 显示当前设备驱动程序状态和属性。ECHO 显示消息，或将命令回显打开或关上。ENDLOCAL 结束批文件中环境更改的本地化。ERASE 删除一个或多个文件。EXIT 退出 CMD.EXE 程序(命令解释程序)。FC 比较两个文件或两个文件集并显示它们之间的不同。FIND 在一个或多个文件中搜索一个文本字符串。FINDSTR 在多个文件中搜索字符串。FOR 为一套文件中的每个文件运行一个指定的命令。FORMAT 格式化磁盘，以便跟 Windows 使用。FSUTIL 显示或配置文件系统的属性。FTYPE 显示或修改用在文件扩展名关联的文件类型。GOTO 将 Windows 命令解释程序指向批处理程序 中某个带标签的行。GPRESULT 显示机器或用户的组策略信息。GRAFTABL 启用 Windows 在图形模式显示扩展字符集。HELP 提供 Windows 命令的帮助信息。ICACLS 显示、修改、备份或还原文件和 目录的 ACL。IF 在批处理程序中执行有条件的处理过程。LABEL 创建、更改或删除磁盘的卷标。MD 创建一个目录。MKDIR 创建一个目录。MKLINK 创建符号链接和硬链接MODE 配置系统设备。MORE 逐屏显示输出。MOVE 将一个或多个文件从一个目录移动到另一个目录。OPENFILES 显示远程用户为了文件共享而打开的文件。PATH 为可执行文件显示或设置搜索路径。PAUSE 停止批处理文件的处理并显示信息。POPD 还原由 PUSHD 保存的当前目录上一次的值。PRINT 打印一个文本文件。PROMPT 改变 Windows 命令提示。PUSHD 保存当前目录，然后对其进行更改。RD 删除目录。RECOVER 从损坏的磁盘中恢复可读取的信息。REM 记录批处理文件或 CONFIG.SYS 中的注释。REN 重新命名文件。RENAME 重新命名文件。REPLACE 替换文件。RMDIR 删除目录。ROBOCOPY 复制文件和目录树的高级实用程序SET 显示、设置或删除 Windows 环境变量。SETLOCAL 开始用批文件改变环境的本地化。SC 显示或配置服务(后台处理)。SCHTASKS 安排命令和程序在一部计算机上按计划运行。SHIFT 调整批处理文件中可替换参数的位置。SHUTDOWN 让机器在本地或远程正确关闭。SORT 将输入排序。START 打开单独视窗运行指定程序或命令。SUBST 将驱动器号与路径关联。SYSTEMINFO 显示机器的具体的属性和配置。TASKLIST 显示包括服务的所有当前运行的任务。TASKKILL 终止正在运行的进程或应用程序。TIME 显示或设置系统时间。TITLE 设置 CMD.EXE 会话的窗口标题。TREE 以图形显示启动器或路径的目录结构。TYPE 显示文本文件的内容。VER 显示 Windows 的版本。VERIFY 告诉 Windows 验证文件是否正确写入磁盘。VOL 显示磁盘卷标和序列号。XCOPY 复制文件和目录树。WMIC 在交互命令外壳里显示 WMI 信息。 命令集 cmdletscmdlets是Powershell的内部命令，cmdlet的类型名为System.Management.Automation.CmdletInfo，包含下列属性和方法： Name MemberType Definition Equals Method bool Equals(System.Object obj) GetHashCode Method int GetHashCode() GetType Method type GetType() ToString Method string ToString() CommandType Property System.Management.Automation.CommandTypes CommandType {get;} DefaultParameterSet Property System.String DefaultParameterSet {get;} Definition Property System.String Definition {get;} HelpFile Property System.String HelpFile {get;} ImplementingType Property System.Type ImplementingType {get;} Module Property System.Management.Automation.PSModuleInfo Module {get;} ModuleName Property System.String ModuleName {get;} Name Property System.String Name {get;} Noun Property System.String Noun {get;} OutputType Property System.Collections.ObjectModel.ReadOnlyCollection`1[[System.Management.Automation.PSTypeName, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]] OutputType {get;} Parameters Property System.Collections.Generic.Dictionary`2[[System.String, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.Management.Automation.ParameterMetadata, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]] Parameters {get;} ParameterSets Property System.Collections.ObjectModel.ReadOnlyCollection`1[[System.Management.Automation.CommandParameterSetInfo, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]] ParameterSets {get;} PSSnapIn Property System.Management.Automation.PSSnapInInfo PSSnapIn {get;} Verb Property System.String Verb {get;} Visibility Property System.Management.Automation.SessionStateEntryVisibility Visibility {get;set;} DLL ScriptProperty System.Object DLL {get=$this.ImplementingType.Assembly.Location;} HelpUri ScriptProperty System.Object HelpUri {get=try { # ok to cast CommandTypes enum to HelpCategory because string/indentifier for # cmdlet,function,filter,alias,externalscript is identical. # it is ok to fail for other enum values (i.e. for Application) $helpObject = get-help -Name ($this.Name) -Category (string) -ErrorAction SilentlyContinue# return first non-null uri (and try not to hit any strict mode things) if ($helpObject -eq $null) { return $null } if ($helpObject.psobject.properties[‘relatedLinks’] -eq $null) { return $null } if ($helpObject.relatedLinks.psobject.properties[‘navigationLink’] -eq $null) { return $null } $helpUri = [string]$( $helpObject.relatedLinks.navigationLink \ %{ if ($.psobject.properties[‘uri’] -ne $null) { $.uri } } \ ?{ $_ } \ select -first 1 ) return $helpUri } catch {};} 下面是全部的Cmdlets命令 每个命令有一个动词和名词组成，命令的作用一目了然。 Name ModuleName Help Add-Computer Microsoft.PowerShell.Management help Add-Content Microsoft.PowerShell.Management help Add-History Microsoft.PowerShell.Core help Add-Member Microsoft.PowerShell.Utility help Add-PSSnapin Microsoft.PowerShell.Core help Add-Type Microsoft.PowerShell.Utility help Checkpoint-Computer Microsoft.PowerShell.Management help Clear-Content Microsoft.PowerShell.Management help Clear-EventLog Microsoft.PowerShell.Management help Clear-History Microsoft.PowerShell.Core help Clear-Item Microsoft.PowerShell.Management help Clear-ItemProperty Microsoft.PowerShell.Management help Clear-Variable Microsoft.PowerShell.Utility help Compare-Object Microsoft.PowerShell.Utility help Complete-Transaction Microsoft.PowerShell.Management help Connect-WSMan Microsoft.WSMan.Management help ConvertFrom-Csv Microsoft.PowerShell.Utility help ConvertFrom-SecureString Microsoft.PowerShell.Security help ConvertFrom-StringData Microsoft.PowerShell.Utility help Convert-Path Microsoft.PowerShell.Management help ConvertTo-Csv Microsoft.PowerShell.Utility help ConvertTo-Html Microsoft.PowerShell.Utility help ConvertTo-SecureString Microsoft.PowerShell.Security help ConvertTo-Xml Microsoft.PowerShell.Utility help Copy-Item Microsoft.PowerShell.Management help Copy-ItemProperty Microsoft.PowerShell.Management help Debug-Process Microsoft.PowerShell.Management help Disable-ComputerRestore Microsoft.PowerShell.Management help Disable-PSBreakpoint Microsoft.PowerShell.Utility help Disable-PSSessionConfiguration Microsoft.PowerShell.Core help Disable-WSManCredSSP Microsoft.WSMan.Management help Disconnect-WSMan Microsoft.WSMan.Management help Enable-ComputerRestore Microsoft.PowerShell.Management help Enable-PSBreakpoint Microsoft.PowerShell.Utility help Enable-PSRemoting Microsoft.PowerShell.Core help Enable-PSSessionConfiguration Microsoft.PowerShell.Core help Enable-WSManCredSSP Microsoft.WSMan.Management help Enter-PSSession Microsoft.PowerShell.Core help Exit-PSSession Microsoft.PowerShell.Core help Export-Alias Microsoft.PowerShell.Utility help Export-Clixml Microsoft.PowerShell.Utility help Export-Console Microsoft.PowerShell.Core help Export-Counter Microsoft.PowerShell.Diagnostics help Export-Csv Microsoft.PowerShell.Utility help Export-FormatData Microsoft.PowerShell.Utility help Export-ModuleMember Microsoft.PowerShell.Core help Export-PSSession Microsoft.PowerShell.Utility help ForEach-Object Microsoft.PowerShell.Core help Format-Custom Microsoft.PowerShell.Utility help Format-List Microsoft.PowerShell.Utility help Format-Table Microsoft.PowerShell.Utility help Format-Wide Microsoft.PowerShell.Utility help Get-Acl Microsoft.PowerShell.Security help Get-Alias Microsoft.PowerShell.Utility help Get-AuthenticodeSignature Microsoft.PowerShell.Security help Get-ChildItem Microsoft.PowerShell.Management help Get-Command Microsoft.PowerShell.Core help Get-ComputerRestorePoint Microsoft.PowerShell.Management help Get-Content Microsoft.PowerShell.Management help Get-Counter Microsoft.PowerShell.Diagnostics help Get-Credential Microsoft.PowerShell.Security help Get-Culture Microsoft.PowerShell.Utility help Get-Date Microsoft.PowerShell.Utility help Get-Event Microsoft.PowerShell.Utility help Get-EventLog Microsoft.PowerShell.Management help Get-EventSubscriber Microsoft.PowerShell.Utility help Get-ExecutionPolicy Microsoft.PowerShell.Security help Get-FormatData Microsoft.PowerShell.Utility help Get-Help Microsoft.PowerShell.Core help Get-History Microsoft.PowerShell.Core help Get-Host Microsoft.PowerShell.Utility help Get-HotFix Microsoft.PowerShell.Management help Get-Item Microsoft.PowerShell.Management help Get-ItemProperty Microsoft.PowerShell.Management help Get-Job Microsoft.PowerShell.Core help Get-Location Microsoft.PowerShell.Management help Get-Member Microsoft.PowerShell.Utility help Get-Module Microsoft.PowerShell.Core help Get-PfxCertificate Microsoft.PowerShell.Security help Get-Process Microsoft.PowerShell.Management help Get-PSBreakpoint Microsoft.PowerShell.Utility help Get-PSCallStack Microsoft.PowerShell.Utility help Get-PSDrive Microsoft.PowerShell.Management help Get-PSProvider Microsoft.PowerShell.Management help Get-PSSession Microsoft.PowerShell.Core help Get-PSSessionConfiguration Microsoft.PowerShell.Core help Get-PSSnapin Microsoft.PowerShell.Core help Get-Random Microsoft.PowerShell.Utility help Get-Service Microsoft.PowerShell.Management help Get-TraceSource Microsoft.PowerShell.Utility help Get-Transaction Microsoft.PowerShell.Management help Get-UICulture Microsoft.PowerShell.Utility help Get-Unique Microsoft.PowerShell.Utility help Get-Variable Microsoft.PowerShell.Utility help Get-WinEvent Microsoft.PowerShell.Diagnostics help Get-WmiObject Microsoft.PowerShell.Management help Get-WSManCredSSP Microsoft.WSMan.Management help Get-WSManInstance Microsoft.WSMan.Management help Group-Object Microsoft.PowerShell.Utility help Import-Alias Microsoft.PowerShell.Utility help Import-Clixml Microsoft.PowerShell.Utility help Import-Counter Microsoft.PowerShell.Diagnostics help Import-Csv Microsoft.PowerShell.Utility help Import-LocalizedData Microsoft.PowerShell.Utility help Import-Module Microsoft.PowerShell.Core help Import-PSSession Microsoft.PowerShell.Utility help Invoke-Command Microsoft.PowerShell.Core help Invoke-Expression Microsoft.PowerShell.Utility help Invoke-History Microsoft.PowerShell.Core help Invoke-Item Microsoft.PowerShell.Management help Invoke-WmiMethod Microsoft.PowerShell.Management help Invoke-WSManAction Microsoft.WSMan.Management help Join-Path Microsoft.PowerShell.Management help Limit-EventLog Microsoft.PowerShell.Management help Measure-Command Microsoft.PowerShell.Utility help Measure-Object Microsoft.PowerShell.Utility help Move-Item Microsoft.PowerShell.Management help Move-ItemProperty Microsoft.PowerShell.Management help New-Alias Microsoft.PowerShell.Utility help New-Event Microsoft.PowerShell.Utility help New-EventLog Microsoft.PowerShell.Management help New-Item Microsoft.PowerShell.Management help New-ItemProperty Microsoft.PowerShell.Management help New-Module Microsoft.PowerShell.Core help New-ModuleManifest Microsoft.PowerShell.Core help New-Object Microsoft.PowerShell.Utility help New-PSDrive Microsoft.PowerShell.Management help New-PSSession Microsoft.PowerShell.Core help New-PSSessionOption Microsoft.PowerShell.Core help New-Service Microsoft.PowerShell.Management help New-TimeSpan Microsoft.PowerShell.Utility help New-Variable Microsoft.PowerShell.Utility help New-WebServiceProxy Microsoft.PowerShell.Management help New-WSManInstance Microsoft.WSMan.Management help New-WSManSessionOption Microsoft.WSMan.Management help Out-Default Microsoft.PowerShell.Utility help Out-File Microsoft.PowerShell.Utility help Out-GridView Microsoft.PowerShell.Utility help Out-Host Microsoft.PowerShell.Utility help Out-Null Microsoft.PowerShell.Utility help Out-Printer Microsoft.PowerShell.Utility help Out-String Microsoft.PowerShell.Utility help Pop-Location Microsoft.PowerShell.Management help Push-Location Microsoft.PowerShell.Management help Read-Host Microsoft.PowerShell.Utility help Receive-Job Microsoft.PowerShell.Core help Register-EngineEvent Microsoft.PowerShell.Utility help Register-ObjectEvent Microsoft.PowerShell.Utility help Register-PSSessionConfiguration Microsoft.PowerShell.Core help Register-WmiEvent Microsoft.PowerShell.Management help Remove-Computer Microsoft.PowerShell.Management help Remove-Event Microsoft.PowerShell.Utility help Remove-EventLog Microsoft.PowerShell.Management help Remove-Item Microsoft.PowerShell.Management help Remove-ItemProperty Microsoft.PowerShell.Management help Remove-Job Microsoft.PowerShell.Core help Remove-Module Microsoft.PowerShell.Core help Remove-PSBreakpoint Microsoft.PowerShell.Utility help Remove-PSDrive Microsoft.PowerShell.Management help Remove-PSSession Microsoft.PowerShell.Core help Remove-PSSnapin Microsoft.PowerShell.Core help Remove-Variable Microsoft.PowerShell.Utility help Remove-WmiObject Microsoft.PowerShell.Management help Remove-WSManInstance Microsoft.WSMan.Management help Rename-Item Microsoft.PowerShell.Management help Rename-ItemProperty Microsoft.PowerShell.Management help Reset-ComputerMachinePassword Microsoft.PowerShell.Management help Resolve-Path Microsoft.PowerShell.Management help Restart-Computer Microsoft.PowerShell.Management help Restart-Service Microsoft.PowerShell.Management help Restore-Computer Microsoft.PowerShell.Management help Resume-Service Microsoft.PowerShell.Management help Select-Object Microsoft.PowerShell.Utility help Select-String Microsoft.PowerShell.Utility help Select-Xml Microsoft.PowerShell.Utility help Send-MailMessage Microsoft.PowerShell.Utility help Set-Acl Microsoft.PowerShell.Security help Set-Alias Microsoft.PowerShell.Utility help Set-AuthenticodeSignature Microsoft.PowerShell.Security help Set-Content Microsoft.PowerShell.Management help Set-Date Microsoft.PowerShell.Utility help Set-ExecutionPolicy Microsoft.PowerShell.Security help Set-Item Microsoft.PowerShell.Management help Set-ItemProperty Microsoft.PowerShell.Management help Set-Location Microsoft.PowerShell.Management help Set-PSBreakpoint Microsoft.PowerShell.Utility help Set-PSDebug Microsoft.PowerShell.Core help Set-PSSessionConfiguration Microsoft.PowerShell.Core help Set-Service Microsoft.PowerShell.Management help Set-StrictMode Microsoft.PowerShell.Core help Set-TraceSource Microsoft.PowerShell.Utility help Set-Variable Microsoft.PowerShell.Utility help Set-WmiInstance Microsoft.PowerShell.Management help Set-WSManInstance Microsoft.WSMan.Management help Set-WSManQuickConfig Microsoft.WSMan.Management help Show-EventLog Microsoft.PowerShell.Management help Sort-Object Microsoft.PowerShell.Utility help Split-Path Microsoft.PowerShell.Management help Start-Job Microsoft.PowerShell.Core help Start-Process Microsoft.PowerShell.Management help Start-Service Microsoft.PowerShell.Management help Start-Sleep Microsoft.PowerShell.Utility help Start-Transaction Microsoft.PowerShell.Management help Start-Transcript Microsoft.PowerShell.Host help Stop-Computer Microsoft.PowerShell.Management help Stop-Job Microsoft.PowerShell.Core help Stop-Process Microsoft.PowerShell.Management help Stop-Service Microsoft.PowerShell.Management help Stop-Transcript Microsoft.PowerShell.Host help Suspend-Service Microsoft.PowerShell.Management help Tee-Object Microsoft.PowerShell.Utility help Test-ComputerSecureChannel Microsoft.PowerShell.Management help Test-Connection Microsoft.PowerShell.Management help Test-ModuleManifest Microsoft.PowerShell.Core help Test-Path Microsoft.PowerShell.Management help Test-WSMan Microsoft.WSMan.Management help Trace-Command Microsoft.PowerShell.Utility help Undo-Transaction Microsoft.PowerShell.Management help Unregister-Event Microsoft.PowerShell.Utility help Unregister-PSSessionConfiguration Microsoft.PowerShell.Core help Update-FormatData Microsoft.PowerShell.Utility help Update-List Microsoft.PowerShell.Utility help Update-TypeData Microsoft.PowerShell.Utility help Use-Transaction Microsoft.PowerShell.Management help Wait-Event Microsoft.PowerShell.Utility help Wait-Job Microsoft.PowerShell.Core help Wait-Process Microsoft.PowerShell.Management help Where-Object Microsoft.PowerShell.Core help Write-Debug Microsoft.PowerShell.Utility help Write-Error Microsoft.PowerShell.Utility help Write-EventLog Microsoft.PowerShell.Management help Write-Host Microsoft.PowerShell.Utility help Write-Output Microsoft.PowerShell.Utility help Write-Progress Microsoft.PowerShell.Utility help Write-Verbose Microsoft.PowerShell.Utility help Write-Warning Microsoft.PowerShell.Utility help 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-04 日志服务]]></title>
    <url>%2Fwindows-04%2F</url>
    <content type="text"><![CDATA[windows-运维-04 日志服务 打开物理机，右键单击“此电脑”，选择“管理”，点进去 出现“计算机管理”对话框，在左侧“计算机管理（本地local）”—“系统工具”—“事件查看 找到“Windows日志”，双击，观察右侧展开区域的变化 找到右侧区域中的“应用程序”，双击打开 看到非常详细的应用程序信息，其中包括应用程序被打开、修改、权限过户、权限登记、关闭以及重要的出错或者兼容性信息，都一一被记录在内，可以根据关键字、时间排序来搜索定位。 右键单击其中任意一条信息，选择“事件属性Event”，可以看到详细的属性。 右键单击其中任意一条应用程序信息，选择“保存选择的事件”，可以将其详细信息保存在计算机中或者自定义的网络位置。 双击左侧的“安全”，可以将具体的电脑记录的设计安全性的事件信息全都枚举于此，我们普通用户也可以对其进行具体查看和保存、附加程序等。其中带钥匙图案的表示审核通过的事件 双击左侧的“设置”，在右侧就会展开系统设置详细内容，再点击“XML样式”切换到XML样式，其中系统自动生成完整的网页信息，如果想要把这些信息嵌入到你的网页中，那么只需声明正确的CSS样式，就可以完成嵌入。但是最好不要擅自修改这些代码，因为格式的不兼容会导致编译过程中程序出现不可逆的乱码。 双击左侧的“系统”，就可以看到Windows操作系统运行时内核以及上层软硬件之间的运行记录，这里面会记录大量的错误信息，是黑客们分析目标计算机漏洞时最常用到的信息库，如果有时间精力的话最好熟悉错误码，这样的话可以提高分析效率。 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-03 活动目录]]></title>
    <url>%2Fwindows-03%2F</url>
    <content type="text"><![CDATA[windows-运维-03 活动目录概述 Active Directory（活动目录）是Windows Server 2003域环境中提供目录服务的组件。目录服务在微软平台上从Windows Server 2000开始引入，所以我们可以理解为活动目录是目录服务在微软平台的一种实现方式。当然目录服务在非微软平台上都有相应的实现。 Windows Server 2012 R2有两种网络环境：工作组和域，默认是工作组网络环境，工作组网络也称为“对等式”的网络，因为网络中每台计算机的地位都是平等的。如下图： 相关概念1.命名空间 命名空间是一个界定好的区域，比如我们把电话簿看成一个“命名空间”，那么我们就可以通过电话簿这个界定好的区域里面的某个人名，找到与这个人名相关的电话、地址以及公司名称等信息。而Windows Server的活动目录就一个命名空间，我们通过活动目录里的对象的名称就可以找到与这个对象相关的信息。活动目录的“命名空间”采用DNS的架构，所以活动目录的域名采用DNS的格式来命名。我们可以把域名命名为feng.com、abc.com等。 2.域、域树、林和组织单元 活动目录的逻辑结构包裹：域（Domain）、域树(Domain Tree)、林（Forest）和组织单元（Organization Unit）。如下图： 域是一种逻辑分组，准确的说是一种环境，域是安全的最小边界。域环境能对网络中的资源集中统一的管理，要想实现域环境，你必须要计算机中安装活动目录。 域树是由一组具有连续命名空间的域组成的。如下图： 其中最上层的域名为feng.com，这个域是这棵域树的根域(root domain)，此根域下面有2个子域,分别是www.feng.com和file.feng.com。从图中我们可以看出他们的命名空间具有连续性。例如，域www.feng.com的后缀名包含着上一层父域的域名feng.com。其实子域www.feng.com和file.feng.com还都可以有自己的子域，图中没有给出而已。 ​ 域树内的所有域共享一个Active Directory(活动目录)，这个活动目录内的数据分散地存储在各个域内，且每一个域只存储该域内的数据，如该域内的用户账户，计算机账户等，Windows Server将存储在各个域内的对象总称为Active Directory。 ​ 林（Forest）是由一棵或多棵域树组成的，每棵域树独享连续的命名空间，不同域树之间没有命名空间的连续性。林中第一棵域树的根域也整个林的根域，同时也是林的名称。 组织单元（OU）是一种容器，它里面可以包含对象（用户账户，计算机账户等），也可以包含其他的组织单元（OU）。 3. 域控制器和站点活动目录的物理结构由域控制器和站点组成。 ​ 域控制器（Domain Controller）是活动目录的存储地方，也就是说活动目录存储在域控制器内。安装了活动目录的计算机就称为域控制器，其实在你第一次安装活动目录的时候，你安装活动目录的那台计算机就成为了域控制器。一个域可以有一台或多台域控制器。最经典的做法是做一个主辅域控。呵呵，这些概念听起来有些咬嘴。 域是逻辑组织形式，它能够对网络中的资源进行统一管理，就像工作组环境对网络进行分散管理一样，要想实现域，必须在一台计算机上安装活动目录才能实现，而安装了活动目录的计算机就称为域控制器（DC）。 当一台域控制器的活动目录数据库发生改动时，这些改动的数据将会复制到其他域控制器的活动目录数据库内。 站点（Site）一般与地理位置相对应。它由一个或几个物理子网组成。创建站点的目的是为了优化DC之间的复制。活动目录允许一个站点可以有多个域，一个域也是可以属于多个站点。 活动目录的优势 Active Directory服务提供了单一登入的能力和一个所有基础设施相关信息的集中储存机制，大幅度的简化了使用者和计算机的管理，同时提供优越的网络资源存取能力。 微软在Windows Server 2000中首次引入了AD技术，经过几年的发展，AD技术已经成为了微软网络架构的核心，几乎所有的产品和技术都是围绕这AD这个核心运转的。可以这么说，在网络中不实现AD，就无法基于微软产品和技术实现基本的网络管理，也无法适应将来的技术发展! 那么到底安装活动目录有什么意义呢?这是所有初学Windows Server的人首要要问的一个问题。因为活动目录并不是Windows系统必需安装的一种服务，要全面理解它又是非常的不容易，那么安装活动目录的意义在哪里呢?它主要体现在以下几个方面： 1、信息的安全性大大增强 2、引入基于策略的管理，使系统的管理更加明朗 3、具有很强的可扩展性 4、具有很强的可伸缩性 5、智能的信息复制能力 6、与 DNS 集成紧密 7、与其他目录服务具有互连性 8、具有灵活的查询 本篇到此结束。]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-02 工作组和域]]></title>
    <url>%2Fwindows-02%2F</url>
    <content type="text"><![CDATA[windows-运维-02 工作组和域什么是工作组？ 工作组（Work Group）是局域网中的一个概念。它是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。 在一个网络内，可能有成百上千台电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。为了解决这一问题，早在Windows 9x/NT/2008就引用了“工作组”这个概念，将不同的电脑一般按功能分别列入不同的组中，如财务部的电脑都列入“财务部”工作组中，人事部的电脑都列入“人事部”工作组中。你要访问某个部门的资源，就在“网上邻居”里找到那个部门的工作组名，双击就可以看到那个部门的电脑了。 那么怎么加入工作组呢？其实很简单，你只需要右击你的Windows桌面上的“网上邻居”，在弹出的菜单出选择“属性”，点击“标识”，在“计算机名”一栏中添入你想好的名字，在“工作组”一栏中添入你想加入的工作组名称。 如果你输入的工作组名称以前没有，那么相当于新建一个工作组，当然只有你的电脑在里面。计算机名和工作组的长度不能超过15个英文字符，可以输入汉字，但是不能超过7个。“计算机说明”是附加信息，不填也可以，但是最好填上一些这台电脑主人的信息，如“技术部主管”等。单击[确定]按钮后，Windows 提示需要重新启动，按要求重新启动之后，再进入“网上邻居”，就可以看到你所在工作组的成员了。 一般来说，同一个工作组内部成员相互交换信息的频率最高，所以你一进入“网上邻居”，首先看到的是你所在工作组的成员。如果要访问其他工作组的成员，需要双击“整个网络”，就会看到网络上所有的工作组，双击工作组名称，就会看到里面的成员。 你也可以退出某个工作组，只要将工作组名称改动即可。不过这样在网上别人照样可以访问你的共享资源，只不过换了一个工作组而已。你可以随便加入同一网络上的任何工作组，也可以离开一个工作组。“工作组”就像一个自由加入和退出的俱乐部一样，它本身的作用仅仅是提供一个“房间”，以方便网上计算机共享资源的浏览。 工作组回忆在说域这个概念之前,我们先来回忆一下工作组. 每一台计算机都独立维护自己的资源,不能集中管理所有网络资源. 每一台计算机都在本地存储用户的帐户 一个账户只能登陆到一台计算机 工作组中计算机都是平等的,对于其他计算机来说即是服务器,也是客户机. 工作组的网络规模一般少于10台计算机. 案例 行业某个哥们小张(某企业网络管理员),刚开始全单位8台计算机,他用的是工作组管理模式。网络配置很轻松,几乎不用管理.哪台机器有问题 就去哪来机器上解决.工作强度也不是很大。不到3个月时间.随着企业信息化的需要,公司的计算机台数增加到了50台.小张采用同样的管理方式。每天都很忙碌,从早上到公司到晚上离开,一直在解决网络中用户的计算机故障问题,病毒\IE首页篡改\甚至出现了公司内部恶意攻击的事件,经常晚上加班,通宵达旦的工作.但问题总是解决不了。一个月后,他被辞退了。为什么会这样呢?有没有更简单方便的管理方式呢? 下面我们来看这么个例子: 如果我们把工作组看成是原始社会,各服务器(人)各自为政，再想想刚刚的例子,小张公司的8台电脑最开始都是各自为政的，所以就不存在管理的概念，小张只能充当一个哪里出问题就去哪解决的故障排除机器般的被动角色。那么在网络日益应用广泛，结构越来越复杂的今天,我们可不可以，让我们的计算机网络世界也进化一下呢？比如在计算机中通过网络成立一个国家,在公司的一定范围内实现集中管理,中央集权！一个国家可以管理的范围只在一个国家内，想做更复杂范围更广阔的管理,需要什么样的体制呢？ 感谢地球,因为我们有联合国、欧盟。实现多个基本管理范围(国家，域)的联合管理，减少这些基本管理范围内的重复管理工作，方便相互之间资源调用。 那么我们继续刚刚的例子，来看看活动目录域的定义 首先谁能加入联合国(活动目录中能放哪些对象) ；其次共同遵守的设定和规则(通用性设定) ；第三不干涉别国内政(各域数据原则上由该数据所在的域进行管理) 。我们何以把活动目录当作一个联合国,其中包括了所有的成员国信息，大家遵守统一的规则,每个成员国各自管理自己的国家。 那么每个成员国以及每个国家中的人(域和域中的计算机)如何去其他国家呢？走什么样的路线呢？国家与国家之间又怎样联系彼此呢？ DNS这个具有全球定位系统服务的管理机构,也就是我们的联合国管理委员会,帮助我们解决了这个问题，准确的定位各个国家的位置，并为各个国民提供了方便的查询服务。 我们想要去某个国家,想在某个国家内享受一个国民的基本权利,比如取得这个国家提供的最低生活保证金(访问域中的网络资源：如共享文件、打印)，就连想要加入某个国家国籍(加入域)都必须通过DNS这个机构为我们指引。 结构关系：域林和树，可以看成联合国和成员国(国家内的省，省内的县市，县市内的村子) 这种管理结构关系 称呼名词。而子域这个名称是相对的，可以看作一个相对某个成员国中的某一个省或者相对某个省的某一个县。 这里有牵扯到一个名词：DC(域控制器，Domain Controller，简写为DC) 。可以把它看成一个国家的首都(也就是一台物理服务器上安装了AD活动目录)。 所有的国民的户籍信息都存储在这里。]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-01 Windows安装以及初始化]]></title>
    <url>%2Fwindows-01%2F</url>
    <content type="text"><![CDATA[windows-运维-01 Windows安装以及初始化概念解析 Windows Server是微软在2003年4月24日推出的Windows 的服务器操作系统，其核心是Microsoft Windows Server System（WSS），每个Windows Server都与其家用（工作站）版对应（2003 R2除外）。 （1）Windows7的服务器版是Windows server 2008 r2 （2）Windows xp的服务器版是Windows server 2003 （3）Windows xp sp的服务器版是Windows server 2003 r2 (稳定性提高，功能拓展) （4）Windows10的服务器版是Windows server 2012 r2 Windows Server 2012（开发代号：Windows Server 8）是微软的一个服务器系统。 这是Windows 8的服务器版本，并且是Windows Server 2008 R2的继任者。该操作系统已经在2012年8月1日 完成编译RTM版，并且在2012年9月4日正式发售。 Windows Server 2012 号称是一款“云操作系统”，它从管理硬件和应用程序扩展到管理服务和技术，让最 终用户、开发人员和IT人员都能享受到云计算的优势。Windows Server 2012 提供了超过300项的新功能， 并包含新一代的Hyper-V 3.0虚拟化技术，同时也是微软首款支持云环境的Server操作系统。Windows Server 2012有句宣传语是“建立在云上”， 是为云而生的 Cloud OS，因此不难理解着奥操作系 统的意图。那么，什么是云技术呢？简而言之，就是利用远程网络服务器（而不是本地服务器）网络来存 储、管理和处理数据。 从运算层、储存层到网络层都可与云端嫁接，Windows Server 2012 完全为云端运算的资源集中、灵活 度、自助服务和使用调配等特性而设计，并可支持各种云端服务，并能够直接连接 Windows Azure 公有云 作业环境，让企业的云端架设方案更有弹性。Windows Server 2012 R2版本将这些技术扩展到企业，并以同样的方式应用于这些企业的员工。所有企业 数据都可现场或远程通过虚拟机或个人工作站直接备份到云中。在当下和未来，云技术都是世界商业发展 的驱动力。 Windows Server 2012 R2新增的功能 · 用户界面的重大变化 · 新增的Action Directory功能，增强了部署和可管理性 · 添加了Hyper-V的新技术 · 对Windows组网技术的增强，使之更快速、更安全 · 新增的管理工具 · IIS 8.0 的重要特性 Windows Server安装在“msdn，我告诉你”网站上可以下载实验所需的Windows Server 2012 R2，网址： https://msdn.itellyou.cn/ 如图，下载cn_windows_server_2012_r2_x64_dvd_2707961版本的即可。 接下来安装虚拟机，安装过程很简单，下面几个选项注意一下即可： 1.选Windows server 2012 2.安装一个名称为WinNew的虚拟机，位置自选，但是路径中不要有中文目录。 3.选择BIOS 4.用我们刚刚下载下来的那个cn_windows_server_2012_r2_x64_dvd_2707961镜像 5.内存和CPU可以稍微给大点，给物理机的一般内核、内存就好。开启此虚拟机，即可开始安装。 6.这里要输入密钥，还只能手动输入，只能慢慢敲了： 1NB4WH-BBBYV-3MPPC-9RCMV-46XCB 7.选择带有GUI的服务器的那个 8.选自定义 9.然后点下一步即可开始安装了，安装好后好设置用户名密码，登录即可使用Windows Server了。如下图，作为一台服务器，显然不适合设置太过简单的密码。最好包括数字大小写字母加符号就很好。 10.关机保存快照，以后玩坏了还可以恢复快照，不用重装。 11.关于虚拟机屏幕解锁，如下图，是需要按Ctrl+Alt+Delete的，然而一旦按了连咱们的物理机都会受到牵连。然后就会看到如下图的提示： 原来，如果不想让物理机也受到牵连的话，可以用Ctrl+Alt+Insert来解锁。 Windows Server安装后的初始化1.桌面右键，调整屏幕分辨率 调整为1680X1050比较合适，当然，主要看个人喜好。 2.关闭windows防火墙进入控制面板，进入防火墙功能，关闭防火墙 3.开启远程桌面 5.查看windows server的ip用win+r输入cmd，然后用ipconfig命令查看windows server的ip：192.168.141.74 6.物理机远程连接到服务器 任何服务器的日常管理都极少在服务器本身上进行，相反，管理员通常都是远程连接到服务器对服务 器进行日常管理。 远程桌面协议（RDP, Remote Desktop Protocol）是一个多通道（multi-channel）的协议，让用户 （客户端或称“本地电脑”）连上提供微软终端机服务的电脑（服务器端或称“远程电脑”）。大部 分的Windows都有客户端所需软件。其他操作系统也有这些客户端软件，例如 Linux、FreeBSD、Mac OS X。服务端电脑方面，则听取送到TCP3389端口的数据。 3389 UDP 网络环境差针对UDP的优化，默认用tcp传输，网络环境差，改为使用udp协议。Remote Desktop for Administration 是远程桌面服务（Remote Desktop Service，RDS）在 Windows Server 2012 R2服务器上的默认实现。在这种模式中，同时最多只有两名管理员可以远程登录服务器进行远程管理。 命令：mstsc（Microsoft terminal services client） win+r，然后输入mstsc回车如下图： 输入windows server的ip，用户名Administrator，如下图： 然后输入windows server的登录密码即可连接成功 我们关掉这次远程连接，再来一次，将它另存为一个文件，就叫WinNew吧！ 以后我们想要远程连接虚拟机WinNew，可以直接双击这个rdp文件即可，很方便。 设置固定ip 检测网络连通性 关闭IESec安全组件 为方便实用IE浏览器，建议关闭IESec组件（生产环境中不建议这么做，生产环境比如你在腾讯云买了一台服务器，服务器装的是这个系统，或者你工作时公司的服务器，关了就不安全了） 开启隐藏文件可见和显示文件后缀名为安全和方便实用开启这两项功能 修改计算机名称就修改为WinNew吧，计算机描述也修改为WinNew。 另外，远程桌面靠复制粘贴共享文件，你的物理机里的文件复制下来，可以粘贴到虚拟机里面。但是直接用鼠标拖拽拖不进去。 好了，基本设置都已经完成了，关机保存快照。 本篇到此结束。]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-32 Zabbix部署]]></title>
    <url>%2Flinux-32%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-32 Zabbix部署概念解析 zabbix是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。zabbix由2部分构成，zabbix server与可选组件zabbix agent。zabbix server可以通过SNMP，zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux，Solaris，HP-UX，AIX，Free BSD，Open BSD，OS X等平台上。 其他开源监控软件：zabbix、cacti、nagios被称为三大监控软件，俗称监控三剑客但它们都是英文界面，而owl是国产监控软件，有时间的话这些监控软件都应该去了解一下。 另外，想从事系统运维方面工作的，可以多在开源中国社区学一下zabbix的使用，以及如何处理各种问题等，下面就先了解一下zabbix最基础的部分吧！ 环境部署安装lanmp或者lnmp框架 为运行zabbix提供环境，此处以安装lamp为例 1[root@localhost ~]# yum install mariadb mariadb-server httpd php php-mysql -y 初始化mariadb数据库服务 123456789101112[root@localhost ~]# setenforce 0[root@localhost ~]# systemctl restart httpd[root@localhost ~]# systemctl enable httpd[root@localhost ~]# systemctl restart mariadb[root@localhost ~]# systemctl enable mariadbCreated symlink from /etc/systemd/system/multi-user.target.wants/mariadb.service to /usr/lib/systemd/system/mariadb.service.[root@localhost ~]# firewall-cmd --add-port=3306/tcp --permanent success[root@localhost ~]# firewall-cmd --add-port=80/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --reloadsuccess 初始化数据库 设置root管理员在数据库中的密码值（注意，该密码并非root管理员在系统中的密码，这里的密码值默认应该为空，可直接按回车键）。 设置root管理员在数据库中的专有密码。 随后删除匿名账户，并使用root管理员从远程登录数据库，以确保数据库上运行的业务的安全性。 删除默认的测试数据库，取消测试数据库的一系列访问权限。 刷新授权列表，让初始化的设定立即生效。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263[root@localhost ~]# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&apos;ll need the currentpassword for the root user. If you&apos;ve just installed MariaDB, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] yNew password: Re-enter new password: Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from &apos;localhost&apos;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] y ... Success!By default, MariaDB comes with a database named &apos;test&apos; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you&apos;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB![root@localhost ~]# 安装zabbix导入zabbix源1[root@localhost ~]# rpm -ivh http://repo.zabbix.com/zabbix/3.2/rhel/7/x86_64/zabbix-release-3.2-1.el7.noarch.rpm 安装zabbix包1[root@localhost ~]# yum -y install zabbix-server-mysql zabbix-web-mysql 配置数据库12345678910111213141516171819[root@localhost ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 10Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; create database zabbix character set utf8 collate utf8_bin;Query OK, 1 row affected (0.00 sec)MariaDB [(none)]&gt; grant all privileges on zabbix.* to zabbix@localhost identified by &apos;zabbix&apos;;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; quitBye[root@localhost ~]# 导入数据12345[root@localhost ~]# cd /usr/share/doc/zabbix-server-mysql-3.2.11/[root@localhost zabbix-server-mysql-3.2.11]# zcat create.sql.gz | mysql -uroot -p zabbixEnter password: [root@localhost zabbix-server-mysql-3.2.11]# cd[root@localhost ~]# 修改zabbix配置文件12345[root@localhost ~]# vim /etc/zabbix/zabbix_server.conf 81 DBHost=localhost91 DBName=zabbix107 DBUser=zabbix115 DBPassword=zabbix 编辑zabbix前端的PHP配合配置12[root@localhost ~]# vim /etc/httpd/conf.d/zabbix.conf19 php_value date.timezone Asia/Shanghai 调整时间同步安装 ntpdate，使用ntpdate同步时间 12[root@localhost ~]# yum install ntpdate -y[root@localhost ~]# ntpdate cn.pool.ntp.org 启动zabbix和apache服务1234[root@localhost ~]# systemctl restart zabbix-server[root@localhost ~]# systemctl enable zabbix-server[root@localhost ~]# systemctl restart httpd[root@localhost ~]# systemctl enable httpd 登录zabbix先查到自己zabbix服务器也就是你的虚拟机的ip 浏览器打开： 1234http://IP/zabbix/http://IP/zabbix/setup.php默认用户名/密码：Admin/zabbix 安装过程 这里连接数据库要填密码，填咱们之前设好的“zabbix”即可。 然后随便想一个主机名 默认用户名/密码：Admin/zabbix 登录上去后是这个样子的 将语言设置为中文 监控zabbix服务器自己本身监控zabbix服务器自己本身默认是停用的，我们可以点击“停用的”那里对它进行启用 启用之后，可以看到“可用性”那里全是灰色的，可用性指的是使用什么插件或者协议去监控，这里说明这些协议都未生效 为了让其中的ZBX生效，我们需要安装并且重启zabbix-agent 12[root@localhost ~]# yum install zabbix-agent -y[root@localhost ~]# systemctl restart zabbix-agent 安装好之后，查看主机状态是否已启用，可用性是否亮绿灯，网上说红灯绿灯都是正常的，我的是红灯说明状态已经正常，但是连接是失败的。 我们把鼠标悬停在红色的ZBX标志那里，可以发现是端口111未被防火墙放行 我们回到zabbix服务器，放行相关端口。另外，zabbix和zabbix-agent的端口分别是10050和10051，顺带也放行了 123456789[root@localhost ~]# firewall-cmd --add-port=111/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --add-port=10050/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --add-port=10051/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# systemctl restart zabbix-agent 放行这些端口之后，回到浏览器，要稍等一会儿，才能看到ZBX标志变成绿色了。这表示已经正常监控了zabbix服务器了 可以切换到图形监控界面，如下图，可以很直观看到zabbix服务器的cpu相关运行参数变化情况 监控Linux主机给Linux客户端安装上代理程序随便开启一台赶紧的centos虚拟机作为客户端，这里我开启的虚拟机ip是192.168.141.53 导入zabbix源1[root@localhost ~]# rpm -ivh http://repo.zabbix.com/zabbix/3.2/rhel/7/x86_64/zabbix-release-3.2-1.el7.noarch.rpm 安装zabbix代理程序下面两个ip填你的zabbix服务器ip即可。 12345[root@localhost ~]# yum -y install zabbix-agent[root@server zabbix-server-mysql-3.2.11]# vim /etc/zabbix/zabbix_agentd.conf 95 Server=192.168.141.12136 ServerActive=192.168.141.12[root@server zabbix-server-mysql-3.2.11]# systemctl restart zabbix-agent.service 回到浏览器，添加对客户机的监控 先选择模板，记住要选择后要添加到“链接的模板”的那个框里面，最后在点击更新 添加主机，填上客户机的ip 添加完成后可以看到 客户端放行相关端口，重启zabbix代理服务 123456789[root@localhost ~]# firewall-cmd --add-port=111/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --add-port=10050/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --add-port=10051/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# systemctl restart zabbix-agent 然后可以看到该客户端的ZBX标志变绿了，说明可用了 可以看到其运行数据，不过本来也没有监控几分钟，所以只能看到这么点儿 监控windows我们的物理机电脑也可以被zabbix服务器所监控，但是需要下载代理组件 可以到zabbix官网：https://www.zabbix.com/自己找 也可以按照下面这个链接下载windows agent https://www.zabbix.com/downloads/3.2.0/zabbix_agents_3.2.0.win.zip 关闭windows防火墙（本次实验完再打开） 解压zabbix_agents_3.2.0.win.zip压缩包 在windows系统中c盘根目录下新建一个目录，将解压后的zabbix_agents_3.2.0.win中bin\win64（看系统具体32位或者64位来选）下的文件和conf下的配置文件，放到新建的zabbix目录下 修改C:\zabbix\zabbix_agentd.win.conf文件（建议用notepad++） 123462 EnableRemoteCommands=171 LogRemoteCommands=184 Server=192.168.141.12136 Hostname=wintest01 windows下按win+x，点击Windows PowerShell(管理员)(A)，然后进行以下操作运行zabbix agent服务 123456789PS C:\WINDOWS\system32&gt; cmdC:\WINDOWS\system32&gt;cd C:\zabbixC:\zabbix&gt;zabbix_agentd.exe -i -c zabbix_agentd.win.confzabbix_agentd.exe [4964]: service [Zabbix Agent] installed successfullyzabbix_agentd.exe [4964]: event source [Zabbix Agent] installed successfullyC:\zabbix&gt;zabbix_agentd.exe -s -c zabbix_agentd.win.confzabbix_agentd.exe [6328]: service [Zabbix Agent] started successfully 回到浏览器，创建windows主机群组 创建windows主机，名称叫做wintest01 先用cmd查看你电脑ip，记住要看哪个和zabbix服务器在同一个网段的那个ip 1ipconfig 可以看到我的ip是192.168.141.1 创建完成，单击wintest01主机 给它配置模板 回到主机那里，点击将它停用，然后再点击一次将它启用，可以看到ZBX从灰色变为红色 等40秒就好了，就变绿色了 和之前一样，可以看看监控图形 实验做完了，别忘了以管理员模式打开powershell再卸载掉zabbix 1234567891011PS C:\WINDOWS\system32&gt; cmdMicrosoft Windows [版本 10.0.17763.195](c) 2018 Microsoft Corporation。保留所有权利。C:\WINDOWS\system32&gt;cd C:\zabbixC:\zabbix&gt;zabbix_agentd.exe -d -c zabbix_agentd.win.confzabbix_agentd.exe [17148]: service [Zabbix Agent] uninstalled successfullyzabbix_agentd.exe [17148]: event source [Zabbix Agent] uninstalled successfullyC:\zabbix&gt; 实验做完了，别忘了你自己电脑的防火墙可以开回去了。 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-31 OpenSSL实现CA证书]]></title>
    <url>%2Flinux-31%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-31 OpenSSL实现CA证书OpenSSL实现CA证书什么是CA CA,Catificate Authority,通俗的理解就是一种认证机制。它的作用就是提供证书（也就是服务端证书，由域名，公司信息，序列号，签名信息等等组成）来加强客户端与服务器端访问信息的安全性，同时提供证书的发放等相关工作。国内的大部分互联网公司都在国际CA机构申请了CA证书，并且在用户进行访问的时候，对用户的信息加密，保障了用户的信息安全。理论上来说，任何组织或者个人都可以扮演CA的角色，只不过，难以得到客户端的信任，不能推而广之，最典型应用莫过于12306网站，这个网站就是自己给自己颁发的根证书。 目前能够让浏览器默认支持的CA大厂有很多，Windows 操作系统在安装之初，也默认安装了很多受信任的根证书。可以通过控制面板–Internet选项来进行查看。 另外，可以将证书理解为带有额外信息的公钥。 SSL/TLS SSL/TLS是网络通信过程中非常重要的两个协议。互联网的通信安全就建立在SSL/TLS协议基础之上。他们通过一系列的加密行为保障了通信的安全，是如今互联网通信最主要的应用之一。 SSL/TLS是一个很大的互联网应用，关于他们的介绍互联网上有很多，我们暂时不做详细的介绍。关于SSL/TLS通信的过程大致可以用下面的这张图来进行描述。 十六字真诀公钥加密，私钥解密私钥签章，公钥验签 实验准备CA服务器：192.168.141.132 客户机：192.168.141.69 物理机（就是你的电脑） OpenSSL OpenSSL是一套开源软件，在Linux中可以很容易的安装。它能够很容易的完成密钥生成以及证书管理。我们接下来就利用OpenSSL搭建CA证书，并实现证书的申请与分发。 1[root@localhost ~]# yum install openssl –y CA配置 要手动创建CA证书，就必须首先了解，OpenSSL中关于CA的配置，配置文件位于下面的/etc/pki/tls/openssl.cnf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[root@localhost ~]# cat /etc/pki/tls/openssl.cnf####################################################################[ ca ]default_ca= CA_default #默认CA####################################################################[ CA_default ]dir=/etc/pki/CA # CA的工作目录这里其实是定义了一个变量certs= $dir/certs # 证书存储路径crl_dir= $dir/crl # 证书吊销列表database= $dir/index.txt # 证书数据库列表new_certs_dir= $dir/newcerts #新的证书路径certificate = $dir/cacert.pem # CA自己的证书serial= $dir/serial #下一个证书的编号，十六进制，默认00crlnumber= $dir/crlnumber #下一个要被吊销的证书编号，十六进制，默认00crl = $dir/crl.pem # The current CRLprivate_key = $dir/private/cakey.pem # CA 的私钥RANDFILE= $dir/private/.rand # private random number filex509_extensions = usr_cert # The extentions to add to the cert# Comment out the following two lines for the &quot;traditional&quot;# (and highly broken) format.name_opt = ca_default # 命名方式cert_opt = ca_default # CA的选项default_days= 365 # 默认证书的有效期限default_crl_days= 30 # how long before next CRLdefault_md= default # use public key default MDpreserve= no # keep passed DN orderingpolicy= policy_match #策略 #这里记录的是 将来CA在搭建的时候，以及客户端申请证书的时候， 需要提交的信息的匹配程度。[ policy_match ] # match意味着CA以及子CA必须一致countryName = match # 国家stateOrProvinceName= match # 州或者省organizationName= match #组织公司organizationalUnitName = optionalcommonName= suppliedemailAddress= optional[ policy_anything ] #可以对外提供证书申请，这时，证书的匹配就可以不用那么严格countryName = optionalstateOrProvinceName = optionallocalityName= optionalorganizationName= optionalorganizationalUnitName = optionalcommonName = suppliedemailAddress= optional 找到配置文件中指定的路径 12[root@localhost ~]# cat /etc/pki/tls/openssl.cnf | grep dirdir = /etc/pki/CA # Where everything is kept 可以看到路径 /etc/pki/CA 创建所需要的文件 这里有一点需要注意，我们的实验环境中包含了一个主机，如果不提前创建这两个文件，那么在生成证书的过程中会出现错误。 我们将文件创建在配置文件中指定的路径下面。 12345生成证书索引数据库文件 [root@localhost ~]# touch /etc/pki/CA/index.txt指定第一个颁发证书的序列号 [root@localhost ~]# echo 01 &gt; /etc/pki/CA/serial CA 自签名证书(构造根CA)首先构造根CA的证书。因为没有任何机构能够给根CA颁发证书，所以只能根CA自己给自己颁发证书。 首先生成私钥文件cakey.pem1234567[root@localhost ~]# openssl genrsa -out /etc/pki/CA/private/cakey.pem -des3 2048Generating RSA private key, 2048 bit long modulus...............+++.......................................+++e is 65537 (0x10001)Enter pass phrase for /etc/pki/CA/private/cakey.pem: #这里需要输入密码（ pass phrase ）Verifying - Enter pass phrase for /etc/pki/CA/private/cakey.pem: #这里确认密码 更具私钥文件cakey.pem生成自签名证书cacert.pem1234567891011121314151617[root@localhost ~]# openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -days 7300 -out /etc/pki/CA/cacert.pemEnter pass phrase for /etc/pki/CA/private/cakey.pem:You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [XX]:CN #中国State or Province Name (full name) []:js #江苏Locality Name (eg, city) [Default City]:zj #镇江Organization Name (eg, company) [Default Company Ltd]:fengOrganizational Unit Name (eg, section) []:caCommon Name (eg, your name or your server&apos;s hostname) []:ca.feng.comEmail Address []:admin@feng.com[root@localhost ~]# 查看生成的证书cacert.pem1234[root@localhost ~]# cd /etc/pki/CA/[root@localhost CA]# lscacert.pem certs crl index.txt newcerts private serial[root@localhost CA]# cat cacert.pem 关闭selinux123[root@localhost CA]# cd[root@localhost ~]# setenforce 0[root@localhost ~]# 颁发证书（客户端申请证书）为客户端颁发ssl证书 客户端首先产生一个私钥以及证书请求的公钥 客户端将公钥发给CA服务器 CA服务器为客户端颁发数字签名再传回客户机 我们再开一台虚拟机作为客户端，由于它不是CA服务器，所以就不在/etc/pki/CA/目录下生成私钥和证书等文件了，咱们另外建一个目录来搞。 客户端首先在/root/key/目录下生成一个私钥https.key1234567[root@localhost ~]# yum install openssl -y #客户端也要装ssl套件[root@localhost ~]# mkdir key[root@localhost ~]# openssl genrsa -out /root/key/https.key 2048Generating RSA private key, 2048 bit long modulus............................+++.................+++e is 65537 (0x10001) 客户端再用私钥https.key生成证书请求https.csr123456789101112131415161718192021[root@localhost ~]# openssl req -new -key /root/key/https.key -out /root/key/https.csr -days 365You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [XX]:CNState or Province Name (full name) []:jsLocality Name (eg, city) [Default City]:zjOrganization Name (eg, company) [Default Company Ltd]:fengOrganizational Unit Name (eg, section) []:techCommon Name (eg, your name or your server&apos;s hostname) []:192.168.141.69Email Address []:admin@feng.comPlease enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []:123456An optional company name []:feng[root@localhost ~]# 客户端将证书请求文件https.csr传到CA服务器的/etc/pki/CA目录下123456789101112[root@localhost ~]# cd key[root@localhost key]# lshttps.csr https.key[root@localhost key]# scp https.csr 192.168.141.132:/etc/pki/CAThe authenticity of host &apos;192.168.141.132 (192.168.141.132)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:mJVa6J0b/NaWyJ+cbVho0hHnUDY9utS7iWUGq91HvpM.ECDSA key fingerprint is MD5:d3:6c:dc:1c:76:df:3a:d1:b9:ef:6c:17:82:64:76:6e.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.141.132&apos; (ECDSA) to the list of known hosts.root@192.168.141.132&apos;s password: https.csr 100% 1090 699.6KB/s 00:00 [root@localhost key]# CA根据客户机发过来的证书请求https.csr生产数字签名https.crt123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@localhost ~]# cd /etc/pki/CA[root@localhost CA]# openssl ca -in https.csr -out https.crt -days 365Using configuration from /etc/pki/tls/openssl.cnfEnter pass phrase for /etc/pki/CA/private/cakey.pem:Check that the request matches the signatureSignature okCertificate Details: Serial Number: 1 (0x1) Validity Not Before: Feb 17 08:07:23 2019 GMT Not After : Feb 17 08:07:23 2020 GMT Subject: countryName = CN stateOrProvinceName = js organizationName = feng organizationalUnitName = tech commonName = 192.168.141.69 emailAddress = admin@feng.com X509v3 extensions: X509v3 Basic Constraints: CA:FALSE Netscape Comment: OpenSSL Generated Certificate X509v3 Subject Key Identifier: 5C:83:77:55:09:E6:6F:BF:5A:0E:7A:D4:45:64:8B:28:81:0A:70:6B X509v3 Authority Key Identifier: keyid:A0:D2:8C:72:63:CE:16:D6:EE:DF:B6:5F:85:C1:57:06:D1:A2:CA:98Certificate is to be certified until Feb 17 08:07:23 2020 GMT (365 days)Sign the certificate? [y/n]:y1 out of 1 certificate requests certified, commit? [y/n]yWrite out database with 1 new entriesData Base Updated[root@localhost CA]# lscacert.pem crl https.csr index.txt.attr newcerts serialcerts https.crt index.txt index.txt.old private serial.old[root@localhost CA]# CA自己的私钥文件cakey.pemCA的自签名证书cacert.pem客户机发过来的证书请求https.csrCA根据https.csr产生数字签名https.crt CA将生产好的数字签名再传回客户机123456789[root@localhost CA]# scp https.crt 192.168.141.69:/root/keyThe authenticity of host &apos;192.168.141.69 (192.168.141.69)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:GxQcqZQLnGUvawOktRB9hLYZZA0ScnEsN3USeyTghgU.ECDSA key fingerprint is MD5:d6:d5:c1:df:2b:47:22:55:4d:1a:a3:f2:63:50:d9:b7.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.141.69&apos; (ECDSA) to the list of known hosts.root@192.168.141.69&apos;s password: https.crt 100% 4551 2.7MB/s 00:00 [root@localhost CA]# 切换到客户机，看一下的确传过来了123[root@localhost key]# lshttps.crt https.csr https.key[root@localhost key]# ​ 接下来客户机将自己的密钥https.key传给CA，由CA生成证书cacert.pem传回给客户机。为了不冲突，在CA服务器上新建一个目录/root/test 12[root@localhost ~]# mkdir test[root@localhost ~]# 客户机将自己的密钥https.key传给CA1234[root@localhost key]# scp https.key 192.168.141.132:/root/testroot@192.168.141.132&apos;s password: https.key 100% 1675 447.2KB/s 00:00 [root@localhost key]# 由CA生成证书cacert.pem12345678910111213141516[root@localhost ~]# openssl req -new -x509 -key /root/test/https.key -days 7300 -out /root/test/cacert.pemYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [XX]:CNState or Province Name (full name) []:jsLocality Name (eg, city) [Default City]:zjOrganization Name (eg, company) [Default Company Ltd]:fengOrganizational Unit Name (eg, section) []:techCommon Name (eg, your name or your server&apos;s hostname) []:192.168.141.69Email Address []:admin@feng.com[root@localhost ~]# CA服务器将证书传给客户机1234567[root@localhost ~]# cd test/[root@localhost test]# lscacert.pem https.key[root@localhost test]# scp cacert.pem 192.168.141.69:/etc/pki/CAroot@192.168.141.69&apos;s password: cacert.pem 100% 1375 1.0MB/s 00:00 [root@localhost test]# 切换到客户机，看一下的确传过来了1234[root@localhost key]# cd /etc/pki/CA[root@localhost CA]# lscacert.pem certs crl newcerts private[root@localhost CA]# 客户机使用https保护网站 原理：比如人们访问网站http://test.feng.com，这个网站又搭建在客户机192.168.141.69上，那么客户机就需要向CA服务器申请到数字签名，这样安装了相应证书的电脑就可以访问https://test.feng.com了。刚刚我们的客户机已经成功申请到了数字签名，现在咱们在客户机上搭网站，只有一个默认网页“Testing……”，用来看证书使用效果即可。 安装apache和mod_ssl模块 12[root@localhost key]# cd[root@localhost ~]# yum install httpd mod_ssl -y 修改配置文件12345[root@localhost ~]# vim /etc/httpd/conf.d/ssl.conf100 SSLCertificateFile /root/key/https.crt107 SSLCertificateKeyFile /root/key/https.key122 SSLCACertificateFile /etc/pki/CA/cacert.pem 放行443端口和https服务，关闭selinux，重启apache服务1234567[root@localhost ~]# firewall-cmd --add-port=&#123;443,80&#125;/tcp --permanent success[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# setenforce 0[root@localhost ~]# [root@localhost ~]# systemctl restart httpd 这里重启apache服务要放到最后，否则会报错。 windows导入根CA证书 将根linux的证书（就是CA服务器生成的自签名证书，ca.feng.com的那个cacert.pem）导出到windows上，然后将后缀名改为.crt，打开后点击安装证书 1234[root@localhost ~]# yum install lrzsz -y[root@localhost ~]# sz /etc/pki/CA/cacert.pem[root@localhost ~]# 导出到自己电脑，如下图，改其后缀为crt，双击它开始安装证书。 如上图，打开这个CA的自签名证书后就可以看到，颁发者和颁发给都是ca.feng.com，且不受信任，证书信息的标志那里都是一个大大的红色叉叉，我们需要手动安装这个证书，安装到本地计算机后，就受信任了，表示本地计算机信任了这个证书机构给它自己办法的证书。 选择本地计算机，然后点击下一步 安装证书，最后下一步点完成 查看证书 win+r，输入certmgr.msc点击确定即可 我们安装的证书是CA的自签名证书，名字叫做ca.feng.com，安装好之后，我们的电脑会对这个CA机构产生充分的信任，且对于这个CA机构颁发给任何网站的证书都会信任。之前我们的客户机：192.168.141.69搭建了apache服务，也算是有了一个网站了，虽然其网站主页还是下面这个“Testing 123”的页面，但是这个不妨碍我们的浏览器对其网站证书进行安全分析。 如下图，我们打开https://192.168.141.69，会看到它的证书来自于ca.feng.com。之前我们的客户机192.168.141.69向CA服务器申请到的证书，现在就发挥了它的作用了，让我们的浏览器得以信任这个网站的证书，同时，由于mod_ssl模块是支持”https“中的“s”的，所以也能用https打开这个网址。 访问网站 吊销证书吊销证书是CA机构做的事，我们不用去做，这里只做方法演示。吊销不会立即生效，要等网站重启。 在根CA上根据客户提交的serial与subject信息，对比检验是否与index.txt文件中的信息一致，然后吊销证书 # 吊销子客户端的证书 使用revoke 命令 123456[root@localhost CA]# openssl ca -revoke /etc/pki/CA/https.crtUsing configuration from /etc/pki/tls/openssl.cnfEnter pass phrase for /etc/pki/CA/private/cakey.pem:Revoking Certificate 01.Data Base Updated[root@localhost CA]# 指定第一个吊销证书的编号（指定吊销证书的编号，只有在更新证书吊销列表之前，才需要操作） 123456# 这条命令与生成证书时指定证书serial 号码的作用是一致的。# 就是说，指定下一个证书吊销时的编号。[root@localhost CA]# echo 01 &gt; /etc/pki/CA/crlnumber[root@localhost CA]# cat /etc/pki/CA/crlnumber01[root@localhost CA]# 更新证书吊销列表前面指定了证书吊销列表编号之后，就可以来更新证书吊销列表了。 1234[root@localhost CA]# openssl ca -gencrl -out /etc/pki/CA/crl/crl.pemUsing configuration from /etc/pki/tls/openssl.cnfEnter pass phrase for /etc/pki/CA/private/cakey.pem: #这里提示输入密码[root@localhost CA]# 查看证书吊销列表的文件 123456789101112131415161718192021222324252627282930[root@localhost CA]# openssl crl -in /etc/pki/CA/crl/crl.pem -noout -text Certificate Revocation List (CRL): Version 2 (0x1) Signature Algorithm: sha256WithRSAEncryption Issuer: /C=CN/ST=js/L=zj/O=feng/OU=tech/CN=ca.feng.com/emailAddress=admin@feng.com Last Update: Feb 17 08:55:41 2019 GMT Next Update: Mar 19 08:55:41 2019 GMT CRL extensions: X509v3 CRL Number: 1Revoked Certificates: Serial Number: 01 Revocation Date: Feb 17 08:54:31 2019 GMT Signature Algorithm: sha256WithRSAEncryption 2e:c5:24:2e:00:ec:bb:58:b5:6a:87:49:7a:1d:f9:5d:e6:83: bd:af:51:49:63:96:49:7a:c7:74:6d:bd:5f:fb:87:65:35:9d: 62:98:0a:42:56:19:67:9a:9f:1e:27:e1:dc:70:36:e6:32:c6: 02:e8:e8:25:1c:15:2e:ab:82:af:54:f7:80:bb:d2:dc:84:a3: 6f:b2:72:70:95:81:18:55:7e:c7:fc:fd:8b:5b:b2:d6:ab:c3: 64:64:89:38:86:dd:28:53:ea:36:64:05:84:88:62:77:a3:2f: 0e:ae:d6:76:64:de:ea:f6:8b:fa:eb:63:0e:ff:13:16:bc:b1: 62:bf:32:99:50:e5:86:2d:95:b8:e7:15:93:86:78:6f:b3:22: 6a:af:7b:43:9d:61:33:ac:65:c1:26:a4:6f:6d:74:91:69:69: 04:36:ca:7e:d0:42:45:12:07:37:4a:f1:2a:a8:45:01:a5:5b: 43:77:fb:6e:26:fc:16:09:d1:f3:44:2e:d0:e7:96:0a:75:af: 50:c2:b7:41:f5:9f:d2:0f:58:92:75:0b:81:d2:99:5c:5c:79: 6a:a8:59:b9:0e:cd:0a:e9:4f:f2:a4:8d:5a:d5:71:8d:6c:b4: f2:f8:0b:7a:cf:9f:6e:43:b5:de:2a:15:84:0c:40:c0:3f:5a: 75:fb:f5:9c[root@localhost CA]# 吊销不会立即生效，要等网站重启，这里在客户机重启apache服务 1[root@localhost ~]# systemctl restart httpd 查看吊销后的结果 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-30 KVM]]></title>
    <url>%2Flinux-30%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-30 KVMKVM概念解析 Kernel-based Virtual Machine的简称，是一个开源的系统虚拟化模块，自Linux 2.6.20之后集成在Linux的各个主要发行版本中。它使用Linux自身的调度器进行管理，所以相对于Xen，其核心源码很少。KVM目前已成为学术界的主流VMM（ Virtual Machine Monitor,虚拟机监控器）之一。 检测虚拟化功能 如下图，把这个勾勾上，另外，做实验用的Server处理器和内存调大一些，因为接下来咱们要在虚拟机Server里新建虚拟机，也就是所谓的“虚拟机里的虚拟机”。 ​ 加一张桥接模式的网卡 KVM 是基于 x86 虚拟化扩展(Intel VT 或者 AMD-V) 技术的虚拟机软件，所以查看 CPU 是否支持 VT 技术，就可以判断是否支持KVM。有返回结果，如果结果中有vmx（Intel）或svm(AMD)字样，就说明CPU的支持的。 123[root@localhost ~]# cat /proc/cpuinfo | egrep &apos;vmx|svm&apos;请看下图： ​ 关掉防火墙，关闭SELinux，将 /etc/sysconfig/selinux 中的 SELinux=enforcing 修改为 SELinux=disabled，这里注意，改了重启后才生效。 1234567891011121314151617181920[root@localhost ~]# systemctl stop firewalld[root@localhost ~]# systemctl disable firewalldRemoved symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.[root@localhost ~]# [root@localhost ~]# vim /etc/sysconfig/selinuxSELINUX=disabled保存退出[root@localhost ~]# getenforce Enforcing[root@localhost ~]# reboot重启后再次查看：[root@localhost ~]# getenforce Disabled[root@localhost ~]# 说明已经关闭了selinux 安装kvm环境通过 yum 安装 kvm 基础包和管理工具 kvm相关安装包及其作用: qemu-kvm 主要的KVM程序包 python-virtinst 创建虚拟机所需要的命令行工具和程序库 virt-manager GUI虚拟机管理工具 virt-top 虚拟机统计命令 virt-viewer GUI连接程序，连接到已配置好的虚拟机 libvirt C语言工具包，提供libvirt服务 libvirt-client 为虚拟客户机提供的C语言工具包 virt-install 基于libvirt服务的虚拟机创建命令 bridge-utils 创建和管理桥接设备的工具 12345678910111213141516171819安装kvm基础包和管理工具[root@localhost ~]# yum -y install qemu-kvm python-virtinst libvirt libvirt-python virt-manager libguestfs-tools bridge-utils virt-install python-virtualenv 其中有一个安装包python-virtinst特别坑，以前是可以直接用yum安装成功的，但是现在yum软件仓库里已经没有这个包了，即使是用命令：yum install epel-release安装并启用EPEL源后，也依然会提示没有可用包python-virtinst。yum软件仓库里没有，rpm软件仓库里倒是有，但是我尝试了n个版本，不是与这个冲突就是和那个矛盾，能把人气死，最后利用github开源出来的python-virtinst包安装终于成功了，实验才得以继续下去。 另外，如果你的python-virtinst包没有安装成功的话，后面虚拟机里安装虚拟机的时候，会总是报错：Kernel panic - not syncing: Fatal exception in inter，无论怎么也装不好。关机，保存快照，以防后面实验手滑敲错。[root@localhost ~]# poweroff开机，查看KVM模块是否被正确加载[root@localhost ~]# lsmod | grep kvmkvm_intel 174841 0 kvm 578518 1 kvm_intelirqbypass 13503 1 kvm[root@localhost ~]# 如下图，将上述yum命令再次执行，可以发现其他包都装好了，就python-virtinst最坑，我们后面再来安装它。 开启kvm服务，并且设置其开机自动启动 12[root@localhost ~]# systemctl restart libvirtd[root@localhost ~]# systemctl enable libvirtd 安装Linux虚拟机 安装前要设置环境语言为英文LANG=”en_US.UTF-8”，如果是中文的话某些版本可能会报错。CentOS 7 在这里修改 /etc/locale.conf。 12[root@localhost ~]# vim /etc/locale.conf LANG=&quot;en_US.UTF-8&quot; 准备安装目录和系统镜像 123[root@localhost ~]# mkdir /kvm/[root@localhost ~]# mkdir /kvm/vms[root@localhost ~]# mkdir /kvm/iso 下载centos镜像的网站： https://www.centos.org/download/ 下载个Minimal的就行，迷你版比较小，下载起来比较快嘛！我这里用的是1804版本的。 安装上传下载工具lrzsz，然后上传系统镜像到/kvm/iso目录中 12345678[root@localhost ~]# yum install lrzsz -y[root@localhost ~]# cd /kvm/iso/[root@localhost iso]# ls[root@localhost iso]# rz[root@localhost iso]# lsCentOS-7-x86_64-Minimal-1810.iso[root@localhost iso]# 定义一个储存池，绑定目录，建立并激活存储池，后面会用这个存储池创建虚拟机 12345678[root@localhost iso]# virsh pool-define-as vmspool --type dir --target /kvm/vmsPool vmspool defined[root@localhost iso]# virsh pool-build vmspoolPool vmspool built[root@localhost iso]# virsh pool-start vmspoolPool vmspool started 现在来安装python-virtinst 12345678[root@localhost ~]# yum install git -y[root@localhost ~]# git clone https://github.com/palli/python-virtinst.git[root@localhost ~]# lsanaconda-ks.cfg python-virtinst[root@localhost ~]# cd python-virtinst/[root@localhost python-virtinst]# python setup.py install[root@localhost python-virtinst]# cd[root@localhost ~]# 先安装ntp服务，下面虚拟机里安装虚拟机的时候才方便，不用再另外添加ntp服务器。 1yum install ntp -y 接下来关机保存快照，以防下面实验手滑 1[root@localhost ~]# poweroff 安装linux虚拟机，名字就叫centos7_01吧： 1[root@localhost ~]# virt-install --virt-type=kvm --name=centos7_01 --vcpus=2 --ram=512 --location=/kvm/iso/CentOS-7-x86_64-Minimal-1810.iso --disk path=/kvm/vms/centos7_01.qcow2,device=disk,format=qcow2,bus=virtio,cache=writeback,size=100 --network bridge=virbr0 --graphics none --extra-args=&apos;console=ttyS0&apos; --force 命令说明： –name 指定虚拟机的名称 –ram 指定分配给虚拟机的内存资源大小 maxmemory 指定可调节的最大内存资源大小，因为KVM支持热调整虚拟机的资源 –vcpus 指定分配给虚拟机的CPU核心数量 maxvcpus 指定可调节的最大CPU核心数量 –os-type 指定虚拟机安装的操作系统类型 –os-variant 指定系统的发行版本 –location 指定ISO镜像文件所在的路径，支持使用网络资源路径，也就是说可以使用URL –disk path 指定虚拟硬盘所存放的路径及名称，size 则是指定该硬盘的可用大小，单位是G –bridge 指定使用哪一个桥接网卡，也就是说使用桥接的网络模式 –graphics 指定是否开启图形 –console 定义终端的属性，target_type 则是定义终端的类型 –extra-args 定义终端额外的参数 系统配置 带 [!] 基本都是要配置的，按照顺序往下配置，按对用的数字以此进行设置。配置一下时间时区，第三第四第五第六项会自动检测好，接下来配置一下第八项的密码即可。 此处配置截图太多，可参考这个教程里的截图：http://blog.51cto.com/zero01/2083896 详细步骤： 1.首先，一开始我们看到的是： 这里设置语言建议设置成英文的，不然后面玩虚拟机的时候会有乱码。 2.设置语言，按数字1，回车进入以下界面，例如我要选Chinese就按数字68并回车即可，回车之后会让你选择是中文简体还是繁体，也是按下相应的数字并回车即可： 3.配置完成之后又会再次回到配置界面，这次我们来设置时区： 4.设置成亚洲上海的时区即可。 5.设置系统安装盘： 选择标准分区 6.设置root用户的密码： 7.设置完root密码后，可以看到1到9所有选项都没有感叹号了，这表是要求你设置的选项你都设置完毕了，敲b开始安装系统： 8.安装完成之后就会停止在以下这个界面，按一下回车即可，这时就会重启安装完的系统： 重启成功之后就会入到登录界面，可以看到我这里是成功登录的，登录上去，将它改名为centos。 这时我们是处于一个虚拟终端的，因为安装了虚拟机，如果要退出来的话，应该说是切出来，按 Ctrl + ]即可。然后再次登录，如下图： 1234567891011[root@localhost ~]# #这里按Ctrl + ]，然后回车，就退出了虚拟终端[root@localhost ~]# virsh console --domain centos7_01 #再次连接虚拟终端Connected to domain centos7_01Escape character is ^][root@localhost ~]# hostname #在虚拟终端里查看主机名称centos[root@localhost ~]# #这里再次按Ctrl + ]，然后回车，就退出了虚拟终端[root@localhost ~]# hostname #现在查看咱们虚拟机的主机名称localhost.localdomain[root@localhost ~]# 现在关机保存快照（给宿主机保存快照） 1[root@localhost ~]# poweroff 使用以下命令可以列出当前有多少个虚拟机，以及其状态，但是无法列出关机状态的虚拟机： 123456[root@localhost ~]# virsh list Id Name State---------------------------------------------------- 2 centos7_01 running[root@localhost ~]# 需要列出关机状态的虚拟机需要加多一个–all参数 查看所有虚拟机和进入控制台 123456789101112131415[root@localhost ~]# virsh list --all Id Name State---------------------------------------------------- 6 centos7_01 running[root@localhost ~]# virsh console --domain centos7_01Connected to domain centos7_01Escape character is ^]CentOS Linux 7 (Core)Kernel 3.10.0-862.el7.x86_64 on an x86_64localhost login: rootPassword: Last login: Sun Sep 2 10:34:40 on ttyS0[root@localhost ~]# 以下介绍一下管理虚拟机的一些常用命令： 123456789[root@localhost ~]# virsh console centos7_01 # 进入指定的虚拟机，进入的时候还需要按一下回车[root@localhost ~]# virsh start centos7_01 # 启动虚拟机[root@localhost ~]# virsh shutdown centos7_01 # 关闭虚拟机[root@localhost ~]# virsh destroy centos7_01 # 强制停止虚拟机[root@localhost ~]# virsh undefine centos7_01 # 彻底销毁虚拟机，会删除虚拟机配置文件，但不会删除虚拟磁盘[root@localhost ~]# virsh autostart centos7_01 # 设置宿主机开机时该虚拟机也开机[root@localhost ~]# virsh autostart --disable centos7_01 # 解除开机启动[root@localhost ~]# virsh suspend centos7_01 # 挂起虚拟机[root@localhost ~]# virsh resume centos7_01 # 恢复挂起的虚拟机 以下实验很乱，可以不做 配置宿主机网络1.KVM 虚拟机是基于 NAT 的网络配置； 2.只有同一宿主机的虚拟机之间可以互相访问，跨宿主机是不能访问； 3.虚拟机需要和宿主机配置成桥接模式，以便虚拟机可以在局域网内可见； 4.宿主机指的是我们用VMware Workstation Pro安装的虚拟机，它相对于虚拟机里面的虚拟机就是宿主。 5.我们之前virt install 的时候，有个参数是bridge=virbr0，用的桥接网卡已经指定为virbr0了。 Bridge模式配置 Bridge方式即虚拟网桥的网络连接方式，是客户机和子网里面的机器能够互相通信。可以使虚拟机成为网络中具有独立IP的主机。桥接网络（也叫 物理设备共享）被用作把一个物理设备复制到一台虚拟机。网桥多用作高级设置，特别是主机多个网络接口的情况。 1234567[root@localhost ~]# yum install -y net-tools #装了网络工具才能用命令：ifconfig[root@localhost ~]# systemctl restart libvirtd[root@localhost ~]# virsh iface-bridge ens33 br0[root@localhost ~]# ifconfig 修改宿主机物理网卡配置（UUID不用改，它是设备标识号） 123456789101112[root@localhost ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33删掉其他无用的行，保留下列4行，另外加一行BRIDGE=“virbr0&quot;，保存退出即可TYPE=EthernetBOOTPROTO=noneNAME=&quot;ens33&quot;UUID=&quot;005e11a3-2859-4497-adc1-d531ddc2675f&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;BRIDGE=“virbr0&quot;NM_CONTROLLED=&quot;no&quot; 修改宿主机网桥配置(宿主机里面的虚拟机与宿主机是桥接关系，我的ens33网卡之前是192.168.141.72，这里将virbr0改为这个ip之后，ens33网卡就没有ip了，重启网络后Xshell也会断开，接下来在vmware workstation里继续实验) 123456789101112131415161718192021222324[root@localhost ~]# vim /etc/sysconfig/network-scripts/ifcfg-virbr0TYPE=&quot;Bridge&quot;BOOTPROTO=&quot;static&quot;DEFROUTE=&quot;yes&quot;PEERDNS=&quot;yes&quot;PEERROUTES=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_PEERDNS=&quot;yes&quot;IPV6_PEERROUTES=&quot;yes&quot;IPV6_PRIVACY=&quot;no&quot;IPV6_FAILURE_FATAL=&quot;no&quot;UUID=&quot;005e11a3-2859-4497-adc1-d531ddc2675f&quot;STP=&quot;yes&quot;DELAY=&quot;0&quot;NAME=&quot;virbr0&quot;DEVICE=&quot;virbr0&quot;ONBOOT=&quot;yes&quot;IPADDR=&quot;192.168.141.72&quot;PREFIX=&quot;24&quot;GATEWAY=&quot;192.168.141.2&quot; 两个网卡都修改完成后重启网络 123456789101112131415161718192021222324252627[root@localhost ~]# systemctl restart network现在Xshell断开，我们接下来在vmware workstation里继续实验[root@localhost ~]# ifconfig ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 ether 00:0c:29:d3:48:93 txqueuelen 1000 (Ethernet) RX packets 7606 bytes 649199 (633.9 KiB) RX errors 0 dropped 2 overruns 0 frame 0 TX packets 7392 bytes 1114718 (1.0 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0virbr0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.141.72 netmask 255.255.255.0 broadcast 192.168.9.255 ether 00:0c:29:d3:48:93 txqueuelen 1000 (Ethernet) RX packets 2157 bytes 153841 (150.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1109 bytes 146573 (143.1 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0[root@localhost ~]# brctl showbridge name bridge id STP enabled interfacesvirbr0 8000.000c29d34893 yes ens33 virbr0-nic vnet1 可以看到ens33网卡已经没有ip了，也可以看到virbr0的接口变成ens33了 进入虚拟机centos7_01测试（如果它关机了的话，virsh start centos7_01 # 启动虚拟机） 1234567891011121314[root@localhost ~]# virsh console centos7_01Connected to domain centos7_01Escape character is ^]CentOS Linux 7 (Core)Kernel 3.10.0-862.el7.x86_64 on an x86_64localhost login: rootPassword: Last login: Sun Sep 2 10:35:29 on ttyS0[root@localhost ~]# ping 192.168.141.72PING 192.168.141.72 (192.168.141.72) 56(84) bytes of data.64 bytes from 192.168.141.72: icmp_seq=1 ttl=64 time=0.310 ms64 bytes from 192.168.141.72: icmp_seq=2 ttl=64 time=0.231 ms 如果之前装系统选的是中文简体，这里改回英文，重启虚拟机，注意宿主机不用重启。 12[root@localhost ~]# vim /etc/locale.conf LANG=&quot;en_US.UTF-8&quot; 配置宿主机网络-NAT模式 NAT(Network Address Translation网络地址翻译)，NAT方式是kvm安装后的默认方式。它支持主机与虚拟机的互访，同时也支持虚拟机访问互联网，但不支持外界访问虚拟机。 其中virbr0是由宿主机虚拟机支持模块安装时产生的虚拟网络接口，也是一个switch和bridge，负责把内容分发到各虚拟机。几个虚拟机管理模块产生的接口关系如下图: 从图上可以看出，虚拟接口和物理接口之间没有连接关系，所以虚拟机只能在通过虚拟的网络访问外部世界，无法从网络上定位和访问虚拟主机。 virbr0是一个桥接器，接收所有到网络192.168.122.*的内容。从下面命令可以验证： 123456789101112[root@localhost ~] brctl show# 输出结果# ---------------------# bridge name bridge id STP enabled interfaces# br0 8000.3863bb44cf6c no eno1# vnet0# virbr0 8000.525400193f0f yes virbr0-nicip route# default via 192.168.188.1 dev br0# 169.254.0.0/16 dev br0 scope link metric 1012# 192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1# 192.168.188.0/24 dev br0 proto kernel scope link src 192.168.188.132 同时，虚拟机支持模块会自动修改iptables规则，通过命令可以查看： 12[root@localhost ~] iptables -t nat -L -nv[root@localhost ~] iptables -t filter -L -nv 创建名为management的NAT网络，vi /usr/share/libvirt/networks/management.xml 12345678910&lt;network&gt; &lt;name&gt;management&lt;/name&gt; &lt;bridge name=&quot;virbr1&quot;/&gt; &lt;forward/&gt; &lt;ip address=&quot;192.168.123.1&quot; netmask=&quot;255.255.255.0&quot;&gt; &lt;dhcp&gt; &lt;range start=&quot;192.168.123.2&quot; end=&quot;192.168.123.254&quot;/&gt; &lt;/dhcp&gt; &lt;/ip&gt;&lt;/network&gt; 启用新建的NAT网络 123[root@localhost ~] virsh net-define /usr/share/libvirt/networks/management.xml[root@localhost ~] virsh net-start management[root@localhost ~] virsh net-autostart management 安装windows虚拟机1[root@localhost vms]# virt-install -n windowsxp -r 512 --disk /kvm/vms/winxp.img,format=qcow2,size=5 --network bridge=virbr1 --os-type=windows --os-variant=winxp --cdrom /kvm/iso/winxp.iso --vnc --vncport=5900 --vnclisten=0.0.0.0 windows用vnc远程屏幕 克隆虚拟机 virt-clone 参数介绍 –version 查看版本。 -h，–help 查看帮助信息。 –connect=URI 连接到虚拟机管理程序 libvirt 的URI。 -o 原始虚拟机名称 原始虚拟机名称，必须为关闭或者暂停状态。 -n 新虚拟机名称 –name 新虚拟机名称。 –auto-clone 从原来的虚拟机配置自动生成克隆名称和存储路径。 -u NEW_UUID, –uuid=NEW_UUID 克隆虚拟机的新的UUID，默认值是一个随机生成的 UUID。 -m NEW_MAC, –mac=NEW_MAC 设置一个新的mac地址，默认为随机生成 MAC。 -f NEW_DISKFILE, –file=NEW_DISKFILE 为新客户机使用新的磁盘镜像文件地址。 –force-copy=TARGET 强制复制设备。 –nonsparse 不使用稀疏文件复制磁盘映像。 1234# 暂停原始虚拟机[root@localhost ~] virsh shutdown centos7_01[root@localhost ~] virt-clone -o centos7_01 -n centos7_02 -f /kvm/vms/centos7_02.qcow2 -m 00:00:00:00:00:01[root@localhost ~] virt-clone -o centos7_01 -n centos7_03 --file /kvm/vms/centos7_03.qcow2 --nonsparse 通过镜像创建虚拟机创建虚拟机镜像文件 123456# 复制第一次安装的干净系统镜像，作为基础镜像文件，# 后面创建虚拟机使用这个基础镜像[root@localhost ~]# mkdir /kvm/img[root@localhost ~]# cp /kvm/vms/centos7_01.qcow2 /kvm/img/centos7_base.qcow2# 使用基础镜像文件，创建新的虚拟机镜像[root@localhost ~]# cp /kvm/img/centos7_base.qcow2 /kvm/vms/centos7_05.qcow2 创建虚拟机配置文件 12345678# 复制第一次安装的干净系统镜像，作为基础配置文件。[root@localhost ~] virsh dumpxml centos7_01 &gt; /kvm/img/centos7_base.xml# 使用基础虚拟机镜像配置文件，创建新的虚拟机配置文件[root@localhost ~] cp /kvm/img/centos7_base.xml /kvm/vms/centos7_05.xml# 编辑新虚拟机配置文件[root@localhost ~] vi /kvm/vms/centos7_05.xml 主要是修改虚拟机文件名，UUID，镜像地址和网卡地址，其中 UUID 在 Linux 下可以使用 uuidgen 命令生成 123456789101112&lt;domain type=&apos;kvm&apos;&gt; &lt;name&gt;centos7_05&lt;/name&gt; &lt;uuid&gt;1e86167a-33a9-4ce8-929e-58013fbf9122&lt;/uuid&gt; &lt;devices&gt; &lt;disk type=&apos;file&apos; device=&apos;disk&apos;&gt; &lt;source file=&apos;/kvm/vms/centos7_05.img&apos;/&gt; &lt;/disk&gt; &lt;interface type=&apos;bridge&apos;&gt; &lt;mac address=&apos;00:00:00:00:00:04&apos;/&gt; &lt;/interface&gt; &lt;/devices&gt;&lt;/domain&gt; 12[root@localhost ~] virsh define /kvm/vms/centos7_05.xml# Domain centos7_05 defined from /kvm/vms/centos7_05.xml 挂载磁盘创建镜像文件 1[root@localhost ~] qemu-img create /kvm/vms/centos7_01_1.img 5G 创建普通的qcow2格式镜像文件 1234# 创建 centos7_01_1 所需的磁盘# create 表示创建，-f qcow2 表示创建一个格式为 qcow2 的磁盘， # /kvm/vms/centos7_05.qcow2 表示创建的磁盘名称及磁盘文件，10G 表示该磁盘可用大小。qemu-img create -f qcow2 -o preallocation=metadata /kvm/vms/centos7_05_1.qcow2 5G 挂载方法： 1[root@localhost ~] virsh attach-disk centos7_05 /kvm/vms/centos7_05_1.qcow2 vdb --cache none 常用命令说明virt-install 常用参数说明1 123456789101112–name指定虚拟机名称–memory分配内存大小。–vcpus分配CPU核心数，最大与实体机CPU核心数相同–disk指定虚拟机镜像，size指定分配大小单位为G。–network网络类型，此处用的是默认，一般用的应该是bridge桥接。–accelerate加速–cdrom指定安装镜像iso–vnc启用VNC远程管理，一般安装系统都要启用。–vncport指定VNC监控端口，默认端口为5900，端口不能重复。–vnclisten指定VNC绑定IP，默认绑定127.0.0.1，这里改为0.0.0.0。–os-type=linux,windows–os-variant=rhel6 virt-install 常用参数说明2 12345678910111213141516171819202122--name 指定虚拟机名称--ram 虚拟机内存大小，以 MB 为单位--vcpus 分配CPU核心数，最大与实体机CPU核心数相同–-vnc 启用VNC远程管理，一般安装系统都要启用。–-vncport 指定VNC监控端口，默认端口为5900，端口不能重复。–-vnclisten 指定VNC绑定IP，默认绑定127.0.0.1，这里改为0.0.0.0。--network 虚拟机网络配置 # 其中子选项，bridge=br0 指定桥接网卡的名称。–os-type=linux,windows–os-variant=rhel7.2--disk 指定虚拟机的磁盘存储位置 # size，初始磁盘大小，以 GB 为单位。--location 指定安装介质路径，如光盘镜像的文件路径。--graphics 图形化显示配置 # 全新安装虚拟机过程中可能会有很多交互操作，比如设置语言，初始化 root 密码等等。 # graphics 选项的作用就是配置图形化的交互方式，可以使用 vnc（一种远程桌面软件）进行链接。 # 我们这列使用命令行的方式安装，所以这里要设置为 none，但要通过 --extra-args 选项指定终端信息， # 这样才能将安装过程中的交互信息输出到当前控制台。--extra-args 根据不同的安装方式设置不同的额外选项 virsh 基础命令 12345678910111213141516virsh list # 查看在运行的虚拟机virsh dumpxml vm-name # 查看kvm虚拟机配置文件virsh start vm-name # 启动kvm虚拟机virsh shutdown vm-name # 正常关机virsh destroy vm-name # 非正常关机，强制关闭虚拟机（相当于物理机直接拔掉电源）virsh undefine vm-name # 删除vm的配置文件ls /etc/libvirt/qemu# 查看删除结果，Centos的配置文件被删除，但磁盘文件不会被删除virsh define file-name.xml # 根据配置文件定义虚拟机virsh suspend vm-name # 挂起，终止virsh resumed vm-name # 恢复被挂起的虚拟机virsh autostart vm-name # 开机自启动vmvirsh console &lt;虚拟机名称&gt; # 连接虚拟机 错误解决如果出现以下字符串使用 CTRL+Shift+5或者CTRL+Shift+] 123console testConnected to domain testEscape character is ^] 彻底删除一个虚拟机（以centos7_01为例） 12345678910111213141516171819202122232425[root@localhost ~]# virshWelcome to virsh, the virtualization interactive terminal.Type: &apos;help&apos; for help with commands &apos;quit&apos; to quitvirsh # list Id Name State---------------------------------------------------- 7 windowsxp running 12 centos7_01 runningvirsh # shutdown centos7_01Domain centos7_01 is being shutdownvirsh # destroy centos7_01Domain centos7_01 destroyedvirsh # undefine centos7_01Domain centos7_01 has been undefinedvirsh # exit[root@localhost ~]# rm -rf /kvm/vms/centos7_01.qcow2 [root@localhost ~]# 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-29 负载均衡]]></title>
    <url>%2Flinux-29%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-29 负载均衡概念解析 负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。 负载均衡（Load Balance）其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。 常用开源软件负载均衡器有：Nginx、LVS、Haproxy，这三种负载均衡都要求学会并掌握。 三种负载均衡器特点简介一、LVS： 稳定性、可靠性好，自身有完美的热备方案（如：LVS+Keepalived）；应用范围比较广，可以对所有应用做负载均衡；配置复杂，对网络依赖比较大，稳定性很高。 二、Ngnix： Nginx对网络的依赖比较小，理论上能ping通就就能进行负载功能；Nginx安装和配置比较简单，测试起来比较方便；Nginx还能做Web服务器即Cache功能。 三、HAProxy的特点是： 支持两种代理模式：TCP（四层）和HTTP（七层），支持虚拟主机；更多的负载均衡策略比如：动态加权轮循(Dynamic Round Robin)，加权源地址哈希(Weighted Source Hash)，加权URL哈希和加权参数哈希(Weighted Parameter Hash)已经实现；单纯从效率上来讲HAProxy更会比Nginx有更出色的负载均衡速度；但是不能做Web服务器即Cache。 适用业务场景 网站建设初期，可以选用Nigix/HAproxy作为反向代理负载均衡（或者流量不大都可以不选用负载均衡），因为其配置简单，性能也能满足一般的业务场景。如果考虑到负载均衡器是有单点问题，可以采用Nginx+Keepalived/HAproxy+Keepalived避免负载均衡器自身的单点问题。网站并发达到一定程度之后，为了提高稳定性和转发效率，可以使用LVS、毕竟LVS比Nginx/HAproxy要更稳定，转发效率也更高。不过维护LVS对维护人员的要求也会更高，投入成本也更大。 负载均衡器作为一个代理，通过访问负载均衡器，访问到的网站是nginx1/2两个服务器上网站的内容。网站根目录可以采用共享存储（samba或者nfs或者iscsi或者ftp等），也可以做后端网络存储以通过负载均衡器看到不同服务器上的同一个网站。今天咱们的实验做的效果是看到不同的内容，以证明确实是通过负载均衡器访问到了两台服务器上的网站。 nginx负载均衡准备环境准备三台Linux服务器，打开后查看并且记住它们的ip： 负载均衡器：192.168.141.132 nginx服务器1：192.168.141.53 nginx服务器2：192.168.141.69 在三台linux服务器上分别安装nginx服务 三台服务器上分别执行以下命令安装完成nginx服务 123456[root@localhost ~]# yum install epel-release.noarch -y[root@localhost ~]# yum install nginx –y[root@localhost ~]# firewall-cmd --add-port=8080/tcp --permanent [root@localhost ~]# firewall-cmd --reload[root@localhost ~]# sed -i &apos;s/SELINUX=enforcing/SELINUX=disabled/&apos; /etc/selinux/config[root@localhost ~]# setenforce 0 配置负载均衡服务器（192.168.141.132那台）修改nginx配置，开启nginx轮询负载均衡 123456789101112131415161718192021222324252627282930313233[root@localhost ~]# vim /etc/nginx/nginx.conf 13 events &#123; 14 accept_mutex on; # （设置网路连接序列化，防止惊群现象发生，默认为on） 15 multi_accept on; # （设置一个进程是否同时接受多个网络连接，默认为off） 16 worker_connections 1024; #（一个进程的最大连接数） 17 &#125; 31 gzip on; # 开启压缩 # 设置群集策略和群集主机 40 upstream eagleslab &#123; 41 server 192.168.141.53:8080;# 可以加上weight=5; 这样的语法设置权重 42 server 192.168.141.69:8080; 43 &#125; 46 listen 8080 default_server; #修改服务监听的端口号 # listen [::]:80 default_server; 47 listen localhost; 54 location / &#123; #（ / 表示所有请求，可以自定义来针对不同的域名设定不同负载规则 和服务） 55 proxy_pass http://eagleslab;#（反向代理填负载均衡规则名） 56 proxy_redirect off; 57 proxy_set_header Host $host; 58 proxy_set_header X-Real-IP $remote_addr; 59 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 60 proxy_connect_timeout 90; 61 proxy_send_timeout 90; 62 proxy_read_timeout 90; 63 64 &#125;[root@localhost ~]# systemctl enable nginxCreated symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service.[root@localhost ~]# systemctl restart nginx 配置nginx提供web的服务器1和2 12345678910111213141516两台服务器都要修改端口号[root@client1 ]# vim /etc/nginx/nginx.conf 39 listen 8080 default_server; 40 # listen [::]:80 default_server;nginx服务器1：[root@client1 ~]# rm –rf /usr/share/nginx/html/index.html[root@client1 ~]# echo &quot;192.168.141.53&quot; &gt; /usr/share/nginx/html/index.htmlnginx服务器2：[root@client2 ~]# rm –rf /usr/share/nginx/html/index.html[root@client2 ~]# echo &quot;192.168.141.69&quot; &gt; /usr/share/nginx/html/index.html启动两台服务器的服务[root@localhost ~]# systemctl restart nginx[root@localhost ~]# systemctl enable nginx 现象​ 浏览器打开http://192.168.141.132:8080，然后不断刷新，可以看到显示出来的网页不断地在两个网页中来回切换。如下图： 在上面实验完成后，关机保存快照，然后恢复到干净的快照，接着做下面的实验 LVS实现负载均衡 LVS是Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。 实验环境做好上面的试验后将三台虚拟机恢复到一个干净的快照，接着做下面这个实验 LVS负载均衡器：192.168.141.132 web服务器1：192.168.141.53 web服务器2：192.168.141.69 准备工作三台虚拟机都放行80端口，关闭selinux 1234[root@localhost ~]# firewall-cmd --add-port=80/tcp --permanent [root@localhost ~]# firewall-cmd --reload[root@localhost ~]# sed -i &apos;s/SELINUX=enforcing/SELINUX=disabled/&apos; /etc/selinux/config[root@localhost ~]# setenforce 0 三台虚拟机安装lvs工具包 123[root@localhost ~]# yum install epel-release.noarch -y[root@server ~]# yum install ipvsadm.x86_64 -y[root@localhost ~]# yum install net-tools -y 配置负载均衡器负载均衡服务器写入以下脚本 123456789101112131415[root@server ~]# vim lvs_s.sh[root@server ~]# cat lvs_s.sh#!/bin/bashifconfig ens33:0 192.168.141.100 broadcast 192.168.141.100 netmask 255.255.255.255 upipvsadm -Cipvsadm -A -t 192.168.141.100:80 -s rripvsadm -a -t 192.168.141.100:80 -r 192.168.141.53:80 -gipvsadm -a -t 192.168.141.100:80 -r 192.168.141.69:80 -gipvsadm -Ln# 保存退出[root@server ~]# chmod +x lvs_s.sh[root@server ~]# ./lvs_s.sh 解析： ens33:0表示子接口ip，广播域为本机ip，监听自身ip，32位匹配到的仅仅是它自己这台机器ip，整个广播域就只有192.168.141.100它自己。 -r表示转发给192.168.141.53和192.168.141.69 配置负载均衡客户机两台web服务器分别都要写入和执行以下脚本 1234567891011[root@client ~]# vim lvs_c.sh[root@client ~]# cat lvs_c.sh#!/bin/bashifconfig lo:0 192.168.141.100 broadcast 192.168.141.100 netmask 255.255.255.255 up route add -host 192.168.141.100 dev lo:0echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignoreecho &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announceecho &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignoreecho &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announce[root@client ~]# chmod +x lvs_c.sh [root@client ~]# ./lvs_c.sh 解析： 两台web服务器接受到客户端请求后，将数据返回到192.168.141.100那里，然后192.168.141.100再将数据返回到客户端上。 两台web服务器分别搭建自己的apache服务 123456789[root@localhost ~]# yum install httpd -yweb服务器1：[root@client1 ~]# echo &quot;i am lvs 192.168.141.53&quot; &gt; /var/www/html/index.htmlweb服务器2：[root@client2 ~]# echo &quot;i am lvs 192.168.141.69&quot; &gt; /var/www/html/index.html启动两台服务器的服务[root@localhost ~]# systemctl restart httpd[root@localhost ~]# systemctl enable httpd 现象: 浏览器访问192.168.141.100，不断刷新，可以看到显示的内容在i am lvs 192.168.141.69和i am lvs 192.168.141.53之间来回切换。可以用低轨道离子炮攻击其中一个web服务器（关闭物理机防火墙），然后访问192.168.141.100，发现被攻击的web服务器的主页打不开了，只能打开另一个web服务器的主页了。 不断刷新192.168.141.100基本只能看到i am lvs 192.168.141.69，因为192.168.141.53正在被攻击。 如果关闭了防火墙，试验结束后记得要开回去。另外，LOIC是用C#写的，属于恶意工具，会报毒，网上下载下来的LOIC可能会有恶意代码，所以可以去github上直接下载源码，然后自己编译即可。如下图，找到这个即可，下载量最高的那个：NewEraCraker/LOIC 另外，在以后的运维工作中，尽量不要在网上直接下载软件，有些恶意代码真是防不胜防，被坑是很常见的。可以尽量在github上自己下载源码进行编译，这是最安全的方式。另外，https://sourceforge.net/是全世界最大的开源软件平台，可以在这里下载一些软件，基本无毒。 HAProxy实现负载均衡实验环境做好上面的试验后将三台虚拟机恢复到一个干净的快照，接着做下面这个实验 Haproxy负载均衡器：192.168.141.132 web服务器1：192.168.141.53 web服务器2：192.168.141.69 准备工作三台虚拟机都放行80端口，关闭selinux 1234[root@localhost ~]# firewall-cmd --add-port=80/tcp --permanent [root@localhost ~]# firewall-cmd --reload[root@localhost ~]# sed -i &apos;s/SELINUX=enforcing/SELINUX=disabled/&apos; /etc/selinux/config[root@localhost ~]# setenforce 0 配置负载均衡器在负载均衡器上安装haproxy 12[root@server ~]# yum install epel-release.noarch –y[root@server ~]# yum -y install haproxy.x86_64 修改haproxy配置 12345678910111213141516171819202122[root@server ~]# vim /etc/haproxy/haproxy.cfgglobal ulimit-n 51200defaults log global mode http option dontlognull contimeout 10000 clitimeout 150000 srvtimeout 150000 # 前端请求拦截frontend frontend1 bind *:80 default_backend backend1 #和后端转发地址对应# 后端转发地址 1backend backend1 server server1 192.168.141.53:80 maxconn 20480 server server1 192.168.141.69:80 maxconn 20480# 后端转发地址 2 backend backend2 server server1 127.0.0.1:80 maxconn 20480 解析: 用浏览器访问web服务器的网址时，客户端发出前端请求，到达远端web服务器，其响应后回传给我们。但是我们的请求发到负载均衡器时，会被它拦截下来，接下来由负载均衡器决定该把这个请求转发到哪台web服务器上。 bind *:80表示拦截所有来自80端口的请求default_backend backend1表示转发给后端转发地址backend1maxconn 20480表示最大连接数为20480 12[root@server ~]# systemctl restart haproxy[root@server ~]# systemctl enable haproxy 配置web服务器123456789[root@localhost ~]# yum install httpd -yweb服务器1：[root@client1 ~]# echo &quot;192.168.141.53&quot; &gt; /var/www/html/index.htmlweb服务器2：[root@client2 ~]# echo &quot;192.168.141.69&quot; &gt; /var/www/html/index.html启动两台服务器的服务[root@localhost ~]# systemctl restart httpd[root@localhost ~]# systemctl enable httpd http默认的就是80端口，所以直接敲负载均衡器的ip就可以，效果如下： 不断刷新，可以看到显示的内容在192.168.141.69和192.168.141.53之间来回切换 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-28 LNMP动态网站架构]]></title>
    <url>%2Flinux-28%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-28 LNMP动态网站架构LNMP动态网站架构 LNMP动态网站部署架构是一套由Linux + Nginx + MySQL + PHP组成的动态网站系统解决方案。LNMP中的字母L是Linux系统的意思，不仅可以是RHEL、CentOS、Fedora，还可以是Debian、Ubuntu等系统 开发环境的部署 在使用源码包安装服务程序之前，首先要让安装主机具备编译程序源码的环境，他需要具备C语言、C++语言、Perl语言的编译器，以及各种常见的编译支持函数库程序。因此请先配置妥当Yum软件仓库，然后把下面列出的这些软件包都统统安装上 1[root@localhost src]# yum install -y apr* autoconf automake bc bison bzip2 bzip2* compat* cpp curl curl-devel elfutils-libelf-devel flex fontconfig fontconfig-devel freetype freetype* freetype-devel gcc gcc-c++ gd gettext gettext-devel glibc kernel kernel-headers keyutils keyutils-libs-devel krb5-devel libcom_err-devel libpng libpng-devel libjpeg* libsepol-devel libselinux-devel libstdc++-devel libtool* libgomp libxml2 libxml2-devel libXpm* libtifflibtiff* make mpfr ncurses* ntp ncurses-devel openssl openssl-devel patch pcre-devel perlphp-common php-gd policycoreutils telnet t1lib t1lib* nasm nasm* wget zlib-devel unzip 下载软件包下载安装LNMP动态网站部署架构所需的16个软件源码包和1个用于检查效果的论坛网站系统软件包 123456789101112131415161718192021222324[root@localhost ~]# cd /usr/local/src/[root@localhost src]# wget https://www.linuxprobe.com/Software/cmake-2.8.11.2.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/cmake-2.8.11.2.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/freetype-2.5.3.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/jpegsrc.v9a.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/libgd-2.1.0.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/libmcrypt-2.5.8.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/libpng-1.6.12.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/libvpx-v1.3.0.tar.bz2[root@localhost src]# wget https://www.linuxprobe.com/Software/mysql-5.6.19.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/nginx-1.6.0.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/openssl-1.0.1h.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/php-5.5.14.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/pcre-8.35.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/t1lib-5.1.2.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/tiff-4.0.3.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/yasm-1.2.0.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/zlib-1.2.8.tar.gz[root@localhost src]# lscmake-2.8.11.2.tar.gz libgd-2.1.0.tar.gz mysql-5.6.19.tar.gz php-5.5.14.tar.gz zlib-1.2.8.tar.gzcmake-2.8.11.2.tar.gz.1 libmcrypt-2.5.8.tar.gz nginx-1.6.0.tar.gz t1lib-5.1.2.tar.gzfreetype-2.5.3.tar.gz libpng-1.6.12.tar.gz openssl-1.0.1h.tar.gz tiff-4.0.3.tar.gzjpegsrc.v9a.tar.gz libvpx-v1.3.0.tar.bz2 pcre-8.35.tar.gz yasm-1.2.0.tar.gz[root@localhost src]# 安装cmake CMake是Linux系统中一款常用的编译工具。要想通过源码包安装服务程序，就一定要严格遵守上面总结的安装步骤—下载及解压源码包文件、编译源码包代码、生成二进制安装程序、运行二进制的服务程序安装包。 12345[root@localhost src]# tar xzvf cmake-2.8.11.2.tar.gz [root@localhost src]# cd cmake-2.8.11.2[root@localhost cmake-2.8.11.2]# ./configure [root@localhost cmake-2.8.11.2]# make[root@localhost cmake-2.8.11.2]# make install 配置MySQL服务1234[root@localhost cmake-2.8.11.2]# cd ..[root@localhost src]# useradd mysql -s /sbin/nologin[root@localhost src]# mkdir -p /usr/local/mysql/var[root@localhost src]# chown -Rf mysql:mysql /usr/local/mysql 接下来解压、编译、安装MySQL数据库服务程序。在编译数据库时使用的是cmake命令，其中， -DCMAKE_INSTALL_PREFIX参数用于定义数据库服务程序的保存目录， -DMYSQL_DATADIR参数用于定义真实数据库文件的目录， -DSYSCONFDIR则是定义MySQL数据库配置文件的保存目录。(编译时间较长，为了防止ssh断开，建议screen运行！) 12345[root@localhost src]# tar xzvf mysql-5.6.19.tar.gz[root@localhost src]# cd mysql-5.6.19[root@localhost mysql-5.6.19]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/var -DSYSCONFDIR=/etc[root@localhost mysql-5.6.19]# make[root@localhost mysql-5.6.19]# make install 为了让MySQL数据库程序正常运转起来，需要先删除/etc目录中的默认配置文件。 然后在MySQL数据库程序的保存目录scripts内找到一个名为mysql_install_db的脚本程序。 执行这个脚本程序并使用–user参数指定MySQL服务的对应账号名称（在前面步骤已经创建）。 使用–basedir参数指定MySQL服务程序的保存目录。 使用–datadir参数指定MySQL真实数据库的文件保存目录。 这样即可生成系统数据库文件，也会生成出新的MySQL服务配置文件。 123[root@linuxprobe mysql-5.6.19]# rm -rf /etc/my.cnf[root@linuxprobe mysql-5.6.19]# cd /usr/local/mysql[root@linuxprobe mysql]# ./scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/var 把系统新生成的MySQL数据库配置文件链接到/etc目录中，然后把程序目录中的开机程序文件复制到/etc/rc.d/init.d目录中，以便通过service命令来管理MySQL数据库服务程序。记得把数据库脚本文件的权限修改成755以便于让用户有执行该脚本的权限： 123[root@localhost mysql]# ln -s my.cnf /etc/my.cnf[root@localhost mysql]# cp ./support-files/mysql.server /etc/rc.d/init.d/mysqld[root@localhost mysql]# chmod 755 /etc/rc.d/init.d/mysqld 编辑刚复制的MySQL数据库脚本文件，把第46、47行的basedir与datadir参数分别修改为MySQL数据库程序的保存目录和真实数据库的文件内容。 123[root@localhost mysql]# vim /etc/rc.d/init.d/mysqld 46行 basedir=/usr/local/mysql47行 datadir=/usr/local/mysql/var 启动mysql，并且设置开机启动 123[root@localhost mysql]# service mysqld startStarting MySQL. SUCCESS! [root@localhost mysql]# chkconfig mysqld on 把命令所保存的目录永久性地定义到PATH变量中，需要编辑/etc/profile文件并写入追加的命令目录，这样当物理设备在下一次重启时就会永久生效了。如果不想通过重启设备的方式来生效，也可以使用source命令加载一下/ect/profile文件，此时新的PATH变量也可以立即生效了。 123[root@localhost mysql]# vim /etc/profile74行本来是空行，现在插入： export PATH=$PATH:/usr/local/mysql/bin[root@localhost mysql]# source /etc/profile MySQL数据库服务程序还会调用到一些程序文件和函数库文件。由于当前是通过源码包方式安装MySQL数据库，因此现在也必须以手动方式把这些文件链接过来。 1234[root@linuxprobe mysql]# mkdir /var/lib/mysql[root@linuxprobe mysql]# ln -s /usr/local/mysql/lib/mysql /usr/lib/mysql[root@linuxprobe mysql]# ln -s /tmp/mysql.sock /var/lib/mysql/mysql.sock[root@linuxprobe mysql]# ln -s /usr/local/mysql/include/mysql /usr/include/mysql 初始化数据库 设置root管理员在数据库中的密码值（注意，该密码并非root管理员在系统中的密码，这里的密码值默认应该为空，可直接按回车键）。 设置root管理员在数据库中的专有密码。 随后删除匿名账户，并使用root管理员从远程登录数据库，以确保数据库上运行的业务的安全性。 删除默认的测试数据库，取消测试数据库的一系列访问权限。 刷新授权列表，让初始化的设定立即生效。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263[root@localhost ~]# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&apos;ll need the currentpassword for the root user. If you&apos;ve just installed MariaDB, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] yNew password: Re-enter new password: Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from &apos;localhost&apos;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] y ... Success!By default, MariaDB comes with a database named &apos;test&apos; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you&apos;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB![root@localhost ~]# 登录数据库 1234567891011121314[root@localhost ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 13Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [DBaaa]&gt; exitBye[root@localhost ~]# 配置nginx服务解决相关的软件依赖关系 提供Perl语言兼容的正则表达式库的软件包pcre 123456[root@localhost ~]# cd /usr/local/src[root@localhost src]# tar xzvf pcre-8.35.tar.gz[root@localhost src]# cd pcre-8.35[root@localhost pcre-8.35]# ./configure --prefix=/usr/local/pcre --enable-utf8[root@localhost pcre-8.35]# make[root@localhost pcre-8.35]# make install openssl软件包是用于提供网站加密证书服务的程序文件，在安装该程序时需要自定义服务程序的安装目录，以便于稍后调用它们的时候更可控。 123456[root@localhost pcre-8.35]# cd /usr/local/src[root@localhost src]# tar xzvf openssl-1.0.1h.tar.gz [root@localhost src]# cd openssl-1.0.1h[root@localhost openssl-1.0.1h]# ./config --prefix=/usr/local/openssl[root@localhost openssl-1.0.1h]# make[root@localhost openssl-1.0.1h]# make install openssl软件包安装后默认会在/usr/local/openssl/bin目录中提供很多的可用命令，我们需要像前面的操作那样，将这个目录添加到PATH环境变量中，并写入到配置文件中，最后执行source命令以便让新的PATH环境变量内容可以立即生效 123[root@localhost openssl-1.0.1h]# vim /etc/profile74行改为： export PATH=$PATH:/usr/local/openssl/bin:/usr/local/openssl/bin[root@localhost openssl-1.0.1h]# source /etc/profile zlib软件包是用于提供压缩功能的函数库文件。其实Nginx服务程序调用的这些服务程序无需深入了解，只要大致了解其作用就已经足够了 123456[root@localhost openssl-1.0.1h]# cd /usr/local/src/[root@localhost src]# tar xzvf zlib-1.2.8.tar.gz[root@localhost src]# cd zlib-1.2.8[root@localhost zlib-1.2.8]# ./configure --prefix=/usr/local/zlib[root@localhost zlib-1.2.8]# make[root@localhost zlib-1.2.8]# make install 创建一个用于执行Nginx服务程序的账户。账户名称可以自定义 12[root@localhost zlib-1.2.8]# cd ..[root@localhost src]# useradd www -s /sbin/nologin 其中，–prefix参数用于定义服务程序稍后安装到的位置， –user与–group参数用于指定执行Nginx服务程序的用户名和用户组。 在使用参数调用openssl、zlib、pcre软件包时，请写出软件源码包的解压路径，而不是程序的安装路径 12345[root@localhost src]# tar xzvf nginx-1.6.0.tar.gz [root@localhost src]# cd nginx-1.6.0[root@localhost nginx-1.6.0]# ./configure --prefix=/usr/local/nginx --without-http_memcached_module --user=www --group=www --group=www --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-openssl=/usr/local/src/openssl-1.0.1h --with-zlib=/usr/local/src/zlib-1.2.8 --with-pcre=/usr/local/src/pcre-8.35[root@localhost nginx-1.6.0]# make[root@localhost nginx-1.6.0]# make install 要想启动Nginx服务程序以及将其加入到开机启动项中，也需要有脚本文件。 1234567891011[root@localhost nginx-1.6.0]# curl https://raw.githubusercontent.com/xcracker/linux_shell/master/init.d/nginx &gt; /etc/rc.d/init.d/nginx[root@localhost nginx-1.6.0]# chmod 755 /etc/rc.d/init.d/nginx [root@localhost nginx-1.6.0]# /etc/rc.d/init.d/nginx restartReloading systemd: [ 确定 ]Starting nginx (via systemctl): [ 确定 ][root@localhost nginx-1.6.0]# chkconfig nginx on[root@localhost nginx-1.6.0]# firewall-cmd --add-port=80/tcp --permanent success[root@localhost nginx-1.6.0]# firewall-cmd --reloadsuccess[root@localhost nginx-1.6.0]# 上面curl链接的网址存放着脚本代码，如下图： 浏览器打开服务器ip，查看是否成功 配置PHP服务yasm源码包是一款常见的开源汇编器 123456[root@localhost nginx-1.6.0]# cd ..[root@localhost src]# tar xzvf yasm-1.2.0.tar.gz [root@localhost src]# cd yasm-1.2.0[root@localhost yasm-1.2.0]# ./configure [root@localhost yasm-1.2.0]# make[root@localhost yasm-1.2.0]# make install libmcrypt源码包是用于加密算法的扩展库程序 123456[root@localhost yasm-1.2.0]# cd ..[root@localhost src]# tar xzvf libmcrypt-2.5.8.tar.gz[root@localhost src]# cd libmcrypt-2.5.8[root@localhost libmcrypt-2.5.8]# ./configure[root@localhost libmcrypt-2.5.8]# make[root@localhost libmcrypt-2.5.8]# make install libvpx源码包是用于提供视频编码器的服务程序 123456[root@linuxprobe libmcrypt-2.5.8]# cd ..[root@linuxprobe src]# tar xjvf libvpx-v1.3.0.tar.bz2[root@linuxprobe src]# cd libvpx-v1.3.0[root@linuxprobe libvpx-v1.3.0]# ./configure --prefix=/usr/local/libvpx --enable-shared --enable-vp9[root@linuxprobe libvpx-v1.3.0]# make[root@linuxprobe libvpx-v1.3.0]# make install tiff源码包是用于提供标签图像文件格式的服务程序 123456[root@localhost libvpx-v1.3.0]# cd ..[root@localhost src]# tar xzvf tiff-4.0.3.tar.gz [root@localhost src]# cd tiff-4.0.3[root@localhost tiff-4.0.3]# ./configure --prefix=/usr/local/tiff --enable-shared[root@localhost tiff-4.0.3]# make[root@localhost tiff-4.0.3]# make install libpng源码包是用于提供png图片格式支持函数库的服务程序 123456[root@localhost tiff-4.0.3]# cd ..[root@localhost src]# tar xzvf libpng-1.6.12.tar.gz[root@localhost src]# cd libpng-1.6.12[root@localhost libpng-1.6.12]# ./configure --prefix=/usr/local/libpng --enable-shared[root@localhost libpng-1.6.12]# make[root@localhost libpng-1.6.12]# make install freetype源码包是用于提供字体支持引擎的服务程序 123456[root@localhost libpng-1.6.12]# cd ..[root@localhost src]# tar xzvf freetype-2.5.3.tar.gz [root@localhost src]# cd freetype-2.5.3[root@localhost freetype-2.5.3]# ./configure --prefix=/usr/local/freetype --enable-shared[root@localhost freetype-2.5.3]# make[root@localhost freetype-2.5.3]# make install jpeg源码包是用于提供jpeg图片格式支持函数库的服务程序 123456[root@localhost freetype-2.5.3]# cd ..[root@localhost src]# tar xzvf jpegsrc.v9a.tar.gz [root@localhost src]# cd jpeg-9a[root@localhost jpeg-9a]# ./configure --prefix=/usr/local/jpeg --enable-shared[root@localhost jpeg-9a]# make[root@localhost jpeg-9a]# make install libgd源码包是用于提供图形处理的服务程序,在编译libgd源码包时，请记得写入的是jpeg、libpng、freetype、tiff、libvpx等服务程序在系统中的安装路径，即在上面安装过程中使用–prefix参数指定的目录路径 123456[root@localhost jpeg-9a]# cd ..[root@localhost src]# tar xzvf libgd-2.1.0.tar.gz [root@localhost src]# cd libgd-2.1.0[root@localhost libgd-2.1.0]# ./configure --prefix=/usr/local/libgd --enable-shared --with-jpeg=/usr/local/jpeg --with-png=/usr/local/libpng --with-freetype=/usr/local/freetype --with-fontconfig=/usr/local/freetype --with-xpm=/usr/ --with-tiff=/usr/local/tiff --with-vpx=/usr/local/libvpx[root@localhost libgd-2.1.0]# make[root@localhost libgd-2.1.0]# make install t1lib源码包是用于提供图片生成函数库的服务程序 安装后把/usr/lib64目录中的函数文件链接到/usr/lib目录中，以便系统能够顺利调取到函数文件 12345678[root@localhost libgd-2.1.0]# cd ..[root@localhost src]# tar xzvf t1lib-5.1.2.tar.gz [root@localhost src]# cd t1lib-5.1.2[root@localhost t1lib-5.1.2]# ./configure --prefix=/usr/local/t1lib --enable-shared[root@localhost t1lib-5.1.2]# make[root@localhost t1lib-5.1.2]# make install[root@localhost t1lib-5.1.2]# ln -s /usr/lib64/libltdl.so /usr/lib/libltdl.so[root@localhost t1lib-5.1.2]# cp -frp /usr/lib64/libXpm.so* /usr/lib 此时终于把编译php服务源码包的相关软件包都已经安装部署妥当了。 在开始编译php源码包之前，先定义一个名为LD_LIBRARY_PATH的全局环境变量，该环境变量的作用是帮助系统找到指定的动态链接库文件，这些文件是编译php服务源码包的必须元素之一。 编译php服务源码包时，除了定义要安装到的目录以外，还需要依次定义配置php服务程序配置文件的保存目录、MySQL数据库服务程序所在目录、MySQL数据库服务程序配置文件所在目录，以及libpng、jpeg、freetype、libvpx、zlib、t1lib等服务程序的安装目录路径，并通过参数启动php服务程序的诸多默认功能 1234567[root@localhost t1lib-5.1.2]# cd ..[root@localhost src]# tar -xzvf php-5.5.14.tar.gz [root@localhost src]# cd php-5.5.14[root@localhost php-5.5.14]# export LD_LIBRARY_PATH=/usr/local/libgd/lib[root@localhost php-5.5.14]# ./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-mysql=/usr/local/mysql --with-mysqli=/usr/local/mysql/bin/mysql_config --with-mysql-sock=/tmp/mysql.sock --with-pdo-mysql=/usr/local/mysql --with-gd --with-png-dir=/usr/local/libpng --with-jpeg-dir=/usr/local/jpeg --with-freetype-dir=/usr/local/freetype --with-xpm-dir=/usr/ --with-vpx-dir=/usr/local/libvpx/ --with-zlib-dir=/usr/local/zlib --with-t1lib=/usr/local/t1lib --with-iconv --enable-libxml --enable-xml --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --enable-opcache --enable-mbregex --enable-fpm --enable-mbstring --enable-ftp --enable-gd-native-ttf --with-openssl --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --enable-session --with-mcrypt --with-curl --enable-ctype [root@localhost php-5.5.14]# make[root@localhost php-5.5.14]# make install 在php源码包程序安装完成后，需要删除当前默认的配置文件，然后将php服务程序目录中相应的配置文件复制过来 12345[root@localhost php-5.5.14]# rm -rf /etc/php.ini[root@localhost php-5.5.14]# ln -s /usr/local/php/etc/php.ini /etc/php.ini[root@localhost php-5.5.14]# cp php.ini-production /usr/local/php/etc/php.ini[root@localhost php-5.5.14]# cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf[root@localhost php-5.5.14]# ln -s /usr/local/php/etc/php-fpm.conf /etc/php-fpm.conf php-fpm.conf是php服务程序重要的配置文件之一，我们需要启用该配置文件中第25行左右的pid文件保存目录（去掉那一行备注），然后分别将第148和149行的user与group参数分别修改为www账户和用户组名称 1234[root@localhost php-5.5.14]# vim /usr/local/php/etc/php-fpm.conf25行 pid = run/php-fpm.pid148行 user = www149行 group = www 配置妥当后便可把用于管理php服务的脚本文件复制到/etc/rc.d/init.d中了。为了能够执行脚本，请记得为脚本赋予755权限。最后把php-fpm服务程序加入到开机启动项中 123[root@localhost php-5.5.14]# cp sapi/fpm/init.d.php-fpm /etc/rc.d/init.d/php-fpm[root@localhost php-5.5.14]# chmod 755 /etc/rc.d/init.d/php-fpm[root@localhost php-5.5.14]# chkconfig php-fpm on 为了安全，编辑php.ini配置文件，在305行的disable_functions参数后面追加上要禁止的功能。（注意：disable_functions = 后面直接接那一大串东西，不要回车换行！） 123[root@localhost php-5.5.14]# vim /usr/local/php/etc/php.ini305行 disable_functions = passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restor e,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,escapeshellcmd,dll,popen,disk_free_space,checkdnsrr,checkdnsrr,g etservbyname,getservbyport,disk_total_space,posix_ctermid,posix_get_last_error,posix_getcwd,posix_getegid,posix_geteuid,posix_getgid,po six_getgrgid,posix_getgrnam,posix_getgroups,posix_getlogin,posix_getpgid,posix_getpgrp,posix_getpid,posix_getppid,posix_getpwnam,posix_ getpwuid,posix_getrlimit,posix_getsid,posix_getuid,posix_isatty,posix_kill,posix_mkfifo,posix_setegid,posix_seteuid,posix_setgid,posix_ setpgid,posix_setsid,posix_setuid,posix_strerror,posix_times,posix_ttyname,posix_uname 编辑Nginx服务程序的主配置文件， 把第2行的井号（#）删除，然后在后面写上负责运行Nginx服务程序的账户名称和用户组名称； 在第45行的index参数后面写上网站的首页名称。 最后是将第65～71行参数前的井号（#）删除来启用参数，主要是修改第69行的脚本名称路径参数， 其中$document_root变量即为网站信息存储的根目录路径，若没有设置该变量，则Nginx服务程序无法找到网站信息，因此会提示“404页面未找到”的报错信息。 在确认参数信息填写正确后便可重启Nginx服务与php-fpm服务 12345678910111213[root@localhost php-5.5.14]# vim /usr/local/nginx/conf/nginx.conf2行 user www;44行 root /usr/local/nginx/html;45行 index index.html index.htm index.php;65行 location ~ \.php$ &#123;66行 root /usr/local/nginx/html;67行 fastcgi_pass 127.0.0.1:9000;68行 fastcgi_index index.php;69行 fastcgi_param SCRIPT_FILENAME /usr/local/nginx/html$fastcgi_script_name;70行 include fastcgi_params;71行 &#125;[root@localhost php-5.5.14]# systemctl restart nginx[root@localhost php-5.5.14]# systemctl restart php-fpm 要改动的地方上面也都写了，参考自网上的文章，如果你担心配错要检查的话，看下面配置文件原文： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162user www www;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root /usr/local/nginx/html; #指定索引文件的目录 index index.html index.htm index.php; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \.php$ &#123; #开启php解析 root /usr/local/nginx/html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME script$fastcgi_script_name 改为： fastcgi_param SCRIPT_FILENAME /usr/local/nginx/html$fastcgi_script_name; #指定路径 include fastcgi_params; &#125; # fastcgi_params; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; 搭建Discuz论坛 为了检验LNMP动态网站环境是否配置妥当，可以使用在上面部署Discuz!系统，然后查看结果。如果能够在LNMP动态网站环境中成功安装使用Discuz!论坛系统，也就意味着这套架构是可用的。Discuz! X3.2是国内最常见的社区论坛系统，在经过十多年的研发后已经成为了全球成熟度最高、覆盖率最广的论坛网站系统之一。 Discuz! X3.2软件包的后缀是.zip格式，因此应当使用专用的unzip命令来进行解压。解压后会在当前目录中出现一个名为upload的文件目录，这里面保存的就是Discuz！论坛的系统程序。我们把Nginx服务程序网站根目录的内容清空后，就可以把这些这个目录中的文件都复制进去了。我们已经把Nginx服务程序的网站根目录的所有者和所属组修改为本地的www用户了，并为其赋予755权限以便于能够读、写、执行该论坛系统内的文件。 123456789101112131415[root@localhost php-5.5.14]# cd /usr/local/src/[root@localhost src]# wget http://download.comsenz.com/DiscuzX/3.2/Discuz_X3.2_SC_UTF8.zip[root@localhost src]# unzip Discuz_X3.2_SC_UTF8.zip [root@localhost src]# rm -rf /usr/local/nginx/html/&#123;index.html,50x.html&#125;*[root@localhost src]# mv upload/* /usr/local/nginx/html/[root@localhost src]# chown -Rf www:www /usr/local/nginx/html[root@localhost src]# chmod -Rf 755 /usr/local/nginx/html[root@localhost src]# cd[root@localhost ~]# firewall-cmd --add-port=&#123;80,3306&#125;/tcp --permanentWarning: ALREADY_ENABLED: 80:tcpsuccess[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# setenforce 0[root@localhost ~]# 打开IP地址，加上/install，如果是下面这个样子，那九成九都是你的配置文件配置错了，需要再次检查： 1vim /usr/local/nginx/conf/nginx.conf 如果你的配置文件正确，那么基本上不会有问题，可以开始安装Discuz论坛了。 浏览器敲入ip，它会跳转到http://192.168.141.132/install/，开始安装。 之前初始化mysql的时候你设置的root密码填上，另外再给你的论坛管理员admin想一个密码 论坛登录成功！本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-27 Discuz论坛搭建]]></title>
    <url>%2Flinux-27%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-27 Discuz论坛搭建LAMP动态网站架构关闭selinux，重启才能生效！ 123456[root@localhost ~]# vim /etc/selinux/config 将SELINUX=enforcing那一行改为：SELINUX=disabled保存退出，重启虚拟机[root@localhost ~]# reboot Discuz下载地址简体中文GBKhttp://download.comsenz.com/DiscuzX/3.2/Discuz_X3.2_SC_GBK.zip繁体中文 BIG5http://download.comsenz.com/DiscuzX/3.2/Discuz_X3.2_TC_BIG5.zip简体 UTF8http://download.comsenz.com/DiscuzX/3.2/Discuz_X3.2_SC_UTF8.zip繁体 UTF8http://download.comsenz.com/DiscuzX/3.2/Discuz_X3.2_TC_UTF8.zip 本次实验用的是简体 UTF8 ，如果是简体中文GBK 的话会出现如下图的乱码，就需要改参数了： 用yum安装lamp架构的web服务器（部署discuz论坛为例） 1234567891011121314151617[root@localhost ~]# yum install wget unzip httpd mariadb mariadb-server php php-mysql -y[root@localhost ~]# cd /var/www/html/[root@localhost html]# wget http://download.comsenz.com/DiscuzX/3.2/Discuz_X3.2_SC_UTF8.zip[root@localhost ~]# [root@localhost html]# unzip Discuz_X3.2_SC_UTF8.zip [root@localhost html]# lsDiscuz_X3.2_SC_UTF8.zip readme upload utility[root@localhost html]# chown -R apache:apache *[root@localhost html]# chmod 755 -R *[root@localhost html]# cd[root@localhost ~]# [root@localhost ~]# systemctl restart httpd mariadb[root@localhost ~]# systemctl enable httpd mariadb[root@localhost ~]# firewall-cmd --add-port=&#123;80,3306&#125;/tcp --permanent[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# 初始化数据库 设置root管理员在数据库中的密码值（注意，该密码并非root管理员在系统中的密码，这里的密码值默认应该为空，可直接按回车键）。 设置root管理员在数据库中的专有密码。 随后删除匿名账户，并使用root管理员从远程登录数据库，以确保数据库上运行的业务的安全性。 删除默认的测试数据库，取消测试数据库的一系列访问权限。 刷新授权列表，让初始化的设定立即生效。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677[root@localhost ~]# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&apos;ll need the currentpassword for the root user. If you&apos;ve just installed MariaDB, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.#这里直接敲回车Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] yNew password: Re-enter new password: Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from &apos;localhost&apos;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] y ... Success!By default, MariaDB comes with a database named &apos;test&apos; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you&apos;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB![root@localhost ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 10Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; exitBye[root@localhost ~]# [root@localhost ~]# systemctl restart mariadb.service [root@localhost ~]# 浏览器打开discuz服务器的ip加上/upload/forum.php，例如http://192.168.141.132/upload/forum.php，回车后自动跳转到安装界面http://192.168.141.132/upload/install/，如下图： 数据库密码就是刚刚我们登录mysql的root密码，这里你再想一个discuz论坛管理员的密码填进去即可： 用你刚刚设置的管理员密码登录，管理员指的是admin 登录成功后，你就可以随心所欲地设置你论坛的主题了，自己多玩玩就熟悉了。 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-26 使用phpmyadmin管理数据库]]></title>
    <url>%2Flinux-26%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-26 使用phpmyadmin管理数据库使用phpMyAdmin管理数据库安装必须的组件 1[root@localhost ~]# yum -y install httpd php mariadb mariadb-server php-mysql php-mbstring php-mcrypt unzip 首先，我们到这个网站：https://www.phpmyadmin.net/files，如下图，右键最新版本的压缩包，复制下载链接，下面wget的链接就是现在复制下来的链接。记住往下翻翻，下载旧一点的版本，这里以4.1.0版本为例： 获得phpmyadmin软件包并且解压和移动路径 1234567891011121314[root@localhost ~]# wget https://files.phpmyadmin.net/phpMyAdmin/4.1.0/phpMyAdmin-4.1.0-all-languages.zip[root@localhost ~]# lsanaconda-ks.cfg phpMyAdmin-4.1.0-all-languages.zip[root@localhost ~]# unzip phpMyAdmin-4.1.0-all-languages.zip [root@localhost ~]# lsanaconda-ks.cfg phpMyAdmin-4.1.0-all-languages phpMyAdmin-4.1.0-all-languages.zip[root@localhost ~]# mv phpMyAdmin-4.1.0-all-languages /var/www/html/phpmyadmin[root@localhost ~]# ls /var/www/html/phpmyadmin[root@localhost ~]# [root@localhost ~]# cd /var/www/html/[root@localhost html]# chown -R apache:apache phpmyadmin[root@localhost html]# chmod 755 -R phpmyadmin[root@localhost html]# 配置phpmyadmin 12345678910[root@localhost html]# cd phpmyadmin/[root@localhost phpmyadmin]# cp config.sample.inc.php config.inc.php[root@localhost phpmyadmin]# vim config.inc.php 我们在$cfg[&apos;blowfish_secret&apos;] = &apos;&apos;的引号中任意写入一串字符，大家可以把它理解为一个身份验证码。第17行： 17 $cfg[&apos;blowfish_secret&apos;] = &apos;abcdefg&apos;; 保存退出 运行phpmyadmin 123456789[root@localhost phpmyadmin]# cd[root@localhost ~]# systemctl start httpd[root@localhost ~]# systemctl enable httpdCreated symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd/system/httpd.service.[root@localhost ~]# firewall-cmd --add-port=80/tcp --permanent success[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# setenforce 0 初始化数据库 设置root管理员在数据库中的密码值（注意，该密码并非root管理员在系统中的密码，这里的密码值默认应该为空，可直接按回车键）。 设置root管理员在数据库中的专有密码。 随后删除匿名账户，并使用root管理员从远程登录数据库，以确保数据库上运行的业务的安全性。 删除默认的测试数据库，取消测试数据库的一系列访问权限。 刷新授权列表，让初始化的设定立即生效。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[root@localhost ~]# systemctl restart mariadb.service [root@localhost ~]# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&apos;ll need the currentpassword for the root user. If you&apos;ve just installed MariaDB, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.#这里直接敲回车Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] yNew password: Re-enter new password: Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from &apos;localhost&apos;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] y ... Success!By default, MariaDB comes with a database named &apos;test&apos; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you&apos;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB![root@localhost ~]# 浏览器打开服务器Server的IP地址，如下图： 在后面追加/phpmyadmin，如下图： 用root和刚刚初始化数据库的密码登录上去 在这里，你可以很方便的建表查表等完成对数据库的操作，具体就靠你自己去玩玩熟了。 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-25 常见网站架构]]></title>
    <url>%2Flinux-25%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-25 常见网站架构 网站架构简称 网站架构全称 LAMP Linux+Apache+Mysql/MariaDB+Perl/PHP/Python LNMP Linux+Nginx+MySQL+PHP WAMP Windows+Apache+Mysql/MariaDB+Perl/PHP/Python WNMP Windows+Nginx+Mysql+PHP Apache与Nginx的优缺点比较 有些时候，在入职面试的时候面试官可能会问你Apache与Nginx那个比较好，但是，其实，二者没有孰优孰劣，只有不同特点。 1、nginx相对于apache的优点： 轻量级，同样起web 服务，比apache 占用更少的内存及资源 抗并发，nginx 处理请求是异步非阻塞的，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能 高度模块化的设计，编写模块相对简单 社区活跃，各种高性能模块出品迅速啊 apache 相对于nginx 的优点： rewrite ，比nginx 的rewrite 强大 模块超多，基本想到的都可以找到 少bug ，nginx 的bug 相对较多 超稳定 存在就是理由，一般来说，需要性能的web 服务，用nginx 。如果不需要性能只求稳定，那就apache 吧。后者的各种功能模块实现得比前者，例如ssl 的模块就比前者好，可配置项多。这里要注意一点，epoll(freebsd 上是 kqueue )网络IO 模型是nginx 处理性能高的根本理由，但并不是所有的情况下都是epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的select 模型或许比epoll 更高性能。当然，这只是根据网络IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。 2、作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。在高连接并发的情况下，Nginx是Apache服务器不错的替代品: Nginx在美国是做虚拟主机生意的老板们经常选择的软件平台之一. 能够支持高达 50,000 个并发连接数的响应, 感谢Nginx为我们选择了 epoll and kqueue 作为开发模型. Nginx作为负载均衡服务器: Nginx 既可以在内部直接支持 Rails 和 PHP 程序对外进行服务, 也可以支持作为 HTTP代理 服务器对外进行服务. Nginx采用C进行编写, 不论是系统资源开销还是CPU使用效率都比 Perlbal 要好很多. 作为邮件代理服务器: Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器）, Last.fm 描述了成功并且美妙的使用经验. Nginx 是一个安装非常的简单 , 配置文件非常简洁（还能够支持perl语法）, Bugs 非常少的服务器: Nginx 启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动. 你还能够不间断服务的情况下进行软件版本的升级 . 3、Nginx 配置简洁, Apache 复杂 Nginx 静态处理性能比 Apache 高 3倍以上 Apache 对 PHP 支持比较简单，Nginx 需要配合其他后端用 Apache 的组件比 Nginx 多 现在 Nginx 才是 Web 服务器的首选 4、最核心的区别在于apache是同步多进程模型，一个连接对应一个进程；nginx是异步的，多个连接（万级别）可以对应一个进程 5、nginx处理静态文件好,耗费内存少.但无疑apache仍然是目前的主流,有很多丰富的特性.所以还需要搭配着来.当然如果能确定nginx就适合需求,那么使用nginx会是更经济的方式. 6、从个人过往的使用情况来看，nginx的负载能力比apache高很多。最新的服务器也改用nginx了。而且nginx改完配置能-t测试一下配置有没有问题，apache重启的时候发现配置出错了，会很崩溃，改的时候都会非常小心翼翼现在看有好多集群站，前端nginx抗并发，后端apache集群，配合的也不错。 7、nginx处理动态请求是鸡肋，一般动态请求要apache去做，nginx只适合静态和反向。 8、從我個人的經驗來看，nginx是很不錯的前端服務器，負載性能很好，在老奔上開nginx，用webbench模擬10000個靜態文件請求毫不吃力。apache對php等語言的支持很好，此外apache有強大的支持網路，發展時間相對nginx更久，bug少但是apache有先天不支持多核心處理負載雞肋的缺點，建議使用nginx做前端，後端用apache。大型網站建議用nginx自代的集群功能 9、Nginx优于apache的主要两点：1.Nginx本身就是一个反向代理服务器 2.Nginx支持7层负载均衡；其他的当然，Nginx可能会比apache支持更高的并发，但是根据NetCraft的统计，2011年4月的统计数据，Apache依然占有62.71%，而Nginx是7.35%，因此总得来说，Aapche依然是大部分公司的首先，因为其成熟的技术和开发社区已经也是非常不错的性能。 10、你对web server的需求决定你的选择。大部分情况下nginx都优于APACHE，比如说静态文件处理、PHP-CGI的支持、反向代理功能、前端Cache、维持连接等等。在Apache+PHP（prefork）模式下，如果PHP处理慢或者前端压力很大的情况下，很容易出现Apache进程数飙升，从而拒绝服务的现象。 11、可以看一下nginx lua模块：https://github.com/chaoslaw...apache比nginx多的模块，可直接用lua实现apache是最流行的，why？大多数人懒得更新到nginx或者学新事物 12、对于nginx，我喜欢它配置文件写的很简洁，正则配置让很多事情变得简单运行效率高，占用资源少，代理功能强大，很适合做前端响应服务器 13、Apache在处理动态有优势，Nginx并发性比较好，CPU内存占用低，如果rewrite频繁，那还是Apache吧]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-24 PXE+Kickstart 无人值守安装系统]]></title>
    <url>%2Flinux-24%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-24 PXE+Kickstart无人值守安装系统概念解析一、pxe介绍 PXE(preboot execute environment，预启动执行环境)是由Intel公司开发的最新技术，工作于Client/Server的网络模式，支持工作站通过网络从远端服务器下载映像，并由此支持通过网络启动操作系统，在启动过程中，终端要求服务器分配IP地址再用TFTP或MTFTP协议下载一个启动软件包到本机内存中执行，由这个启动软件包完成终端(客户?)基本软件设置，从而引导预先安装在服务器中的终端操作系统。PXE可以引导多种操作系统。 二、.kickstart介绍 许多系统管理员倾向于使用自动安装方法来安装RedHat企业Linux在他们的机器上。为了满足这个需要，RedHat创建了kickstart安装方法。使用kickstart，系统管理员可以创建一个包含所有在典型的安装过程中通常会被问到的问题的答案的文件。启动文件可以保存在单个服务器系统上，并在运行期间有个人计算机读取安装。这安装方法可以支持使用一个启动文件来安装RedHat企业Linux在多台机器上。kickstart为用户提供了一种自动化的安装方法。 Kickstart是一种无人值守的安装方式。它的工作原理是在安装过程中记录人工干预填写的各种参数，并生成一个名为ks.cfg的文件。如果在自动安装过程中出现要填写参数的情况，安装程序首先会去查找ks.cfg文件，如果找到合适的参数，就采用所找到的参数；如果没有找到合适的参数，便会弹出对话框让安装者手工填写。所以，如果ks.cfg文件涵盖了安装过程中所有需要填写的参数，那么安装者完全可以只告诉安装程序从何处下载ks.cfg文件，然后就去忙自己的事情。等安装完毕，安装程序会根据ks.cfg中的设置重启/关闭系统，并结束安装。 三、应用 刚入职的运维新手经常会被要求去做一些安装操作系统的工作。如果按照第1章讲解的用光盘镜像来安装操作系统，其效率会相当低下。本章将介绍可以实现无人值守安装服务的PXE+Kickstart服务程序，并带领大家动手安装部署PXE + TFTP + FTP + DHCP + Kickstart等服务程序，从而搭建出一套可批量安装Linux系统的无人值守安装系统。在学完本章内容之后，运维新手就可以避免枯燥乏味的重复性工作，大大提供系统安装的效率。 PXE+Kicstart 无人值守安装系统 主机名称 操作系统 IP地址 无人值守系统 CENTOS 7 ens33：192.168.141.132 ens37：192.168.10.10 客户端主机 未安装操作系统 - 客户端主机先不要开机，服务器Server增加一块网卡，设置为仅主机模式，客户机client一块网卡为仅主机模式，尚未安装系统的客户机内存至少大于等于2G，其CD/DVD里不用放置iso系统镜像，如下图： 配置Server服务器直接关闭服务器上防火墙和selinux，省事儿 123[root@localhost ~]# setenforce 0[root@localhost ~]# systemctl stop firewalld[root@localhost ~]# 设置服务器新添加的仅主机模式网卡为固定ip 12345678910111213141516171819202122232425[root@localhost ~]# nmcli connection add con-name ens37 ifname ens37 type ethernet autoconnect yes ipv4.method manual ipv4.addresses 192.168.10.10/24连接“ens37”(4a690975-263e-4f5f-8ba9-d08fb16ff66d) 已成功添加。[root@localhost ~]# systemctl restart network[root@localhost ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:98:66:4e brd ff:ff:ff:ff:ff:ff inet 192.168.141.132/24 brd 192.168.141.255 scope global noprefixroute dynamic ens33 valid_lft 1797sec preferred_lft 1797sec inet6 fe80::5a82:cc9d:de3:b9f0/64 scope link noprefixroute valid_lft forever preferred_lft forever3: ens37: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:98:66:58 brd ff:ff:ff:ff:ff:ff inet 192.168.10.10/24 brd 192.168.10.255 scope global noprefixroute ens37 valid_lft forever preferred_lft forever inet6 fe80::8df1:2a48:abf7:c67b/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@localhost ~]# 可以看到网卡ens37的ip已经成功改为192.168.10.10/24了 配置DHCP服务 123456789101112131415161718192021222324[root@localhost ~]# yum install dhcp -y[root@localhost ~]# vim /etc/dhcp/dhcpd.conf ## DHCP Server Configuration file.# see /usr/share/doc/dhcp*/dhcpd.conf.example# see dhcpd.conf(5) man page#allow booting;allow bootp;ddns-update-style interim;ignore client-updates;subnet 192.168.10.0 netmask 255.255.255.0 &#123; option subnet-mask 255.255.255.0; option domain-name-servers 192.168.10.10; range dynamic-bootp 192.168.10.100 192.168.10.200; default-lease-time 21600; max-lease-time 43200; next-server 192.168.10.10; filename &quot;pxelinux.0&quot;;&#125;保存退出，重启dhcp服务[root@localhost ~]# systemctl restart dhcpd 配置TFTP服务 123456789101112[root@localhost ~]# yum install tftp-server xinetd -y[root@localhost ~]# vim /etc/xinetd.d/tftp 将第14行的 disable = yes改为： disable = no即可。保存退出，重启xinetd服务[root@localhost ~]# systemctl restart xinetd[root@localhost ~]# systemctl enable xinetd 配置syslinux服务程序 1[root@localhost ~]# yum install syslinux -y 在安装好SYSLinux服务程序软件包后，/usr/share/syslinux目录中会出现很多引导文件。 首先需要把SYSLinux提供的引导文件复制到TFTP服务程序的默认目录中，也就是前文提到的文件pxelinux.0，这样客户端主机就能够顺利地获取到引导文件了。 另外在Centos 7系统光盘镜像中也有一些我们需要调取的引导文件。确认光盘镜像已经被挂载到/media/cdrom目录后，使用复制命令将光盘镜像中自带的一些引导文件也复制到TFTP服务程序的默认目录中。 12345678910111213[root@localhost ~]# cd /var/lib/tftpboot/[root@localhost tftpboot]# cp /usr/share/syslinux/pxelinux.0 .[root@localhost tftpboot]# mkdir -p /media/cdrom[root@localhost tftpboot]# mount /dev/cdrom /media/cdrom/mount: /dev/sr0 写保护，将以只读方式挂载[root@localhost tftpboot]# cd /media/cdrom/images/pxeboot/[root@localhost pxeboot]# lsinitrd.img TRANS.TBL vmlinuz[root@localhost pxeboot]# cd -/var/lib/tftpboot[root@localhost tftpboot]# [root@localhost tftpboot]# cp /media/cdrom/images/pxeboot/&#123;vmlinuz,initrd.img&#125; .[root@localhost tftpboot]# cp /media/cdrom/isolinux/&#123;vesamenu.c32,boot.msg&#125; . 然后在TFTP服务程序的目录中新建pxelinux.cfg目录，虽然该目录的名字带有后缀，但依然也是目录，而非文件！将系统光盘中的开机选项菜单复制到该目录中，并命名为default。这个default文件就是开机时的选项菜单 123[root@localhost tftpboot]# mkdir pxelinux.cfg[root@localhost tftpboot]# cp /media/cdrom/isolinux/isolinux.cfg pxelinux.cfg/default[root@localhost tftpboot]# 默认安装系统会对安装介质进行检验，无法做到无人值守，所以修改菜单 123[root@localhost tftpboot]# vi pxelinux.cfg/default1行 default linux64行 append initrd=initrd.img inst.stage2=ftp://192.168.10.10 ks=ftp://192.168.10.10/pub/ks.cfg quiet 配置vsftpd服务 光盘镜像是通过FTP协议传输的，因此要用到vsftpd服务程序 123456[root@localhost tftpboot]# cd [root@localhost ~]# yum install vsftpd -y[root@localhost ~]# systemctl restart vsftpd[root@localhost ~]# systemctl enable vsftpdCreated symlink from /etc/systemd/system/multi-user.target.wants/vsftpd.service to /usr/lib/systemd/system/vsftpd.service.[root@localhost ~]# 在确认系统光盘镜像已经正常挂载到/media/cdrom目录后，把目录中的光盘镜像文件全部复制到vsftpd服务程序的工作目录中。并且添加防火墙策略和设置SELinux安全上下文 12[root@localhost ~]# cp -r /media/cdrom/* /var/ftp/[root@localhost ~]# setsebool -P ftpd_connect_all_unreserved=on 创建KickStart应答文件 Kickstart应答文件中包含了系统安装过程中需要使用的选项和参数信息，系统可以自动调取这个应答文件的内容，从而彻底实现了无人值守安装系统。 在root管理员的家目录中有一个名为anaconda-ks.cfg的文件，它就是应答文件。下面将这个文件复制到vsftpd服务程序的工作目录中（在开机选项菜单的配置文件中已经定义了该文件的获取路径，也就是vsftpd服务程序数据目录中的pub子目录中）。使用chmod命令设置该文件的权限，确保所有人都有可读的权限，以保证客户端主机可以顺利获取到应答文件及里面的内容 123[root@localhost ~]# cp ~/anaconda-ks.cfg /var/ftp/pub/ks.cfg[root@localhost ~]# chmod +r /var/ftp/pub/ks.cfg [root@localhost ~]# 注意，既然应答文件ks.cfg 来自于Server的anaconda-ks.cfg文件，那么之后的客户机装好后root密码和Server的是一样的。 修改这个文件，root密码就不改了，就和Server用一样的吧 123[root@localhost ~]# vi /var/ftp/pub/ks.cfg 5行 url --url=ftp://192.168.10.10 //删除原本的cdrom，把镜像来源定位到Server上30行 clearpart --all --initlabel //意思是清空所有磁盘内容并初始化磁盘 如果觉得系统默认自带的应答文件参数较少，不能满足生产环境的需求，则可以通过Yum软件仓库来安装system-config-kickstart软件包。这是一款图形化的Kickstart应答文件生成工具，可以根据自己的需求生成自定义的应答文件，然后将生成的文件放到/var/ftp/pub目录中并将名字修改为ks.cfg即可。 开启一台没有安装系统的虚拟机（内存至少大于等于2G） 选择否 下图中敲完回车不要急，等~ 可以看到自动安装已经开始了，咱们不用去动它，它自己会装好的，我们耐心等待即可 ​ 它自动给root设置了密码，就是我们之前提到的，和Server一样的root密码。我们不用进行任何操作，等，等蛮久的，等吧~ 终于等到它完成了，点击重启 重启后，用root以及Server的root密码来登录客户机： 可以看到登录成功！ Server关机后保存好快照，以后咱们装新的虚拟机可以找开启Server后关掉防火墙和selinux后，让它自动安装系统。 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-23 MariaDB数据库管理系统]]></title>
    <url>%2Flinux-23%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-23 MariaDB数据库管理系统概念解析MariaDB数据库管理系统初始化MariaDB数据库安装和初始化mariadb数据库服务 12345678[root@localhost ~]# yum -y install mariadb mariadb-server[root@localhost ~]# systemctl restart mariadb[root@localhost ~]# systemctl enable mariadbCreated symlink from /etc/systemd/system/multi-user.target.wants/mariadb.service to /usr/lib/systemd/system/mariadb.service.[root@localhost ~]# firewall-cmd --add-port=3306/tcp --permanent success[root@localhost ~]# firewall-cmd --reloadsuccess 初始化数据库 设置root管理员在数据库中的密码值（注意，该密码并非root管理员在系统中的密码，这里的密码值默认应该为空，可直接按回车键）。 设置root管理员在数据库中的专有密码。 随后删除匿名账户，并使用root管理员从远程登录数据库，以确保数据库上运行的业务的安全性。 删除默认的测试数据库，取消测试数据库的一系列访问权限。 刷新授权列表，让初始化的设定立即生效。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[root@localhost ~]# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&apos;ll need the currentpassword for the root user. If you&apos;ve just installed MariaDB, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] yNew password: Re-enter new password: Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from &apos;localhost&apos;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] y ... Success!By default, MariaDB comes with a database named &apos;test&apos; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you&apos;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB![root@localhost ~]# 登录数据库 1234567891011[root@localhost ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 13Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; 查看数据库 123456789MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema |+--------------------+3 rows in set (0.00 sec) 修改当前用户的密码 1234MariaDB [(none)]&gt; set password = password(&apos;123456&apos;);Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; 管理账户及授权创建一个用户并设置密码 1234567MariaDB [(none)]&gt; create user aaa@localhost identified by &apos;123456&apos; -&gt; ;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; 注意，这里我是忘了敲分号，不过第二行补敲也是可以的。 查看这个用户的指定属性 1234567891011121314MariaDB [(none)]&gt; use mysqlReading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [mysql]&gt; select Host,User,Password from user where User= &apos;aaa&apos;;+-----------+------+-------------------------------------------+| Host | User | Password |+-----------+------+-------------------------------------------+| localhost | aaa | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |+-----------+------+-------------------------------------------+1 row in set (0.00 sec)MariaDB [mysql]&gt; 为用户赋予权限grant命令用于为账户进行授权 命令 作用 GRANT 权限 ON 数据库.表单名称 TO 账户名@主机名 对某个特定数据库中的特定表单给予授权 GRANT权限ON数据库.*TO账户名@主机名 对某个特定数据库中的所有表单给予授权 GRANT权限ON.TO账户名@主机名 对所有数据库及所有表单给予授权 GRANT权限1,权限2 ON 数据库.*TO账户名@主机名 对某个数据库中的所有表单给予多个授权 GRANT ALL PRIVILEGES ON .TO账户名@主机名 对所有数据库及所有表单给予全部授权（需谨慎操作） 为用户aaa授予增、删、改、查的权限 12345678910111213MariaDB [mysql]&gt; grant select,update,insert on mysql.user to aaa@localhost;Query OK, 0 rows affected (0.00 sec)MariaDB [mysql]&gt; show grants for aaa@localhost;+------------------------------------------------------------------------------------------------------------+| Grants for aaa@localhost |+------------------------------------------------------------------------------------------------------------+| GRANT USAGE ON *.* TO &apos;aaa&apos;@&apos;localhost&apos; IDENTIFIED BY PASSWORD &apos;*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9&apos; || GRANT SELECT, INSERT, UPDATE ON `mysql`.`user` TO &apos;aaa&apos;@&apos;localhost&apos; |+------------------------------------------------------------------------------------------------------------+2 rows in set (0.00 sec)MariaDB [mysql]&gt; 移除aaa用户增、删、改、查的权限 12345678910MariaDB [mysql]&gt; revoke select,update,insert on mysql.user from aaa@localhost;Query OK, 0 rows affected (0.00 sec)MariaDB [mysql]&gt; show grants for aaa@localhost;+------------------------------------------------------------------------------------------------------------+| Grants for aaa@localhost |+------------------------------------------------------------------------------------------------------------+| GRANT USAGE ON *.* TO &apos;aaa&apos;@&apos;localhost&apos; IDENTIFIED BY PASSWORD &apos;*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9&apos; |+------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 创建数据库与表单 命令 作用 CREATE DATABASE 数据库名称 创建新的数据库 DESCRIBE 表单名称 描述表单 UPDATE表单名称SET attribute=新值WHERE attribute&gt;原始值 更新表单中的数据 USE数据库名称 指定使用的数据库 SHOW databases 显示当前已有的数据库 SHOW tables 显示当前数据库中的表单 SELECT * FROM表单名称 从表单中选中某个记录值 DELETE FROM表单名WHERE attribute=值 从表单中删除某个记录值 创建数据库123456789101112131415MariaDB [mysql]&gt; create database DBaaa;Query OK, 1 row affected (0.00 sec)MariaDB [mysql]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || DBaaa || mysql || performance_schema |+--------------------+4 rows in set (0.01 sec)MariaDB [mysql]&gt; 使用这个库以及在新建的库里新建数据表，并且查询新建表的结构 1234567891011121314151617181920MariaDB [mysql]&gt; use DBaaa;Database changedMariaDB [DBaaa]&gt; create table student( -&gt; name char(15), -&gt; school char(15), -&gt; age int -&gt; );Query OK, 0 rows affected (0.00 sec)MariaDB [DBaaa]&gt; desc student;+--------+----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+----------+------+-----+---------+-------+| name | char(15) | YES | | NULL | || school | char(15) | YES | | NULL | || age | int(11) | YES | | NULL | |+--------+----------+------+-----+---------+-------+3 rows in set (0.00 sec)MariaDB [DBaaa]&gt; 管理表单及数据——增删改查插入一条学生信息（增） 123456789101112131415MariaDB [DBaaa]&gt; select * from student;Empty set (0.00 sec)MariaDB [DBaaa]&gt; insert into student(name,school,age) values(&apos;zhangsan&apos;,&apos;beida&apos;,18);Query OK, 1 row affected (0.00 sec)MariaDB [DBaaa]&gt; select * from student;+----------+--------+------+| name | school | age |+----------+--------+------+| zhangsan | beida | 18 |+----------+--------+------+1 row in set (0.00 sec)MariaDB [DBaaa]&gt; 修改这条信息（改）如果数据库里只有这一个人，我们可以这样修改他的信息，即修改所有成员的年龄为20 12345678910111213MariaDB [DBaaa]&gt; update student set age=20;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0MariaDB [DBaaa]&gt; select * from student;+----------+--------+------+| name | school | age |+----------+--------+------+| zhangsan | beida | 20 |+----------+--------+------+1 row in set (0.00 sec)MariaDB [DBaaa]&gt; 如果数据库里不只这一个人，如下，我们再加几个，然后我们可以这样修改他的信息，即针对某个人修改其年龄。 123456789101112131415161718192021222324252627282930313233343536MariaDB [DBaaa]&gt; insert into student(name,school,age) values(&apos;lisi&apos;,&apos;qinghua&apos;,16);Query OK, 1 row affected (0.00 sec)MariaDB [DBaaa]&gt; insert into student(name,school,age) values(&apos;wangwu&apos;,&apos;fudan&apos;,17);Query OK, 1 row affected (0.00 sec)MariaDB [DBaaa]&gt; insert into student(name,school,age) values(&apos;zhaoliu&apos;,&apos;zheda&apos;,19);Query OK, 1 row affected (0.00 sec)MariaDB [DBaaa]&gt; select * from student;+----------+---------+------+| name | school | age |+----------+---------+------+| zhangsan | beida | 20 || lisi | qinghua | 16 || wangwu | fudan | 17 || zhaoliu | zheda | 19 |+----------+---------+------+4 rows in set (0.00 sec)MariaDB [DBaaa]&gt; update student set age=50 where name=&apos;zhangsan&apos;;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0MariaDB [DBaaa]&gt; select * from student;+----------+---------+------+| name | school | age |+----------+---------+------+| zhangsan | beida | 50 || lisi | qinghua | 16 || wangwu | fudan | 17 || zhaoliu | zheda | 19 |+----------+---------+------+4 rows in set (0.00 sec)MariaDB [DBaaa]&gt; 删除数据库的信息（删）如果数据库里不只有一个人，我们可以这样删除他的信息，即针对某个人删除其信息 12345678910111213141516171819202122232425MariaDB [DBaaa]&gt; select * from student;+----------+---------+------+| name | school | age |+----------+---------+------+| zhangsan | beida | 50 || lisi | qinghua | 16 || wangwu | fudan | 17 || zhaoliu | zheda | 19 |+----------+---------+------+4 rows in set (0.00 sec)MariaDB [DBaaa]&gt; delete from student where name=&apos;zhangsan&apos;;Query OK, 1 row affected (0.00 sec)MariaDB [DBaaa]&gt; select * from student;+---------+---------+------+| name | school | age |+---------+---------+------+| lisi | qinghua | 16 || wangwu | fudan | 17 || zhaoliu | zheda | 19 |+---------+---------+------+3 rows in set (0.00 sec)MariaDB [DBaaa]&gt; 一次性删除所有表项： 1234567891011121314151617MariaDB [DBaaa]&gt; select * from student;+---------+---------+------+| name | school | age |+---------+---------+------+| lisi | qinghua | 16 || wangwu | fudan | 17 || zhaoliu | zheda | 19 |+---------+---------+------+3 rows in set (0.00 sec)MariaDB [DBaaa]&gt; delete from student;Query OK, 3 rows affected (0.00 sec)MariaDB [DBaaa]&gt; select * from student;Empty set (0.00 sec)MariaDB [DBaaa]&gt; 数据表中插入多条信息 1234567891011121314151617181920212223MariaDB [DBaaa]&gt; select * from student;Empty set (0.00 sec)MariaDB [DBaaa]&gt; insert into student(name,school,age) values(&apos;lisi&apos;,&apos;qinghua&apos;,16);Query OK, 1 row affected (0.00 sec)MariaDB [DBaaa]&gt; insert into student(name,school,age) values(&apos;wangwu&apos;,&apos;fudan&apos;,17);Query OK, 1 row affected (0.00 sec)MariaDB [DBaaa]&gt; insert into student(name,school,age) values(&apos;zhaoliu&apos;,&apos;zheda&apos;,19);Query OK, 1 row affected (0.00 sec)MariaDB [DBaaa]&gt; select * from student;+---------+---------+------+| name | school | age |+---------+---------+------+| lisi | qinghua | 16 || wangwu | fudan | 17 || zhaoliu | zheda | 19 |+---------+---------+------+3 rows in set (0.00 sec)MariaDB [DBaaa]&gt; 查询数据库中的数据——查​ 查找某条信息，要想让查询结果更加精准，就需要结合使用select与where命令了。其中，where命令是在数据库中进行匹配查询的条件命令。通过设置查询条件，就可以仅查找出符合该条件的数据 参数 作用 = 相等 &lt;&gt;或!= 不相等 &gt; 大于 &lt; 小于 &gt;= 大于或等于 &lt;= 小于或等于 BETWEEN 在某个范围内 LIKE 搜索一个例子 IN 在列中搜索多个值 123456789101112131415161718192021222324252627282930MariaDB [DBaaa]&gt; select * from student;+---------+---------+------+| name | school | age |+---------+---------+------+| lisi | qinghua | 16 || wangwu | fudan | 17 || zhaoliu | zheda | 19 |+---------+---------+------+3 rows in set (0.00 sec)MariaDB [DBaaa]&gt; select * from student where age&lt;18;+--------+---------+------+| name | school | age |+--------+---------+------+| lisi | qinghua | 16 || wangwu | fudan | 17 |+--------+---------+------+2 rows in set (0.00 sec)MariaDB [DBaaa]&gt; select * from student where age&gt;18;+---------+--------+------+| name | school | age |+---------+--------+------+| zhaoliu | zheda | 19 |+---------+--------+------+1 row in set (0.00 sec)MariaDB [DBaaa]&gt; exitBye[root@localhost ~]# 数据库的备份和恢复mysqldump命令用于备份数据库数据，格式为“mysqldump [参数] [数据库名称]”。 其中参数与mysql命令大致相同，-u参数用于定义登录数据库的账户名称，-p参数代表密码提示符 123[root@localhost ~]# mysqldump -u root -p DBaaa &gt; /root/DBaaa.dumpEnter password: [root@localhost ~]# 尝试删除eagleslab数据库，然后再恢复 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[root@localhost ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 15Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; drop database DBaaa;Query OK, 1 row affected (0.01 sec)MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema |+--------------------+3 rows in set (0.00 sec)删完库，我们给它加回来，但是事实上加回来的只是一个空壳MariaDB [(none)]&gt; create database DBaaa;Query OK, 1 row affected (0.00 sec)MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || DBaaa || mysql || performance_schema |+--------------------+4 rows in set (0.00 sec)MariaDB [(none)]&gt; use DBaaa;Database changedMariaDB [DBaaa]&gt; select * from student;ERROR 1146 (42S02): Table &apos;DBaaa.student&apos; doesn&apos;t existMariaDB [DBaaa]&gt; exitBye[root@localhost ~]# 可以看到这个空壳数据库里，并没有student表。 将刚刚备份的文件导入数据库 12345678910111213141516171819202122232425262728293031323334353637383940[root@localhost ~]# mysql -u root -p DBaaa &lt; /root/DBaaa.dump Enter password: [root@localhost ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 18Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; use DBaaa;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [DBaaa]&gt; show tables;+-----------------+| Tables_in_DBaaa |+-----------------+| student |+-----------------+1 row in set (0.00 sec)MariaDB [DBaaa]&gt; select * from student;+---------+---------+------+| name | school | age |+---------+---------+------+| lisi | qinghua | 16 || wangwu | fudan | 17 || zhaoliu | zheda | 19 |+---------+---------+------+3 rows in set (0.00 sec)MariaDB [DBaaa]&gt; exitBye[root@localhost ~]# 可以看到我们的数据恢复成功了。 数据库密码泄露不安全的数据库登录方式： 1mysql -uroot -p123456 ​ 这种登录方式可以用history 查看到数据库账户密码，是极不安全的 1234567891011121314151617181920[root@localhost ~]# mysql -uroot -p123456Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 20Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; exitBye[root@localhost ~]# history 1 87 history 1[root@localhost ~]# history 3 86 mysql -uroot -p123456 87 history 1 88 history 3[root@localhost ~]# 注意，history后面的参数是显示历史命令的条数。 建议还是用正常的mysql -u root -p 再输入看不见的密码比较好 1234567891011121314151617181920212223242526272829303132333435363738[root@localhost ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 23Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; create user bbb@localhost identified by &apos;123456&apos; -&gt; ;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [mysql]&gt; select Host,User,Password from user where User= &apos;bbb&apos;;+-----------+------+-------------------------------------------+| Host | User | Password |+-----------+------+-------------------------------------------+| localhost | bbb | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |+-----------+------+-------------------------------------------+1 row in set (0.00 sec)MariaDB [mysql]&gt; MariaDB [mysql]&gt; exitBye[root@localhost ~]# history 2 89 mysql -u root -p 90 history 2[root@localhost ~]# 如上，使用history看不到密码，进到mysql里查看bbb的密码也只是乱码。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-22 iSCSI网络存储服务]]></title>
    <url>%2Flinux-22%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-22 iSCSI网络存储服务概念解析 iSCSI（Internet Small Computer System Interface，发音为/ˈаɪskʌzi/），Internet小型计算机系统接口，又称为IP-SAN，是一种基于因特网及SCSI-3协议下的存储技术，由IETF提出，并于2003年2月11日成为正式的标准。 ​ iSCSI利用了TCP/IP的port 860 和 3260 作为沟通的渠道。透过两部计算机之间利用iSCSI的协议来交换SCSI命令，让计算机可以透过高速的局域网集线来把SAN模拟成为本地的储存装置。 iSCSI使用 TCP/IP 协议（一般使用TCP端口860和3260）。 本质上，iSCSI 让两个主机通过 IP 网络相互协商然后交换SCSI命令。这样一来，iSCSI 就是用广域网仿真了一个常用的高性能本地存储总线，从而创建了一个存储局域网（SAN）。 ​ SCSI 小型计算机系统接口（英语：Small Computer System Interface; 简写：SCSI），一种用于计算机和智能设备之间的系统级接口的独立处理器标准。 SCSI是一种智能的通用接口标准。 为了进一步提升硬盘存储设备的读写速度和性能，人们一直在努力改进物理硬盘设备的接口协议。当前的硬盘接口类型主要有IDE、SCSI和SATA这3种。 IDE是一种成熟稳定、价格便宜的并行传输接口。 SATA是一种传输速度更快、数据校验更完整的串行传输接口。 SCSI是一种用于计算机和硬盘、光驱等设备之间系统级接口的通用标准，具有系统资源占用率低、转速高、传输速度快等优点。 不论使用什么类型的硬盘接口，硬盘上的数据总是要通过计算机主板上的总线与CPU、内存设备进行数据交换，这种物理环境上的限制给硬盘资源的共享带来了各种不便。后来，IBM公司开始动手研发基于TCP/IP协议和SCSI接口协议的新型存储技术，这也就是我们目前能看到的互联网小型计算机系统接口（iSCSI，Internet Small Computer System Interface）。这是一种将SCSI接口与以太网技术相结合的新型存储技术，可以用来在网络中传输SCSI接口的命令和数据。这样，不仅克服了传统SCSI接口设备的物理局限性，实现了跨区域的存储资源共享，还可以在不停机的状态下扩展存储容量。 为了让各位读者做到知其然，知其所以然，以便在工作中灵活使用这项技术，下面将讲解一下iSCSI技术在生产环境中的优势和劣势。首先，iSCSI存储技术非常便捷，在访问存储资源的形式上发生了很大变化，摆脱了物理环境的限制，同时还可以把存储资源分给多个服务器共同使用，因此是一种非常推荐使用的存储技术。但是，iSCSI存储技术受到了网速的制约。以往，硬盘设备直接通过主板上的总线进行数据传输，现在则需要让互联网作为数据传输的载体和通道，因此传输速率和稳定性是iSCSI技术的瓶颈。随着网络技术的持续发展，相信iSCSI技术也会随之得以改善。 既然要通过以太网来传输硬盘设备上的数据，那么数据是通过网卡传入到计算机中的么？这就有必要向大家介绍iSCSI-HBA卡了（见图17-1）。与一般的网卡不同（连接网络总线和内存，供计算机上网使用），iSCSI-HBA卡连接的则是SCSI接口或FC（光纤通道）总线和内存，专门用于在主机之间交换存储数据，其使用的协议也与一般网卡有本质的不同。运行Linux系统的服务器会基于iSCSI协议把硬盘设备命令与数据打包成标准的TCP/IP数据包，然后通过以太网传输到目标存储设备，而当目标存储设备接收到这些数据包后，还需要基于iSCSI协议把TCP/IP数据包解压成硬盘设备命令与数据。 iSCSI网络存储服务创建一个raid磁盘阵列添加4个硬盘 开机，检查硬盘是否添加成功 1234567[root@localhost ~]# ll /dev/sd?brw-rw----. 1 root disk 8, 0 Feb 7 07:08 /dev/sdabrw-rw----. 1 root disk 8, 16 Feb 7 07:08 /dev/sdbbrw-rw----. 1 root disk 8, 32 Feb 7 07:08 /dev/sdcbrw-rw----. 1 root disk 8, 48 Feb 7 07:08 /dev/sddbrw-rw----. 1 root disk 8, 64 Feb 7 07:08 /dev/sde[root@localhost ~]# 创建raid阵列 12345678910111213[root@localhost ~]# yum install mdadm.x86_64 -y[root@localhost ~]# mdadm -Cv /dev/md0 -n 3 -l 5 -x 1 /dev/sd&#123;b,c,d,e&#125;[root@localhost ~]# mdadm -D /dev/md0 /dev/md0: Version : 1.2 Creation Time : Sat Sep 22 14:06:23 2018 Raid Level : raid5 Array Size : 41908224 (39.97 GiB 42.91 GB) Used Dev Size : 20954112 (19.98 GiB 21.46 GB) Raid Devices : 3 Total Devices : 4 Persistence : Superblock is persistent ……………………………………………………………………………………………………略 配置ISCSI服务安装iscsi服务端、iscsi初始化和配置服务所需的工具 1[root@localhost ~]# yum -y install targetd targetcli iscsi-initiator-utils 开启并设置iscsi服务开机启动 1234[root@localhost ~]# systemctl start targetd[root@localhost ~]# systemctl enable targetdCreated symlink from /etc/systemd/system/multi-user.target.wants/targetd.service to /usr/lib/systemd/system/targetd.service.[root@localhost ~]# 进入交互式iSCSI子系统配置iSCSI服务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[root@localhost ~]# targetcliWarning: Could not load preferences file /root/.targetcli/prefs.bin.targetcli shell version 2.1.fb46Copyright 2011-2013 by Datera, Inc and others.For help on commands, type &apos;help&apos;./&gt; lso- / ............................................................................. [...] o- backstores .................................................................. [...] | o- block ...................................................... [Storage Objects: 0] | o- fileio ..................................................... [Storage Objects: 0] | o- pscsi ...................................................... [Storage Objects: 0] | o- ramdisk .................................................... [Storage Objects: 0] o- iscsi ................................................................ [Targets: 0] o- loopback ............................................................. [Targets: 0] # 为ISCSI服务提供资源池 /&gt; cd /backstores/block /backstores/block&gt; create disk0 /dev/md0Created block storage object disk0 using /dev/md0./backstores/block&gt; cd //&gt; lso- / ............................................................................. [...] o- backstores .................................................................. [...] | o- block ...................................................... [Storage Objects: 1] | | o- disk0 ............................. [/dev/md0 (40.0GiB) write-thru deactivated] | | o- alua ....................................................... [ALUA Groups: 1] | | o- default_tg_pt_gp ........................... [ALUA state: Active/optimized] | o- fileio ..................................................... [Storage Objects: 0] | o- pscsi ...................................................... [Storage Objects: 0] | o- ramdisk .................................................... [Storage Objects: 0] o- iscsi ................................................................ [Targets: 0] o- loopback ............................................................. [Targets: 0] # 为iSCSI服务提供主机提供一个主机名，敲完create后将下面的iqn复制下来/&gt; cd iscsi/iscsi&gt; createCreated target iqn.2003-01.org.linux-iscsi.localhost.x8664:sn.70683bd3ee6d.Created TPG 1.Global pref auto_add_default_portal=trueCreated default portal listening on all IPs (0.0.0.0), port 3260.这里cd的就是上面复制下来的iqn/iscsi&gt; cd iqn.2003-01.org.linux-iscsi.localhost.x8664:sn.70683bd3ee6d# 为客户机划分出lun提供存储资源/iscsi/iqn.20....70683bd3ee6d&gt; cd tpg1/luns /iscsi/iqn.20...e6d/tpg1/luns&gt; create /backstores/block/disk0 Created LUN 0./iscsi/iqn.20...e6d/tpg1/luns&gt; cd ..# 设置允许访问服务器控制访问列表，这里的iqn是linux客户端装完iscsi-initiator-utils之后在/etc/iscsi/initiatorname.iscsi 文件中得到的客户机iqn，注意不是上面用过的iqn，为了与之前那个iqn区分，咱们称呼它为iqn2吧。如下图：/iscsi/iqn.20...3bd3ee6d/tpg1&gt; cd acls/iscsi/iqn.20...e6d/tpg1/acls&gt; create iqn.1994-05.com.redhat:0191b6bea67Created Node ACL for iqn.1994-05.com.redhat:0191b6bea67Created mapped LUN 0./iscsi/iqn.20...e6d/tpg1/acls&gt; exitGlobal pref auto_save_on_exit=trueConfiguration saved to /etc/target/saveconfig.json[root@localhost ~]# 咱们在XShell那里复制一个会话，在新的窗口复制下来新的iqn作为iqn2，然后回到原来那个窗口即可粘贴使用。 防火墙放行服务端的3260端口 12345[root@localhost ~]# firewall-cmd --add-port=3260/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# 现在再开一台linux虚拟机作为测试用的客户机，这里以client2为例： Linux客户机挂载服务端上的ISCSI硬盘 1234567891011121314151617181920212223242526[root@localhost ~]# yum -y install iscsi-initiator-utils[root@localhost ~]# vi /etc/iscsi/initiatorname.iscsi 这里将其iqn修改为咱们刚刚复制的iqn2InitiatorName=iqn.1994-05.com.redhat:0191b6bea67保存退出，重启iscsid服务[root@localhost ~]# systemctl restart iscsid[root@localhost ~]# systemctl enable iscsidCreated symlink from /etc/systemd/system/multi-user.target.wants/iscsid.service to /usr/lib/systemd/system/iscsid.service.[root@localhost ~]# # 没有挂载之前我们只有一块硬盘[root@localhost ~]# ll /dev/sd?brw-rw----. 1 root disk 8, 0 2月 7 22:18 /dev/sda[root@localhost ~]# 挂载，再次检查，发现多出来一块硬盘，第二块就是我们挂载上来的iscsi硬盘（这里192.168.141.12是iscsi服务器的ip）[root@localhost ~]# iscsiadm -m discovery -t st -p 192.168.141.12 --login192.168.141.12:3260,1 iqn.2003-01.org.linux-iscsi.localhost.x8664:sn.70683bd3ee6dLogging in to [iface: default, target: iqn.2003-01.org.linux-iscsi.localhost.x8664:sn.70683bd3ee6d, portal: 192.168.141.12,3260] (multiple)Login to [iface: default, target: iqn.2003-01.org.linux-iscsi.localhost.x8664:sn.70683bd3ee6d, portal: 192.168.141.12,3260] successful.[root@localhost ~]# ll /dev/sd?brw-rw----. 1 root disk 8, 0 2月 7 22:18 /dev/sdabrw-rw----. 1 root disk 8, 16 2月 7 22:31 /dev/sdb[root@localhost ~]# windows客户机挂载iSCSI首先，先看看我电脑本来有几个硬盘： 可以看到，本来我的电脑只有俩硬盘，一会咱们挂载成功后，理论上会多出一个硬盘来。 打开windows自带的iSCSI发起程序，在windows10搜索栏即可搜索 目标填上IP地址，选择快速连接点击完成（这里我已经连过一次了，下面那个可以不管，也可以刷新一下即可） 为了能连接上，修改配置中的客户端名，修改成之前我们所谓的iqn2 改完以后选择连接 显示已连接 现在再次看看我电脑上有几个硬盘： 我刚打开，就跳出个消息，说是要让我初始化磁盘2，点击确定即可，如下图： 现在将磁盘管理全屏显示（太小了磁盘2就被遮住了），如下图： 如上图，多出来的磁盘2就是咱们挂载上去的磁盘了。 右键磁盘2，新建简单卷，然后一直点击下一步即可建成。 接下来我们打开文件资源管理器，如下图，可以看到一个新加卷： 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-21 Squid部署代理缓存服务]]></title>
    <url>%2Flinux-21%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-21 Squid部署代理缓存服务概念解析Squid Squid是一个高性能的代理缓存服务器，Squid支持FTP、gopher、HTTPS和HTTP协议。和一般的代理缓存软件不同，Squid用一个单独的、非模块化的、I/O驱动的进程来处理所有的客户端请求。 Squid是一种用来缓冲Internet数据的软件。它是这样实现其功能的，接受来自人们需要下载的目标（object）的请求并适当地处理这些请求。也就是说，如果一个人想下载一web页面，他请求Squid为他取得这个页面。Squid随之连接到远程服务器（比如：http://squid.nlanr.net）并向这个页面发出请求。然后，Squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时，Squid可以简单地从磁盘中读到它，那样数据迅即就会传输到客户机上。当前的Squid可以处理HTTP，FTP，GOPHER，SSL和WAIS等协议。但它不能处理如POP，NNTP，RealAudio以及其它类型的东西。 squid分类按照代理类型的不同，可以将Squid代理分为正向代理和反向代理。 正向代理：根据实现方式的不同，又可以分为普通代理和透明代理。 1）普通代理：需要客户机在浏览器中指定代理服务器的地址、端口； 2）透明代理：适用于企业的网关主机（共享接入Internet）中，客户机不需要指定代理服务器地址、端口等信息，代理服务器需要设置防火墙策略将客户机的Web访问数据转交给代理服务程序处理； 反向代理：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 ​ ​ 代理服务器英文全称是Proxy Server，其功能就是代理网络用户去取得网络信息。 ​ Squid是一个缓存Internet 数据的软件，其接收用户的下载申请，并自动处理所下载的数据。当一个用户想要下载一个主页时，可以向Squid 发出一个申请，要Squid 代替其进行下载，然后Squid 连接所申请网站并请求该主页，接着把该主页传给用户同时保留一个备份，当别的用户申请同样的页面时，Squid 把保存的备份立即传给用户，使用户觉得速度相当快。Squid 可以代理HTTP、FTP、GOPHER、SSL和WAIS等协议并且Squid 可以自动地进行处理，可以根据自己的需要设置Squid，使之过滤掉不想要的东西。 Squid代理服务器工作在TCP/IP的应用层： 实验准备工作实验原理 我们需要两台虚拟机，一台是win10操作系统作为客户端，另一台我们新安装一个Centos 7的虚拟机Server。配置好虚拟机Server后，将Server作为客户端win10的代理服务器，从而让win10能够上网。为了大家能完全理解虚拟机通信原理，我这里将整体上的网络结构拓扑图画出来，如下图： ​ 在之前的文章中，我们讲解过网络适配器三种模式的工作原理，本次实验设置如下： 设置1.虚拟机Server 2.虚拟机WIN10 3.VMware Workstation Pro设置 ​ 点击图中更改设置即可更改，这里放出的图是改好后的图。 通信原理 结合下图，我们的Server网卡1和WIN10 的网卡均是仅主机模式的，所以对应的，他们的ip自然是由VMnet1的虚拟DHCP服务器来分配。我们的Server网卡2是桥接模式的，相当于用一个交换机连着我们电脑的真实电脑，所以我们现在用着的物理机的ip和Server网卡2的ip均由我们的家用路由器分配。我们去到别人家里，连上别人家wifi，就会得到一个ip地址，仔细看的话就会发现家用路由器分配给我们的都是192.168.1.X的ip，在这里也是这个道理。 对了，有一次我将虚拟机网卡设置为桥接模式之后，开机查看ip发现ip竟然不是192.168.1.X了，而是一个奇怪的ip。我当时想了很久也没发现问题，难道是电脑抽风了？后来才想起来，我家断网了，我临时连着的是手机热点，真是很尴尬。 ​ 如下图，由于虚拟机WIN10是仅主机模式的，所以它要访问NET外网，其数据就必须从Server那里经过。 查看本机ip（虚拟机win10） 1C:\Users\zhong&gt;ipconfig 查看Server的ip 1[root@localhost ~]# ip add 由上面两张图我们得知了虚拟机WIN10的ip是192.168.23.53 虚拟机Server的ip分别是192.168.23.52和192.168.1.106 为了实验更加清晰明了，我们把分配好的ip加到拓扑图里，新的拓扑图如下： 保存快照 实验到这里，基本准备已经准备好，记住一定要给上述虚拟机Server关机保存快照，这个快照的名字就叫做“快照1”，待会我们做透明代理实验的时候恢复成这个快照再做。虚拟机WIN10就可以不用弄快照了，反正是测试用的，配置少得可怜。 配置Squid服务程序 检查虚拟机WIN10是否可以和Server通信，这里要注意的是，不同网段不能ping通，同一网段可以ping通，如下图： 检查Server是否可以连接外网和ping通虚拟机WIN10（ping需要手动用ctrl+c打断） 123456789101112131415161718[root@localhost ~]# ping baidu.comPING baidu.com (123.125.115.110) 56(84) bytes of data.64 bytes from 123.125.115.110 (123.125.115.110): icmp_seq=1 ttl=51 time=45.7 ms64 bytes from 123.125.115.110 (123.125.115.110): icmp_seq=2 ttl=51 time=45.8 ms64 bytes from 123.125.115.110 (123.125.115.110): icmp_seq=3 ttl=51 time=101 ms^C--- baidu.com ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2002msrtt min/avg/max/mdev = 45.774/64.315/101.284/26.141 ms[root@localhost ~]# ping 192.169.23.53PING 192.169.23.53 (192.169.23.53) 56(84) bytes of data.^C--- 192.169.23.53 ping statistics ---3 packets transmitted, 0 received, 100% packet loss, time 2001ms[root@localhost ~]# 可以看到，Server可以ping通外网，但是无法ping 虚拟机WIN10的时候没有响应。然鹅，奇怪的是，虚拟机WIN10可以ping通它而它能不能ping通WIN10，其实这是系统差异导致的，对本实验没有影响，Server无法ping通虚拟机WIN10那就ping不通吧，我们往下继续做实验。实验结束后，我们再解析如何让它可以ping通虚拟机WIN10。 安装squid程序，并查看配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384[root@localhost ~]# yum install squid -y[root@localhost ~]# ls /etc/squid/cachemgr.conf errorpage.css mime.conf squid.confcachemgr.conf.default errorpage.css.default mime.conf.default squid.conf.default[root@localhost ~]# [root@localhost ~]# cat /etc/squid/squid.conf以下为其配置文件内容：## Recommended minimum configuration:## Example rule allowing access from your local networks.# Adapt to list your (internal) IP networks from where browsing# should be allowedacl localnet src 10.0.0.0/8 # RFC1918 possible internal networkacl localnet src 172.16.0.0/12 # RFC1918 possible internal networkacl localnet src 192.168.0.0/16 # RFC1918 possible internal networkacl localnet src fc00::/7 # RFC 4193 local private network rangeacl localnet src fe80::/10 # RFC 4291 link-local (directly plugged) machinesacl SSL_ports port 443acl Safe_ports port 80 # httpacl Safe_ports port 21 # ftpacl Safe_ports port 443 # httpsacl Safe_ports port 70 # gopheracl Safe_ports port 210 # waisacl Safe_ports port 1025-65535 # unregistered portsacl Safe_ports port 280 # http-mgmtacl Safe_ports port 488 # gss-httpacl Safe_ports port 591 # filemakeracl Safe_ports port 777 # multiling httpacl CONNECT method CONNECT## Recommended minimum Access Permission configuration:## Deny requests to certain unsafe portshttp_access deny !Safe_ports# Deny CONNECT to other than secure SSL portshttp_access deny CONNECT !SSL_ports# Only allow cachemgr access from localhosthttp_access allow localhost managerhttp_access deny manager# We strongly recommend the following be uncommented to protect innocent# web applications running on the proxy server who think the only# one who can access services on &quot;localhost&quot; is a local user#http_access deny to_localhost## INSERT YOUR OWN RULE(S) HERE TO ALLOW ACCESS FROM YOUR CLIENTS## Example rule allowing access from your local networks.# Adapt localnet in the ACL section to list your (internal) IP networks# from where browsing should be allowedhttp_access allow localnethttp_access allow localhost# And finally deny all other access to this proxyhttp_access deny all# Squid normally listens to port 3128http_port 3128# Uncomment and adjust the following to add a disk cache directory.#cache_dir ufs /var/spool/squid 100 16 256# Leave coredumps in the first cache dircoredump_dir /var/spool/squid## Add any of your own refresh_pattern entries above these.#refresh_pattern ^ftp: 1440 20% 10080refresh_pattern ^gopher: 1440 0% 1440refresh_pattern -i (/cgi-bin/|\?) 0 0% 0refresh_pattern . 0 20% 4320[root@localhost ~]# 可以看到其监听的端口号为3128，一会我们设置客户端代理的时候要用到！ 参数 作用 http_port 3128 监听的端口号 cache_mem 64M 内存缓冲区的大小 cache_dir ufs /var/spool/squid 2000 16 256 硬盘缓冲区的大小 cache_effective_user squid 设置缓存的有效用户 cache_effective_group squid 设置缓存的有效用户组 dns_nameservers [IP地址] 一般不设置，而是用服务器默认的DNS地址 cache_access_log /var/log/squid/access.log 访问日志文件的保存路径 cache_log /var/log/squid/cache.log 缓存日志文件的保存路径 visible_hostname linuxprobe.com 设置Squid服务器的名称 正向代理开启ip forward（路由转发） 1234567891011121314151617181920[root@localhost ~]# echo &quot;net.ipv4.ip_forward = 1&quot; &gt;&gt;/usr/lib/sysctl.d/50-default.conf[root@localhost ~]# grep ip_forward /usr/lib/sysctl.d/50-default.confnet.ipv4.ip_forward = 1[root@localhost ~]# sysctl -a | grep -w ip_forwardsysctl: reading key &quot;net.ipv6.conf.all.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.default.stable_secret&quot;net.ipv4.ip_forward = 0 #0表示未开启sysctl: reading key &quot;net.ipv6.conf.ens33.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.ens37.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.lo.stable_secret&quot;[root@localhost ~]# sysctl -w net.ipv4.ip_forward=1 #我们将之开启net.ipv4.ip_forward = 1[root@localhost ~]# sysctl -a | grep -w ip_forwardsysctl: reading key &quot;net.ipv6.conf.all.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.default.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.ens33.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.ens37.stable_secret&quot;net.ipv4.ip_forward = 1 #1表示已开启sysctl: reading key &quot;net.ipv6.conf.lo.stable_secret&quot;[root@localhost ~]# 放行所有http访问 12345678[root@localhost ~]# vim /etc/squid/squid.conf将第56行改为：http_access allow all保存退出，查看结果[root@localhost ~]# grep -n http /etc/squid/squid.conf |grep -w all56:http_access allow all[root@localhost ~]# 安装openssl 1[root@localhost ~]# yum -y install openssl 关闭防火墙 1[root@localhost ~]# systemctl stop firewalld.service squid加上DNS，重启squid服务 123456[root@localhost ~]# echo &quot;dns_nameservers 114.114.114.114 114.114.115.115&quot; &gt;&gt; /etc/squid/squid.conf[root@localhost ~]# grep nameserver /etc/squid/squid.confdns_nameservers 114.114.114.114 114.114.115.115[root@localhost ~]# systemctl restart squid[root@localhost ~]# systemctl enable squid[root@localhost ~]# 一开始，我们的虚拟机WIN10客户端是无法上网的，所以要设置代理。 虚拟机WIN10设置客户端代理，如下图： 如上图，原本处在仅主机模式的虚拟机WIN10是无法上网的，现在设置了代理就可以访问外网了。 ACL访问控制只允许某个客户端进行代理修改配置文件 1234567891011121314151617[root@localhost ~]# vim /etc/squid/squid.conf将之前改过的56行改回：http_access deny all将下面这行备注掉（大概第10行）： #acl localnet src 192.168.0.0/16 它的作用是让192.168.0.1-192.168.255.254之间所有ip都可以被放行，把它备注掉，方便我们接下来实验的观察。 如下图在合适的地方加入：acl client src 192.168.23.53在合适的地方加入：http_access allow client保存退出，重启squid服务[root@localhost ~]# systemctl restart squid.service ​ 可以看到咱们的虚拟机WIN10仍然可以上外网，这是由于acl client src 192.168.23.53放行了它的ip所致： ​ 为了对比效果，我又装了一台虚拟机WIN10Test用来测试，给它与之前那台虚拟机WIN10同等的待遇，给它的ie浏览器也配置了一样的代理，现在看看它能否上外网： 看看它的ip： 将他的ip也加入放行队列： 1234567891011[root@localhost ~]# vim /etc/squid/squid.conf如下图在合适的地方加入：acl client2 src 192.168.23.55在合适的地方加入：http_access allow client2保存退出，重启squid服务[root@localhost ~]# systemctl restart squid.service 可以看到，这台新加的虚拟机也可以访问外网了 现在开了三台虚拟机，电脑非常卡，可以把这台新的虚拟机关掉了，接下来我们继续回到正题，继续做代理实验。 特别注意： 本次实验特别坑的地方是，不把Server上的防火墙关掉，客户端就无法访问外网！而且，如果实验中途把Server关机了，重新启动后又得再次关闭防火墙！网上大多数的教程都没有说这一步，导致非常多初次做实验的同学们都被坑死在这里。 过滤敏感字修改配置文件(还原上次实验的更改后再做，还原的相关命令也在下面) 1234567891011121314151617181920[root@localhost ~]# vi /etc/squid/squid.conf去掉第10行的注释acl localnet src 192.168.0.0/16 第58行左右，讲我们之前改过的deny改回allowhttp_access allow all如下图，在合适的地方加入如下两行：大概27行：acl deny_keyword url_regex -i nba大概33行：http_access deny deny_keyword保存退出，重启squid服务，关闭防火墙[root@localhost ~]# systemctl restart squid.service [root@localhost ~]# systemctl stop firewalld.service 这里之所以我又关了一次防火墙，是因为实验中途我把Server关机了，重新开机后虚拟机WIN10怎么也访问不了外网，IE浏览器上只提示“代理服务器无响应”，又是被防火墙坑了。这里防火墙一关，那里ie浏览器又就可以正常访问外网了。 效果如下： ​ 如下图，可以正常访问外网，但是无法访问带有敏感字的网站。 禁止访问特定网站修改配置文件(可以接着上述实验的更改继续再做，相当于叠加过滤) 注意，我们平时访问qq官网，是https的网址：https://www.qq.com，但是由于咱们的Server现在针对的是http协议进行过滤的，就连配置文件里也全都是“http_access”的字段，所以我们测试用的是http://www.qq.com。 123456789[root@localhost ~]# vi /etc/squid/squid.conf如下图，在合适的地方加入如下两行：大概28行：acl deny_url url_regex http://www.qq.com大概31行：http_access deny deny_url保存退出，重启squid服务[root@localhost ~]# systemctl restart squid.service 效果如下： ​ 可以正常访问外网，但是无法访问http://www.qq.com 效果对比： 123456789[root@localhost ~]# vi /etc/squid/squid.conf我们把之前加的两行备注掉：大概28行：#acl deny_url url_regex http://www.qq.com大概31行：#http_access deny deny_url保存退出，重启squid服务[root@localhost ~]# systemctl restart squid.service 现在回到刚刚的测试页面，刷新一下，可以看到它自动的从http://www.qq.com跳转到了https://www.qq.com，成功访问了qq官网。 禁止下载特定格式文件修改配置文件((可以接着上述实验的更改继续再做，相当于叠加过滤) 123456789[root@localhost ~]# vi /etc/squid/squid.conf如下图，在合适的地方加入如下两行：大概29行：acl badfile urlpath_regex -i \.exe$ \.msi$大概32行：http_access deny badfile保存退出，重启squid服务[root@localhost ~]# systemctl restart squid.service ​ 如下图，我们这里用下载nodejs软件历史版本的网站https://nodejs.org/dist/v0.6.2/来测试，分别点开三个文件对比测试： node-v0.6.2.msi node.exe node-v0.6.2.tar.gz ​ 理论上，我们禁止下载了msi和exe后缀格式的文件，那么tar.gz是没有禁止的，实际测试效果如下： ​ 可以看到，实际测试效果和理论上是一样的。 透明正向代理 正向代理服务一般是针对企业内部的所有员工设置的，鉴于每位员工所掌握的计算机知识不尽相同，如果您所在的公司不是IT行业的公司，想教会大家如何使用代理服务也不是一件容易的事情。再者，无论是什么行业的公司，公司领导都希望能采取某些措施限制员工在公司内的上网行为，这时就需要用到透明的正向代理模式了。 “透明”二字指的是让用户在没有感知的情况下使用代理服务，这样的好处是一方面不需要用户手动配置代理服务器的信息，进而降低了代理服务的使用门槛；另一方面也可以更隐秘地监督员工的上网行为。 在透明代理模式中，用户无须在浏览器或其他软件中配置代理服务器地址、端口号等信息，而是由DHCP服务器将网络配置信息分配给客户端主机。这样只要用户打开浏览器便会自动使用代理服务了。 准备工作： 删除之前实验配置的客户端浏览器代理配置，如下图： 现在又无法访问外网了，如下图： 接下来我们要用透明正向代理让它恢复访问网络的能力。 使用firewalld配置透明正向代理 这里有很多坑，网上的大多教程不是缺东就是少西，另外在配置的时候要用的明明是ens37和ens33而网上的教程却都是误人子弟的eth0和eth1，为了试验更加清晰明了，这里也不特意还原之前实验的状态了，我们从头开始，把接下来的实验单独拿出来作为另外一个实验！ 恢复快照 之前我们保存了快照叫做“快照1”的那个，现在咱们把Server恢复快照到那个地方，则相当于准备工作已经安排妥当，接下来实验从头开始，只不过这次咱们做的是透明代理。 安装squid程序 1[root@localhost ~]# yum install squid -y 禁用selinux 1[root@localhost ~]setenforce 0 #临时关闭selinux 开启ip forward（路由转发） 1234567891011121314151617181920212223242526[root@localhost ~]# echo &quot;net.ipv4.ip_forward = 1&quot; &gt;&gt;/usr/lib/sysctl.d/50-default.conf[root@localhost ~]# grep ip_forward /usr/lib/sysctl.d/50-default.confnet.ipv4.ip_forward = 1[root@localhost ~]# sysctl -a | grep -w ip_forwardsysctl: reading key &quot;net.ipv6.conf.all.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.default.stable_secret&quot;net.ipv4.ip_forward = 0 #0表示未开启sysctl: reading key &quot;net.ipv6.conf.ens33.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.ens37.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.lo.stable_secret&quot;[root@localhost ~]# sysctl -w net.ipv4.ip_forward=1 #我们将之开启net.ipv4.ip_forward = 1[root@localhost ~]# sysctl -a | grep -w ip_forwardsysctl: reading key &quot;net.ipv6.conf.all.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.default.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.ens33.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.ens37.stable_secret&quot;net.ipv4.ip_forward = 1 #1表示已开启sysctl: reading key &quot;net.ipv6.conf.lo.stable_secret&quot;[root@localhost ~]# [root@localhost ~]# vim /etc/sysctl.conf在文末追加一行：net.ipv4.ip_forward=1保存退出 配置squid配置文件，放行所有http访问，transparent是透明的意思 123456789101112131415161718192021[root@localhost ~]# vim /etc/squid/squid.conf将第56行改为：http_access allow all如下图，在合适的地方修改这两行：大概59行（追加一个transparent即可）：http_port 3128 transparent大概62行（去掉备注即可）：cache_dir ufs /var/spool/squid 100 16 256保存退出检查配置文件是否有误[root@localhost ~]# squid -k parse 初始化透明代理[root@localhost ~]# squid -z初始化完成后敲回车即可。重启squid服务[root@localhost ~]# systemctl restart squid 使用firewalld配置SNAT，然后添加squid服务 12345678910111213141516171819202122232425262728293031323334353637383940414243 //外网网卡添加到外网zone //内网网卡添加到内网zone //将masquerade配置成yes //添加squid服务 //添加squid服务 //列出外网区域信息 //配置端口转发 //重新加载防火墙 //重启firewalld服务[root@localhost ~]# firewall-cmd --zone=external --add-interface=ens37 --permanentThe interface is under control of NetworkManager, setting zone to &apos;external&apos;.success[root@localhost ~]# firewall-cmd --zone=internal --add-interface=ens33 --permanentThe interface is under control of NetworkManager, setting zone to &apos;internal&apos;.success[root@localhost ~]# firewall-cmd --zone=external --add-masquerade --permanentWarning: ALREADY_ENABLED: masqueradesuccess[root@localhost ~]# firewall-cmd --zone=external --add-service=squid --permanentsuccess[root@localhost ~]# firewall-cmd --zone=internal --add-service=squid --permanentsuccess[root@localhost ~]# firewall-cmd --zone=external --list-allexternal (active) target: default icmp-block-inversion: no interfaces: ens37 sources: services: ssh ports: protocols: masquerade: yes forward-ports: source-ports: icmp-blocks: rich rules: [root@localhost ~]# firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.23.0/24&quot; forward-port port=&quot;80&quot; protocol=&quot;tcp&quot; to-port=&quot;3128&quot; to-addr=&quot;192.168.23.52&quot;&quot; --zone=internalsuccess[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# systemctl restart firewalld[root@localhost ~]# 这里注意，如下，有时候手误会少敲一个d，结果命令就可能没敲进去。 123[root@localhost ~]# systemctl restart firewallFailed to restart firewall.service: Unit not found.[root@localhost ~]# 检查客户端可以正常上网 使用iptables配置透明正向代理注意：iptables和firewalld是冲突的，同时只能使用一个防火墙，所以要还原上次实验的更改后再做 放行DNS查询端口，配置IPv4地址转发 使用iptables防火墙管理命令把所有客户端主机对网站80端口的请求转发至Squid服务器本地的3128端口上 1234567891011121314151617181920[root@localhost ~]# systemctl stop firewalld.service [root@localhost ~]# systemctl mask firewalld.service Created symlink from /etc/systemd/system/firewalld.service to /dev/null. # 安装iptables 服务[root@localhost ~]# yum install iptables-services -y # 开启iptables服务[root@localhost ~]# systemctl start iptables[root@localhost ~]# iptables -F[root@localhost ~]# iptables -t nat -A POSTROUTING -p udp --dport 53 -o ens37 -j MASQUERADE[root@localhost ~]# echo &quot;net.ipv4.ip_forward=1&quot; &gt;&gt; /etc/sysctl.conf [root@localhost ~]# sysctl -pnet.ipv4.ip_forward = 1net.ipv4.ip_forward = 1[root@localhost ~]# iptables -t nat -A PREROUTING -p tcp -m tcp --dport 80 -j REDIRECT --to-port 3128[root@localhost ~]# iptables -t nat -A POSTROUTING -s 192.168.23.0/24 -o ens37 -j SNAT --to 192.168.1.105[root@localhost ~]# service iptables saveiptables: Saving firewall rules to /etc/sysconfig/iptables:[ 确定 ][root@localhost ~]# 注意：不要写错网卡和ip，上述ens37为外网网卡，192.168.1.105为外网ip，192.168.23.0/24是内网ip。 现在检查： 反向代理 网站页面是由静态资源和动态资源一起组成的，其中静态资源包括网站架构CSS文件、大量的图片、视频等数据，这些数据相对于动态资源来说更加稳定，一般不会经常发生改变。但是，随着建站技术的更新换代，外加人们不断提升的审美能力，这些静态资源占据的网站空间越来越多。如果能够把这些静态资源从网站页面中抽离出去，然后在全国各地部署静态资源的缓存节点，这样不仅可以提升用户访问网站的速度，而且网站源服务器也会因为这些缓存节点的存在而降低负载。 反向代理是Squid服务程序的一种重要模式，其原理是把一部分原本向网站源服务器发起的用户请求交给Squid服务器缓存节点来处理。但是这种技术的弊端也很明显，如果有心怀不轨之徒将自己的域名和服务器反向代理到某个知名的网站上面，从理论上来讲，当用户访问到这个域名时，也会看到与那个知名网站一样的内容（有些诈骗网站就是这样骗取用户信任的）。因此，当前许多网站都默认禁止了反向代理功能。开启了CDN（内容分发网络）服务的网站也可以避免这种窃取行为。 修改配置文件​ 注意，我的虚拟机Server重启后，作为桥接模式的外网网卡ip有所变化是很正常的，因为它的ip本就是由我家的家用路由器分配的，现在它变成了192.168.1.107，我们就用这个ip来配置。 58.250.26.38是一个网站的ip，这个随意，拿来测试的而已，找个能用的就行。 1234567891011121314151617181920212223242526272829[root@localhost ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:98:66:4e brd ff:ff:ff:ff:ff:ff inet 192.168.23.52/24 brd 192.168.23.255 scope global noprefixroute dynamic ens33 valid_lft 952sec preferred_lft 952sec inet6 fe80::5a82:cc9d:de3:b9f0/64 scope link noprefixroute valid_lft forever preferred_lft forever3: ens37: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:98:66:58 brd ff:ff:ff:ff:ff:ff inet 192.168.1.107/24 brd 192.168.1.255 scope global noprefixroute dynamic ens37 valid_lft 7081sec preferred_lft 7081sec inet6 fe80::ccc:8d0d:490e:7f9f/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@localhost ~]# [root@localhost ~]# vim /etc/squid/squid.conf大概第59行，改为：http_port 192.168.1.107:80 vhost在上面那行下面追加下面这一行：cache_peer 58.250.26.38 parent 80 0 originserver[root@localhost ~]# systemctl restart squid.service 客户端访问我们输入Server外网网卡的ip：192.168.1.107，如下图，可以看到它自动跳转到了目标网站。 实验到此结束 课外拓展仅主机模式下，linux无法ping通windows的解决办法 我们重新弄两台虚拟机，实验准备和上面那个实验一样。Server网卡一为仅主机模式，网卡二为桥接模式。虚拟机WIN10的网卡为仅主机模式。 1.虚拟机Server 2.虚拟机WIN10 3.VMware Workstation Pro设置 ​ 点击图中更改设置即可更改，这里放出的图是改好后的图。 ​ 拓扑图就是和原来一样的拓扑图。 开机，查看各个设备的ip： 1.Server ens33:192.168.23.52 ens37:192.168.1.107 2.虚拟机WIN10 ens33：192.168.23.53 3.物理机WIN10（就是宿主机，我们现在用着的真实电脑） VMnet1:192.168.23.1 VMnet8:192.168.141.1 物理网卡：192.169.1.108 桥接模式与物理网卡相互桥接，故网段均为192.168.1.0/24 仅主机模式对应VMnet1，故网段均为192.168.23.0/24 我们这里没用到VMnet8，也没有NAT模式的虚拟机网卡，就先不管它了。 现象： 按照原理上讲，同一网段的ip是可以互相ping同的。然而在这里，我们可以发现，windows可以ping通linux，但是linux却是无法ping通windows的，如下图： 1.物理机windows去ping虚拟机Server可以ping通 2.虚拟机Server却无法ping通物理机windows（ping无响应，只能手动ctrl+c打断） 3.虚拟机WIN10可以ping通Server： 4.Server却不能ping通虚拟机WIN10： 解决办法： 先在虚拟机WIN10上做如下设置： 然后Server就可以ping通虚拟机WIN10了： 现在在物理机windows上做如下设置： 现在虚拟机Server也可以ping通物理机windows了： 实验完毕 实验做完了记得要把自己物理机的启用网络发现关闭掉。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-20 Postfix与Dovecot部署邮件系统]]></title>
    <url>%2Flinux-20%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-20 Postfix与Dovecot部署邮件系统实验环境配置，Centos7虚拟机两台： Test（192.168.141.12）：提供DNS服务 client2（192.168.141.53）：提供postfix和dovecot服务 测试用的是咱们的物理机 概念解析电子邮件电子邮件系统基于邮件协议来完成电子邮件的传输，常见的邮件协议有下面这些。 • 简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）用于发送和中转发出 的电子邮件，占用服务器的25/TCP端口。 • 邮局协议版本3（Post Office Protocol 3）用于将电子邮件存储到本地主机，占用服 务器的110/TCP端口。 • Internet消息访问协议版本4（Internet Message Access Protocol 4）用于在本地 主机上访问邮件，占用服务器的143/TCP端口。 Postfix Postfix是一种电子邮件服务器，它是由任职于IBM华生研究中心（T.J. Watson Research Center）的荷兰籍研究员Wietse Venema为了改良sendmail邮件服务器而产生的。最早在1990年代晚期出现，是一个开放源代码的软件。 dovecot​ Dovecot 是一个开源的 IMAP 和 POP3 邮件服务器，支持 Linux/Unix 系统。Dovecot 是一个比较新的软件，由 Timo Sirainen 开发，最初发布于 2002年7月。作者将安全性考虑在第一，所以 Dovecot 在安全性方面比较出众。另外，Dovecot 支持多种认证方式，所以在功能方面也比较符合一般的应用。 Test（192.168.141.12）：提供DNS服务 这里几乎和上篇文章中所做一模一样，但是毕竟是新的一片文章，所以我们重新做一遍，也好顺便复习上篇文章中敲过的命令。 Test安装DNS服务软件包 1[root@localhost ~]# yum install bind bind-chroot bind-utils -y 修改主配置文件 1234567891011121314[root@localhost ~]# vim /etc/named.conf将 listen-on port 53那行改为any，将listen-on-v6那行备注掉，将 allow-query 的由localhost改为any即可options &#123; listen-on port 53 &#123; any; &#125;;# listen-on-v6 port 53 &#123; ::1; &#125;; directory &quot;/var/named&quot;; dump-file &quot;/var/named/data/cache_dump.db&quot;; statistics-file &quot;/var/named/data/named_stats.txt&quot;; memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;; recursing-file &quot;/var/named/data/named.recursing&quot;; secroots-file &quot;/var/named/data/named.secroots&quot;; allow-query &#123; any; &#125;;保存退出 正向区域解析区域配置文件 12345678[root@localhost ~]# vim /etc/named.rfc1912.zones 在最后面加上一段：zone &quot;feng.io&quot; IN &#123; type master; file &quot;feng.io.zone&quot;; allow-update &#123; none; &#125;;&#125;;保存退出 配置正向解析数据文件 123456789101112131415161718[root@localhost ~]# cd /var/named/[root@localhost named]# cp -a named.localhost feng.io.zone[root@localhost named]# vim feng.io.zone $TTL 1D@ IN SOA feng.io. root.feng.io. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS ns.feng.io.ns IN A 192.168.141.12 A 192.168.141.53IN MX 10 mail.feng.io.mail IN A 192.168.141.53保存退出 防火墙放行服务 12345[root@localhost named]# firewall-cmd --add-service=dns --permanent success[root@localhost named]# firewall-cmd --reload success[root@localhost named]# 修改反向解析区域配置文件 12345678910[root@localhost named]# vim /etc/named.rfc1912.zones 在尾部加入：zone &quot;141.168.192.in-addr.arpa&quot; IN &#123; type master; file &quot;192.168.141.arpa&quot;; allow-update &#123; none; &#125;;&#125;;保存退出 反向区域解析数据文件 12345678910111213141516171819[root@localhost named]# cp feng.io.zone 192.168.141.arpa[root@localhost named]# vim 192.168.141.arpa$TTL 1D@ IN SOA feng.io. root.feng.io. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS ns.feng.io. A 192.168.141.5353 PTR feng.io.12 PTR ns.feng.io.53 PTR mail.feng.io.保存退出，重启named服务[root@localhost named]# systemctl restart named client2（192.168.141.53）：提供postfix和dovecot服务配置主机域名，需要保证服务器主机名称与发信域名保持一致： 1234[root@localhost ~]# hostnamectl set-hostname mail.feng.io[root@localhost ~]# hostnamemail.feng.io[root@localhost ~]# 修改dns配置 12345678[root@localhost ~]# vi /etc/resolv.conf # Generated by NetworkManagersearch localdomain feng.ionameserver 192.168.141.12nameserver 114.114.114.114保存退出 检查dns服务 123456789101112131415161718192021[root@localhost ~]# nslookup&gt; 192.168.141.12Server: 192.168.141.12Address: 192.168.141.12#5312.141.168.192.in-addr.arpa name = ns.feng.io.&gt; mail.feng.ioServer: 192.168.141.12Address: 192.168.141.12#53Name: mail.feng.ioAddress: 192.168.141.53&gt; 192.168.141.53Server: 192.168.141.12Address: 192.168.141.12#5353.141.168.192.in-addr.arpa name = feng.io.53.141.168.192.in-addr.arpa name = mail.feng.io.&gt; exit[root@localhost ~]# 可以看出，dns服务正常，正反向解析都成功了。 安装邮件服务器需要的软件包 1[root@localhost ~]# yum install postfix dovecot -y 配置postfix服务 参数 作用 myhostname 邮局系统的主机名 mydomain 邮局系统的域名 myorigin 从本机发出邮件的域名名称 inet_interfaces 监听的网卡接口 mydestination 可接收邮件的主机名或域名 mynetworks 设置可转发哪些主机的邮件 relay_domains 设置可转发哪些网域的邮件 12345678910111213141516171819202122[root@localhost ~]# vi /etc/postfix/main.cf 修改为以下内容，记得原来那行的备注符号#号不要忘了去掉！76行：myhostname = mail.feng.io83行：mydomain = feng.io99行：myorigin = $mydomain116行：inet_interfaces = all164行：mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain179行：local_recipient_maps =保存退出 Postfix与vsftpd服务程序一样，都可以调用本地系统的账户和密码，因此在本地系统创建常规账户即可。最后重启配置妥当的postfix服务程序，并将其添加到开机启动项中 1234567[root@localhost ~]# useradd aaa[root@localhost ~]# echo &quot;123456&quot; | passwd --stdin aaa更改用户 aaa 的密码 。passwd：所有的身份验证令牌已经成功更新。[root@localhost ~]# systemctl restart postfix[root@localhost ~]# systemctl enable postfix[root@localhost ~]# 配置dovecot服务修改配置文件 1234567891011[root@localhost ~]# vi /etc/dovecot/dovecot.conf将第24行改为：protocols = imap pop3 lmtp其实也就是去掉了备注而已注意：如果想允许所有人都能使用，则不用修改下面的参数，反正这次实验我是没去改如果想要仅仅允许192.168.141.0/24网段的用户使用dovecot服务，则将第48行改为：login_trusted_networks = 192.168.141.0/24保存退出 允许明文传输内容 12345678910[root@localhost ~]# vi /etc/dovecot/conf.d/10-auth.conf 修改为以下内容，记得原来那行的备注符号#号不要忘了去掉！第10行：disable_plaintext_auth = no第100行：auth_mechanisms = plain login保存退出 取消SSL 12345678910111213[root@localhost ~]# vi /etc/dovecot/conf.d/10-ssl.conf 修改为以下内容第8行：ssl = no将14、15行都备注掉第14行：#ssl_cert = &lt;/etc/pki/dovecot/certs/dovecot.pem第15行：#ssl_key = &lt;/etc/pki/dovecot/private/dovecot.pem保存退出 设置收件箱 12345[root@localhost ~]# vi /etc/dovecot/conf.d/10-mail.conf 将第25行改为： mail_location = mbox:~/mail:INBOX=/var/mail/%u其实也就是去掉备注而已保存退出 然后切换到配置Postfix服务程序时创建的eagle账户，并在家目录中建立用于保存邮件的目录。记得要重启Dovecot服务并将其添加到开机启动项中。至此，对Dovecot服务程序的配置部署步骤全部结束。 12345678[root@localhost ~]# su - aaa[aaa@mail ~]$ mkdir -p mail/.imap/INBOX[aaa@mail ~]$ exit登出[root@localhost ~]# systemctl restart dovecot[root@localhost ~]# systemctl enable dovecotCreated symlink from /etc/systemd/system/multi-user.target.wants/dovecot.service to /usr/lib/systemd/system/dovecot.service.[root@localhost ~]# 设置邮件服务的防火墙放行 12345[root@localhost ~]# firewall-cmd --add-port=&#123;25,110,143&#125;/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# 在本篇文章开始那里，常见的邮件协议介绍的三种协议的端口号分别便是25,110,143，均放行。 在windows上用foxmail客户端测试邮件服务修改window上的dns地址，如下图： 使用foxmail测试邮件服务器是否成功，如下图： 安装完成后打开，选择手动设置，然后如下图： 发送邮件给咱们的client2那台虚拟机的root用户，看看它能不能收到。 首先在client2上安装相关工具包 123456789101112131415161718192021222324252627282930313233[root@localhost ~]# yum install mailx sendmail -y装好后，先敲mail命令，然后直接回车即可[root@localhost ~]# mailHeirloom Mail version 12.5 7/5/10. Type ? for help.&quot;/var/spool/mail/root&quot;: 1 message 1 new&gt;N 1 aaa@feng.io Sun Feb 3 19:07 52/2158 &quot;HelloMail&quot;&amp; Message 1:From aaa@feng.io Sun Feb 3 19:07:47 2019Return-Path: &lt;aaa@feng.io&gt;X-Original-To: root@feng.ioDelivered-To: root@feng.ioDate: Sun, 3 Feb 2019 19:07:45 +0800From: &quot;aaa@feng.io&quot; &lt;aaa@feng.io&gt;To: root &lt;root@feng.io&gt;Subject: HelloMailX-Priority: 3X-Has-Attach: noX-Mailer: Foxmail 7.2.9.156[cn]Content-Type: multipart/alternative; boundary=&quot;----=_001_NextPart407851228804_=----&quot;Status: RContent-Type: text/plain; charset=&quot;GB2312&quot;当您收到这封邮件时，证明我的邮局系统实验已经成功！aaa@feng.io&amp; 可以看到，它的确收到了邮件了，说明咱们的配置成功了！ 至于linux端发邮件给windows，写起来比较麻烦,也不好解释怎么操作，有兴趣的朋友可以自行网上学习，最好是视频形式的教程，那样才听得明白。 题外话 ​ 上面咱们用到的那款软件Foxmail中文名是狐邮，正是在最近热播的电视剧《创业时代》里面的罗维开发的软件，这剧真的挺好看的，主演黄轩演的真的不错，喜欢的朋友们可以去追一追这部剧。 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-19 bind提供域名解析服务]]></title>
    <url>%2Flinux-19%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-19 bind提供域名解析服务概念解析DNS域名解析服务 很早很早之前，人们通过ip地址来上网，后来，人们觉得，相较于由数字构成的IP地址，域名更容易被理解和记忆，所以我们通常更习惯通过域名的方式来访问网络中的资源。但是，网络中的计算机之间只能基于IP地址来相互识别对方的身份，而且要想在互联网中传输数据，也必须基于外网的IP地址来完成。 为了降低用户访问网络资源的门槛，DNS（Domain Name System，域名系统）技术应运而生。这是一项用于管理和解析域名与IP地址对应关系的技术，简单来说，就是能够接受用户输入的域名或IP地址，然后自动查找与之匹配（或者说具有映射关系）的IP地址或域名，即将域名解析为IP地址（正向解析），或将IP地址解析为域名（反向解析）。这样一来，我们只需要在浏览器中输入域名就能打开想要访问的网站了。DNS域名解析技术的正向解析也是我们最常使用的一种工作模式。 鉴于互联网中的域名和IP地址对应关系数据库太过庞大，DNS域名解析服务采用了类似目录树的层次结构来记录域名与IP地址之间的对应关系，从而形成了一个分布式的数据库系统， DNS域名解析服务采用的层次目录结构 如下图，DNS域名解析服务中，一级域名例如.com .net .org等，而二级域名有google taobao等，三级域名如www等。连起来就是www.google.com。 域名后缀一般分为国际域名和国内域名。原则上来讲，域名后缀都有严格的定义，但在实际使用时可以不必严格遵守。目前最常见的域名后缀有.com（商业组织）、.org（非营利组织）、.gov（政府部门）、.net（网络服务商）、.edu（教研机构）、.pub（公共大众）、.cn（中国国家顶级域名）等。 当今世界的信息化程度越来越高，大数据、云计算、物联网、人工智能等新技术不断涌现，全球网民的数量据说也超过了35亿，而且每年还在以10%的速度迅速增长。这些因素导致互联网中的域名数量进一步激增，被访问的频率也进一步加大。假设全球网民每人每天只访问一个网站域名，而且只访问一次，也会产生35亿次的查询请求，如此庞大的请求数量肯定无法被某一台服务器全部处理掉。DNS技术作为互联网基础设施中重要的一环，为了为网民提供不间断、稳定且快速的域名查询服务，保证互联网的正常运转，提供了下面三种类型的服务器。 主服务器 在特定区域内具有唯一性，负责维护该区域内的域名与IP地址之间的对应关系。 从服务器 从主服务器中获得域名与IP地址的对应关系并进行维护，以防主服务器宕机等情况。 缓存服务器 通过向其他域名解析服务器查询获得域名与IP地址的对应关系，并将经常查询的域名信息保存到服务器本地，以此来提高重复查询时的效率。 简单来说，主服务器是用于管理域名和IP地址对应关系的真正服务器，从服务器帮助主服务器“打下手”，分散部署在各个国家、省市或地区，以便让用户就近查询域名，从而减轻主服务器的负载压力。缓存服务器不太常用，一般部署在企业内网的网关位置，用于加速用户的域名查询请求。 DNS域名解析服务采用分布式的数据结构来存放海量的“区域数据”信息，在执行用户发起的域名查询请求时，具有递归查询和迭代查询两种方式。所谓递归查询，是指DNS服务器在收到用户发起的请求时，必须向用户返回一个准确的查询结果。如果DNS服务器本地没有存储与之对应的信息，则该服务器需要询问其他服务器，并将返回的查询结果提交给用户。而迭代查询则是指，DNS服务器在收到用户发起的请求时，并不直接回复查询结果，而是告诉另一台DNS服务器的地址，用户再向这台DNS服务器提交请求，这样依次反复，直到返回查询结果。 用户向就近的一台DNS服务器发起对某个域名的查询大致流程 当用户向网络指定的DNS服务器发起一个域名请求时，通常情况下会有本地由此DNS服务器向上级的DNS服务器发送迭代查询请求；如果该DNS服务器没有要查询的信息，则会进一步向上级DNS服务器发送迭代查询请求，直到获得准确的查询结果为止。其中最高级、最权威的根DNS服务器总共有13台，分布在世界各地。 根域名服务器 根域名服务器是域名解析体系的核心，握有域名的最终解释权，简单来说，如果要查询域名，均需要从根域名服务器开始查询。域名服务器是提供域名解析的服务器，在有基本的知识下，任何人都可以搭建域名服务器，甚至是根域名服务器，有名的软件有：BIND。 全球只有13台根服务器的准确说法​ 域名服务器就像许多国际组织一样，是需要被承认的，当你的根域名服务器被全世界承认，你的服务器也可以成为这其中的一员。因为互联网起源于美国，域名体系也是诞生于美国，在互联网不断扩张和发展的过程中，逐渐形成了13台服务器为全球根服务器。这13台根服务器由ICANN管理，由12个机构具体运营。13台根服务器如下图所示： 13台根域名服务器从a至m编号，分属12个运营机构运营。 但是，网上新闻中有些说法并不准确，举个反例：“全世界只有13台根域名服务器，名字分别为A至M，其中一个主根服务器在美国，其余12个均为辅根服务器，其中9个在美国，欧洲两个，分别位于英国和瑞典，亚洲一个位于日本” 个人认为比较正确的说法应该是这样：“13台根域名服务器不是一个物理概念，它是一个逻辑概念，根域名服务器可以由分布在全球的多个服务器组成，形成一个集群，对外统一为1台逻辑的根域名服务器。在root-servers网站上，我们能查到所有的真实服务器分布“。 截至2018年9月11日，全球一共分布了937台根域名服务器，可以看到，包含港澳台，中国一共有17台根域名服务器。 在上述反例中，还强调了主辅之分，然鹅，事实上，这几百台除了运营者不同，哪有什么区别，真正的根一直在幕后。我个人比较支持下面的一种说法： 全世界只有13台逻辑根域名服务器，名字分别为A至M，由12个运营者运营，其中8个在美国，欧洲两个位于英国和瑞典，亚洲1个位于日本，而真正的主根服务器并未公开。 BIND BIND（Berkeley Internet Name Domain，伯克利网络域名）服务是全球范围内使用最广泛、最安全可靠且高效的域名解析服务程序。DNS域名解析服务作为互联网基础设施服务，其责任之重可想而知，因此建议大家在生产环境中安装部署bind服务程序时加上chroot（俗称牢笼机制）扩展包，以便有效地限制bind服务程序仅能对自身的配置文件进行操作，以确保整个服务器的安全。 准备工作CentOS7安装DNS服务软件包 1[root@localhost ~]# yum install bind bind-chroot bind-utils -y 在bind服务程序中有下面这三个比较关键的文件。 主配置文件（/etc/named.conf）：只有58行，而且在去除注释信息和空行之后，实际有效的参数仅有30行左右，这些参数用来定义bind服务程序的运行。 区域配置文件（/etc/named.rfc1912.zones）：用来保存域名和IP地址对应关系的所在位置。类似于图书的目录，对应着每个域和相应IP地址所在的具体位置，当需要查看或修改时，可根据这个位置找到相关文件。 数据配置文件目录（/var/named）：该目录用来保存域名和IP地址真实对应关系的数据配置文件。 修改主配置文件 1234567891011121314[root@localhost ~]# vim /etc/named.conf将 listen-on port 53那行改为any，将listen-on-v6那行备注掉，将 allow-query 的由localhost改为any即可options &#123; listen-on port 53 &#123; any; &#125;;# listen-on-v6 port 53 &#123; ::1; &#125;; directory &quot;/var/named&quot;; dump-file &quot;/var/named/data/cache_dump.db&quot;; statistics-file &quot;/var/named/data/named_stats.txt&quot;; memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;; recursing-file &quot;/var/named/data/named.recursing&quot;; secroots-file &quot;/var/named/data/named.secroots&quot;; allow-query &#123; any; &#125;;保存退出 正向解析实验修改区域配置文件 12345678[root@localhost ~]# vim /etc/named.rfc1912.zones 在最后面加上一段：zone &quot;feng.io&quot; IN &#123; type master; file &quot;feng.io.zone&quot;; allow-update &#123; none; &#125;;&#125;;保存退出 配置解析数据文件 12345678910111213141516171819[root@localhost ~]# cd /var/named/[root@localhost named]# cp -a named.localhost feng.io.zone[root@localhost named]# vim feng.io.zone $TTL 1D@ IN SOA feng.io. root.feng.io. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS ns.feng.io.ns IN A 192.168.141.12 A 192.168.141.12www IN A 192.168.141.12IN MX 10 mail.feng.iomail IN A 192.168.141.12保存退出 启动named服务，防火墙放行服务 123456[root@localhost named]# systemctl restart named[root@localhost named]# firewall-cmd --add-service=dns --permanent success[root@localhost named]# firewall-cmd --reload success[root@localhost named]# windows客户端测试，用咱们的电脑物理机测试 如下图： 正向解析成功。 反向解析实验修改区域配置文件 12345678910[root@localhost named]# vim /etc/named.rfc1912.zones 在尾部加入：zone &quot;141.168.192.in-addr.arpa&quot; IN &#123; type master; file &quot;192.168.141.arpa&quot;; allow-update &#123; none; &#125;;&#125;;保存退出 配置解析数据文件 12345678910111213141516171819[root@localhost named]# cp feng.io.zone 192.168.141.arpa[root@localhost named]# vim 192.168.141.arpa$TTL 1D@ IN SOA feng.io. root.feng.io. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS feng.io.ns A 192.168.141.1212 PTR ns.feng.io.38 PTR www.feng.io.12 PTR mail.feng.io.保存退出，重启named服务[root@localhost named]# systemctl restart named 注意：上述文件配置中，12 38 12 值得是192.168.141.12 192.168.141.38 192.168.141.12三个ip，意思是对这三个ip的反向解析的结果分别对应什么域名。下面测试就用的上述ip。 用linux客户端测试dns 12345678910111213141516171819202122[root@localhost ~]# vim /etc/resolv.conf # Generated by NetworkManagersearch localdomainnameserver 192.168.141.12保存退出[root@localhost ~]# yum install bind-utils -y[root@localhost ~]# nslookup&gt; 192.168.141.12Server: 192.168.141.12Address: 192.168.141.12#5312.141.168.192.in-addr.arpa name = mail.feng.io.12.141.168.192.in-addr.arpa name = ns.feng.io.&gt; 192.168.141.38Server: 192.168.141.12Address: 192.168.141.12#5338.141.168.192.in-addr.arpa name = www.feng.io.&gt; 可以看到，反向解析成功了 部署dns的主从服务器做dns服务器的故障备份服务器，当主服务器故障，我们就可以用从服务器的地址继续进行解析 配置主服务器1234567891011121314151617咱们上面配好的就是主服务器，但是这里为了与从服务器配合工作，咱们还需要添加一些配置：[root@localhost ~]# vim /etc/named.rfc1912.zones 在文件尾部，将前面咱们添加的两个代码块修改为以下内容zone &quot;feng.io&quot; IN &#123; type master; file &quot;feng.io.zone&quot;; allow-update &#123; 192.168.141.53; &#125;;&#125;;zone &quot;141.168.192.in-addr.arpa&quot; IN &#123; type master; file &quot;192.168.141.arpa&quot;; allow-update &#123; 192.168.141.53; &#125;;&#125;;其实也就是将原本的none改成了从服务器client2的ip而已保存退出，重启named服务[root@localhost named]# systemctl restart named 配置从服务器现在我们新安装一台虚拟机client2作为咱们的从服务器。 从服务器的主配置文件和主服务器一样，只要修改区域文件就可以 12345678910111213141516171819202122[root@localhost ~]# yum install bind bind-chroot bind-utils -y[root@localhost ~]# vi /etc/named.rfc1912.zones 在文件尾部加入下列内容zone &quot;feng.io&quot; IN &#123; type slave; masters&#123; 192.168.141.12; &#125;; file &quot;slaves/feng.io.zone&quot;;&#125;;zone &quot;141.168.192.in-addr.arpa&quot; IN &#123; type slave; masters&#123; 192.168.141.12; &#125;; file &quot;slaves/192.168.141.arpa&quot;;&#125;;保存退出[root@localhost ~]# firewall-cmd --add-service=dns --permanentsuccess[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# 注意：上述参数中，slave（奴隶）指的是从服务，master（主人）指的是主服务 从服务器的主配置文件和主服务器一样 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253[root@localhost ~]# vim /etc/named.conf将 listen-on port 53那行改为any，将listen-on-v6那行备注掉，将 allow-query 的由localhost改为any即可options &#123; listen-on port 53 &#123; any; &#125;;# listen-on-v6 port 53 &#123; ::1; &#125;; directory &quot;/var/named&quot;; dump-file &quot;/var/named/data/cache_dump.db&quot;; statistics-file &quot;/var/named/data/named_stats.txt&quot;; memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;; recursing-file &quot;/var/named/data/named.recursing&quot;; secroots-file &quot;/var/named/data/named.secroots&quot;; allow-query &#123; any; &#125;;保存退出[root@localhost ~]# cd /var/named/[root@localhost named]# cp -a named.localhost feng.io.zone[root@localhost named]# vim feng.io.zone $TTL 1D@ IN SOA feng.io. root.feng.io. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS ns.feng.io.ns IN A 192.168.141.12 A 192.168.141.12www IN A 192.168.141.12IN MX 10 mail.feng.iomail IN A 192.168.141.12保存退出[root@localhost named]# vim 192.168.141.arpa$TTL 1D@ IN SOA feng.io. root.feng.io. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS feng.io.ns A 192.168.141.1212 PTR ns.feng.io.38 PTR www.feng.io.12 PTR mail.feng.io.保存退出，重启named服务[root@localhost named]# systemctl restart named 检查同步结果将客户机/etc/resolv.conf 的IP改为从服务器ip，用nslookup测试就可以了，此处仍然以client来测试 从服务器client2上： 12345678910111213141516[root@localhost ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:fc:9f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute dynamic ens33 valid_lft 1618sec preferred_lft 1618sec inet6 fe80::1440:45a7:228d:4942/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@localhost ~]# 记住ip：192.168.141.53 测试用的客户机client上： 123456789101112131415161718192021222324252627[root@localhost ~]# vim /etc/resolv.conf # Generated by NetworkManagersearch localdomainnameserver 192.168.141.53保存退出测试:[root@localhost ~]# nslookup&gt; mail.feng.ioServer: 192.168.141.53Address: 192.168.141.53#53Name: mail.feng.ioAddress: 192.168.141.12&gt; 192.168.141.12Server: 192.168.141.53Address: 192.168.141.53#5312.141.168.192.in-addr.arpa name = ns.feng.io.12.141.168.192.in-addr.arpa name = mail.feng.io.&gt; 192.168.141.38Server: 192.168.141.53Address: 192.168.141.53#5338.141.168.192.in-addr.arpa name = www.feng.io.&gt; 如上图，客户端通过从服务器的正反向解析都成功了 安全的加密传输同步主从服务器主服务器配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354生成密钥文件[root@localhost ~]# [root@localhost ~]# cd /var/named/chroot/etc/[root@localhost etc]# dnssec-keygen -a HMAC-MD5 -b 128 -n HOST master-slaveKmaster-slave.+157+61793复制上面弄出来的文件名Kmaster-slave.+157+61793，加上.private 就可以cat出来了：修改配置文件并且设置文件安全[root@localhost etc]# cat Kmaster-slave.+157+61793.private Private-key-format: v1.3Algorithm: 157 (HMAC_MD5)Key: 5U4NAMvTT0RfK2TvNu/jUw==Bits: AAA=Created: 20190203024817Publish: 20190203024817Activate: 20190203024817复制上面cat出来的Key的内容5U4NAMvTT0RfK2TvNu/jUw==，一会儿填入下面这个文件secret的里面[root@localhost etc]# vim transfer.keykey &quot;master-slave&quot;&#123; algorithm hmac-md5; secret &quot;5U4NAMvTT0RfK2TvNu/jUw==&quot;;&#125;;保存退出 [root@localhost etc]# chown root:named transfer.key[root@localhost etc]# chmod 640 transfer.key [root@localhost etc]# ln transfer.key /etc/transfer.key[root@localhost etc]# 开启bind服务的密钥验证功能[root@localhost etc]# vim /etc/named.conf 在文件第11行插入这一行：include &quot;/etc/transfer.key&quot;;在文件第22行左右插入这一行：allow-transfer &#123; key master-slave; &#125;;保存退出，重启named服务[root@localhost etc]# setenforce 0[root@localhost etc]# systemctl restart named 从服务器上观察： 123456做到这步，现在由于从服务器尚未做相关配置，所以现在从服务器无法同步信息了[root@localhost slaves]# rm -rf /var/named/slaves/*[root@localhost slaves]# systemctl restart named[root@localhost slaves]# ls[root@localhost slaves]# 配置从服务器12345678910111213141516171819202122232425262728293031323334[root@localhost ~]# cd /var/named//chroot/etc/我们把上面主服务器transfer.key的内容一模一样地复制到这里：[root@localhost etc]# vi transfer.keykey &quot;master-slave&quot;&#123; algorithm hmac-md5; secret &quot;5U4NAMvTT0RfK2TvNu/jUw==&quot;;&#125;;保存退出[root@localhost etc]# chown root:named transfer.key[root@localhost etc]# chmod 640 transfer.key [root@localhost etc]# ln transfer.key /etc/transfer.key[root@localhost etc]# 修改主配置文件[root@localhost etc]# vi /etc/named.conf 在文件尾部将原本的include &quot;/etc/named.rfc1912.zones&quot;;include &quot;/etc/named.root.key&quot;;改为下列内容：server 192.168.141.12&#123;keys &#123; master-slave; &#125;;&#125;;include &quot;/etc/named.rfc1912.zones&quot;;include &quot;/etc/named.root.key&quot;;include &quot;/etc/transfer.key&quot;;保存退出，重启named服务[root@localhost etc]# setenforce 0[root@localhost etc]# systemctl restart named[root@localhost etc]# 检查结果检查同步，查看/var/named/slaves目录下有没有同步过来的区域数据文件 123[root@localhost etc]# ls /var/named/slaves/192.168.141.arpa feng.io.zone[root@localhost etc]# 如上图，现在/var/named/slaves目录下又有文件了，说明从服务器和主服务器又可以同步信息了。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-18 DHCP动态管理主机地址]]></title>
    <url>%2Flinux-18%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-18 DHCP动态管理主机地址配置实验环境 有Test和client两台虚拟机，Test用作服务器，client用作客户端，客户端的ip由服务器分配而来。举个栗子，就是你连上了别人家wifi后，那么他家的路由器会给你的电脑或者手机分配一个ip，这样你的电脑或手机才能上网。 做实验之前，最好把用过的虚拟机恢复到比较干净的快照，或者重新装两台虚拟机。例如我的虚拟机Test在前面的章节中，就改了网卡ip，至今它的ens33网卡还有192.168.141.12 、13、14、15多个ip呢，而且ens37我们之前也配置过静态ip，这样会影响本实验的观察，因此我是恢复到之前改网卡配置之前的快照后再进行下面的实验的。 Server硬件配置 Client硬件配置 VMware Workstation Pro 软件设置 在软件上找到“编辑”-&gt;”虚拟网络编辑器”-&gt;”更改设置”，做如下图的设置 注意：ip不用改，例如我的VMnet1的ip是192.168.23.0网段，VMnet8的ip是192.168.141.0网段，那就让它保持原样，不用去改。 下图中，如图选择即可。注意，不要勾选“使用本地DHCP服务将ip分配给虚拟机”，如果你勾选了，那分配ip给client的就不是Test这台服务器，而是VMware Workstation Pro软件分配的了。 两台虚拟机开机，开始配置。 Test配置DHCP服务配置网络 Test中能上网的网卡（NAT模式的网卡，也就是网络适配器1，也就是ens33）不用管，给新增的网卡（仅主机模式的网卡，也就是网络适配器2，也就是ens37）配置一个跟默认网卡不同网段的固定IP，此处以网段192.168.10.0/24为例。 123456789101112131415161718192021222324[root@localhost ~]# nmcli connection add con-name ens37 ifname ens37 type ethernet autoconnect yes ipv4.method manual ipv4.addresses 192.168.10.254/24Connection &apos;ens37&apos; (cae18d83-b6d8-4945-b704-aaf9b918ef04) successfully added.[root@localhost ~]# systemctl restart network[root@localhost ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:9b:23:d9 brd ff:ff:ff:ff:ff:ff inet 192.168.141.173/24 brd 192.168.141.255 scope global noprefixroute dynamic ens33 valid_lft 1798sec preferred_lft 1798sec inet6 fe80::be8c:1227:c5b2:e66d/64 scope link noprefixroute valid_lft forever preferred_lft forever3: ens37: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:9b:23:e3 brd ff:ff:ff:ff:ff:ff inet 192.168.10.254/24 brd 192.168.10.255 scope global noprefixroute ens37 valid_lft forever preferred_lft forever inet6 fe80::81bc:c746:2ead:eb30/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@localhost ~]# 可以看到，ens37的ip已经变成了192.168.10.254/24 安装dhcp服务1[root@localhost ~]# yum install dhcp -y 查看参考示例1[root@localhost ~]# cat /usr/share/doc/dhcp*/dhcpd.conf.example | grep -v &quot;^$&quot; | grep -v &quot;#&quot; 参数 作用 ddns-update-style [类型] 定义DNS服务动态更新的类型，类型包括none（不支持动态更新）、interim（互动更新模式）与ad-hoc（特殊更新模式） [allow \ ignore] client-updates 允许/忽略客户端更新DNS记录 default-lease-time [21600] 默认超时时间 max-lease-time [43200] 最大超时时间 option domain-name-servers [8.8.8.8] 定义DNS服务器地址 option domain-name [“domain.org”] 定义DNS域名 range 定义用于分配的IP地址池 option subnet-mask 定义客户端的子网掩码 option routers 定义客户端的网关地址 broadcase-address[广播地址] 定义客户端的广播地址 ntp-server[IP地址] 定义客户端的网络时间服务器（NTP） nis-servers[IP地址] 定义客户端的NIS域服务器的地址 Hardware[网卡物理地址] 指定网卡接口的类型与MAC地址 server-name[主机名] 向DHCP客户端通知DHCP服务器的主机名 fixed-address[IP地址] 将某个固定的IP地址分配给指定主机 time-offset[偏移误差] 指定客户端与格林尼治时间的偏移差 配置dhcp服务1234567891011121314151617181920[root@localhost ~]# vim /etc/dhcp/dhcpd.conf ## DHCP Server Configuration file.# see /usr/share/doc/dhcp*/dhcpd.conf.example# see dhcpd.conf(5) man page#ddns-update-style none;ignore client-updates;subnet 192.168.10.0 netmask 255.255.255.0&#123;range 192.168.10.50 192.168.10.150;option subnet-mask 255.255.255.0;option routers 192.168.10.254;option domain-name &quot;feng.io&quot;;option domain-name-servers 8.8.8.8;default-lease-time 21600;default-lease-time 43200;&#125; 保存退出 PS：如果要将某个固定的IP分配给指定的主机,需要在主配置文件追加如下（实际上是将MAC地址和IP做了一个映射）： 123456host subnet1&#123; hardware ethernet 00:0c:29:66:3d:fd; #机器的mac地址 fixed-address 192.168.10.88; #提供的独立IP&#125; 参数作用 参数 解析 ddns-update-style none; 设置DNS服务不自动进行动态更新 ignore client-updates; 忽略客户端更新DNS记录 subnet 192.168.1.0 netmask 255.255. 255.0 作用域为192.168.1.0/24网段 range 192.168.1.50 192.168.1.150; IP地址池为192.168.1.50-150（约100个IP地址） option subnet-mask 255.255.255.0; 定义客户端默认的子网掩码 option routers 192.168.1.1; 定义客户端的网关地址 option domain-name “test.com”; 定义默认的搜索域 option domain-name-servers 192.168. 1.1; 定义客户端的DNS地址 default-lease-time 21600; 定义默认租约时间（单位：秒） max-lease-time 43200; 定义最大预约时间（单位：秒） } 结束符 启动dhcp服务12345678[root@localhost ~]# firewall-cmd --add-service=dhcp --permanent success[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# systemctl restart dhcpd[root@localhost ~]# systemctl enable dhcpdCreated symlink from /etc/systemd/system/multi-user.target.wants/dhcpd.service to /usr/lib/systemd/system/dhcpd.service.[root@localhost ~]# client客户端设置成自动获取ip（默认就是），测试12[root@localhost ~]# systemctl restart network[root@localhost ~]# ip add 可以看到，client获取到的ip是192.168.10.50/24，恰恰是我们IP地址池为192.168.1.50-150（约100个IP地址）的第一个地址，说明我们的DHCP服务配置成功了。 这时，我们试试在Test上关掉DHCP服务 Test上： 12[root@localhost ~]# systemctl stop dhcpd[root@localhost ~]# client上： 12[root@localhost ~]# systemctl restart network[root@localhost ~]# ip add 可以看到，一旦Tset上面的DHCP服务关掉了，那么client重启网络服务就会直接报错，再次查看其ip发现，它连IP地址都没了，只能看到其物理地址（Mac地址），上图中我的Mac地址就是00:0c:29:98:66:4e。 接下来，我们把它的ens33网卡的Mac地址记下来，加入到Test的DHCP配置中（Mac地址这么长不要敲错了哈,那个冒号:是英文的冒号，容易敲错）： Test上： 123456789101112131415161718192021222324252627[root@localhost ~]# vim /etc/dhcp/dhcpd.conf ## DHCP Server Configuration file.# see /usr/share/doc/dhcp*/dhcpd.conf.example# see dhcpd.conf(5) man page#ddns-update-style none;ignore client-updates;subnet 192.168.10.0 netmask 255.255.255.0&#123;range 192.168.10.50 192.168.10.150;option subnet-mask 255.255.255.0;option routers 192.168.10.254;option domain-name &quot;feng.io&quot;;option domain-name-servers 8.8.8.8;default-lease-time 21600;default-lease-time 43200;&#125;host subnet1&#123; hardware ethernet 00:0c:29:98:66:4e; #机器的mac地址 fixed-address 192.168.10.88; #提供的独立IP&#125; 保存退出，重启DHCP服务[root@localhost ~]# systemctl restart dhcpd[root@localhost ~]# client上： 12[root@localhost ~]# systemctl restart network[root@localhost ~]# ip add ​ 可以看到，它的ip已经变成了我们指定分配给它的192.168.10.88/24了，配置成功！ ​ 实验到此结束！ ​ 虚拟机和虚拟网卡的通信原理host-only（仅主机）模式与VMnet1虚拟网卡进行通信NAT模式与VMnet8虚拟网卡进行通信桥接使用的是你机器的真实网卡进行上网 1.仅主机模式 此模式下，虚拟机与VMnet1虚拟网卡进行通信，咱们做一下测试： 在虚拟网络编辑器中，我们将VMnet1如下图设置，给它设置一个DHCP地址池192.168.23.50-150。这样一来，我们的虚拟机网络适配器但凡是使用仅主机模式且以DHCP方式获取ip的，就能从这个地址池中获取到ip。 这样设置以后，只要你的虚拟机网卡是仅主机模式且网卡配置文件里设置的ip获取方式是DHCP（默认就是DHCP），则其ip就会从上图中那个DHCP地址池中选取。例如，我新安装的一台虚拟机，网卡设置为仅主机模式后，打开后其ip如下图： 可以看到它的ip为192.168.23.50，恰恰是上述地址池的第一个ip。 2.NAT模式​ 此模式下，虚拟机与VMnet8虚拟网卡进行通信，咱们做一下测试： 在虚拟网络编辑器中，我们将VMnet8如下图设置，给它设置一个DHCP地址池192.168.100.50-150。这样一来，我们的虚拟机网络适配器但凡是使用NAT模式且以DHCP方式获取ip的，就能从这个地址池中获取到ip。 这样设置以后，只要你的虚拟机网卡是NAT模式且网卡配置文件里设置的ip获取方式是DHCP（默认就是DHCP），则其ip就会从上图中那个DHCP地址池中选取。例如，刚刚那台虚拟机，网卡设置为NAT模式后，打开后其ip如下图： 可以看到它的ip为192.168.100.50，恰恰是上述地址池的第一个ip。 3.桥接模式 桥接模式使用的是你机器的真实网卡进行上网，也就是说，如果你的虚拟机网络适配器设置为桥接模式的话，则相当于虚拟机与你的电脑物理主机桥接，桥指的是网桥，就是交换机。所以，桥接模式下，你的虚拟机和你的物理机是在同一个网段的，如下图： ​ 我们将刚刚那台虚拟机设置为桥接模式，查看其ip： 可以看到它的ip为192.168.1.105，那么我们看看我的物理机ip： 可以看到我的物理机ip是192.168.1.108，与之确实是同一个网段的。 我们常用的是NAT模式的虚拟机，所以我们按刚刚的NAT那样设置就好。 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-17 Samba服务与NFS]]></title>
    <url>%2Flinux-17%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-17 Samba服务与NFS概念解析 Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。通过设置“NetBIOS over TCP/IP”使得Samba不但能与局域网络主机分享资源，还能与全世界的电脑分享资源。 NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。 samba安装samba服务1[root@localhost ~]# yum install samba -y [global] 参数 作用 workgroup = MYGROUP #工作组名称 server string = Samba Server Version %v #服务器介绍信息，参数%v为显示SMB版本号 log file = /var/log/samba/log.%m #定义日志文件的存放位置与名称，参数%m为来访的主机名 max log size = 50 #定义日志文件的最大容量为50KB security = user #安全验证的方式，总共有4种 #share：来访主机无需验证口令；比较方便，但安全性很差 #user：需验证来访主机提供的口令后才可以访问；提升了安全性 #server：使用独立的远程主机验证来访主机提供的口令（集中管理账户） #domain：使用域控制器进行身份验证 passdb backend = tdbsam #定义用户后台的类型，共有3种 #smbpasswd：使用smbpasswd命令为系统用户设置Samba服务程序的密码 #tdbsam：创建数据库文件并使用pdbedit命令建立Samba服务程序的用户 #ldapsam：基于LDAP服务进行账户验证 load printers = yes #设置在Samba服务启动时是否共享打印机设备 cups options = raw #打印机的选项 [homes] #共享参数 comment = Home Directories #描述信息 browseable = no #指定共享信息是否在“网上邻居”中可见 writable = yes #定义是否可以执行写入操作，与“read only”相反 [printers] #打印机共享参数 去掉配置文件中的注释 12345678910111213141516171819202122232425262728293031[root@localhost ~]# mv /etc/samba/smb.conf /etc/samba/smb.conf.bak[root@localhost ~]# cat /etc/samba/smb.conf.bak | grep -v &quot;#&quot; | grep -v &quot;;&quot; | grep -v &quot;^$&quot; &gt; /etc/samba/smb.conf[root@localhost ~]# cat /etc/samba/smb.conf[global] workgroup = SAMBA security = user passdb backend = tdbsam printing = cups printcap name = cups load printers = yes cups options = raw[homes] comment = Home Directories valid users = %S, %D%w%S browseable = No read only = No inherit acls = Yes[printers] comment = All Printers path = /var/tmp printable = Yes create mask = 0600 browseable = No[print$] comment = Printer Drivers path = /var/lib/samba/drivers write list = @printadmin root force group = @printadmin create mask = 0664 directory mask = 0775[root@localhost ~]# 配置一个共享 123456789101112131415[root@localhost ~]# vim /etc/samba/smb.conf在文件首部插入下列代码，保存退出即可[database]comment = Do not arbitrarily modify the database file path = /home/databasepath = /home/databasepublic = nowritable = yes上述配置含义：共享名称为database警告用户不要随意修改数据库共享目录为/home/database关闭“所有人可见”允许写入操作 新建共享所需要的目录 1[root@localhost ~]# mkdir /home/database 新建访问共享使用的用户（注意：此用户并非本地用户，但是本地要有一个用户与之对应） 12345678910111213141516171819202122232425262728293031新建本地用户aaa[root@localhost ~]# useradd aaa新建访问共享使用的用户aaa[root@localhost ~]# pdbedit -a -u aaanew password:retype new password:Unix username: aaaNT username: Account Flags: [U ]User SID: S-1-5-21-2065519308-1855748627-1460656783-1000Primary Group SID: S-1-5-21-2065519308-1855748627-1460656783-513Full Name: Home Directory: \\localhost\aaaHomeDir Drive: Logon Script: Profile Path: \\localhost\aaa\profileDomain: LOCALHOSTAccount desc: Workstations: Munged dial: Logon time: 0Logoff time: Wed, 06 Feb 2036 10:06:39 ESTKickoff time: Wed, 06 Feb 2036 10:06:39 ESTPassword last set: Wed, 30 Jan 2019 04:27:29 ESTPassword can change: Wed, 30 Jan 2019 04:27:29 ESTPassword must change: neverLast bad password : 0Bad password count : 0Logon hours : FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF[root@localhost ~]# 对共享的目录配置相应的权限 123456789安装semanage管理工具[root@localhost ~]# yum install policycoreutils-python.x86_64 -y 对共享的目录配置相应的权限[root@localhost ~]# chown -Rf aaa:aaa /home/database/[root@localhost ~]# semanage fcontext -a -t samba_share_t /home/database[root@localhost ~]# restorecon -Rv /home/database/restorecon reset /home/database context unconfined_u:object_r:home_root_t:s0-&gt;unconfined_u:object_r:samba_share_t:s0[root@localhost ~]# 启动samba服务，配置防火墙 123456[root@localhost ~]# systemctl restart smb[root@localhost ~]# firewall-cmd --add-port=445/tcp --permanent success[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# 在windows上访问samba共享,win+r 输入 1234\\ip例如我的就是：\\192.168.141.12 输入账号aaa和你刚刚设置的密码即可 在linux客户端上访问samba共享 我们现在另外开一台虚拟机，用作客户端client，没有第二台虚拟机的可以现装一个 安装客户端需要的软件包 1[root@localhost ~]# yum install samba-client cifs-utils -y 访问samba的共享 注意ip不要输错了，我的samba服务器ip是192.168.141.12，但是你的可不一定，用户名也是如此 12345678910[root@localhost ~]# smbclient //192.168.141.12/database -U aaaEnter SAMBA\aaa&apos;s password: Try &quot;help&quot; to get a list of possible commands.smb: \&gt; ls . D 0 Wed Jan 30 17:19:02 2019 .. D 0 Wed Jan 30 17:27:16 2019 17811456 blocks of size 1024. 16474020 blocks availablesmb: \&gt; exit[root@localhost ~]# 客户端开机自动挂载samba的共享 客户端配置： 12345[root@localhost ~]# vim auth.smbusername=aaapassword=123456保存退出 编辑/etc/fstab文件 12345[root@localhost ~]# vim /etc/fstab在文件最后面加入以下内容//192.168.141.12/database /database cifs credentials=/root/auth.smb 0 0保存退出 创建挂载文件夹/database，重载fstab测试挂载是否成功 12345[root@localhost ~]# mkdir /database[root@localhost ~]# mount -a[root@localhost ~]# mount | grep database//192.168.141.12/database on /database type cifs (rw,relatime,vers=1.0,cache=strict,username=aaa,domain=,uid=0,noforceuid,gid=0,noforcegid,addr=192.168.141.12,soft,unix,posixpaths,serverino,mapposix,acl,rsize=1048576,wsize=65536,echo_interval=60,actimeo=1)[root@localhost ~]# 看到有内容说明挂载成功 NFS现在我们可以关掉客户端，回到samba服务器继续接下来的实验 安装nfs工具包 1[root@localhost ~]# yum install nfs-utils.x86_64 -y 创建共享的目录，并为目录设置权限 12345[root@localhost ~]# mkdir /nfsfile[root@localhost ~]# chmod -Rf 777 /nfsfile/[root@localhost ~]# echo &quot;hello nfs&quot; /nfsfile/readme.txthello nfs /nfsfile/readme.txt[root@localhost ~]# 编辑nfs共享配置文件 12345[root@localhost ~]# vim /etc/exports[root@localhost ~]# 就写一行即可：/nfsfile *(rw,sync,root_squash)保存退出 启动nfs服务 123456[root@localhost ~]# systemctl restart rpcbind[root@localhost ~]# systemctl enable rpcbind[root@localhost ~]# systemctl start nfs-server.service [root@localhost ~]# systemctl enable nfs-server.service Created symlink from /etc/systemd/system/multi-user.target.wants/nfs-server.service to /usr/lib/systemd/system/nfs-server.service.[root@localhost ~]# nfs客户端配置 123456789101112[root@localhost ~]# showmount -e 192.168.141.12Export list for 192.168.141.12:/nfsfile *[root@localhost ~]# [root@localhost ~]# showmount -e 192.168.141.12Export list for 192.168.141.12:/nfsfile *[root@localhost ~]# mkdir /nfs[root@localhost ~]# mount -t nfs 192.168.141.12:/nfsfile /nfs[root@localhost ~]# cat /nfs/readmehello nfs[root@localhost ~]# echo &quot;192.168.141.12:/nfsfile /nfs nfs defaults 0 0&quot; &gt;&gt; /etc/fstab autofs自动挂载服务当检测到用户视图访问一个尚未挂载的文件系统时，autofs将自动挂载该文件系统 安装autofs 1[root@localhost ~]# yum install autofs -y autofs主配置文件中需要按照“挂载目录 子配置文件”的格式进行填写。 挂载目录是设备挂载位置的上一级目录。 例如，光盘设备一般挂载到/media/cdrom目录中，那么挂载目录写成/media即可。 12345[root@localhost ~]# vim /etc/auto.master将原本的/misc /etc/auto.misc改为/misc /etc/iso.misc 在子配置文件中，应按照“挂载目录 挂载文件类型及权限 :设备名称”的格式进行填写。 例如，要把光盘设备挂载到/media/iso目录中， 可将挂载目录写为iso， 而-fstype为文件系统格式参数， iso9660为光盘设备格式， ro、nosuid及nodev为光盘设备具体的权限参数， /dev/cdrom则是定义要挂载的设备名称。配置完成后再顺手将autofs服务程序启动并加入到系统启动项中： 123456789[root@localhost ~]# vi /etc/iso.misc写入以下内容iso -fstype=iso9660,ro,nosuid,nodev :/dev/cdrom保存退出[root@localhost ~]# systemctl restart autofs[root@localhost ~]# systemctl enable autofsCreated symlink from /etc/systemd/system/multi-user.target.wants/autofs.service to /usr/lib/systemd/system/autofs.service.[root@localhost ~]# 检查是否一开始没有挂载iso,但是一旦访问iso子目录，就立马被挂载上 123456789101112131415[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/centos-root 17G 1.3G 16G 8% /devtmpfs 476M 0 476M 0% /devtmpfs 488M 0 488M 0% /dev/shmtmpfs 488M 7.7M 480M 2% /runtmpfs 488M 0 488M 0% /sys/fs/cgroup/dev/sda1 1014M 130M 885M 13% /boottmpfs 98M 0 98M 0% /run/user/0192.168.141.12:/nfsfile 17G 1.3G 16G 8% /nfs11. [root@localhost ~]# cd /media12. [root@localhost media]# ls13. [root@localhost media]# cd iso14. [root@localhost iso]# ls15. manifest.txt run_upgrader.sh VMwareTools-10.2.0-7259539.tar.gz vmware-tools-upgrader-32 vmware-tools-upgrader-64 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-16 vsftpd服务]]></title>
    <url>%2Flinux-16%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-16 vsftpd服务文件传输协议FTP协议有下面两种工作模式。 主动模式：FTP服务器主动向客户端发起连接请求。 被动模式：FTP服务器等待客户端发起连接请求（FTP的默认工作模式） 安装并启动vsftpd 123456789[root@localhost ~]# yum install vsftps -y[root@localhost ~]# systemctl restart vsftpd[root@localhost ~]# systemctl enable vsftpdCreated symlink from /etc/systemd/system/multi-user.target.wants/vsftpd.service to /usr/lib/systemd/system/vsftpd.service.[root@localhost ~]# firewall-cmd --add-service=ftp --permanent success[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# 备份配置文件 1234[root@localhost ~]# mv /etc/vsftpd/vsftpd.conf&#123;,.bak&#125;[root@localhost ~]# ls /etc/vsftpd/ftpusers user_list vsftpd.conf.bak vsftpd_conf_migrate.sh[root@localhost ~]# 创建新的没有注释的配置文件 1234[root@localhost ~]# grep -v &quot;#&quot; /etc/vsftpd/vsftpd.conf.bak &gt; /etc/vsftpd/vsftpd.conf[root@localhost ~]# ls /etc/vsftpd/ftpusers user_list vsftpd.conf vsftpd.conf.bak vsftpd_conf_migrate.sh[root@localhost ~]# 查看默认配置文件中的选项 12345678910111213141516[root@localhost ~]# cat /etc/vsftpd/vsftpd.confanonymous_enable=YESlocal_enable=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=NOlisten_ipv6=YESpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YES[root@localhost ~]# Vsftpd服务程序vsftpd作为更加安全的文件传输的服务程序，允许用户以三种认证模式登录到FTP服务器上。 vsftpd使用三大模式： 匿名用户模式 是一种最不安全的认证模式，任何人都可以无需密码验证而直接登录到FTP服务器。 本地用户模式 是通过Linu系统本地的账户密码信息进行认证的模式，相较于匿名开放模式更安全，而且配置起来也很简单。但是如果被黑客破解了账户的信息，就可以畅通无阻地登录FTP服务器，从而完全控制整台服务器。 虚拟用户模式 是这三种模式中最安全的一种认证模式，它需要为FTP服务单独建立用户数据库文件，虚拟出用来进行口令验证的账户信息，而这些账户信息在服务器系统中实际上是不存在的，仅供FTP服务程序进行认证使用。这样，即使黑客破解了账户信息也无法登录服务器，从而有效降低了破坏范围和影响。 匿名开放模式修改配置文件 123456789101112131415161718192021222324252627[root@localhost ~]# vim /etc/vsftpd/vsftpd.confanonymous_enable=YESanon_umask=022anonymous_enable=YESanon_umask=022anon_upload_enable=Yesanon_mkdir_write_enable=Yesanon_other_write_enable=Yeslocal_enable=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=NOlisten_ipv6=YESpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YES保存退出 [root@localhost ~]# systemctl restart vsftpd[root@localhost ~]# chown -Rf ftp /var/ftp/pub[root@localhost ~]# setsebool -P ftpd_full_access=on[root@localhost ~]# 接下来就可以用windows资源管理器登录上去上传下载文件 本地用户模式修改配置文件 1234567891011121314151617[root@localhost ~]# vim /etc/vsftpd/vsftpd.confanonymous_enable=NOlocal_enable=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=NOlisten_ipv6=YESpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YES保存退出[root@localhost ~]# systemctl restart vsftpd 再次用windows资源管理器登录服务器： 按理来讲，现在已经完全可以本地用户的身份登录FTP服务器了。但是在使用root管理员登录后，发现登陆失败： 可见，我们已经被系统拒绝访问了。这是因为vsftpd服务程序所在的目录中默认存放着两个名为“用户名单”的文件（ftpusers和user_list）。vsftpd服务程序目录中的这两个文件只要里面写有某位用户的名字，就不再允许这位用户登录到FTP服务器上。分别打开 ftpusers 和 user_list 这两个文件，删除里面的root，然后保存并退出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182[root@localhost ~]# cat /etc/vsftpd/ftpusers # Users that are not allowed to login via ftprootbindaemonadmlpsyncshutdownhaltmailnewsuucpoperatorgamesnobody[root@localhost ~]# vim /etc/vsftpd/ftpusers 删除root，保存退出。[root@localhost ~]# cat /etc/vsftpd/ftpusers # Users that are not allowed to login via ftpbindaemonadmlpsyncshutdownhaltmailnewsuucpoperatorgamesnobody[root@localhost ~]# [root@localhost ~]# cat /etc/vsftpd/user_list # vsftpd userlist# If userlist_deny=NO, only allow users in this file# If userlist_deny=YES (default), never allow users in this file, and# do not even prompt for a password.# Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers# for users that are denied.rootbindaemonadmlpsyncshutdownhaltmailnewsuucpoperatorgamesnobody[root@localhost ~]# [root@localhost ~]# vim /etc/vsftpd/user_list 删除root，保存退出。[root@localhost ~]# cat /etc/vsftpd/user_list # vsftpd userlist# If userlist_deny=NO, only allow users in this file# If userlist_deny=YES (default), never allow users in this file, and# do not even prompt for a password.# Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers# for users that are denied.bindaemonadmlpsyncshutdownhaltmailnewsuucpoperatorgamesnobody[root@localhost ~]# 现在就可以用本地用户root登录了，本地用户登录上去之后，登录的目录是本地用户的家目录，如下图 虚拟用户模式创建一个本地用户，用于映射虚拟用户在本地的代理，为了安全起见，禁止这个用户登录linux服务器 1[root@localhost ~]# useradd -d /var/ftproot -s /sbin/nologin virtual 创建用于进行FTP认证的用户数据库文件，其中奇数行为账户名，偶数行为密码。 1234567891011[root@localhost ~]# cd /etc/vsftpd/[root@localhost vsftpd]# vim vuser.listaaa123456bbb123456ccc123456保存退出 使用db_load命令用哈希（hash）算法将原始的明文信息文件转换成数据库文件 降低数据库文件的权限（避免其他人看到数据库文件的内容） 把原始的明文信息文件删除。 123456[root@localhost vsftpd]# db_load -T -t hash -f vuser.list vuser.db[root@localhost vsftpd]# file vuser.dbvuser.db: Berkeley DB (Hash, version 9, native byte-order)[root@localhost vsftpd]# chmod 600 vuser.db[root@localhost vsftpd]# rm -f vuser.list[root@localhost vsftpd]# 建立用于支持虚拟用户的PAM文件 12345[root@localhost vsftpd]# vim /etc/pam.d/vsftpd.vuauth required pam_userdb.so db=/etc/vsftpd/vuseraccount required pam_userdb.so db=/etc/vsftpd/vuser保存退出 修改vsftpd配置文件 12345678910111213141516171819202122[root@localhost vsftpd]# vim /etc/vsftpd/vsftpd.confanonymous_enable=NOlocal_enable=YESguest_enable=YESguest_username=virtualallow_writeable_chroot=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=NOlisten_ipv6=YES pam_service_name=vsftpd.vuuserlist_enable=YEStcp_wrappers=YES保存退出，重启vsftpd服务[root@localhost vusers_dir]# systemctl restart vsftpd 再次用windows资源管理器登录服务器，这次我们用bbb用户登录： 登录成功，到了bbb用户的家目录，不过这里什么文件也木有 tftp服务安装tftp服务 12345678[root@localhost ~]# yum install xinetd tftp-server.x86_64 tftp -y[root@localhost ~]# firewall-cmd --add-port=69/udp --permanent success[root@localhost ~]# firewall-cmd --reload success[root@localhost ~]# 这里tftp的对应端口号69 修改配置文件 1234567[root@localhost ~]# vim /etc/xinetd.d/tftp 将 disable = yes改为disable = no保存退出 重启服务 123[root@localhost ~]# systemctl restart xinetd.service [root@localhost ~]# systemctl enable xinetd[root@localhost ~]# 命令 作用 ? 帮助信息 put 上传文件 get 下载文件 verbose 显示详细的处理信息 status 显示当前的状态信息 binary 使用二进制进行传输 ascii 使用ASCII码进行传输 timeout 设置重传的超时时间 quit 退出 测试 1234567[root@localhost ~]# echo &quot;hello,tftp&quot; &gt; /var/lib/tftpboot/readme.txt[root@localhost ~]# tftp 192.168.141.12tftp&gt; get readme.txttftp&gt; quit[root@localhost ~]# cat readme.txt hello,tftp[root@localhost ~]# 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-15 Apache服务]]></title>
    <url>%2Flinux-15%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-15 Apache服务基本步骤1.安装启动Apache服务，防火墙放行相应的端口1234567[root@localhost ~]# yum install httpd -y[root@localhost ~]# systemctl restart httpd[root@localhost ~]# firewall-cmd --add-port=80/tcp --permanent success[root@localhost ~]# firewall-cmd --reload success[root@localhost ~]# 接下来在自己电脑浏览器上访问虚拟机的ip地址，例如我的ip是192.168.141.12，打开后可以看到这个测试页面： 2.编写第一个网页文件123456[root@localhost ~]# cd /var/www/html/[root@localhost html]# ls[root@localhost html]# vim index.html[root@localhost html]# cat index.html hello world ![root@localhost html]# 此时就可以在浏览器上输入ip看到这个网页了 如果你刚刚重启了虚拟机，有可能会看不到网页效果，此时需要重启httpd服务 1systemctl restart httpd 此时就又可以在浏览器上输入ip看到这个hello world ! 的网页了 3.开启selinux，并配置selinux1234567[root@localhost ~]# vim /etc/selinux/config 将selinux设置为enforcing将SELINUXTYPE设置为targeted如下：SELINUX=enforcingSELINUXTYPE=targeted 4.重启虚拟机，查看selinux状态1234[root@localhost ~]# reboot[root@localhost ~]# getenforce Enforcing 5.查看网站服务的系统文件123[root@localhost ~]# ls -Zd /var/www/htmldrwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www/html[root@localhost ~]# 用户段system_u代表系统进程的身份 角色段object_r代表文件目录的角色 类型段httpd_sys_content_t代表网站服务的系统文件 例如上述网站服务的系统文件角为/var/www/html 6.新建一个目录，后面我们会把网站根目录改到这个新建目录下1234[root@localhost ~]# mkdir /home/wwwroot[root@localhost ~]# ls -Zd /home/wwwroot/drwxr-xr-x. root root unconfined_u:object_r:home_root_t:s0 /home/wwwroot/[root@localhost ~]# semanage工具semanage命令用于管理SELinux的策略，格式为“semanage [选项] [文件]” 经常用到的几个参数及其功能如下所示： -l参数用于查询； -a参数用于添加； -m参数用于修改； -d参数用于删除。 安装semanage管理工具1[root@localhost ~]# yum install policycoreutils-python.x86_64 -y PS: 如果安装不了就换个yum源 修改网站根目录，为新设置的网站根目录配置SELinux安全上下文1234567891011首先在新的网站目录下也弄一个默认网页[root@localhost ~]# cd /home/wwwroot/[root@localhost wwwroot]# touch index.html[root@localhost wwwroot]# vim index.html [root@localhost wwwroot]# cat index.html /home/wwwroot/ have hello world too ![root@localhost wwwroot]# 修改配置文件,在第119/124/131行将原本的/var/www/html修改为/home/wwwroot/vim编辑文件时，：set nu即可查看行号[root@localhost ~]# vim /etc/httpd/conf/httpd.conf 修改为： 然后保存退出即可 接下来重启httpd服务，为新设置的网站根目录配置SELinux安全上下文 1234567[root@localhost ~]# systemctl restart httpd.service [root@localhost ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/[root@localhost ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/*[root@localhost ~]# restorecon -Rv /home/wwwroot/restorecon reset /home/wwwroot context unconfined_u:object_r:home_root_t:s0-&gt;unconfined_u:object_r:user_home_dir_t:s0restorecon reset /home/wwwroot/index.html context unconfined_u:object_r:home_root_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0[root@localhost ~]# 再次到浏览器访问自己的ip，可以看到自己放在新的网站根目录地下的index.html的内容 个人用户主页修改配置文件1[root@localhost ~]# vim /etc/httpd/conf.d/userdir.conf 将该配置文件第17行的内容由disabled改为public_html 修改成： 保存退出，重启httpd服务，将httpd_enable_homedirs 的状态由 off改为on 1234567[root@localhost ~]# systemctl restart httpd.service [root@localhost ~]# getsebool -a | grep http | grep homehttpd_enable_homedirs --&gt; off[root@localhost ~]# setsebool -P httpd_enable_homedirs=on[root@localhost ~]# getsebool -a | grep http | grep homehttpd_enable_homedirs --&gt; on[root@localhost ~]# 新建一个用户，设置这个用户的主页12345678910111213[root@localhost ~]# cd /home[root@localhost home]# lswwwroot[root@localhost home]# useradd aaa[root@localhost home]# lsaaa wwwroot[root@localhost home]# chmod o+x /home/aaa[root@localhost home]# su aaa[aaa@localhost home]$ cd ~[aaa@localhost ~]$ mkdir public_html[aaa@localhost ~]$ echo &quot;hello ,i am aaa&quot; &gt; public_html/index.html[aaa@localhost ~]$ chmod 755 public_html/[aaa@localhost ~]$ 到浏览器访问自己虚拟机的ip加上/~用户名/看看效果： 例如我访问的就是：192.168.141.12/~aaa/ 如下图: 密码认证为个人用户主页加上密码认证（密码认证也可以直接用作正常网站） 12345678910111213141516171819202122在交互模式下为用户aaa设置httpd服务的密码，我这里设置的是123456[aaa@localhost root]$ su rootPassword: [root@localhost ~]# htpasswd -c /etc/httpd/passwd aaaNew password: Re-type new password: Adding password for user aaa[root@localhost ~]# 修改配置文件，将&lt;Directory &quot;/home/*/public_html&quot;&gt;和&lt;/Directory&gt;之间的内容修改为如下形式，有代码，也有截图供您参考：[root@localhost ~]# vim /etc/httpd/conf.d/userdir.conf &lt;Directory &quot;/home/*/public_html&quot;&gt; AllowOverride all authuserfile &quot;/etc/httpd/passwd&quot; authname &quot;My privately website&quot; authtype basic require user aaa # Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec# Require method GET POST OPTIONS&lt;/Directory&gt; 原来的文件是这样的： 修改后的文件是这样的： 保存退出，重启httpd服务 12[root@localhost ~]# systemctl restart httpd[root@localhost ~]# 再次到浏览器访问自己虚拟机的ip加上/~用户名/看看效果： 例如我访问的就是：192.168.141.12/~aaa/ 如下图: 登录上去后是这样的： 虚拟主机基于IP地址划分虚拟主机首先，为虚拟机再添加三个IP地址123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@localhost ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33如下，我给网卡新加了.13 .14 .15三个ip，这里以此三个ip为例TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot;DEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;9c86a9bc-0939-4790-8580-274041e5eff3&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;yIPADDR=192.168.141.12NETMASK=255.255.255.0IPADDR0=192.168.141.13NETMASK0=255.255.255.0IPADDR1=192.168.141.14NETMASK1=255.255.255.0IPADDR2=192.168.141.15NETMASK2=255.255.255.0GATEWAY1=192.168.141.2DNS1=114.114.114.114DNS2=8.8.8.8保存退出，重启网络服务[root@localhost ~]# systemctl restart network[root@localhost ~]# ip add | grep inet | grep brd inet 192.168.141.12/24 brd 192.168.141.255 scope global noprefixroute ens33 inet 192.168.141.13/24 brd 192.168.141.255 scope global secondary noprefixroute ens33 inet 192.168.141.14/24 brd 192.168.141.255 scope global secondary noprefixroute ens33 inet 192.168.141.15/24 brd 192.168.141.255 scope global secondary noprefixroute ens33 inet 192.168.141.1 创建网页 为不同站点创建不同网站根目录 12345678[root@localhost ~]# cd /home/wwwroot/[root@localhost wwwroot]# mkdir 10[root@localhost wwwroot]# mkdir 20[root@localhost wwwroot]# mkdir 30[root@localhost wwwroot]# echo &quot;i am 192.168.141.13&quot; &gt; /home/wwwroot/10/index.html[root@localhost wwwroot]# echo &quot;i am 192.168.141.14&quot; &gt; /home/wwwroot/20/index.html[root@localhost wwwroot]# echo &quot;i am 192.168.141.15&quot; &gt; /home/wwwroot/30/index.html[root@localhost wwwroot]# 修改配置文件123456789101112131415161718192021222324252627282930313233[root@localhost wwwroot]# cd [root@localhost ~]# vim /etc/httpd/conf/httpd.conf 在该文件尾部加上三个虚拟主机配置：&lt;VirtualHost 192.168.141.13&gt;DocumentRoot /home/wwwroot/10ServerName 10&lt;Directory /home/wwwroot/10&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.141.14&gt;DocumentRoot /home/wwwroot/20ServerName 20&lt;Directory /home/wwwroot/20&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.141.15&gt;DocumentRoot /home/wwwroot/30ServerName 30&lt;Directory /home/wwwroot/30&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;保存退出，重启httpd服务[root@localhost ~]# systemctl restart httpd.service 分别在浏览器打开ip，此处以192.168.141.15为例，看看如下图的效果： 可以看到报403错，服务器（咱们的虚拟机）拒绝浏览器访问这个网站，原因很简单，就是咱们创建了三个新的网站，却没有为三个新的网站根目录配置SELinux安全上下文，就会导致这种情况，接下来咱们来一一设置一下即可： 12345678910111213[root@localhost ~]# systemctl restart httpd[root@localhost ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/10/[root@localhost ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/20/[root@localhost ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/30/[root@localhost ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/10/*[root@localhost ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/20/*[root@localhost ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/30/*[root@localhost ~]# restorecon -Rv /home/wwwroot/restorecon reset /home/wwwroot/10/index.html context unconfined_u:object_r:user_home_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0restorecon reset /home/wwwroot/20/index.html context unconfined_u:object_r:user_home_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0restorecon reset /home/wwwroot/30/index.html context unconfined_u:object_r:user_home_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0[root@localhost ~]# systemctl restart httpd.service [root@localhost ~]# 设置完成后重新启动httpd服务，然后浏览器就可以看到如下效果了 效果截图： 咱们可以把之前弄的网站一起看看，都是可以顺利访问的： 看着上面这张图，顿时就有了一丢丢成就感。 基于主机域名划分的虚拟主机创建网页文件1234[root@localhost ~]# echo &quot;i am 10&quot; &gt; /home/wwwroot/10/index.html [root@localhost ~]# echo &quot;i am 20&quot; &gt; /home/wwwroot/20/index.html [root@localhost ~]# echo &quot;i am 30&quot; &gt; /home/wwwroot/30/index.html [root@localhost ~]# 修改http配置文件12345678910111213141516171819202122232425262728293031323334[root@localhost ~]# vim /etc/httpd/conf/httpd.conf #仅仅修改一下ServerName即可：&lt;VirtualHost 192.168.141.13&gt;DocumentRoot /home/wwwroot/10ServerName 10.feng.io&lt;Directory /home/wwwroot/10&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.141.14&gt;DocumentRoot /home/wwwroot/20ServerName 20.feng.io&lt;Directory /home/wwwroot/20&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.141.15&gt;DocumentRoot /home/wwwroot/30ServerName 30.feng.io&lt;Directory /home/wwwroot/30&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;保存退出，重启httpd服务[root@localhost ~]# systemctl restart httpd.service [root@localhost ~]# 由于网站根目录没变，所以网站根目录无需再次配置selinux安全上下文 接下来在自己电脑上修改一个文件 C:\Windows\System32\drivers\etc的目录下，有个叫hosts的文件，咱们可以用notepad++打开编辑，保存的时候回提示以管理员身份才能保存。咱们在该文件尾部，加上三行配置保存退出即可。 ​ ps：这个文件用于域名重定向，很多病毒也经常来改你这个文件，让你在浏览器敲入“taobao.com”等网址的时候，ip其实已经重定向到黑客指定的服务器上了，这样你就会上一个假的淘宝网站，造成你的困扰甚至经济损失。 123192.168.141.13 10.feng.io192.168.141.14 20.feng.io192.168.141.15 30.feng.io 前面的是服务器ip，后面的是对应域名 接下来咱们打开电脑的cmd，刷新一下dns，ping一下10.feng.io看看是哪个ip在相应我们 12ipconfig /flushdnsping 10.feng.io 如下图，可以看到ping 10.feng.io的话，就相当于直接ping 192.168.141.13，说明配置成功 接下来咱们在浏览器上访问域名，效果如下： 咱们改了host文件，这个实验做完了之后可以把我们的改动删掉或者备注掉，也可以留在那，一般情况下不会出问题。 基于端口号划分的虚拟主机修改配置文件123456789101112131415161718192021222324252627282930313233[root@localhost ~]# vim /etc/httpd/conf/httpd.conf Listen 30010Listen 30020Listen 30030&lt;VirtualHost 192.168.141.12:30010&gt;DocumentRoot /home/wwwroot/10ServerName 10.feng.io&lt;Directory /home/wwwroot/10&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.141.12:30020&gt;DocumentRoot /home/wwwroot/20ServerName 20.feng.io&lt;Directory /home/wwwroot/20&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.141.12:30030&gt;DocumentRoot /home/wwwroot/30ServerName 30.feng.io&lt;Directory /home/wwwroot/30&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt; 相应端口做好相应协议、防火墙配置 123456789[root@localhost ~]# semanage port -a -t http_port_t -p tcp 30010[root@localhost ~]# semanage port -a -t http_port_t -p tcp 30020[root@localhost ~]# semanage port -a -t http_port_t -p tcp 30030[root@localhost ~]# firewall-cmd --add-port=&#123;30010,30020,30030&#125;/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --reload success[root@localhost ~]# systemctl restart httpd.service [root@localhost ~]# 接下来在浏览器访问ip加端口，效果如下： 阻止特定浏览器特征访问例如：VirtualHost 192.168.141.12:30010阻止firefox访问 VirtualHost 192.168.141.12:30020和VirtualHost 192.168.141.12:30030不阻止firefox访问 12345678910111213141516171819202122232425262728293031323334353637383940[root@localhost ~]# vim /etc/httpd/conf/httpd.conf Listen 30010Listen 30020Listen 30030&lt;VirtualHost 192.168.141.12:30010&gt;DocumentRoot /home/wwwroot/10ServerName 10.feng.io&lt;Directory /home/wwwroot/10&gt;SetEnvif User-Agent &quot;Firefox&quot; ff=1Order deny,allowDeny from env=ffAllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.141.12:30020&gt;DocumentRoot /home/wwwroot/20ServerName 20.feng.io&lt;Directory /home/wwwroot/20&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.141.12:30030&gt;DocumentRoot /home/wwwroot/30ServerName 30.feng.io&lt;Directory /home/wwwroot/30&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;保存退出，重启httpd服务[root@localhost ~]# systemctl restart httpd.service 接下来咱们看看效果，如下图： 可以看到，咱们的VirtualHost 192.168.141.12:30010阻止firefox访问后，再次访问已经看不到其网页内容了 ，然而其他主机却仍然可以正常访问 好了，本篇到此结束，Apache服务在以后咱们运维实战的时候，搭建在服务器上也是很好用的，可以用作网站下分设多个子网站。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-14 SSH远程访问服务]]></title>
    <url>%2Flinux-14%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-14 SSH远程访问服务 提示：SSH远程访问服务会在后续章节“linux-运维实战”中，在远程控制腾讯云服务器时使用到，是保证你的服务器不被别人黑掉的重要知识点，所以必须牢牢掌握。 知识回顾带端口和不带端口ssh远程连接服务器（这里以虚拟机为例，下一章咱们再去腾讯云买服务器玩儿） 12345[C:\~]$ ssh root@192.168.141.12[C:\~]$ ssh root@192.168.141.12 22PS：不带端口时，就是默认采用了22端口 nmcli网络管理命令查看当前网络设备12345[root@localhost ~]# nmcli connection showNAME UUID TYPE DEVICE Wired connection 1 e574440b-5a39-3a2b-a14d-ea6a2d920a7e ethernet ens37 ens33 9c86a9bc-0939-4790-8580-274041e5eff3 ethernet ens33 [root@localhost ~]# 查看指定网络设备的详细信息1[root@localhost ~]# nmcli connection show ens33 给网卡绑定多个配置文件12345678910111213# 给网卡ens33增加一个名为ens60的配置文件[root@localhost ~]# nmcli connection add con-name ens60 ifname ens33 autoconnect no type ethernet ipv4.addresses 192.168.141.200/24 gw4 192.168.141.2Connection &apos;ens60&apos; (8ad23f3d-e490-48a8-bc9f-273ae773435a) successfully added.[root@localhost ~]# nmcli connection showNAME UUID TYPE DEVICE Wired connection 1 e574440b-5a39-3a2b-a14d-ea6a2d920a7e ethernet ens37 ens33 9c86a9bc-0939-4790-8580-274041e5eff3 ethernet ens33 ens60 8ad23f3d-e490-48a8-bc9f-273ae773435a ethernet -- # 启用ens60配置文件[root@localhost ~]# nmcli connection up ens60# 启用了这个配置之后，IP就可以ping通，但ifconfig可能看不到这个配置，同时ens33的ip会变化，xshell会断开，这个先不用着急。 验证： 由于xshell、4已经断开，咱们在直接虚拟机里查看当前网卡ip 可以看到ip 192.168.141.200已经加上去了 那么咱们用nmcli网络管理命令管理网路的配置就到此结束 接下来咱们在虚拟机里重启网络服务，继续下面的实验 12[root@localhost ~]# systemctl restart network[root@localhost ~]# ip add 可以看到原先的ip又回来了，现在又可以用xshell连接192.168.141.12这个ip，接着做下面的实验。 SSH远程访问服务保证Linux服务器开启ssh之后的基本安全，要做到以下四点： 禁止root使用ssh访问远程Linux服务器 禁止使用密码登录ssh服务 使用非对称密钥登录ssh服务 修改ssh服务的默认端口号 解析：1.禁止root使用ssh访问远程Linux服务器 有效防止黑客利用暴力破解工具，在已知用户名root的情况下，轻易将你的root密码破解。 2.禁止使用密码登录ssh服务 即使你禁止了root使用ssh访问远程Linux服务器，但是依然存在这样一种可能：黑客可能通过社交软件了解了一些你的个人信息，了解到你可能用你的英文名或者社交昵称等作为你的服务器用户名，然后暴力破解出你的用户名和密码，黑掉你的服务器。所以用密码登录服务器，始终是不安全的。 3.使用非对称密钥登录ssh服务 不用密码登录，那咱们怎么验证身份呢？这里我们可以采用比密码安全不知道几万倍的非对称密钥登录ssh服务，别人没有你的秘钥，就无法ssh远程操控你的服务器。 4.修改ssh服务的默认端口号​ ssh的默认端口号是22，咱们之前用的命令： 1234[C:\~]$ ssh root@192.168.141.12[C:\~]$ ssh root@192.168.141.12 22PS：不带端口时，就是默认采用了22端口 这两条命令就是通常我们ssh远程访问服务器所使用的命令，许多小白级别的运维人员，用的root加密码123456就可以登录上去，话说就算小白同学多个心眼改一下ssh端口号，黑客也相对没那么容易攻破你的服务器哇！ 步骤：1.新建一个用户组afeng，然后新建一个用户aaa，用来代替root的使用，加入到afeng组，可以使用sudo命令借用root的权限来管理Linux服务器 123456789101112131415161718192021[root@localhost ~]# groupadd afeng[root@localhost ~]# useradd aaa -G afeng [root@localhost ~]# cat /etc/group | grep aaaafeng:x:1000:aaaaaa:x:1001:[root@localhost ~]# [root@localhost ~]# cat /etc/passwd | grep aaaaaa:x:1000:1001::/home/aaa:/bin/bash[root@localhost ~]# 可以看到，用户aaa的UID是1000，GID是1001对应的也就是aaa，所以其主组是aaa从/etc/group下的afeng:x:1000:aaa也可以看出afeng是aaa的附属组设置用户aaa的密码[root@localhost ~]# passwd aaaChanging password for user aaa.New password: BAD PASSWORD: The password is shorter than 8 charactersRetype new password: passwd: all authentication tokens updated successfully.[root@localhost ~]# 2.锁定root用户的密码 12345678[root@localhost ~]# passwd -l rootLocking password for user root.passwd: Success# 查看root用户密码的状态[root@localhost ~]# passwd -S rootroot LK 2018-09-24 0 99999 7 -1 (Password locked.)[root@localhost ~]# 这时候，我们已经可以用普通用户登录到Linux服务器，用sudo su root切换到root用户继续使用root。 可以用xshell另外多开一个会话来验证一下 123456789[C:\~]$ ssh aaa@192.168.141.12Connecting to 192.168.141.12:22...Connection established.To escape to local shell, press &apos;Ctrl+Alt+]&apos;.WARNING! The remote SSH server rejected X11 forwarding request.[aaa@localhost ~]$ 发现咱们现在确实可以登陆上来，接下来验证一下咱们能否用sudo su root切换到root用户继续使用root。 123456789101112[aaa@localhost ~]$ sudo su rootWe trust you have received the usual lecture from the local SystemAdministrator. It usually boils down to these three things: #1) Respect the privacy of others. #2) Think before you type. #3) With great power comes great responsibility.[sudo] password for aaa: aaa is not in the sudoers file. This incident will be reported.[aaa@localhost ~]$ 结果咱们被拒绝了，因为现在aaa用户尚未在sudoers file里。 那咱们回到原来的会话（xshell一个窗口就是一个会话），也就是root登录着的那个会话，先把aaa添加进sudoers file里。 123456[root@localhost ~]# visudo 找到root ALL=(ALL) ALL在上面这一行下面新加一行：aaa ALL=(ALL) ALL保存退出 现在切换回aaa那个会话，再次验证咱们能否用sudo su root切换到root用户继续使用root 12345[aaa@localhost ~]$ sudo su root[sudo] password for aaa: [root@localhost aaa]# 这回可以了 3.设置ssh服务，禁止root使用ssh访问远程Linux服务器，禁止使用密码登录ssh服务器，改变服务端口号为10022 1234567891011121314151617181920212223242526272829303132[root@localhost ~]# vim /etc/ssh/sshd_config 禁止Root使用ssh远程登录38行将#PermitRootLogin yes改成PermitRootLogin no别忘了#号也要去掉，#号是备注的意思开启证书登录的功能43行将 #PubkeyAuthentication yes去掉注释改成PubkeyAuthentication yes禁止使用密码登录ssh服务器65行将PasswordAuthentication yes改为PasswordAuthentication no改变ssh服务端口号17行将#Port 22改成Port 10022保存后退出，重启ssh服务（sshd就是ssh device的意思）[root@localhost ~]# systemctl restart sshd如果这里报错了，那一定是上面/etc/ssh/sshd_config 这个配置文件你哪里写错了 4.向防火墙中添加修改的端口，如果开启了selinux，在修改端口号的时候会失败，我们直接关闭selinux 123456789101112131415161718192021222324252627282930313233[root@localhost ~]# firewall-cmd --zone=public --add-port=10022/tcp --permanent success[root@localhost ~]# firewall-cmd --reload success查看端口是否添加成功:[root@localhost ~]# firewall-cmd --zone=public --query-port=10022/tcpyes[root@localhost ~]# [root@localhost ~]# vim /etc/selinux/config 将SELINUX=enforcing改为SELINUX=disabled检查一下[root@localhost ~]# cat /etc/selinux/config # This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=disabled# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection.SELINUXTYPE=targeted [root@localhost ~]# 5.生成证书： 注意：新的用户需要生成新的密钥来用来登录 1234xshell的新会话中先切换回aaa[root@localhost aaa]# su aaa[aaa@localhost ~]$ ssh-keygen 此处一直敲回车即可 ​ 命令敲完后，系统会自动生成~/.ssh目录，这个目录下会保存Linux的公钥和私钥以及存放客户端公钥的文件.ssh/authorized_keys 6.windows生成客户端公钥： 此处一直点下一步，直到进入如下选项时，我们设一个密钥名称，密码和确认那俩框不用填，点击完成即可 7.将复制的内容写入到Linux系统中我们新建用户aaa的~/.ssh/authorized_keys文件中 1234567[aaa@localhost ~]$ whoamiaaa[aaa@localhost ~]$ vim ~/.ssh/authorized_keys[aaa@localhost ~]$ cat ~/.ssh/authorized_keysssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAurKiTVI2mKJswDThaEYNF/DiBOJZeMTCofxFXw0ZjD0fisnKmLmnBQKEna1NArHFVn42RcwRYM3o5KezSNz9dcj0QB2KB9Rby7N5RBL6WQP5HhhclY5ldHI8AIrMDKtzd+IbZYoMknIXWt0iQ9Z069YmQB4dQlQrq9ZUxEdgz5mhusjoSZxVu2kf14/qhuK28/Mo5NLATvTIbN04D8bXX2Jh9vlhhhK8XCnvyuIxV2lNvfU5K88CgM+utOAvELjKhsiMlmrhvNs4kh5o3JSpmIyJfayFpnLvdrGn9w6u1ndzoTE29oTCUKllwD3BZRqPmdVGDF+koBLzipNMCjk21w== rsa 2048-013019[aaa@localhost ~]$ chmod 600 ~/.ssh/authorized_keys[aaa@localhost ~]$ 8.重启sshd服务，让ssh配置生效（改/etc/sshd/目录下的文件需要重新服务，添加删除用户密钥并不需要重启sshd服务） 12345[root@localhost ssh]# systemctl restart sshd[root@localhost ssh]# netstat -ntlp | grep 10022tcp 0 0 0.0.0.0:10022 0.0.0.0:* LISTEN 6110/sshd tcp6 0 0 :::10022 :::* LISTEN 6110/sshd [root@localhost ssh]# 9.用xshell远程登录Linux服务器 用户aaa成功登录啦！ 情况一：现在假设黑客猜到了你的ssh端口号是10022，又把你的密钥也搞到了手，现在他尝试用root用户登录 1[C:\~]$ ssh root@192.168.141.12 10022 结果如下图，黑客登录失败，失败的原因就是我们拒绝了root登录 情况二：假设黑客搞到了你的用户名aaa和ssh端口号10022，但是服务器是拒绝用密码登陆的，也就是他没法爆破，只能用密钥登录，可惜他没有你的aaa用户的密钥feng_system，所以也登录不上 情况三：这是99.99%的情况 别人不知道你的端口号，也不知道你的用户名，更没有你的用户密钥，所以服务器很安全。但是服务器ip很容易就会被知道，ping一下咱网站域名就可以看到服务器ip了，比如ping一下我的个人博客https://xiaoxingzone.coding.me/如下图 黑客仅仅知道你的服务器ip的话，是无法ssh远程控制你的服务器的。但是黑客可以搞一个低轨道粒子炮之类的工具，对你的服务器一直轰炸，或者搞一些其他的攻击方式，让你的服务器很难受，这就涉及到网络安全方面的知识了。 ​ 此外，我们后续章节中还会介绍如何禁止别人ping咱们的服务器。 另外，HEXO个人博客利用coding和github开源仓库搭建，并没有搭建在我自己的服务器上，所以无需多虑。关于ssh的配置后面我们会在运维实战章节再次用到。 不间断会话服务（虚拟终端） 因为在执行一些脚本的时候，可能要使用的时间很长，而我们电脑可能不会开那么久的终端软件，那么这时候，就要有一个虚拟的终端来帮助我们执行长时间的任务 安装screen 1234[aaa@localhost ~]$ sudo su root[sudo] password for aaa: [root@localhost aaa]# [root@localhost aaa]# yum install screen -y 新建一个终端任务 1234[root@localhost ~]# screen -S lnmp回车之后进入到新的终端开始一个任务[root@localhost aaa]# wget http://soft.vpser.net/lnmp/lnmp1.5.tar.gz -cO lnmp1.5.tar.gz &amp;&amp; tar zxf lnmp1.5.tar.gz &amp;&amp; cd lnmp1.5 &amp;&amp; ./install.sh lnmp 如果任务没有执行完，我们需要关闭终端，可以直接关掉终端（千万不要用CTRL+Z或者CTRL+C），也可以用ctrl+a，松开a再按一下d（ctrl不要放开）临时退出虚拟终端 恢复最近的一个终端，用screen -r命令 1[root@localhost aaa]# screen -r 如果有多个虚拟终端，我们可以使用命令查看后台运行的虚拟终端 123456[root@localhost aaa]# screen -listThere is a screen on: 6327.lnmp (Detached)1 Socket in /var/run/screen/S-root.[root@localhost aaa]# 要恢复指定的虚拟终端 1[root@localhost aaa]# screen -r lnmp 退出虚拟终端的话，进入虚拟中断（ctrl+c）之后用exit退出就行啦 1[root@localhost lnmp1.5]# exit 虚拟终端这个不好演示，截图的话也没啥意义，上面的命令行足矣 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-13 iptables与firewalld防火墙]]></title>
    <url>%2Flinux-13%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-13 iptables与firewalld防火墙iptablesiptables是centos6以及之前版本的默认防火墙工具，在centos7中默认防火墙工具已经替换为firewalld。 区别iptables防火墙的底层是netfiter firewalld防火墙的底层是iptables 注意：iptables和firewalld是冲突的，同时只能使用一个防火墙 netfilter模块 在centos6上，我们用的是iptables服务，而在centos7上，我们用的是firewalld服务。同样的，centos6上安装的是iptables包，而centos7上安装的是firewalld包。不管是centos6还是centos7，核心其实都是netfilter，netfilter是linux的一个内核模块，iptables命令是linux内核自带的。centos6上的iptables服务和centos7上的firewalld服务，其实都是用来定义防火墙规则功能的防火墙管理工具。它们都是将定义好的规则交由内核中的netfilter即网络过滤器来读取，从而真正实现防火墙功能，所以其实在配置规则的思路上是完全一致的。 在centos7中开启iptables的使用 12345678910# 禁用firewalld防火墙[root@localhost ~]# systemctl stop firewalld.service [root@localhost ~]# systemctl mask firewalld.service Created symlink from /etc/systemd/system/firewalld.service to /dev/null. # 安装iptables 服务[root@localhost ~]# yum install iptables-services -y # 开启iptables服务[root@localhost ~]# systemctl start iptables iptables命令的基本参数 参数 作用 -P 设置默认策略 -F 清空规则链 -L 查看规则链 -A 在规则链的末尾加入新规则 -I num 在规则链的头部加入新规则 -D num 删除某一条规则 -s 匹配来源地址IP/MASK，加叹号“!”表示除这个IP外 -d 匹配目标地址 -i网卡名称 匹配从这块网卡流入的数据 -o网卡名称 匹配从这块网卡流出的数据 -p 匹配协议，如TCP、UDP、ICMP –dport num 匹配目标端口号 使用iptables 123456789101112131415161718192021222324252627282930# 清除iptables中所有的规则[root@localhost ~]# iptables -F # 查看iptables防火墙中所有的规则[root@localhost ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination Chain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination [root@localhost ~]# iptables -P INPUT DROP #默认INPUT全部允许 禁止所有人ping服务器[root@localhost ~]# iptables -I INPUT -p icmp -j DROP [root@localhost ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination DROP icmp -- anywhere anywhere Chain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination # 这个是服务器接收到icmp的包之后丢弃 接下来在宰门物理机上验证能否ping通虚拟机： 1C:\Users\zhong&gt;ping 192.168.141.12 结果是ping不通 接下来咱们删掉丢失包的规则，也就是刚刚咱们创建的那条禁止ping的规则 12[root@localhost ~]# iptables -D INPUT 1[root@localhost ~]# 现在又可以ping通了 接下来咱们创建一条拒绝ping的规则 123456789101112[root@localhost ~]# iptables -I INPUT -p icmp -j REJECT [root@localhost ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination REJECT icmp -- anywhere anywhere reject-with icmp-port-unreachableChain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination [root@localhost ~]# 现在再用物理机来ping虚拟机： 1C:\Users\zhong&gt;ping 192.168.141.12 显示不可达。 查看iptables中的防火墙规则1234567891011[root@localhost ~]# iptables -L -n --line-numbers Chain INPUT (policy ACCEPT)num target prot opt source destination 1 REJECT icmp -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-port-unreachableChain FORWARD (policy ACCEPT)num target prot opt source destination Chain OUTPUT (policy ACCEPT)num target prot opt source destination [root@localhost ~]# 可以看到，拒绝ping的那条规则的规则号是1（ping是属于icmp协议的），待会咱们把这条规则删掉 删除规则1iptables -D [INPUT | OUTPUT | FORWARD] 规则号 删除input表中的第一个规则 1234567891011[root@localhost ~]# iptables -D INPUT 1[root@localhost ~]# iptables -L -n --line-numbers Chain INPUT (policy ACCEPT)num target prot opt source destination Chain FORWARD (policy ACCEPT)num target prot opt source destination Chain OUTPUT (policy ACCEPT)num target prot opt source destination [root@localhost ~]# 可以看到那条规则以及删除了 于是物理机又可以ping通虚拟机了 添加规则iptables -I 插入一条规则，默认加在最前面（注意别看错了，这是字母i的大写） iptables -A增加一条规则，默认增加在最后 举例：注意下面我的虚拟机和物理机的VM网卡是192.168.141网段的，不同电脑网段可能不同 1234567891011121314151617181920212223[root@localhost ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination Chain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination [root@localhost ~]# iptables -A INPUT -s 192.168.141.0/24 -p tcp --dport 22 -j ACCEPT[root@localhost ~]# iptables -A INPUT -p tcp --dport 22 -j REJECT [root@localhost ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination ACCEPT tcp -- 192.168.141.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachableChain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination [root@localhost ~]# 如果现在要增加一条规则，使172.25.0.0/24这个网段允许访问本机的22端口，那么不能使用-A参数增加，只能使用 -I 插入规则 iptables -I INPUT 2 -s 172.25.0.0/24 -p tcp –dport 22 -j ACCEPT 中，INPUT 2表示插入的是Chain INPUT 的规则号为2的规则 12345678910111213141516171819202122232425[root@localhost ~]# iptables -L -n --line-numbers Chain INPUT (policy ACCEPT)num target prot opt source destination 1 ACCEPT tcp -- 192.168.141.0/24 0.0.0.0/0 tcp dpt:222 REJECT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:22 reject-with icmp-port-unreachableChain FORWARD (policy ACCEPT)num target prot opt source destination Chain OUTPUT (policy ACCEPT)num target prot opt source destination [root@localhost ~]# iptables -I INPUT 2 -s 172.25.0.0/24 -p tcp --dport 22 -j ACCEPT [root@localhost ~]# iptables -L -n --line-numbers Chain INPUT (policy ACCEPT)num target prot opt source destination 1 ACCEPT tcp -- 192.168.141.0/24 0.0.0.0/0 tcp dpt:222 ACCEPT tcp -- 172.25.0.0/24 0.0.0.0/0 tcp dpt:223 REJECT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:22 reject-with icmp-port-unreachableChain FORWARD (policy ACCEPT)num target prot opt source destination Chain OUTPUT (policy ACCEPT)num target prot opt source destination [root@localhost ~]# 保存防火墙状态12345678910111213141516[root@localhost ~]# service iptables saveiptables: Saving firewall rules to /etc/sysconfig/iptables:[ OK ]# 防火墙保存了之后，在/etc/sysconfig/iptables文件中就会出现相应的规则[root@localhost ~]# cat /etc/sysconfig/iptables# Generated by iptables-save v1.4.21 on Thu Jan 24 23:42:17 2019*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [30:3540]-A INPUT -s 192.168.141.0/24 -p tcp -m tcp --dport 22 -j ACCEPT-A INPUT -s 172.25.0.0/24 -p tcp -m tcp --dport 22 -j ACCEPT-A INPUT -p tcp -m tcp --dport 22 -j REJECT --reject-with icmp-port-unreachableCOMMIT# Completed on Thu Jan 24 23:42:17 2019[root@localhost ~]# 保存出错时的解决方案如果保存命令执行失败报出： 1The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl. 解决方案： 1234567systemctl stop firewalld 关闭防火墙yum install iptables-services 安装或更新服务再使用systemctl enable iptables 启动iptables最后 systemctl start iptables 打开iptables再执行service iptables save 重启iptables服务service iptables restart 执行完毕之后/etc/syscofig/iptables文件就有规则了 firewalld firewalls是centos7的默认防火墙，安装完centos7 默认开启，默认开放22端口（所以用xshell的ssh能连上）和dhcpv6-client端口 开启firewalld防火墙 1234567[root@localhost ~]# systemctl stop iptables.service [root@localhost ~]# systemctl mask iptables.service Created symlink from /etc/systemd/system/iptables.service to /dev/null.[root@localhost ~]# systemctl unmask firewalld.service Removed symlink /etc/systemd/system/firewalld.service.[root@localhost ~]# systemctl restart firewalld.service [root@localhost ~]# 如果你之前没有启动iptables是不需要做上面的操作的，直接systemctl restart firewalld.service 即可。 防火墙一般只关心进来的流量，不关心出去的流量。 注意：出去之后再回来的流量定义为出去的流量 九大区域firewalld防火墙默认定义了9大区域： drop：除非与传出流量相关，否则拒绝所有传入流量（不产生包含ICMP的错误响应） block：除非与传出流量相关，否则拒绝所有传入流量。 dmz：除非与传出流量相关或者与ssh预定义服务匹配，否则拒绝传入流量 external：除非与传出流量相关或者与ssh预定义服务匹配，否则拒绝传入流量。通过此区域转发的IPv4传出流量将进行伪装，使其看起来像传出网络接口的IPv4地址而不是主机的源IP internel：初始状态与home相同 home：除非与传出流量相关或者与ssh、mdns、ipp-client、dhcpv6-client、samba-client预定义服务匹配，否则拒绝传入流量 work：除非与传出流量相关或者与ssh、ipp-client、dhcpv6-client预定义的服务匹配，否则拒绝传入流量。此区域为网络接口的默认区域 public：除非与传出流量相关或者与ssh、dhcpv6-client预定义的服务匹配，否则拒绝传入流量。此区域为网络接口的默认区域 trusted：允许所有流量传入 配置firewalld防火墙的三种方法： 使用图形工具firwalld-config 使用命令行工具firewalld-cmd 查看区域中的规则查看public区域中的所有信息 12345678910111213141516[root@localhost ~]# firewall-cmd --list-all --zone=publicpublic (active) target: default icmp-block-inversion: no interfaces: ens33 ens37 sources: services: ssh dhcpv6-client #可以看到这里默认只放行ssh和dhcpv6-client ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@localhost ~]# 允许访问本机的http服务第一种方法：添加服务名允许访问，要求http服务使用默认端口80，不然规则无效 123456789101112131415161718[root@localhost ~]# yum install httpd -y[root@localhost ~]# systemctl restart httpd[root@localhost ~]# firewall-cmd --add-service=httpsuccess[root@localhost ~]# firewall-cmd --list-allpublic (active)target: defaulticmp-block-inversion: nointerfaces: ens33 ens37sources: services: ssh dhcpv6-client http #可以看到这里除了默认放行的ssh和dhcpv6-client，多了个httpports: protocols: masquerade: noforward-ports: source-ports: icmp-blocks: rich rules: 第二种方法：放行端口号80（http协议对应端口号为80） 1234567891011121314151617181920212223242526272829303132333435[root@localhost ~]# firewall-cmd --remove-service=http #先把上面放行的http移除掉success[root@localhost ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 ens37 sources: services: ssh dhcpv6-client ports: #可以看到本来没有通过端口号放行的协议 protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@localhost ~]# firewall-cmd --add-port=80/tcpsuccess[root@localhost ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 ens37 sources: services: ssh dhcpv6-client ports: 80/tcp #可以看到现在多了个放行的使用80端口号的http协议 protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@localhost ~]# 保存已经设置的规则 防火墙使用firewall-cmd添加实时生效的规则之后，重启Linux系统或者重启防火墙服务之后，运行时修改的规则都会丢失，如果要保存规则，有以下几种方式： 方式1.在规则后面添加 –permanent，这时这条命令不会实时生效，但会把规则号添加到配置文件中 12[root@localhost ~]# firewall-cmd --add-port=8080/tcp --permanent success 这条命令敲完后，我们查看防火墙规则，发现并没有实时生效 12345678910111213141516[root@localhost ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 ens37 sources: services: ssh dhcpv6-client ports: 80/tcp protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@localhost ~]# 让其生效的三种方法 12345678910111213141516171819202122[root@localhost ~]# firewall-cmd --reload success[root@localhost ~]# systemctl restart firewalld.service [root@localhost ~]# firewall-cmd --add-port=8080/tcp验证：[root@localhost ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 ens37 sources: services: ssh dhcpv6-client ports: 8080/tcp protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@localhost ~]# 方式2.让runtime时配置的规则永久保存 12345678910111213141516171819202122232425262728[root@localhost ~]# firewall-cmd --add-port=10000/tcpsuccess[root@localhost ~]# firewall-cmd --add-port=10001/tcpsuccess[root@localhost ~]# firewall-cmd --add-port=10086/tcpsuccess# 下面的命令可以将上面的规则在运行时永久保存到防火墙配置中[root@localhost ~]# firewall-cmd --runtime-to-permanentsuccess验证：[root@localhost ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 ens37 sources: services: ssh dhcpv6-client ports: 8080/tcp 10000/tcp 10001/tcp 10086/tcp protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@localhost ~]# 富规则拒绝所有172.25.0.0/24网段的ip访问本机的ssh服务 123456789101112131415161718[root@localhost ~]# firewall-cmd --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;172.25.0.0/24&quot; service name=&quot;ssh&quot; reject&quot;success[root@localhost ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 ens37 sources: services: ssh dhcpv6-client ports: 8080/tcp 10000/tcp 10001/tcp 10086/tcp protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: rule family=&quot;ipv4&quot; source address=&quot;172.25.0.0/24&quot; service name=&quot;ssh&quot; reject[root@localhost ~]# TCP Wrapper应用层流量控制工具 TCP Wrappers是RHEL 7系统中默认启用的一款流量控制程序，它能够根据来访主机的地址与本机的目标服务程序作出允许或拒绝的操作。 系统将会先检查允许控制列表文件（/etc/hosts.allow），如果匹配到相应的允许策略则放行流量；如果没有匹配，则去进一步匹配拒绝控制列表文件（/etc/hosts.deny），若找到匹配项则拒绝该流量。如果这两个文件全都没有匹配到，则默认放行流量。 在配置TCP Wrappers服务时需要遵循两个原则： 编写拒绝策略规则时，填写的是服务名称，而非协议名称； 建议先编写拒绝策略规则，再编写允许策略规则，以便直观地看到相应的效果。 格式为： 服务名:规则 规则 客户端类型 示例 满足示例的客户端列表 单一主机 192.168.10.10 IP地址为192.168.10.10的主机 指定网段 192.168.10. IP段为192.168.10.0/24的主机 指定网段 192.168.10.0/255.255.255.0 IP段为192.168.10.0/24的主机 指定DNS后缀 .aaa.com 所有DNS后缀为.aaa.com的主机 指定主机名称 www.aaa.com 主机名称为www.aaa.com的主机 指定所有客户端 ALL 所有主机全部包括在内 利用tcp wrapper控制应用层数据的流量 123456789101112131415161718192021222324252627282930313233[root@localhost ~]# systemctl stop firewalld[root@localhost ~]# vim /etc/hosts.allow 1 # 2 # hosts.allow This file contains access rules which are used to 3 # allow or deny connections to network services that 4 # either use the tcp_wrappers library or that have been 5 # started through a tcp_wrappers-enabled xinetd. 6 # 7 # See &apos;man 5 hosts_options&apos; and &apos;man 5 hosts_access&apos; 8 # for information on rule syntax. 9 # See &apos;man tcpd&apos; for information on tcp_wrappers 10 # 在最后一行添加： 11 sshd:192.168.9. 172.25.0.1 表示上述两个网段的用户使用本虚拟机的sshd服务 [root@localhost ~]# vim /etc/hosts.deny 1 # 2 # hosts.deny This file contains access rules which are used to 3 # deny connections to network services that either use 4 # the tcp_wrappers library or that have been 5 # started through a tcp_wrappers-enabled xinetd. 6 # 7 # The rules in this file can also be set up in 8 # /etc/hosts.allow with a &apos;deny&apos; option instead. 9 # 10 # See &apos;man 5 hosts_options&apos; and &apos;man 5 hosts_access&apos; 11 # for information on rule syntax. 12 # See &apos;man tcpd&apos; for information on tcp_wrappers 13 # 在最后一行添加： 14 sshd:ALL 表示拒绝所有网段的用户使用sshd服务 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-12 RAID和LVM]]></title>
    <url>%2Flinux-12%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-12 RAID和LVMRAID RAID是英文Redundant Array of Independent Disks的缩写，中文简称为独立冗余磁盘阵列。简单的说，RAID是一种把多块独立的硬盘（物理硬盘）按不同的方式组合起来形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据备份技术。 ​ 组成磁盘阵列的不同方式称为RAID级别（RAID Levels）。在用户看起来，组成的磁盘组就像是一个硬盘，用户可以对它进行分区，格式化等等。总之，对磁盘阵列的操作与单个硬盘一模一样。不同的是，磁盘阵列的存储速度要比单个硬盘高很多，而且可以提供自动数据备份。数据备份的功能是在用户数据一旦发生损坏后，利用备份信息可以使损坏数据得以恢复，从而保障了用户数据的安全性。 RAID分类​ RAID技术经过不断的发展，现在已拥有了从 RAID 0 到 7 八种基本的RAID 级别。另外，还有一些基本RAID级别的组合形式，如RAID 10（RAID 0与RAID 1的组合），RAID 50（RAID 0与RAID 5的组合）等。不同RAID 级别代表着不同的存储性能、数据安全性和存储成本。但我们最为常用的是下面的几种RAID形式。 RAID级别的选择有三个主要因素：可用性（数据冗余）、性能和成本。如果不要求可用性，选择RAID0以获得最佳性能。如果可用性和性能是重要的而成本不是一个主要因素，则根据硬盘数量选择RAID 1。如果可用性、成本和性能都同样重要，则根据一般的数据传输和硬盘的数量选择RAID3、RAID5。 下面以几张图来举例 RAID0 RAID1 RAID5 RAID10（不是读作十，而是一零） 部署磁盘阵列mdadm用于管理Linux系统中的软件RAID硬盘阵列，格式为 1mdadm [模式] &lt;RAID设备名称&gt; [选项] [成员设备名称] 安装Linux 软阵列管理工具mdadm 1[root@localhost ~]# yum install mdadm -y 题目：添加4块20G的硬盘，将硬盘用工具组合成软RAID10（上面有图RAID10） 生成磁盘阵列 参数 作用 -a 检测设备名称 -n 指定设备数量 -l 指定RAID级别 -C 创建 -v 显示过程 -f 模拟设备损坏 -r 移除设备 -Q 查看摘要信息 -D 查看详细信息 -S 停止RAID磁盘阵列 -x 指定备份盘数量 首先用fdisk -l查看系统中的磁盘信息 生成磁盘阵列123456789[root@localhost ~]# mdadm -Cv /dev/md0 -a yes -n 4 -l 10 /dev/sd&#123;b,c,d,e&#125;mdadm: layout defaults to n2mdadm: layout defaults to n2mdadm: chunk size defaults to 512Kmdadm: size set to 20954112Kmdadm: Fail create md0 when using /sys/module/md_mod/parameters/new_arraymdadm: Defaulting to version 1.2 metadatamdadm: array /dev/md0 started.[root@localhost ~]# 查看阵列信息1234567891011121314151617181920212223242526272829303132333435[root@localhost ~]# mdadm -D /dev/md0 /dev/md0: Version : 1.2 Creation Time : Thu Jan 24 21:29:53 2019 Raid Level : raid10 Array Size : 41908224 (39.97 GiB 42.91 GB) Used Dev Size : 20954112 (19.98 GiB 21.46 GB) Raid Devices : 4 Total Devices : 4 Persistence : Superblock is persistent Update Time : Thu Jan 24 21:30:20 2019 State : clean, resyncing Active Devices : 4 Working Devices : 4 Failed Devices : 0 Spare Devices : 0 Layout : near=2 Chunk Size : 512KConsistency Policy : resync Resync Status : 17% complete Name : localhost.localdomain:0 (local to host localhost.localdomain) UUID : 681083d9:0b891154:c4a4358f:3511a208 Events : 2 Number Major Minor RaidDevice State 0 8 16 0 active sync set-A /dev/sdb 1 8 32 1 active sync set-B /dev/sdc 2 8 48 2 active sync set-A /dev/sdd 3 8 64 3 active sync set-B /dev/sde[root@localhost ~]# 使用磁盘阵列使用制作出来的md0，将磁盘分出一个5G大小的分区，格式化为xfs，挂载到/mnt/raid使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344[root@localhost ~]# mkdir /mnt/raid[root@localhost ~]# fdisk /dev/md0Welcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Device does not contain a recognized partition tableBuilding a new DOS disklabel with disk identifier 0x48492670.Command (m for help): nPartition type: p primary (0 primary, 0 extended, 4 free) e extendedSelect (default p): pPartition number (1-4, default 1): First sector (2048-83816447, default 2048): Using default value 2048Last sector, +sectors or +size&#123;K,M,G&#125; (2048-83816447, default 83816447): +5GPartition 1 of type Linux and of size 5 GiB is setCommand (m for help): pDisk /dev/md0: 42.9 GB, 42914021376 bytes, 83816448 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 524288 bytes / 1048576 bytesDisk label type: dosDisk identifier: 0x48492670 Device Boot Start End Blocks Id System/dev/md0p1 2048 10487807 5242880 83 LinuxCommand (m for help): wThe partition table has been altered!Calling ioctl() to re-read partition table.Syncing disks.[root@localhost ~]# partprobe Warning: Unable to open /dev/sr0 read-write (Read-only file system). /dev/sr0 has been opened read-only.[root@localhost ~]# mount /dev/md0p1 /mnt/raid/mount: /dev/md0p1 is write-protected, mounting read-onlymount: unknown filesystem type &apos;(null)&apos;[root@localhost ~]# 损坏磁盘阵列及修复12345678[root@localhost ~]# mdadm /dev/md0 -f /dev/sdb…………[root@localhost ~]# mdadm -D /dev/md0…………[root@localhost ~]# umount /raid[root@localhost ~]# mount –a[root@localhost ~]# df –h………… 停止磁盘阵列umount卸载已经挂载的分区，用fdisk删除阵列硬盘上的分区 12345[root@localhost ~]# mdadm -S /dev/md0mdadm: stopped /dev/md0[root@localhost ~]# partprobe Warning: Unable to open /dev/sr0 read-write (Read-only file system). /dev/sr0 has been opened read-only.[root@localhost ~]# LVM​ LVM是 Logical Volume Manager（逻辑卷管理）的简写，它是Linux环境下对磁盘分区进行管理的一种机制，它由Heinz Mauelshagen在Linux 2.4内核上实现，目前最新版本为：稳定版1.0.5，开发版 1.1.0-rc2，以及LVM2开发版。Linux用户安装Linux操作系统时遇到的一个常见的难以决定的问题就是如何正确地评估各分区大小，以分配合适的硬盘空间。普通的磁盘分区管理方式在逻辑分区划分好之后就无法改变其大小，当一个逻辑分区存放不下某个文件时，这个文件因为受上层文件系统的限制，也不能跨越多个分区来存放，所以也不能同时放到别的磁盘上。而遇到出现某个分区空间耗尽时，解决的方法通常是使用符号链接，或者使用调整分区大小的工具，但这只是暂时解决办法，没有从根本上解决问题。随着Linux的逻辑卷管理功能的出现，这些问题都迎刃而解，用户在无需停机的情况下可以方便地调整各个分区大小。 什么是逻辑卷管理器？ LVM 是逻辑盘卷管理（Logical Volume Manager）的简称，它是 Linux 环境下对卷进行方便操作的抽象层。 LVM 是建立在硬盘和分区之上的一个逻辑层，来为文件系统屏蔽下层磁盘分区布局，从而提高磁盘分区管理的灵活性。 LVM允许在多个物理设备间重新组织文件系统，包括重新设定文件系统的大小。 概念区分PV（物理卷）： 物理卷(physical volume, PV)在 LVM 系统中处于最底层 物理卷可以是整个硬盘、硬盘上的分区或从逻辑上与磁盘分区具有同样功能的设备（如：RAID） 物理卷是 LVM 的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有与 LVM 相关的管理参数 VG（卷组）： 卷组(Volume Group, VG)建立在物理卷之上，它由一个或多个物理卷组成 卷组创建之后，可以动态添加物理卷到卷组中，在卷组上可以创建一个或多个“LVM 分区”（逻辑卷） 一个 LVM 系统中可以只有一个卷组，也可以包含多个卷组 LVM 的卷组类似于非LVM系统中的物理硬盘 LV（逻辑卷）： 逻辑卷(Logical Volume, LV)建立在卷组之上，它是从卷组中“切出”的一块空间 逻辑卷创建之后，其大小可以伸缩 LVM 的逻辑卷类似于非 LVM 系统中的硬盘分区，在逻辑卷之上可以建立文件系统 （比如 /home 或者 /usr 等） 创建逻辑卷过程添加一块20G和一块10G的硬盘（物理卷大小不需要一样，没有硬性要求） 物理卷操作将两块硬盘变为物理卷 1234[root@localhost ~]# pvcreate /dev/sd&#123;b,c&#125; Physical volume &quot;/dev/sdb&quot; successfully created. Physical volume &quot;/dev/sdc&quot; successfully created.[root@localhost ~]# 查看系统中的物理卷 12345[root@localhost ~]# pvs PV VG Fmt Attr PSize PFree /dev/sda2 centos lvm2 a-- &lt;19.00g 0 /dev/sdb lvm2 --- 10.00g 10.00g /dev/sdc lvm2 --- 20.00g 20.00g 扫描系统中的物理卷 12345[root@localhost ~]# pvscan PV /dev/sda2 VG centos lvm2 [&lt;19.00 GiB / 0 free] PV /dev/sdb lvm2 [10.00 GiB] PV /dev/sdc lvm2 [20.00 GiB] Total: 3 [&lt;49.00 GiB] / in use: 1 [&lt;19.00 GiB] / in no VG: 2 [30.00 GiB] 查看物理卷详细信息 1234567891011121314[root@localhost ~]# pvdisplay /dev/sdb &quot;/dev/sdb&quot; is a new physical volume of &quot;10.00 GiB&quot; --- NEW Physical volume --- PV Name /dev/sdb VG Name PV Size 10.00 GiB Allocatable NO PE Size 0 Total PE 0 Free PE 0 Allocated PE 0 PV UUID R1Tcud-WHmk-JfIV-0Zh3-0bg3-enz0-SK81CJ [root@localhost ~]# pvdisplay后面不加某一块物理卷，那么显示的就是系统中所有的物理卷的详细信息 卷组操作创建卷组aaa，将两个物理卷加入到卷组里 123[root@localhost ~]# vgcreate aaa /dev/sd&#123;b,c&#125; Volume group &quot;aaa&quot; successfully created[root@localhost ~]# 查看系统中卷组用命令vgs，扫描用vgscan，查看详细信息用vgdisplay，用法和pv那套命令一样 1234567891011121314151617181920212223[root@localhost ~]# vgdisplay aaa --- Volume group --- VG Name aaa System ID Format lvm2 Metadata Areas 2 Metadata Sequence No 1 VG Access read/write VG Status resizable MAX LV 0 Cur LV 0 Open LV 0 Max PV 0 Cur PV 2 Act PV 2 VG Size 29.99 GiB PE Size 4.00 MiB Total PE 7678 Alloc PE / Size 0 / 0 Free PE / Size 7678 / 29.99 GiB VG UUID sIRezl-w3K2-9o2i-wDjV-szxH-7mbY-5RW0jW [root@localhost ~]# 逻辑卷操作创建一个逻辑卷system，大小为1G，要求指定大小的时候使用基本单元 123456789101112131415161718192021[root@localhost ~]# lvcreate -n system -l 250 aaa Logical volume &quot;system&quot; created.[root@localhost ~]# lvdisplay /dev/aaa/system --- Logical volume --- LV Path /dev/aaa/system LV Name system VG Name aaa LV UUID Qnfuv6-a0lS-WRy6-s0Uo-4pFS-Y1yf-y4Jd9v LV Write Access read/write LV Creation host, time localhost.localdomain, 2019-01-24 21:52:17 -0500 LV Status available # open 0 LV Size 1000.00 MiB Current LE 250 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:2 [root@localhost ~]# 创建逻辑卷network，大小为3G，不需要用基本单元指定大小 123456789101112131415161718192021[root@localhost ~]# lvcreate -n network -L 3G aaa Logical volume &quot;network&quot; created.[root@localhost ~]# lvdisplay /dev/aaa/network --- Logical volume --- LV Path /dev/aaa/network LV Name network VG Name aaa LV UUID pga3dS-2S08-dit2-2Wm1-ZA7x-OPa8-tLxUtr LV Write Access read/write LV Creation host, time localhost.localdomain, 2019-01-24 21:54:51 -0500 LV Status available # open 0 LV Size 3.00 GiB Current LE 768 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:3 [root@localhost ~]# 将system格式化为xfs，挂载到/mnt/aaa_system 12345678910111213141516171819202122232425[root@localhost ~]# mkfs.xfs /dev/aaa/system meta-data=/dev/aaa/system isize=512 agcount=4, agsize=64000 blks = sectsz=512 attr=2, projid32bit=1 = crc=1 finobt=0, sparse=0data = bsize=4096 blocks=256000, imaxpct=25 = sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=1log =internal log bsize=4096 blocks=855, version=2 = sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0[root@localhost ~]# partprobe Warning: Unable to open /dev/sr0 read-write (Read-only file system). /dev/sr0 has been opened read-only.[root@localhost ~]# mkdir /mnt/aaa_system[root@localhost ~]# mount /dev/aaa/system /mnt/aaa_system/[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/centos-root 17G 1.3G 16G 8% /devtmpfs 476M 0 476M 0% /devtmpfs 488M 0 488M 0% /dev/shmtmpfs 488M 7.7M 480M 2% /runtmpfs 488M 0 488M 0% /sys/fs/cgroup/dev/sda1 1014M 130M 885M 13% /boottmpfs 98M 0 98M 0% /run/user/0/dev/mapper/aaa-system 997M 33M 965M 4% /mnt/aaa_system[root@localhost ~]# 逻辑卷在系统中的两种表示方式第一种：/dev/[卷组名]/[逻辑卷] 12[root@localhost ~]# ll /dev/aaa/system lrwxrwxrwx. 1 root root 7 Jan 24 21:55 /dev/aaa/system -&gt; ../dm-2 第二种：/dev/mapper/[卷组名]-[逻辑卷] 123[root@localhost ~]# ll /dev/mapper/aaa-system lrwxrwxrwx. 1 root root 7 Jan 24 21:55 /dev/mapper/aaa-system -&gt; ../dm-2[root@localhost ~]# 逻辑卷扩容 发现system只有1G大小远远不够用，至少要有5G的空间才够用，所以要将system扩容到5G 12345[root@localhost ~]# umount /mnt/aaa_system[root@localhost ~]# e2fsck -f /dev/aaa/system [root@localhost ~]# lvextend -L 10G /dev/aaa/system[root@localhost ~]# resize2fs /dev/aaa/system[root@localhost ~]# mount /dev/aaa/system /mnt/aaa_system 逻辑卷快照相当于是磁盘的备份 123456789101112131415[root@localhost ~]# echo &quot;helloworld&quot; &gt; /mnt/aaa_system/hello.txt创建快照：[root@localhost ~]# lvcreate -L 10G -s -n SNAP /dev/aaa/system Reducing COW size 10.00 GiB down to maximum usable size 1004.00 MiB. Logical volume &quot;SNAP&quot; created.[root@localhost ~]# lvdisplay ......[root@localhost ~]# rm -f /mnt/aaa_system/hello.txt [root@localhost ~]# 还原快照：[root@localhost ~]# umount /mnt/eagle_system[root@localhost ~]# lvconvert --merge /dev/eagleslab/SNAP 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-11 存储结构与磁盘划分]]></title>
    <url>%2Flinux-11%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-11 存储结构与磁盘划分Linux文件结构 Linux 文件系统是一个目录树的结构，文件系统结构从一个根目录开始，根目录下可以有任意多个文件和子目录，子目录中又可以有任意多个文件和子目录。Linux 的这种文件系统结构使得一个目录和它包含的文件/子目录之间形成一种层次关系。 物理设备的命名规则 硬件设备 文件名称 IDE设备 /dev/hd[a-d] SCSI/SATA/U盘 /dev/sd[a-p] 软驱 /dev/fd[0-1] 打印机 /dev/lp[0-15] 光驱 /dev/cdrom 鼠标 /dev/mouse 磁带机 /dev/st0或/dev/ht0 主分区或扩展分区的编号从1开始，到4结束； •逻辑分区从编号5开始。 文件系统Ext3​ 一款日志文件系统，能够在系统异常宕机时避免文件系统资料丢失，并能自动修复数据的不一致与错误。然而，当硬盘容量较大时，所需的修复时间也会很长，而且也不能百分之百地保证资料不会丢失。它会把整个磁盘的每个写入动作的细节都预先记录下来，以便在发生异常宕机后能回溯追踪到被中断的部分，然后尝试进行修复。 Ext4​ Ext3的改进版本，作为RHEL 6系统中的默认文件管理系统，它支持的存储容量高达1EB（1EB=1,073,741,824GB），且能够有无限多的子目录。另外，Ext4文件系统能够批量分配block块，从而极大地提高了读写效率。 XFS​ 一种高性能的日志文件系统，而且是RHEL 7中默认的文件管理系统，它的优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大的日志功能只用花费极低的计算和存储性能。并且它最大可支持的存储容量为18EB，这几乎满足了所有需求。 挂载 在windows操作系统中， 挂载通常是指给磁盘分区（包括被虚拟出来的磁盘分区）分配一个盘符。 第三方软件，如磁盘分区管理软件、虚拟磁盘软件等，通常也附带挂载功能。 ​ 在linux操作系统中， 挂载是指将一个设备（通常是存储设备）挂接到一个已存在的目录上。 我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上， 然后通过访问这个目录来访问存储设备。 在linux 操作系统中，挂载是一个非常重要的功能，使用非常频繁。它指将一个设备（通常是存储设备）挂接到一个已存在的目录上。（这个目录可以不为空，但挂载后这个目录下以前的内容将不可用。）需要理解的是，linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。 举个栗子：123456[root@localhost ~]# cd /dev[root@localhost dev]# ll cdromlrwxrwxrwx. 1 root root 3 Jan 24 04:37 cdrom -&gt; sr0[root@localhost dev]# cd cdrom-bash: cd: cdrom: Not a directory[root@localhost dev]# 如上，我们的/dev目录下有个叫做cdrom的文件（就是指设备，设备也是一种文件），但是我们没办法cd到这个文件（设备）里面去看它究竟包含了哪些东西。所以呢，我们可以新建一个目录/mnt/cdrom/，然后把原来的cdrom文件（设备）挂载到/mnt/cdrom/这个目录底下，此时你可以cd到/mnt/cdrom/目录下看看，多出来一堆东西就是原来的cdrom文件（设备）里包含的东西了。 12345678[root@localhost dev]# mkdir -p /mnt/cdrom[root@localhost dev]# ls /mnt/cdrom/[root@localhost dev]# mount /dev/cdrom /mnt/cdrom/mount: /dev/sr0 is write-protected, mounting read-only[root@localhost dev]# ls /mnt/cdrom/CentOS_BuildTag EULA images LiveOS repodata RPM-GPG-KEY-CentOS-Testing-7EFI GPL isolinux Packages RPM-GPG-KEY-CentOS-7 TRANS.TBL[root@localhost dev]# 挂载条件1、挂载点必须是一个目录。 2、一个分区挂载在一个已存在的目录上，这个目录可以不为空，但挂载后这个目录下以前的内容将不可用。对于其他操作系统建立的文件系统的挂载也是这样。 挂载硬件设备mountmount命令用于挂载文件系统，格式为 1mount 文件系统 挂载目录 临时挂载、使用mount命令来查看mount的挂载情况举例：1234567891011121314151617181920[root@localhost ~]# cd /mnt[root@localhost mnt]# mkdir cdrom[root@localhost mnt]# cd /[root@localhost /]# mount /dev/cdrom /mnt/cdrom/mount: /dev/sr0 is write-protected, mounting read-only[root@localhost /]# ls /mnt/cdromCentOS_BuildTag EULA images LiveOS repodata RPM-GPG-KEY-CentOS-Testing-7EFI GPL isolinux Packages RPM-GPG-KEY-CentOS-7 TRANS.TBL我们可以使用mount命令来查看mount的挂载情况[root@localhost /]# cd /mnt/cdrom/[root@localhost cdrom]# mount | grep /mnt/cdrom #注意这里cdrom后面没有//dev/sr0 on /mnt/cdrom type iso9660 (ro,relatime)[root@localhost cdrom]# 注意：这样挂载的文件系统是临时的，会在重启之后消失！重启后：[root@localhost ~]# ls /mnt/cdrom/[root@localhost ~]# 可以看到，重启后咱们挂载的文件的确消失了！ 卸载文件系统（取消挂载）的两种方法12345678910111213[root@localhost ~]# ls /mnt/cdrom/CentOS_BuildTag EULA images LiveOS repodata RPM-GPG-KEY-CentOS-Testing-7EFI GPL isolinux Packages RPM-GPG-KEY-CentOS-7 TRANS.TBL[root@localhost ~]# umount /mnt/cdrom/ #也可以 umount /dev/sr0[root@localhost ~]# ls /mnt/cdrom/[root@localhost ~]# mount /dev/cdrom /mnt/cdrom/mount: /dev/sr0 is write-protected, mounting read-only[root@localhost ~]# ls /mnt/cdrom/CentOS_BuildTag EULA images LiveOS repodata RPM-GPG-KEY-CentOS-Testing-7EFI GPL isolinux Packages RPM-GPG-KEY-CentOS-7 TRANS.TBL[root@localhost ~]# umount /dev/sr0[root@localhost ~]# ls /mnt/cdrom/[root@localhost ~]# umount 的时候要求目标设备没有在使用中，比如当前没有用户cd到这个目录 123[root@localhost ~]# cd /mnt/cdrom/[root@localhost cdrom]# umount /mnt/cdrom/umount: /mnt/cdrom/: not mounted 开机自动挂载 注意：现在咱们是继续上面的实验继续做，也就是说，上面咱们已经把挂载好的卸载掉了，/mnt/cdrom/现在仅仅是空目录，现在先让它空着就好！呐： 12[root@localhost ~]# ls /mnt/cdrom/[root@localhost ~]# 接下来咱们开始做开机自动挂载 在/etc目录下有个fstab文件，它里面列出了linux开机时自动挂载的文件系统的列表。 编辑/etc/fstab文件使分区开机自动挂载 123[root@localhost cdrom]# vim /etc/fstab 在文件最后一行加上如下内容：/dev/sr0 /mnt/cdrom ext4 defaults 0 0 字段 意义 设备文件 一般为设备的路径+设备名称，也可以写唯一识别码（UUID，Universally Unique Identifier） 挂载目录 指定要挂载到的目录，需在挂载前创建好 格式类型 指定文件系统的格式，比如Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等 权限选项 若设置为defaults，则默认权限为：rw, suid, dev, exec, auto, nouser, async 是否备份 若为1则开机后使用dump进行磁盘备份，为0则不备份 是否自检 若为1则开机后自动进行磁盘自检，为0则不自检 mount -a命令可以重新加载fstab文件测试此文件是否修改成功且配置生效,如果哪里出错它会显示出来 12345678[root@localhost ~]# mount -amount: /dev/sr0 is write-protected, mounting read-onlymount: wrong fs type, bad option, bad superblock on /dev/sr0, missing codepage or helper program, or other error In some cases useful info is found in syslog - try dmesg | tail or so.[root@localhost ~]# 如上，哎，出错了 QAQ。如果刚刚没有用mount -a检查一下就重启，后面就会遇到一系列问题。 解决思路：把你出错的提示复制下来，百度一下即可。我了个去，刚刚百度花了快十分钟，才找到问题所在，其实虽然从报错字面wrong fs type可以看出是我的文件格式类型写错了，也就是不能写ext4，关键是我也不知道写啥呀。万能的百度上搜到的，原来就是咱们上面敲过的命令： 12[root@localhost cdrom]# mount | grep /mnt/cdrom #注意这里cdrom后面没有符号//dev/sr0 on /mnt/cdrom type iso9660 (ro,relatime) 我刚刚没有认真看它的type是iso9660，于是后面就写错了，现在改正： 123[root@localhost ~]# vim /etc/fstab 最后一行改为：/dev/sr0 /mnt/cdrom iso9660 defaults 0 0 然后再检查一下，就没有报错了！同时顺带检查了一下挂载情况，的确挂载成功了！ 1234567891011121314151617[root@localhost ~]# mount -amount: /dev/sr0 is write-protected, mounting read-only[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/centos-root 17G 1.3G 16G 8% /devtmpfs 476M 0 476M 0% /devtmpfs 488M 0 488M 0% /dev/shmtmpfs 488M 7.7M 480M 2% /runtmpfs 488M 0 488M 0% /sys/fs/cgroup/dev/sda1 1014M 130M 885M 13% /boottmpfs 98M 0 98M 0% /run/user/0/dev/sr0 906M 906M 0 100% /mnt/cdrom[root@localhost ~]# [root@localhost ~]# ls /mnt/cdrom/CentOS_BuildTag EULA images LiveOS repodata RPM-GPG-KEY-CentOS-Testing-7EFI GPL isolinux Packages RPM-GPG-KEY-CentOS-7 TRANS.TBL[root@localhost ~]# 重启 1[root@localhost ~]# reboot 再次检查 12345678910111213[root@localhost ~]# ls /mnt/cdrom/CentOS_BuildTag EULA images LiveOS repodata RPM-GPG-KEY-CentOS-Testing-7EFI GPL isolinux Packages RPM-GPG-KEY-CentOS-7 TRANS.TBL[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/centos-root 17G 1.3G 16G 8% /devtmpfs 476M 0 476M 0% /devtmpfs 488M 0 488M 0% /dev/shmtmpfs 488M 7.6M 480M 2% /runtmpfs 488M 0 488M 0% /sys/fs/cgroup/dev/sr0 906M 906M 0 100% /mnt/cdrom/dev/sda1 1014M 130M 885M 13% /boottmpfs 98M 0 98M 0% /run/user/0 可以看到，上面的挂载并未消失，所以这个开机自动挂载是成功滴！ 磁盘分区fdisk工具： 在Linux系统中，管理硬盘设备最常用的方法就当属fdisk命令了。fdisk命令用于管理磁盘分区它提供了集添加、删除、转换分区等功能于一身的“一站式分区服务”，格式为 1fdisk [磁盘名称] 题目：添加一块20G硬盘，分出一个5G大小的分区，分区格式分别为xfs，将分区通过UUID永久挂载到/mnt/note目录 首先，查看硬盘及分区信息 12345678910111213141516171819202122232425[root@localhost ~]# fdisk -l Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x000bf707 Device Boot Start End Blocks Id System/dev/sda1 * 2048 2099199 1048576 83 Linux/dev/sda2 2099200 41943039 19921920 8e Linux LVMDisk /dev/mapper/centos-root: 18.2 GB, 18249416704 bytes, 35643392 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytes[root@localhost ~]# 可以看出，Disk /dev/sda: 21.5 GB说明只有一块磁盘，我们现在给它加上第二块磁盘： 然后再次查看硬盘及分区信息： 12345678910111213141516171819202122232425262728293031[root@localhost ~]# fdisk -l Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x000bf707 Device Boot Start End Blocks Id System/dev/sda1 * 2048 2099199 1048576 83 Linux/dev/sda2 2099200 41943039 19921920 8e Linux LVMDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk /dev/mapper/centos-root: 18.2 GB, 18249416704 bytes, 35643392 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytes[root@localhost ~]# 可以看到多出了Disk /dev/sdb: 21.5 GB的另一块磁盘。咱们接下来就在这个新磁盘上完成题目要求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 1.使用fdisk分出一个大小为5G的分区 [root@localhost ~]# fdisk /dev/sdb欢迎使用 fdisk (util-linux 2.23.2)。 更改将停留在内存中，直到您决定将更改写入磁盘。使用写入命令前请三思。 命令(输入 m 获取帮助)：nPartition type: p primary (0 primary, 0 extended, 4 free) e extendedSelect (default p): p分区号 (1-4，默认 1)：起始 扇区 (2048-41943039，默认为 2048)：将使用默认值 2048Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-41943039，默认为 41943039)：+5G分区 1 已设置为 Linux 类型，大小设为 5 GiB 命令(输入 m 获取帮助)：p 磁盘 /dev/sdb：21.5 GB, 21474836480 字节，41943040 个扇区Units = 扇区 of 1 * 512 = 512 bytes扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：dos磁盘标识符：0x802025ce 设备 Boot Start End Blocks Id System/dev/sdb1 2048 10487807 5242880 83 Linux 命令(输入 m 获取帮助)：wThe partition table has been altered! Calling ioctl() to re-read partition table.正在同步磁盘。 # 2.格式化磁盘为xfs格式[root@localhost ~]# mkfs.xfs /dev/sdb1meta-data=/dev/sdb1 isize=512 agcount=4, agsize=327680 blks = sectsz=512 attr=2, projid32bit=1 = crc=1 finobt=0, sparse=0data = bsize=4096 blocks=1310720, imaxpct=25 = sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=1log =internal log bsize=4096 blocks=2560, version=2 = sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0 # 3.用partprobe命令将修改写入硬盘[root@localhost ~]# partprobe # 4.用blkid命令查看分区的UUID[root@localhost ~]# blkid | grep /dev/sdb1/dev/sdb1: UUID=&quot;081fb70a-c886-4926-bc0d-0e94a9c31687&quot; TYPE=&quot;xfs&quot; # 5.修改/etc/fstab达到开机挂载的目的[root@localhost ~]# tail -n 1 /etc/fstab UUID=&quot;081fb70a-c886-4926-bc0d-0e94a9c31687&quot; /mnt/note xfs defaults 0 0# 6.使用mount -a命令测试fstab挂载是否成功[root@localhost ~]# mount | grep /dev/sdb1[root@localhost ~]# mount -a[root@localhost ~]# mount | grep /dev/sdb1/dev/sdb1 on /mnt/note type xfs (rw,relatime,seclabel,attr2,inode64,noquota)[root@localhost ~]# df -h用于查看文件系统的使用情况 123456789101112[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/centos-root 17G 1.3G 16G 8% /devtmpfs 476M 0 476M 0% /devtmpfs 488M 0 488M 0% /dev/shmtmpfs 488M 7.7M 480M 2% /runtmpfs 488M 0 488M 0% /sys/fs/cgroup/dev/sr0 906M 906M 0 100% /mnt/cdrom/dev/sda1 1014M 130M 885M 13% /boottmpfs 98M 0 98M 0% /run/user/0/dev/sdb1 5.0G 33M 5.0G 1% /mnt/note[root@localhost ~]# du -sh用于查看文件数据占用量的du命令，其格式为 1du [选项] [文件] 1234[root@localhost ~]# cd /[root@localhost /]# du -sh /root4.9M /root[root@localhost /]# 交换分区 题目：添加一个3G大小的交换分区，删除原先系统里的交换分区fstab挂载（如下图有“swap”的那一行），然后再用mount -a命令重新挂载fstab文件，还要敲下面的命令关闭当前系统生效的交换分区 123456[root@localhost ~]# swapoff /dev/mapper/centos-swap [root@localhost ~]# free -m total used free shared buff/cache availableMem: 974 126 693 7 155 680Swap: 0 0 0[root@localhost ~]# 1.首先添加一块3G的分区sdb2 123456789101112131415161718192021222324252627282930313233343536373839404142[root@localhost ~]# fdisk /dev/sdbWelcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help): nPartition type: p primary (1 primary, 0 extended, 3 free) e extendedSelect (default p): Using default response pPartition number (2-4, default 2): First sector (10487808-41943039, default 10487808): Using default value 10487808Last sector, +sectors or +size&#123;K,M,G&#125; (10487808-41943039, default 41943039): +3GPartition 2 of type Linux and of size 3 GiB is setCommand (m for help): wThe partition table has been altered!Calling ioctl() to re-read partition table.WARNING: Re-reading the partition table failed with error 16: Device or resource busy.The kernel still uses the old table. The new table will be used atthe next reboot or after you run partprobe(8) or kpartx(8)Syncing disks.[root@localhost ~]# fdisk -l /dev/sdbDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0xbfd160d1 Device Boot Start End Blocks Id System/dev/sdb1 2048 10487807 5242880 83 Linux/dev/sdb2 10487808 16779263 3145728 83 Linux[root@localhost ~]# partprobe 注意：最后一条命令别忘了敲！ 2.将分区格式化为交换分区 123456789[root@localhost ~]# mkswap /dev/sdb2Setting up swapspace version 1, size = 3145724 KiBno label, UUID=3060761d-8f1b-4222-96ba-2d2a101864ae[root@localhost ~]# swapon /dev/sdb2[root@localhost ~]# free -m total used free shared buff/cache availableMem: 974 128 687 7 158 675Swap: 3071 0 3071[root@localhost ~]# 3.让交换分区能开机启动生效 12345678910[root@localhost ~]# blkid | grep /dev/sdb2/dev/sdb2: UUID=&quot;3060761d-8f1b-4222-96ba-2d2a101864ae&quot; TYPE=&quot;swap&quot; [root@localhost ~]# vim /etc/fstab [root@localhost ~]# init 6重启后：[root@localhost ~]# free -m total used free shared buff/cache availableMem: 976 119 718 6 138 695Swap: 3071 0 3071# 看到我们设置的虚拟内存，生效 磁盘配额 为了限制用户在分区上使用磁盘的容量，利用磁盘限额技术来限制，一般应用场景有网盘、邮箱，还有网络论坛用户上传文件限制等等。 修改/etc/fstab中的类型字段来开启分期的磁盘配额功能 12345678910111213141516171819202122232425262728293031[root@localhost ~]# vim /etc/fstab [root@localhost ~]# grep note /etc/fstab UUID=&quot;081fb70a-c886-4926-bc0d-0e94a9c31687&quot; /mnt/note xfs defaults,uquota 0 0# 重启使分区的磁盘配额功能[root@localhost ~]# reboot[root@localhost ~]# xfs_quota -x -c &apos;limit bsoft=3m bhard=6m isoft=3 ihard=6 aaa&apos; /mnt/note/# 其中软限制为3m，硬限制为6m [aaa@localhost root]$ cd /mnt/note/# 生成一个4M的文件[aaa@localhost note]$ dd if=/dev/zero of=4mfile bs=1M count=4记录了4+0 的读入记录了4+0 的写出4194304字节(4.2 MB)已复制，0.00425314 秒，986 MB/秒[eagle@localhost note]$ ll总用量 4096-rw-rw-r--. 1 aaa afeng 4194304 8月 14 17:18 4mfile[aaa@localhost note]$ ll -h总用量 4.0M-rw-rw-r--. 1 aaa afeng 4.0M 8月 14 17:18 4mfile[aaa@localhost note]$ # 生成一个3M的文件，报错失败，最终这个文件只生成出来2M[aaa@localhost note]$ dd if=/dev/zero of=3mfile bs=1M count=3dd: 写入&quot;3mfile&quot; 出错: 超出磁盘限额记录了3+0 的读入记录了2+0 的写出2097152字节(2.1 MB)已复制，0.00378417 秒，554 MB/秒[aaa@localhost note]$ ll -h总用量 6.0M-rw-rw-r--. 1 aaa afeng 2.0M 8月 14 17:19 3mfile-rw-rw-r--. 1 aaa afeng 4.0M 8月 14 17:18 4mfile 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-10 用户权限与文件权限]]></title>
    <url>%2Flinux-10%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-10 用户权限与文件权限用户权限uid（user id）和gid(group id)root用户的uid和gid都是0 系统用户uid为1-999 普通用户的uid从1000开始：由管理员创建的日常使用的用户 （UID和GID不需要一一对应） 将普通用户的UID设置为0 ，那这个用户也就是root用户了 用户操作1useradd [username] 新建一个用户zhangsan 新建一个用户lisi，指定其家目录为/home/userlisi，指定他的登录shell为zsh 从passwd文件中查看出上述两个用户的uid、git、家目录、登录shell信息 用id命令可以查看用户的基本信息 使用usermod命令修改已有用户的信息（其参数和useradd几乎一样），例如将李四的登录shell改为bash 1234567891011121314[root@localhost ~]# useradd zhangsan[root@localhost ~]# grep zhangsan /etc/passwdzhangsan:x1009:1009::/home/zhangsan:/bin/bash[root@localhost ~]# useradd lisi -d /home/userlisi -s /bin/zsh[root@localhost ~]# grep lisi /etc/passwdlisi:x1010:1010::/home/userlisi:/bin/zsh[root@localhost ~]# id zhangsanuid=1009(zhangsan) gid=1009(zhangsan) groups=1009(zhangsan)[root@localhost ~]# id lisiuid=1010(lisi) gid=1010(lisi) groups=1010(lisi)[root@localhost ~]# usermod lisi -d /home/userlisi -s /bin/bash[root@localhost ~]# grep lisi /etc/passwdlisi:x:1010:1010::/home/userlisi:/bin/bash[root@localhost ~]# 参数 useradd 参数 作用 -d 指定用户的家目录（默认为/home/username） -e 账户的到期时间，格式为YYYY-MM-DD. -u 指定该用户的默认UID -g 指定一个初始的用户基本组（必须已存在） -G 指定一个或多个扩展用户组 -N 不创建与用户同名的基本用户组 -s 指定该用户的默认Shell解释器 查看用户id、uid、主组和附属组12345id 用户名例如[root@node2 ~]# id fenguid=1024(feng) gid=0(root) 组=0(root) 目录/目录 、/home目录 、~目录的区别/ ：根目录 /home ：家目录（可以理解为用户列表目录），你创建的所有用户的家目录默认会在/home目录下 ~ ：当前用户的家目录 查看这台虚拟机有哪些用户，到家目录/home下即可1234[root@localhost ~]# cd /home[root@localhost home]# lsaaa aaawww bbb bbbwww ccc cccwww ddd dddwww testuser userlisi zhangsan[root@localhost home]# 删除用户 注意：不要小看删除用户，很多时候咱们都会忘了敲参数-r，以导致该用户的其他信息未能被一起彻底删除，于是再次添加该用户的时候就无法添加上去了，所以两种删用户的方式都要掌握！ 完全删除用户账号（也就是删除所有与该用户相关的文件） 注意：判断你删除是否彻底是否成功的标准是，如果你删除了还能给它加回来那就是成功的，加不回来的话那你的删除就是失败的或者说不彻底的！ 方式一： 1userdel -r 用户名 以用户zzz为例： 123456789101112[root@localhost ~]# cd /home/[root@localhost home]# ls[root@localhost home]# useradd zzz[root@localhost home]# lszzz[root@localhost home]# userdel -r zzz[root@localhost home]# ls[root@localhost home]# useradd zzz[root@localhost home]# lszzz你看，删掉了用户zzz，还能加回来，这次删除就是成功的！ 方式二： 12userdel 用户名 #删除账户和组的信息，但是/home下还能看到该用户的家目录find / -name &quot;*用户名*&quot; | xargs rm -rf #彻底删除用户其他信息 接着上面的命令继续以用户zzz为例： 1234567891011[root@localhost home]# userdel zzz[root@localhost home]# lszzz[root@localhost home]# find / -name &quot;*zzz*&quot; | xargs rm -rf[root@localhost home]# ls[root@localhost home]# useradd zzz[root@localhost home]# lszzz[root@localhost home]# 你看，删掉了用户zzz，还能加回来，这次删除就是成功的！ 失败案例（删除不彻底导致删除后无法再加回来） 接着上面的命令以用户qqq为例： 123456789101112131415161718192021[root@localhost home]# useradd qqq[root@localhost home]# userdel qqq[root@localhost home]# useradd qqquseradd: warning: the home directory already exists.Not copying any file from skel directory into it.Creating mailbox file: File exists[root@localhost home]# find / -name &quot;*qqq*&quot; | xargs rm -rf[root@localhost home]# lszzz[root@localhost home]# useradd qqquseradd: user &apos;qqq&apos; already exists注意：失败了之后，那你可以参考下述命令补救，然后彻底将该用户删除。[root@localhost home]# userdel qqq[root@localhost home]# find / -name &quot;*qqq*&quot; | xargs rm -rf[root@localhost home]# useradd qqq[root@localhost home]# lsqqq zzz[root@localhost home]# 补救成功！ 用户组主组创建用户的时候系统会同时创建一个和这个用户名同名的组，这个组就是主组，不可以把用户从主组中删除。 当然，在创建用户的时候如果你使用使用了-g参数，该用户就可加入和用户不同名的用户组作为该用户的主组。 也可以创建用户之后，再使用usermod -g来改变用户的主组，然鹅这样和用户同名的组依然会存在，并不会被删除。 附属组除了主组之外，用户所在的其他组，都是附属组。用户是可以从附属组中被删除的。 用户的从属组，并不会影响主组，useradd时用-G参数来加入，同时用户主组默认是那个和用户同名的组。 创建用户之后，可以用usermod -G加入其他的附属组，而且之前加入的组不会退掉。 主组与附属组的区别与联系一个用户可以属于多个附属组。但是一个用户只能有一个主组。 创建一个用户组feng，在/etc/group下可看到该组，然后把它删除掉，然后再加回来。可以看到删组可以不用加参数。 123456789101112[root@localhost ~]# groupadd feng[root@localhost ~]# grep feng /etc/groupfeng:x:1000:[root@localhost ~]# groupdel feng[root@localhost ~]# grep feng /etc/group[root@localhost ~]# groupadd feng[root@localhost ~]# grep feng /etc/groupfeng:x:1000:[root@localhost ~]# grep feng /etc/groupfeng:x:1000:[root@localhost ~]# 创建用户组afeng，bfeng，cfeng 123[root@localhost ~]# groupadd afeng[root@localhost ~]# groupadd bfeng[root@localhost ~]# groupadd cfeng 创建用户aaa，并且其主组设置为afeng 12345678[root@localhost ~]# useradd aaa -g afeng[root@localhost ~]# cat /etc/passwd | grep aaaaaa:x:1000:1001::/home/aaa:/bin/bash #可以看到aaa的GID为1001，对应的组为afeng[root@localhost ~]# cat /etc/group | grep fengfeng:x:1000:afeng:x:1001:bfeng:x:1002:cfeng:x:1003: 创建用户bbb，本来默认其主组是bbb，修改其主组为bfeng 1234567891011121314[root@localhost ~]# cat /etc/group | grep feng #先看看各个附属组的GIDfeng:x:1000:afeng:x:1001:bfeng:x:1002:cfeng:x:1003:[root@localhost ~]# useradd bbb[root@localhost ~]# cat /etc/passwd | grep bbbbbb:x:1001:1004::/home/bbb:/bin/bash #可以看到本来bbb的GID是1004，对应的组是bbb[root@localhost ~]# cat /etc/group | grep bbbbbb:x:1004:[root@localhost ~]# usermod bbb -g bfeng[root@localhost ~]# cat /etc/passwd | grep bbbbbb:x:1001:1002::/home/bbb:/bin/bash #现在bbb的GID是1002，对应的组也就是bfeng[root@localhost ~]# 创建用户ccc，其主组设置为cfeng，其附属组有：afeng、bfeng 123456789[root@localhost ~]# useradd ccc -g cfeng -G afeng,bfeng[root@localhost ~]# cat /etc/group | grep fengfeng:x:1000:afeng:x:1001:ccc #可以看到afeng、bfeng下附属有cccbfeng:x:1002:ccccfeng:x:1003:[root@localhost ~]# cat /etc/passwd | grep cccccc:x:1002:1003::/home/ccc:/bin/bash #可以看到ccc的GID为1003，对应的组为cfeng[root@localhost ~]# 用户的主组在/etc/passwd文件中的gid字段体现，并不会在/etc/group文件中体现出来 用户的附属组在/etc/group文件中体现，并不会在/etc/passwd文件中体现 设置用户密码12passwd 用户名交互式输入密码 为用户aaa设置密码 1234567[root@localhost ~]# passwd aaaChanging password for user aaa.New password: BAD PASSWORD: The password is shorter than 8 charactersRetype new password: passwd: all authentication tokens updated successfully.[root@localhost ~]# 上述密码设置已经成功，至于BAD PASSWORD:忽略掉即可，想要了解可以浏览我博客的另一篇文章：linux-基础学习-02 Linux系统介绍和安装，这篇文章详细讲解了设置密码时遇到的N种情况。 锁定用户密码1234567891011[root@localhost ~]# passwd -l aaaLocking password for user aaa.passwd: Success[root@localhost ~]# passwd -S aaa #查看密码状态aaa LK 2019-01-18 0 99999 7 -1 (Password locked.)[root@localhost ~]# passwd -u aaa #解锁密码Unlocking password for user aaa.passwd: Success[root@localhost ~]# passwd -S aaaaaa PS 2019-01-18 0 99999 7 -1 (Password set, SHA512 crypt.)[root@localhost ~]# 使用非交互式（系统标准输入）设置用户密码（不安全） 12345678910[root@localhost ~]# echo &quot;123456&quot; | passwd --stdin aaaChanging password for user aaa.passwd: all authentication tokens updated successfully.[root@localhost ~]# history 5 #用history查看最近输入该的5条命令 81 passwd -S aaa 82 echo &quot;123456&quot; | passwd aaa 83 echo &quot;123456&quot; | passwd --stdin aaa #完了，密码露馅了 84 history -5 85 history 5[root@localhost ~]# 文件权限文件的分类 Linux系统使用了不同的字符来加以区分，常见的字符如下所示。 -：普通文件。 d：目录文件。 l：链接文件。 b：块设备文件。 c：字符设备文件。 p：管道文件。 权限分配 文件所有者 文件所有者 文件所有者 文件所属组 文件所属组 文件所属组 其他用户 其他用户 其他用户 权限项 读 执行 写 读 写 执行 读 写 执行 字符表示 r x w r w x r w x 数字表示 4 1 2 4 2 1 4 2 1 chmod修改文件权限的命令 用法 12chmod [user]+[ r | w| x ] file chmod [user] -[ r | w| x ] file 注意： 如果不加user的话，那么所有的用户的执行权限都会被加上，其他权限只对当前用户生效 例如： 12chmod 755 filechmod 750 file 更改一个文件的归属权1chown [user] file 例如： 1234567891011121314151617181920[root@localhost ~]# ll#一开始，hello.sh是root组下的root用户的文件-rw-r--r--. 1 root root 0 Jan 23 04:14 hello.sh[root@localhost ~]# chown aaa hello.sh[root@localhost ~]# ll#改成aaa用户的文件-rw-r--r--. 1 aaa root 0 Jan 23 04:14 hello.sh[root@localhost ~]# chown bbb:bfeng hello.sh [root@localhost ~]# ll#改成bfeng组下的bbb用户的文件-rw-r--r--. 1 bbb bfeng 0 Jan 23 04:14 hello.sh[root@localhost ~]# chgrp afeng hello.sh[root@localhost ~]# ll#改成归属afeng组的文件-rw-r--r--. 1 bbb afeng 0 Jan 23 04:14 hello.sh[root@localhost ~]# 文件特殊权限SUID让二进制程序的执行者临时拥有属主的权限（仅对拥有执行权限的二进制程序有效） 123456[root@localhost ~]# ll hello.sh -rw-r--r--. 1 bbb afeng 0 Jan 23 04:14 hello.sh[root@localhost ~]# chmod u+s hello.sh [root@localhost ~]# ll hello.sh -rwSr--r--. 1 bbb afeng 0 Jan 23 04:14 hello.sh[root@localhost ~]# SGID和SUID同理 SBID当对某个目录设置了SBIT粘滞位权限后，那么该目录中的文件就只能被其所有者执行删除操作。 当目录被设置SBIT特殊权限位后，文件的其他人权限部分的x执行权限就会被替换成t或者T，原本有x执行权限则会写成t，原本没有x执行权限则会被写成T。 12345678910111213[root@localhost ~]# mkdir test[root@localhost ~]# cd test[root@localhost test]# touch hello.sh[root@localhost test]# lltotal 0-rw-r--r--. 1 root root 0 Jan 23 04:33 hello.sh[root@localhost test]# chmod -R o+t hello.sh [root@localhost test]# lltotal 0-rw-r--r-T. 1 root root 0 Jan 23 04:33 hello.sh[root@localhost test]# su aaa[aaa@localhost test]$ rm -f hello.shrm: cannot remove ‘hello.sh’: Permission denied 文件的隐藏属性chattrchattr命令用于设置文件的隐藏权限，格式为 1chattr [参数] 文件 参数 作用 i 无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件 a 仅允许补充（追加）内容，无法覆盖/删除内容（Append Only） S 文件内容在变更后立即同步到硬盘（sync） s 彻底从硬盘中删除，不可恢复（用0填充原文件所在硬盘区域） b 不再修改文件或目录的存取时间 D 检查压缩文件中的错误 d 使用dump命令备份时忽略本文件/目录 c 默认将文件或目录进行压缩 u 当删除该文件后依然保留其在硬盘中的数据，方便日后恢复 t 让文件系统支持尾部合并（tail-merging） X 可以直接访问压缩文件中的内容 lsattr1234567[root@localhost test]# chattr +a hello.sh [root@localhost test]# lsattr hello.sh -----a---------- hello.sh[root@localhost test]# chattr -a hello.sh [root@localhost test]# lsattr hello.sh ---------------- hello.sh[root@localhost test]# 文件权限扩展权限设置setfacl题目： 创建文件/root/testfacl，其文件所属者和组都是root 系统中有aaa，bbb和ccc三个用户， root用户对testfacl有最高权限 aaa用户对testfacl有可读可写可执行权限 bbb用户对testfacl有可读可写权限 ccc用户对testfacl有可读权限 用户组中的用户对testfacl文件有可读可执行权限 用户组cfeng对testfacl有可读权限 其他用户对testfacl没有任何权限 命令： 1234567[root@localhost ~]# touch testfacl[root@localhost ~]# ll testfacl -rw-r--r--. 1 root root 0 Jan 23 04:49 testfacl[root@localhost ~]# setfacl -m u:root:rwx,u:aaa:rwx,u:bbb:rw-,u:ccc:r--,g::r-x,g:cfeng:r--,o::--- testfacl [root@localhost ~]# ll testfacl -rw-rwx---+ 1 root root 0 Jan 23 04:49 testfacl[root@localhost ~]# getfacl查看文件扩展属性 123456789101112131415[root@localhost ~]# getfacl testfacl # file: testfacl# owner: root# group: rootuser::rw-user:root:rwxuser:aaa:rwxuser:bbb:rw-user:ccc:r--group::r-xgroup:cfeng:r--mask::rwxother::---[root@localhost ~]# 切换用户su​ su命令可以解决切换用户身份的需求，使得当前用户在不退出登录的情况下，顺畅地切换到其他用户。su命令与用户名之间有一个减号（-），这意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。强烈建议在切换用户身份时添加这个减号（-）。 12345678910[root@localhost ~]# su aaa[aaa@localhost root]$ iduid=1000(aaa) gid=1001(afeng) groups=1001(afeng) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023[aaa@localhost root]$ su rootPassword: [root@localhost ~]# su - aaaLast login: Wed Jan 23 04:56:46 EST 2019 on pts/0[aaa@localhost ~]$ iduid=1000(aaa) gid=1001(afeng) groups=1001(afeng) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023[aaa@localhost ~]$ 尴尬的是，root和aaa恰好环境变量信息是一样的，唉算了就这样吧，加个减号也不费事 sudosudo命令用于给普通用户提供额外的权限来完成原本root管理员才能完成的任务，格式为 1sudo [参数] 命令名称 sudo命令具有如下功能： 限制用户执行指定的命令： 记录用户执行的每一条命令； 配置文件（/etc/sudoers）提供集中的用户管理、权限与主机等参数； 验证密码的后5分钟内（默认值）无须再让用户再次验证密码。 参数 作用 -h 列出帮助信息 -l 列出当前用户可执行的命令 -u用户名或UID值 以指定的用户身份执行命令 -k 清空密码的有效时间，下次执行sudo时需要再次进行密码验证 -b 在后台执行指定的命令 -p 更改询问密码的提示语 visudo举例：使用visudo命令配置sudo命令的配置文件 [root@localhost ~]# visudo 98 ## Allows people in group wheel to run all commands 99 %wheel ALL=(ALL) ALL 100 root ALL=(ALL) ALL]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-09 编写Shell脚本]]></title>
    <url>%2Flinux-09%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-09 编写Shell脚本 可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。 交互式（Interactive）：用户每输入一条命令就立即执行。 批处理（Batch）：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。 指定解释器脚本的第一行用于指定脚本使用哪个shell程序做为脚本中命令的解释器 使用bash做为脚本命令的解释器 1#!/bin/bash 使用zsh做为脚本的命令解释器 1#!/bin/zsh 创建一个脚本123456[root@localhost ~]# vim hello.sh里面输入：#!/bin/bashecho &quot;helloworld&quot;保存退出 执行一个脚本123[root@localhost ~]# ./hello.sh-bash: ./hello.sh: Permission denied #发现你的权限不够[root@localhost ~]# 添加执行权限 脚本写完后运行，利用./执行发现权限不够。Linux文件创建之后默认是没有可执行权限的，可以用chmod给文件或目录添加上可执行权限 123456[root@localhost ~]# ll[root@localhost ~]# chmod +x hello.sh [root@localhost ~]# ll[root@localhost ~]# ./hello.sh helloworld[root@localhost ~]# 上面两次ll出来的文件列表，是为了对比出添加权限前后文件权限的变化，x表示可执行。 没有执行权限情况下想要执行脚本的两种方式12345678910首先咱们在新建一个脚本[root@localhost ~]# vim aaa.sh里面输入：#!/bin/bashecho &quot;hello aaa&quot;保存退出验证它无权限被执行[root@localhost ~]# ./aaa.sh-bash: ./aaa.sh: Permission denied 解释器后面跟上脚本12[root@localhost ~]# bash aaa.sh hello aaa 点加空格后面跟上脚本或者脚本的全路径12[root@localhost ~]# . aaa.sh hello aaa Shell脚本执行的几种方法 在脚本拥有可执行权限之后，我们就可以去执行脚本，执行脚本有以下几种方式： 在脚本所在目录下时 123456789[root@localhost ~]# ./hello.sh helloworld[root@localhost ~]# . hello.sh helloworld[root@localhost ~]# bash hello.sh helloworld[root@localhost ~]# sh hello.sh helloworld[root@localhost ~]# 不在脚本所在目录下时 12345678910[root@localhost ~]# mkdir -p a/b/c/d[root@localhost ~]# cd a[root@localhost a]# bash /root/hello.sh helloworld[root@localhost a]# cd b/c/d[root@localhost d]# pwd/root/a/b/c/d[root@localhost d]# ./../../../../hello.sh helloworld[root@localhost d]# 接受用户的参数脚本的参数就是脚本后面跟的用户输入的选项或者是变量 在脚本中 脚本的名字使用$0来表示 脚本的参数个数使用$#表示 脚本的第N个参数使用$N表示（例如脚本第三个参数$3） 12345678910[root@localhost ~]# vim hello.sh 输入：#!/bin/bashecho &quot;脚本名称：$0&quot;echo &quot;参数个数：$#&quot;echo &quot;第一个参数：$1&quot;echo &quot;第二个参数：$2&quot;echo &quot;第三个参数：$3&quot;echo &quot;第四个参数：$4&quot;echo &quot;第五个参数：$5&quot; 执行该脚本： 1[root@localhost ~]# bash hello.sh 1 2 3 4 5 判断用户参数（下面两种写法）123456789101112[root@localhost ~]# vim isroot.sh输入：#!/bin/bashif [ $USER == root ];then echo &quot;当前用户是管理员&quot;else echo &quot;当前用户不是管理员&quot; fi[ $USER = root ] &amp;&amp; echo &quot;当前用户是管理员&quot; || echo &quot;当前用户不是管理员&quot;exit 0 执行该脚本： 1234[root@localhost ~]# bash isroot.sh 当前用户是管理员当前用户是管理员[root@localhost ~]# 可用的整数比较运算符 运算符 作用 -eq 是否等于 -ne 是否不等于 -gt 是否大于 -lt 是否小于 -le 是否等于或小于 -ge 是否大于或等于 常见的字符串比较运算符 运算符 作用 = 比较字符串内容是否相同 != 比较字符串内容是否不同 -z 判断字符串内容是否为空 123 [root@localhost ~]# [ $LANG=&quot;EN.US.UTF-8&quot; ]&amp;&amp;echo &quot;is English&quot;is English[root@localhost ~]# Shell中的四则运算注意：方括号外取值符号$不能少，方括号内一定要用空格把方括号和里面的命令隔开 123456[root@localhost ~]# i=$[10 * 10][root@localhost ~]# echo $i100[root@localhost ~]# echo $[999 + 999]1998[root@localhost ~]# 写一个判断内存是否够用的脚本 1[root@localhost ~]# vim isfree.sh 输入： 123456789101112#!/bin/bash# 此脚本用于判断内存是否够用，标准为空闲内存大于总内存的20%（说明脚本功能）# bash isfree.sh （说明脚本的用法）# 作者：feng（说明脚本作者）# qq:略（说明作者的联系方式） # 可能有些脚本里有复杂参数或者函数，请在最下面进行说明 Totalmem=`free -m | grep Mem | awk &apos;&#123;print $2&#125;&apos;`Freemem=`free -m | grep Mem | awk &apos;&#123;print $4&#125;&apos;`i=$[ $Totalmem/5 ][ $Freemem -gt $i ] &amp;&amp; echo &quot;内存够用&quot; || echo &quot;内存紧缺，请抓紧清理内存&quot; 执行： 123[root@localhost ~]# bash isfree.sh 内存够用[root@localhost ~]# if流程控制语句上面判断用户参数时，我们已经使用过了if语句 现在再来一次 linux shell 中判断文件、目录是否存在-e filename 如果 filename存在，则为真-d filename 如果 filename为目录，则为真-f filename 如果 filename为常规文件，则为真-L filename 如果 filename为符号链接，则为真-r filename 如果 filename可读，则为真-w filename 如果 filename可写，则为真-x filename 如果 filename可执行，则为真-s filename 如果文件长度不为0，则为真 1[root@localhost ~]# vim 1.sh 输入: 12345678910#!/bin/bashDIR=&quot;/root/test&quot;if [ ! -d $DIR ]then echo &quot;目录不存在&quot; mkdir /root/testelse echo &quot;目录已经存在&quot;fiexit 0 1234[root@localhost ~]# bash 1.sh 目录不存在[root@localhost ~]# bash 1.sh 目录已经存在 结果如下图： 判断主机是否能正常访问百度的脚本1[root@localhost ~]# vim baidu.sh 输入： 1234567891011121314151617#!/bin/bash# example： ./testhost.sh www.baidu.comif [ $# -eq 1 ] then ping -c 4 -i 0.2 -W 3 $1 &amp;&gt; /dev/nullelse echo &quot;example: $0 www.baidu.com&quot;fi if [ $? -eq 0 ] then echo &quot;主机$1能正常访问&quot; exit 0else echo &quot;主机$1无法访问&quot; exit 1fi 1234[root@localhost ~]# bash baidu.sh example: baidu.sh www.baidu.com主机能正常访问[root@localhost ~]# 判断成绩的脚本1[root@localhost ~]# vim result.sh 123456789101112 #!/bin/bashread -p &quot;Enter your score(0-100): &quot; scif [ $sc -gt 100 ] || [ $sc -lt 0 ] ; then echo &quot;Error,Please input score 0~100!&quot; exit 2elif [ $sc -ge 85 ] &amp;&amp; [ $sc -le 100 ]; then echo &quot;$sc is Excellent&quot;elif [ $sc -ge 60 ] &amp;&amp; [ $sc -le 84 ]; then echo &quot;$sc is Pass&quot;else echo &quot;$sc is Fail&quot;fi 1234[root@localhost ~]# bash result.sh Enter your score(0-100): 9090 is Excellent[root@localhost ~]# for循环 题目：在linux上创建一个脚本，名为/root/makeusers，此脚本能实现为系统创建本地用户，并且这些用户的用户名来自一个包含用户名列表的文件。 同时满足下列要求： 此脚本要求提供一个参数，此参数就是包含用户列表的文件 如果没有提供参数，此脚本应该给出下面的提示信息 Usage:/root/makeusers ，然后退出并返回相应的值 如果提供一个不存在的文件名，此脚本应该给出下面的提示信息 Input file not found 然后退出并返回相应的值 创建的用户登录 shell 为/bin/false，此脚本不需要为用户设置密码 首先，了解一下新建用户的命令： 12[root@localhost ~]# useradd -s /bin/fasle &quot;testuser&quot;[root@localhost ~]# cat /etc/passwd 通过cat命令查看所有用户信息，可以看到如下图，用户testuser已经成功创建出来了 现在开始写脚本： 1[root@localhost ~]# vim foruser.sh 123456789101112#!/bin/bashif [ $# -ne 1 ];then echo &apos;Usage: $0 &lt;userfile&gt;&lt;&gt;&apos; exit 1elif [ ! -f &quot;$1&quot; ];then echo &quot;input file not found&quot; exit 2else for USER in $(cat &quot;$1&quot;);do useradd -s /bin/false $USER donefi 新建一个包含用户名的文件，里面随便设置几个用户 1[root@localhost ~]# vim user.txt 1234aaabbbcccddd 执行脚本 12[root@localhost ~]# bash foruser.sh user.txt [root@localhost ~]# cat /etc/passwd 如下图，几个用户已经被成功添加了！ 把for循环改成wheel循环的写法 另外再写一个脚本： 1[root@localhost ~]# vim wheeluser.sh 123456789101112#!/bin/bashif [ $# -eq 1 ];then if [ -f &quot;$1&quot; ];then while read username;do useradd -s /bin/false $username &amp;&gt;/dev/null done&lt;$1 #跳出循环 else echo &quot;Input file not found&quot; fi else echo &quot;Usage: $0 &lt;userfile&gt;&quot;fi 重新编辑一下user.txt 1[root@localhost ~]# vim user.txt 1234aaawwwbbbwwwcccwwwdddwww 执行脚本 12[root@localhost ~]# bash wheeluser.sh user.txt [root@localhost ~]# cat /etc/passwd 如下图，几个用户已经被成功添加了！ case语句在 linux上创建一个名为/root/script.sh 的脚本，让其提供下列特性： 当运行/root/script.sh all，输出为 none 当运行/root/script.sh none，输出为 all 当没有任何参数或参数不是 all 或者 none 时，其错误输出产生以下的信息： 1/root/script.sh all|none 开始写脚本 1[root@localhost ~]# vim script.sh 123456789101112#!/bin/bashcase $1 in all) echo &quot;none&quot; ;; none) echo &quot;all&quot; ;; *) echo &quot;Usage: $0 all|none&quot; ;; esac 执行脚本： 1234567[root@localhost ~]# bash script.sh allnone[root@localhost ~]# bash script.sh noneall[root@localhost ~]# bash script.sh abcUsage: script.sh all|none[root@localhost ~]# 如下图 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础学习-08 管道符、重定向与环境变量]]></title>
    <url>%2Flinux-08%2F</url>
    <content type="text"><![CDATA[linux-基础学习-08 管道符、重定向与环境变量重定向输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。 标准输入重定向（STDIN，文件描述符为0）：默认从键盘输入，也可从其他文件或命令中输入。 标准输出重定向（STDOUT，文件描述符为1）：默认输出到屏幕。 错误输出重定向（STDERR，文件描述符为2）：默认输出到屏幕。 输入重定向中用到的符号以及作用 符号 作用 命令 &lt; 文件 将文件作为命令的标准输入 命令 &lt;&lt; 分界符 从标准输入中读入，直到遇见分界符才停止 命令 &lt; 文件1 &gt; 文件2 将文件1作为命令的标准输入并将标准输出到文件2 输出重定向中用到的符号及其作用 符号 作用 命令 &gt; 文件 将标准输出重定向到一个文件中（清空原有文件的数据） 命令 2&gt; 文件 将错误输出重定向到一个文件中（清空原有文件的数据） 命令 &gt;&gt; 文件 将标准输出重定向到一个文件中（追加到原有内容的后面） 命令 2&gt;&gt; 文件 将错误输出重定向到一个文件中（追加到原有内容的后面） 命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面） 将当前的网络信息保存到当前目录中的network_info.txt文件中（输出重定向） 12[root@localhost ~]# ifconfig &gt; network_info.txt[root@localhost ~]# cat network_info.txt 追加一个日期到network_info.txt文件中（输出重定向） 12[root@localhost ~]# date &gt;&gt; network_info.txt [root@localhost ~]# cat network_info.txt 管道符命令用于把前一个命令原本要输出到屏幕的标准正常数据当作是后一个命令的标准输入案例：统计当前Linux系统中有多少用户不能交互式登录系统 123[root@localhost ~]# grep nologin /etc/passwd | wc -l16[root@localhost ~]# 命令行通配符 通配符就是通用的匹配信息的符号，比如星号（*）代表匹配零个或多个字符，问号（?）代表匹配单个字符，中括号内加上数字[0-9]代表匹配0～9之间的单个数字的字符，而中括号内加上字母[abc]则是代表匹配a、b、c三个字符中的任意一个字符。 案例1： 查看系统中有哪些硬盘1234[root@localhost ~]# ll /dev/sd*[root@localhost ~]# ll /dev/sd?[root@localhost ~]# ll /dev/sd[a-z][root@localhost ~]# 案例2： 查看系统中有哪些分区1[root@localhost ~]# ll /dev/sd*[0-9] 常用转义字符Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据 反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。 单引号（’’）：转义其中所有的变量为单纯的字符串。 双引号（””）：保留其中的变量属性，不进行转义处理。 反引号（）：把其中的命令执行后返回结果。 在一串字符串中输出$符号 1234567直接echo无法输出$符号，而且对其他的字符和字符串还会造成影响[root@localhost ~]# echo hello$worldhello[root@localhost ~]# echo hello\$worldhello$world[root@localhost ~]# alias命令别名临时让命令别名生效 12345678 [root@localhost ~]# curl myip.ipip.net当前 IP：112.24.12.22 来自于：中国 江苏 镇江 移动[root@localhost ~]# myip-bash: myip: command not found[root@localhost ~]# alias myip=&apos;curl myip.ipip.net&apos;[root@localhost ~]# myip当前 IP：112.24.12.22 来自于：中国 江苏 镇江 移动[root@localhost ~]# 永久对当前用户生效 12345[root@localhost ~]# vim ~/.bashrc在下图所示处加上一行alias myip=&apos;curl myip.ipip.net&apos;保存退出 修改了~/.bashrc文件后必须使用source命令刷新才会生效 1234[root@localhost ~]# source ~/.bashrc[root@localhost ~]# myip当前 IP：112.24.12.22 来自于：中国 江苏 镇江 移动[root@localhost ~]# Linux系统中最重要的10个环境变量 变量名称 作用 HOME 用户的主目录（即家目录） SHELL 用户在使用的Shell解释器名称 HISTSIZE 输出的历史命令记录条数 HISTFILESIZE 保存的历史命令记录条数 MAIL 邮件保存路径 LANG 系统语言、语系名称 RANDOM 生成一个随机数字 PS1 Bash解释器的提示符 PATH 定义解释器搜索用户执行命令的路径 EDITOR 用户默认的文本编辑器 本篇到此结束，这是linux基础学习章节的最后一篇，下一篇linux-09将进入到新的章节：运维进阶]]></content>
      <categories>
        <category>linux</category>
        <category>linux-基础学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础学习-07 Linux系统上传下载命令rz和sz]]></title>
    <url>%2Flinux-07%2F</url>
    <content type="text"><![CDATA[linux-基础学习-07 Linux系统上传下载命令rz和sz 在部署项目时，我们经常需要从本地电脑和linux服务器间上传或下载项目包，所以今天来个好用的命令，sz， rz命令 安装lrzsz 1[root@localhost ~]# yum install -y lrzsz 我们上传一个aaa.txt测试一下（aaa.txt最好有内容，大小不要是0字节）： 下载测试： 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-基础学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础学习-06 炫酷的zsh]]></title>
    <url>%2Flinux-06%2F</url>
    <content type="text"><![CDATA[linux-基础学习-06 炫酷的zsh概念：cmd cmd是command的缩写，即命令提示符。命令提示符（CMD）是在操作系统中，提示进行命令输入的一种工作提示符。在不同的操作系统环境下，命令提示符各不相同。 在windows环境下，命令行程序为cmd.exe，是一个32位的命令行程序，微软Windows系统基于Windows上的命令解释程序，类似于微软的DOS操作系统。输入一些命令，cmd.exe可以执行，比如输入shutdown -s -t 30就会在30秒后关机。总之，它非常有用。 打开方法：开始-所有程序-附件 或 开始-寻找-输入：cmd/cmd.exe 回车。用户可以在命令提示符直接输入中文调用文件。 Shell Shell基本上是一个命令解释器，类似于DOS下的command和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序。 Xshell Xshell 是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。Xshell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。除此之外，其还有丰富的外观配色方案以及样式选择。 PowerShell Windows PowerShell 是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以利用 .NET Framework的强大功能。PowerShell跟cmd有什么关系呢？可以简单地说，PowerShell可以看作是cmd的升级版、补充版，但其背后的实现方式却有很大的不同，PowerShell基于面向对象。PowerShell是运行在Windows操作系统上实现对系统以及应用程序进行管理自动化的命令行脚本环境，PowerShell需要.NET环境的支持，借助.NET Framework平台强大的类库，几乎让一切都成为可能。微软起“PowerShell”这个名字并不是夸夸其谈，它完全支持对象，其可读性，易用性，毫不夸张的说可以居所有Shell之首。 打开方法：windows的win+R输入powershell回车即可打开powershell Bash Bash (GNU Bourne-Again Shell) 是许多Linux发行版的默认Shell Zsh Zsh是一个Linux用户很少使用的shell，这是由于大多数Linux产品安装，以及默认使用bash shell。几乎每一款Linux产品都包含有zsh，通常可以用apt-get、urpmi或yum等包管理器进行安装。（CentOS用yum） 安装zsh安装 oh-my-zsh 套件123[root@localhost ~]# yum install zsh -y[root@localhost ~]# yum -y install git[root@localhost ~]# sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; .oh-my-zsh 点开头，表示这是个隐藏文件！ 查看当前使用的SHELL123➜ ~ echo $SHELL/bin/bash➜ ~ 退出当前状态1➜ ~ exit 切换用户登录Shell的方法想用zsh的话就把指定用户最后登录shell设置为/bin/zsh* 12[root@localhost ~]# vim /etc/passwdroot:x0:0:root:/root:/bin/zsh 想用zsh的话就把指定用户最后登录shell设置为/bin/bash* 12[root@localhost ~]# vim /etc/passwdroot:x0:0:root:/root:/bin/bash 再打开一个xhell窗口验证一下： 修改zsh主题修改zsh主题为每次登录随机主题* 12[root@localhost ~]# vim .zshrc ZSH_THEME=&quot;random&quot; *#random就是随机主题 所有主题文件存放的位置 1[root@localhost ~]# ls ~/.oh-my-zsh/themes/ 修改zsh主题为每次登录主题为ys 12[root@localhost ~]# vim .zshrc ZSH_THEME=&quot;ys&quot; 再打开一个xhell窗口验证一下，ys主题如下图，还自带时间的呢（图中是下午三点哈）！ zsh安装智能补全插件12345678[root@localhost ~]# mkdir ~/.oh-my-zsh/plugins/incr[root@localhost ~]# cd ~/.oh-my-zsh/plugins/incr[root@localhost incr]# wget http://mimosa-pudica.net/src/incr-0.2.zsh[root@localhost incr]# chmod +x incr-0.2.zsh[root@localhost incr]# vim ~/.zshrc#在最后加上这一行，保存退出source ~/.oh-my-zsh/plugins/incr/incr*.zsh 如何切换到隐藏目录参考上面一行命令即可 1[root@localhost ~]# cd ~/.oh-my-zsh/plugins/incr 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-基础学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础学习-05 服务器基础环境配置和Yum软件仓库]]></title>
    <url>%2Flinux-05%2F</url>
    <content type="text"><![CDATA[linux-基础学习-05 服务器基础环境配置和Yum软件仓库查看和配置Linux系统的主机名：12345[root@localhost ~]# hostnamelocalhost.localdomain[root@localhost ~]# hostnamectl set-hostname abc[root@localhost ~]# hostnameabc 查看软件仓库列表1[root@localhost ~]# yum repolist 如下图，我的yum源都是阿里云仓库的源。 将Yum仓库替换成中科大的仓库（Centos 7）12345678910[root@localhost ~]# cd /etc/yum.repos.d/[root@localhost yum.repos.d]# mv CentOS-Base.repo CentOS-Base.repo.backup //备份[root@localhost yum.repos.d]# wget -O CentOS-Base.repo https://lug.ustc.edu.cn/wiki/_export/code/mirrors/help/centos?codeblock=3查看yum源名称，可以看到已经不是阿里云的了[root@localhost yum.repos.d]# yum repolist 清空之前的yum缓存和生成新的yum软件列表元数据[root@localhost yum.repos.d]# cd ~[root@localhost ~]# yum clean all &amp;&amp; yum makecache 配置网卡信息（配置固定IP地址）1[root@localhost ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33 将ens33网卡配置如下（备注可以不写）： 1234567891011121314151617181920TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot; # 设备获得IP的方式设置为静态获取，固定ipDEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;9c86a9bc-0939-4790-8580-274041e5eff3&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;y # 设备是否随着network的启动而启动IPADDR=192.168.141.12 # 设备的默认IPNETMASK=255.255.255.0 # 设备的默认掩码GATEWAY=192.168.141.2 # 设备的默认网关DNS1=114.114.114.114 # 设备DNSDNS2=8.8.8.8 重启网络服务（你改了网卡ip，xshell远程连接就会断掉，需要重新连接） 12345678910111213141516171819202122232425262728[root@localhost ~]# systemctl restart networkSocket error Event: 32 Error: 10053.Connection closing...Socket close.Connection closed by foreign host.Disconnected from remote host(Test) at 09:46:57.Type `help&apos; to learn how to use Xshell prompt.你可以手动重新连接：[C:\~]$ ssh root@192.168.141.12 Connecting to 192.168.141.12:22...Connection established.To escape to local shell, press &apos;Ctrl+Alt+]&apos;.WARNING! The remote SSH server rejected X11 forwarding request.Last login: Thu Jan 17 20:41:17 2019 from 192.168.141.1[root@localhost ~]# 连接成功！[root@localhost ~]# ip add可以看到ens33的ip已经变成192.168.141.12了！ 给网卡配置多个IP地址1[root@localhost ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33 将ens33网卡配置如下（备注可以不写）： 12345678910111213141516171819202122232425262728293031TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot; # 设备获得IP的方式设置为静态获取，固定ipDEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;9c86a9bc-0939-4790-8580-274041e5eff3&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;yIPADDR=192.168.141.12 # 第1个IPNETMASK=255.255.255.0 # 设备的默认掩码IPADDR0=192.168.141.13 # 第2个IP（secondary）NETMASK0=255.255.255.0IPADDR1=192.168.141.14 # 第3个IP（secondary）NETMASK1=255.255.255.0IPADDR2=192.168.141.15 # 第4个IP（secondary）NETMASK2=255.255.255.0GATEWAY1=192.168.141.2DNS1=114.114.114.114DNS2=8.8.8.8 注意事项（考试易错）： 首个ip是从IPADDR开始的，而从IPADDR0开始以及其之后的都是secondary 的网卡ip！这里一定要记住！ 有同学在考红帽认证的时候犯过这个错，望引以为戒！ 重启网络服务，查看网卡ip 12[root@localhost ~]# systemctl restart network[root@localhost ~]# ip add | grep inet 如下图，可以看到多出来3个新的ip 给Linux增加一块网卡，并且配置静态IP：在VMware里点虚拟机设置，给虚拟机添加一块网卡（不用将虚拟机关机） 查看网卡： 1[root@localhost ~]# ifconfig 如下图，多出来的end37网卡就是我们新增加的网卡，其ip目前还是它dhcp自动获取到的 新增的ens37是dhcp得到的IP，我们想自己配制成静态的IP，去/etc/sysconfig/network-scripts/目录下找ifcfg-ens37，发现没有这个配置文件，那里只有ens33的文件，哎！ 12[root@localhost ~]# cd /etc/sysconfig/network-scripts/[root@localhost network-scripts]# ls 因此，我们需要复制ens33的配置文件ifcfg-ens33为ifcfg-ens37，重新编辑其内容 1234[root@localhost network-scripts]# cp ifcfg-ens33 ifcfg-ens37[root@localhost network-scripts]# ls[root@localhost network-scripts]# vim ifcfg-ens37 其内容改为以下的形式： 123456789101112131415161718192021TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot;DEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens37&quot; # 修改网卡名UUID=&quot;9c86a9bc-0939-4790-8580-274041e5eff3&quot;DEVICE=&quot;ens37&quot; # 修改设备名ONBOOT=&quot;yes&quot;yIPADDR=192.168.141.111 #设置一个与之前ens33网卡的三个ip不同的ip NETMASK=255.255.255.0GATEWAY1=192.168.141.2DNS1=114.114.114.114DNS2=8.8.8.8 修改完成保存退出,重启网络服务 12[root@localhost network-scripts]# systemctl restart network[root@localhost network-scripts]# ifconfig ens37 如下图，网卡设置成功啦！ 注意事项： 将虚拟机关机再打开后，发现ens37的ip又变成了自动获取到的192.168.141.163，甚至有时候会发现ens37同时出现了两个ip：192.168.141.163和192.168.141.111 这种情况，并不是配错了，只要再次重启网络服务即可！ 12[root@localhost network-scripts]# systemctl restart network[root@localhost network-scripts]# ifconfig ens37 另外，在某些极端特殊的情况下，有时候，在重启虚拟机之后，两个网卡ens33和ens37都挂掉了，没有ip了，遇到这种情况，先尝试以下命令： 12ifup ens33ifup ens37 敲完之后网卡立马就up了，ip也有了。 ​ 之前没有ip是你的网卡down的原因，在以后玩虚拟机的时候，可能会由于某些操作失误导致网卡down掉，这时候只要敲上述的ifup命令就好了。 本篇到此结束，注意配置网卡的时候不要敲错了]]></content>
      <categories>
        <category>linux</category>
        <category>linux-基础学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础学习-04 Vim编辑器]]></title>
    <url>%2Flinux-04%2F</url>
    <content type="text"><![CDATA[linux-基础学习-04 Vim编辑器 Vim是一个类似于Vi的著名的功能强大、高度可定制的文本编辑器，在Vi的基础上改进和增加了很多特性。 系统里面会自带vi编辑器，但VIM是VI的扩展版本，所以需要手动安装 1[root@localhost ~]# yum install vim -y VIM编辑器三大模式：普通模式（命令模式）：进入VIM编辑器后默认的模式是普通模式（此时无法对文本进行改动） 输入模式（插入模式）：在普通模式下按insert键、a、i、o、O进入到输入模式，用Esc键可以从插入模式返回到普通模式 末行模式（底行命令模式）：在普通模式下按“:”进入末行模式，末行模式主要是各种搜索替换以及保存退出功能 搜索模式：在普通模式下按“/”,然后输入想要搜索的内容，按回车；在搜索模式下向下搜索直接按“/”回车，也可以在普通模式下用“n”向下搜索，大写的“N”为向上搜索 命令 作用 dd 删除（剪切）光标所在整行 5dd 删除（剪切）从光标处开始的5行 yy 复制光标所在整行 5yy 复制从光标处开始的5行 n 显示搜索命令定位到的下一个字符串 N 显示搜索命令定位到的上一个字符串 u 撤销上一步的操作 p 将之前删除（dd）或复制（yy）过的数据粘贴到光标后面 x 删除光标所在位置的字符 [n]x 删除光标所在位置以及之后的n个字符 G 快速到达文档尾部 Vim键盘功能表： 末行模式中可用的命令： 命令 作用 :w 保存 :q 退出 :q! 强制退出（放弃对文档的修改内容） :wq! 强制保存退出 :set nu 显示行号 :set nonu 不显示行号 :命令 执行该命令 :s/one/two 将当前光标所在行的第一个one替换成two :s/one/two/g 将当前光标所在行的所有one替换成two :%s/one/two/g 将全文中的所有one替换成two ?字符串 在文本中从下至上搜索该字符串 /字符串 在文本中从上至下搜索该字符串 使末行模式下配置的VIM环境永久生效1.修改/etc/vimrc让VIM配置对所有用户永久生效 2.修改~/.vimrc 用户家目录下的vimrc对当前用户永久生效 隐藏文件以”.”开头 1234[root@localhost ~]# vim .vimrc[root@localhost ~]# cat .vimrc set nuset ts=4 快速清空文档我们新建并编辑一个文档，里面随便敲几行字母，如下： 12345678[root@localhost ~]# vim test.txt[root@localhost ~]# cat test.txt osifhisudfsdufhisudsidfhisudsudhfisudhfsudhfsudfi[root@localhost ~]# 接下来vim打开test.txt，打开后默认是在命令行模式 1[root@localhost ~]# vim test.txt 此时在文档尾部还能看到文件名，如果是插入模式，那就会显示“插入”两个字 此时你按下gg，可以看到光标跳到了首行 此时你按下dG，可以看到文档内容被瞬间清空 然后你按下i，可以看到变成了插入模式，输入hello world 保存退出，再次查看文档内容，可以看到修改成功 利用可视块去除文本前面的行号 有时候，我们会从网上粘贴一些代码，但是由于一些配置文件修改时为了方便找到修改的内容在哪一行，许多作者都是习惯将行号也写出来的。那么，如何快速去除文本前面的行号呢？ 我们新建一个文本来演示一下，里面放5行，接下来尝试删掉11~15这5个行号 1234567[root@localhost ~]# vim hello.txt[root@localhost ~]# cat hello.txt 11 hello12 hello13 hello14 hello15 hello 用vim打开这个文件，此时默认就是命令行模式，底部还可以看到文件名 1[root@localhost ~]# vim hello.txt 按下ctrl+v，可以看到底部文字变成了“可视块”。 接下来按右方向键和上方向键，选中你要删除的部分内容块 接下来按下小写的x键，可以看到你选中的那些内容块直接被你删除了 接下来照常保存退出，再次查看hello.txt的内容，可以看到修改成功 撤销与恢复撤销 在使用VIM的时候，难免会有输错的情况，这个时候我们应该如何撤销，然后回到输错之前的状态呢？答案：使用u（小写，且在命令模式下）命令。 但如果有时我们一不小心在命令模式下输入了u，然后刚输入的一大片代码都不见了，这个时候我们应该如何恢复刚才的撤销操作呢？答案：使用Ctrl + r命令。 总结： 撤销：u 恢复撤销：Ctrl + r 现在来演示一遍 继续以上一个文档为例，我们在 12345678[root@localhost ~]# vim hello.txt[root@localhost ~]# cat hello.txt hellohellohellohellohello[root@localhost ~]# 首先用vim打开这个文件，按i进入插入模式，然后在文档底部随便加上一行字母 然后按Esc键，切换到命令行模式 此时，按下小写字母u，可以看到我们刚刚加上去的一大串字母不见了，这说明我们成功撤销掉了刚刚对文档的编辑修改。 现在再按下ctrl+r，可以看到，我们撤销掉的内容又回来了，说明恢复撤销成功了 然后保存退出即可 有了上面教的这几招，基本上就可以熟练使用vim了 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-基础学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础学习-03 linux必知必会的命令]]></title>
    <url>%2Flinux-03%2F</url>
    <content type="text"><![CDATA[linux-基础学习-03 linux必知必会的命令获取命令帮助123date --help //date查看系统时间，加了--help以看后面可以跟什么参数等date -hman date echoecho命令用于在终端输出字符串或变量提取后的值，格式为“echo [字符串 | $变量]”。1234567[root@localhost ~]# echo helloworldhelloworld[root@localhost ~]# echo &quot;helloworld&quot;helloworld[root@localhost ~]# i=&quot;helloworld&quot;[root@localhost ~]# echo $ihelloworld datedate查看时间以及设置时间相关命令，-s参数表示set设置 1234[root@localhost ~]# dateWed Jan 16 07:48:36 EST 2019[root@localhost ~]# date -s &quot;19961001 1:01:00&quot;Tue Oct 1 01:01:00 EDT 1996 ntpdate将系统的当前时间同步回网络时间1234[root@localhost ~]# ntpdate -u ntp.api.bz16 Jan 07:54:58 ntpdate[1494]: step time server 47.96.136.13 offset 703496889.865151 sec[root@localhost ~]# dateWed Jan 16 07:55:09 EST 2019 wget （Linux上的下载命令）12yum -y install wgetwget 链接地址 ps（静态任务管理器）用于查看系统中的进程状态，命令格式为：1ps [参数] 常用ps命令组合：1ps -aux -a：显示所有进程 -u：用户以及其他详细信息 -x：显示没有控制终端的进程 备注: 状态栏中，R表示正在运行的进程，S表示中断的进程，D表示不可终端的进程，Z表示僵尸进程，T表示停止的进程 TOP命令（动态任务管理器） TOP命令用于动态地监视进程活动与系统负载等信息，其格式为top。能够动态地查看系统运维状态，完全将它看作Linux中的“强化版的Windows任务管理器”。 第1行：系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。 第2行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。 第3行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。 第4行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。 第5行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量。 kill命令：结束后台进程为1的进程1[root@localhost ~]# kill %[后台进程号] 结束进程pid为1234的进程1[root@localhost ~]# kill 1234 结束进程pid为1234的进程树1[root@localhost ~]# kill -9 1234 pkill格式：pkill [进程名或者进程名的一部分连续字符串] 1[root@localhost ~]# pkill ss 系统状态检测命令查看和IP地址1ifconfig 临时修改IP地址1ifconfig ens33 192.168.9.101 netmask 255.255.255.0 free查看内存相关信息12[root@localhost ~]# free[root@localhost ~]# free -h who查看当前登入主机的用户终端信息：1[root@localhost ~]# who [参数] last：用于查看所有系统的登录记录：1[root@localhost ~]# last [参数] history用于显示历史执行过的命令，最多一千条：1[root@localhost ~]# history [-c] sosreport用于收集系统配置及架构信息并输出诊断文档：12[root@localhost ~]# yum install sos -y[root@localhost ~]# sosreport cd用于切换目录pwd用于显示当前所在目录123456789101112131415161718192021222324252627282930#切换到根目录*[root@localhost etc]# cd /[root@localhost /]# pwd#切换到/etc/yum.repos.d目录*[root@localhost /]# cd /etc/yum.repos.d/[root@localhost yum.repos.d]# pwd/etc/yum.repos.d#切换到当前目录的上一级目录*[root@localhost yum.repos.d]# cd .. *#“.”代表当前目录，两个“.”代表上一级目录*[root@localhost etc]# pwd/etc#切换到家目录*[root@localhost etc]# cd[root@localhost ~]# pwd/root[root@localhost ~]# cd ~[root@localhost ~]# pwd/root *#回到切换目录之前所在的目录* [root@localhost ~]# pwd /root [root@localhost ~]# cd /var/tmp/ [root@localhost tmp]# cd - /root [root@localhost ~]# pwd /root ls命令ls命令用于显示目录中的文件信息（Linux中一切皆文件），格式为“ls [选项] [文件] ”。在CentOS系列系统中，ls -l 默认别名有ll查看目录下文件的详细信息 1[root@localhost ~]# ls -l 查看目录下的隐藏文件 1[root@localhost ~]# ls -a 只查看目录本身的信息，不显示目录中的文件 12[root@localhost ~]# cd /[root@localhost /]# ls -ld /root/ tail命令tail命令用于查看纯文本文档的后N行或持续刷新内容，格式为“tail [选项] [文件]”。 动态追踪文本更新 123tail -f或者tailf 1[root@localhost ~]# tailf /var/log/messages cat文本输出命令,通常是用于观看某个文件的内容的1[root@localhost ~]# cat anaconda-ks.cfg trtr命令用于替换文本文件中的字符，格式为“tr [原始字符] [目标字符]”。1[root@localhost ~]# cat anaconda-ks.cfg | tr [a-z] [A-Z] stat查看文件或者文件系统的状态touchtouch命令用于创建空白文件或设置文件的时间，格式为“touch [选项] [文件]” 创建文件filea，查看该文件的状态 12[root@localhost ~]# touch filea[root@localhost ~]# stat filea 修改filea的最近访问和最近改动的时间 12[root@localhost ~]# touch -d &quot;19990101 01:01:01&quot; filea[root@localhost ~]# stat filea wc命令wc命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本” 统计系统中一共有多少个用户 1[root@localhost ~]# wc -l /etc/passwd 统计/etc/yum.repos.d/CentOS-Base.repo文件一共有多少字数 1[root@localhost ~]# wc -c /etc/yum.repos.d/CentOS-Base.repo 统计/etc/yum.repos.d/CentOS-Base.repo文件一共有多少个单词 1[root@localhost ~]# wc -w /etc/yum.repos.d/CentOS-Base.repo mkdir用于创建目录相对路径：相对于当前目录的路径 绝对路径：以/开头的路径（相对于根目录的路径） 在/root目录下新建目录aaa 1[root@localhost ~]# mkdir aaa 在/root目录下新建目录bbb(当你还在另一个目录时，利用../命令切换式创建) 12[root@localhost ~]# cd /var/tmp[root@localhost tmp]# mkdir ../../root/bbb 在/root目录下新建目录ccc（当你还在另一个目录时，利用绝对路径创建） 1[root@localhost tmp]# mkdir /root/ccc 递归创建目录 12[root@localhost tmp]# cd /root[root@localhost ~]# mkdir -p ddd/eee cp用于复制文件或目录格式为“cp [选项] 源文件 目标文件” 复制操作具体分为3种情况： 如果目标文件是目录，则会把源文件复制到该目录中； 如果目标文件也是普通文件，则会询问是否要覆盖它； 如果目标文件不存在，则执行正常的复制操作。 将家目录（/root目录）下的hello.c文件复制到/var/tmp目录下 12[root@localhost ~]# touch hello.c[root@localhost ~]# cp hello.c /var/tmp cp命令的参数及其作用 参数 作用 -p 保留原始文件的属性aa* -d 若对象为“链接文件”，则保留该“链接文件”的属性 -r 递归持续复制（用于目录）* -i 若目标文件存在则询问是否覆盖 -a 相当于-pdr（p、d、r为上述参数）*** mv用于剪切文件或将文件重命名格式为“mv [选项] 源文件 [目标路径|目标文件名]” 将hello.c重命名为 helloworld.c 1[root@localhost ~]# mv hello.c helloworld.c 将 helloworld.c剪切到/var/tmp目录下 1[root@localhost ~]# mv helloworld.c /var/tmp rm用于删除文件或目录格式为“rm [选项] 文件” 删除/var/tmp的hello.c文件（需要确认，敲y加回车） 1234[root@localhost ~]# cd /var/tmp[root@localhost tmp]# rm hello.crm: remove regular empty file ‘hello.c’? y[root@localhost tmp]# 不用确认（敲y加回车）直接删除helloworld.c 1[root@localhost tmp]# rm -f helloworld.c 删除家目录（/root目录）下的aaa目录（需要确认，敲y加回车） 1234[root@localhost tmp]# cd -[root@localhost ~]# rm -r aaarm: remove directory ‘aaa’? y[root@localhost ~]# 删除家目录（/root目录）下的bbb目录（不需要确认，不用敲y加回车） 1[root@localhost ~]# rm -rf bbb dd用于按照指定大小和个数的数据块来复制文件或转换文件格式为“dd [参数]” 生成一个大小为128M的空文件1dd if=/dev/zero of=128M_file count=1M bs=128 可以参考以下教程： http://www.runoob.com/linux/linux-comm-dd.html 将光盘中的文件制作成为光盘镜像（.ISO）1.插入光盘到Linux系统中 2.将光盘/dev/cdrom挂载到指定的目录，检查光盘是否能读取 12345[root@localhost ~]# mkdir /mnt/cdrom[root@localhost ~]# ls /mnt/cdrom[root@localhost ~]# mount /dev/cdrom /mnt/cdrom/mount: /dev/sr0 is write-protected, mounting read-only[root@localhost ~]# ls /mnt/cdrom 3.卸载已经挂载的目录，将光盘中的内容制作成虚拟光盘（ISO镜像文件） 123456789[root@localhost ~]# umount /mnt/cdrom[root@localhost ~]# ls /mnt/cdrom[root@localhost ~]# cd ~[root@localhost ~]# lsanaconda-ks.cfg[root@localhost ~]# dd if=/dev/cdrom of=/root/CentOS.iso[root@localhost ~]# lsanaconda-ks.cfg CentOS.iso[root@localhost ~]# 如下图，看到了CentOS.iso文件，这就是制作出来的光盘镜像 意外情况： ​ 如果你到挂在目录下卸载绝对会卸载失败，因为你在他的目录下占用着，卸载肯定失败！ 12345[root@localhost ~]# cd /mnt/cdrom/[root@localhost cdrom]# umount /mnt/cdrom/umount: /mnt/cdrom: target is busy. (In some cases useful info about processes that use the device is found by lsof(8) or fuser(1)) File用于查看文件的类型格式为“file 文件名” 12345678[root@localhost ~]#[root@localhost ~]# file CentOS.isoCentOS.iso: # ISO 9660 CD-ROM filesystem data &apos;CentOS 7 x86_64&apos; (bootable)[root@localhost ~]# file /dev/cdrom/dev/cdrom: symbolic link to `sr0&apos;[root@localhost ~]# file /dev/sr0/dev/sr0: block special[root@localhost ~]# tar用于打包压缩与搜索格式为“tar [选项] [文件]” 将/root目录打包为root.tar 123[root@localhost ~]# cd ..[root@localhost /]# tar -cvf root.tar /root/[root@localhost /]# ls 将/root目录打包并且使用gzip压缩算法打包到文件/root.tar.gz中 12[root@localhost /]# tar -czvf root.tar.gz /root[root@localhost /]# ls 加压缩算法和不加压缩算法对同一个目录打包的文件大小进行对比 12[root@localhost /]# ll -h root.tar[root@localhost /]# ll -h root.tar.gz 可以看出加了压缩算法后，压出来的包明显更小更节省空间！ .tar文件的解压命令 12[root@localhost /]# rm -rf /root/*[root@localhost /]# tar -xvf root.tar .tar.gz文件的解压命令 12345[root@localhost /]# rm -rf /root/*[root@localhost /]# ls /root[root@localhost /]# tar -xzvf root.tar.gz[root@localhost /]# ls /rootaaa.txt anaconda-ks.cfg text grep用于在文本中执行关键词搜索，并显示匹配的结果格式为“grep [选项] [文件]” 匹配所有不能登录系统的用户 1[root@localhost ~]# grep nologin /etc/passwd 匹配出所有没有被注释的行，且不是空行的行 1[root@localhost ~]# grep -v &quot;^#&quot; /etc/selinux/config | grep -v &quot;^$&quot; find用于按照指定条件来查找文件格式为“find [查找路径] 寻找条件 操作” 搜索/dev目录下所有硬盘和分区设备 1[root@localhost ~]# find /dev/ -name sd* 搜索磁盘中所有.conf格式的文件 1[root@localhost ~]# find / -name *.conf 本篇到此结束，这篇文章真长QAQ]]></content>
      <categories>
        <category>linux</category>
        <category>linux-基础学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础学习-02 Linux系统介绍和安装]]></title>
    <url>%2Flinux-02%2F</url>
    <content type="text"><![CDATA[linux-基础学习-02 Linux系统介绍和安装一、安装软件，新建虚拟机 在360软件管家下载安装VMware Workstation Pro，点击创建新的虚拟机即可。现在最新版本的是VMware Workstation Pro 15版本，然而这玩意儿竟然要付费，很多人就望而却步。 其实网上还是可以搜索到许多激活密钥的，如下，任选一个即可。 1234567891011YG5H2-ANZ0H-M8ERY-TXZZZ-YKRV8UG5J2-0ME12-M89WY-NPWXX-WQH88UA5DR-2ZD4H-089FY-6YQ5T-YPRX6GA590-86Y05-4806Y-X4PEE-ZV8E0ZF582-0NW5N-H8D2P-0XZEE-Z22VAYA18K-0WY8P-H85DY-L4NZG-X7RAD ​ 创建新的虚拟机很简单，此处不再赘述，但是虚拟机处理器的内核总数必须≤物理机逻辑处理器总数。 可以在任务管理器查看到自己的物理机逻辑处理器数量： centos镜像下载地址https://www.centos.org/download/ VMware Workstation Pro快捷键Ctrl+Alt+Enter：从物理机进入到全屏的虚拟机 Ctrl+Alt：将鼠标光标从虚拟机释放出来 二、Centos开机密码破解（救援模式）第一步：重启Linux，在系统boot引导界面迅速按键e键进入boot编辑模式 第二步：找到linux16开头的行，将内容删除至ro（ro不要删），在ro后面添加空格和“rd.break” 修改为： 第三步：按ctrl+x键进入到救援模式 键入以下命令： 123456switch_root:/# mount -o remount,rw /sysrootswitch_root:/# chroot /sysrootsh-4.2# passwd root //在交互模式下输入两次密码（提示BAD PASSWORD不用管）sh-4.2# touch /.autorelabel //初学linux时，特别多的人会忘了敲这条命令或者label写错！sh-4.2# exitswitch_root:/# exit 注意：如果你的密码带有数字，登录系统的时候如果你敲的是小键盘，一定要注意小键盘有没有没被你NumLock掉！初学者容易被坑，说老是登录不上去。 PS: 意外情况1： ​ 有时候会出现乱码，用命令行改语言为english即可。 命令： 1LANG=en 意外情况2： ​ 有时候会有提示密码长度不得小于8位，不过短密码也是可以使用的，不一定非得长于8位！ 意外情况3： ​ 有时候会有提示密码是一个回文数，不过其实回文数密码也是可以使用的。 意外情况4： ​ 如果你设置的密码不是回文数，不是短密码，比如设置为123456789，它还是提醒你BAD PASSWORD 因为它太简单了，但是同上，即使简单，也是不妨碍咱们使用的。 意外情况5：​ 密码字典检查失败，密码字典内没有该词 意外情况N： ​ 至于其他意外情况诸如此类，基本套路就是BAD PASSWORD可以用但是不安全。如下图，我把上述所有种类的所谓BAD PASSWORD均尝试了一遍，都可以登录上去！ 三、远程登录Linux1.下载安装XShell或者SecureCRT，这里以XShell为例，在360软件管家就能下载到。然后根据自己的喜好设置一下XShell的颜色、字体、透明度等。 2.查看虚拟机ip地址： 1ip address 3.在windows上打开终端软件（推荐XShell或者SecureCRT）远程连接到Linux系统，输入root密码即可。 命令： 1ssh root@ip 4.建议把会话保存起来，下次再打开的时候就不用再输入命令打开了,记住在用户登录验证那里输入密码。 5.关键操作之后，一定要记得拍快照（关机之后快照） 6.意外情况： ​ 如果在虚拟机里发现有ip，但windows和虚拟机无法通信，ssh连接不上去，在虚拟机里ping一下当前的网关地址， 然后windows再ping虚拟机，就应该能通信，这时候ssh就没有问题了。 四、基本命令介绍RPM（redhat package managment）安装命令rpm软件商店：http://rpmfind.net/linux/RPM/ 安装rpm包，你需要到上述软件商店下载相应的rpm包到虚拟机里，然后用下列安装命令进行安装。但是这个听起来就很麻烦，而且很多时候安装a包往往都根据其依赖关系，要求先安装c包、d包、e包……，非常不人性化。所以yum安装命令才是主流，只有当yum命令装不了，或者说yum软件仓库里没有你要装的包时，再来考虑用rpm安装。 安装软件的命令格式 rpm -ivh filename.rpm 升级软件的命令格式 rpm -Uvh filename.rpm 卸载软件的命令格式 rpm -e filename.rpm 查询软件描述信息的命令格式 rpm -qpi filename.rpm 列出软件文件信息的命令格式 rpm -qpl filename.rpm 查询文件属于哪个RPM的命令格式 rpm -qf filename Yum （黄狗更新管理器，yellow update managment）安装代码补全工具1[root@localhost ~]# yum install bash-completion -y 安装常用工具1[root@localhost ~]# yum install vim screen unzip net-tools -y 安装扩展yum源1[root@localhost ~]# yum install epel-release -y 有时候很多包域名软件仓库里没有，可以安装扩展源，然后再次安装，就能安装成功了。 下表笔记中加星号的是目前必须掌握的 命令 作用 yum repolist all 列出所有仓库 yum list all 列出仓库中所有软件包 yum info 软件包名称 查看软件包信息 *yum install 软件包名称 安装软件包 yum reinstall 软件包名称 重新安装软件包 yum update 软件包名称 升级软件包 *yum remove 软件包名称 移除软件包 *yum clean all 清除所有仓库缓存 yum check-update 检查可更新的软件包 yum grouplist 查看系统中已经安装的软件包组 yum groupinstall 软件包组 安装指定的软件包组 yum groupremove 软件包组 移除指定的软件包组 yum groupinfo 软件包组 查询指定的软件包组信息 清理yum源缓存1yum clean all 建立yum源缓存1yum makecache 搜索软件仓库中的软件12yum search 软件名或者软件名的一部分yum list | grep 软件名或者软件名的一部分 systemctl系统管理命令重启 [root@localhost ~]# systemctl reboot [root@localhost ~]# reboot [root@localhost ~]# init 6 关机 [root@localhost ~]# systemctl poweroff [root@localhost ~]# poweroff [root@localhost ~]# init 0 参数作用：-i：安装软件install -U：升级软件update -e：卸载软件 -v：显示详细信息 -h：显示操作的进度 修改主机名1234567891011121314151617181920[root@localhost ~]# hostnamectl set-hostname test[root@localhost ~]# exit登出Connection closing...Socket close.Connection closed by foreign host.Disconnected from remote host(client) at 12:51:54.Type `help&apos; to learn how to use Xshell prompt.[C:\~]$ ssh root@192.168.141.69Connecting to 192.168.141.69:22...Connection established.To escape to local shell, press &apos;Ctrl+Alt+]&apos;.WARNING! The remote SSH server rejected X11 forwarding request.Last login: Thu Mar 7 12:37:53 2019 from 192.168.141.1[root@test ~]# 可以看到，重新登录后主机名称变成了test linux文件系统（Centos）]]></content>
      <categories>
        <category>linux</category>
        <category>linux-基础学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础学习-01 课程大纲思维导图]]></title>
    <url>%2Flinux-01%2F</url>
    <content type="text"><![CDATA[linux-基础学习-01 课程大纲思维导图课程大纲思维导图 目标：学好所有知识点，考取红帽认证（RHCE），进阶运维工程师！]]></content>
      <categories>
        <category>linux</category>
        <category>linux-基础学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO-06-coding 认证问题]]></title>
    <url>%2Fhexo-06%2F</url>
    <content type="text"><![CDATA[HEXO-06-coding 认证问题 由于coding的安全机制，它会不定时选择某一天，当你敲下hexo d时弹出一个窗口，让你输入coding的用户名和密码，万一你输错了，那么后面这个窗口直接不弹出来，然后每次你敲hexo d是都会报错，关机重启也没用，连一个给你改过的机会都不给，实在有违人道！ 但是，其实解决办法还是有的。 在控制面板打开凭据管理器 找到这个coding的凭据，点击编辑 在这里输入你的coding的用户名和密码，再次hexo d的时候就不会再报错了。 coding的用户名不是你的coding账号名，而是用户名，不要搞错了。 后来想想，每个一段时间就要这样认证一次，估计是电脑里保存的那个凭据有一定时长的有效期，到期了就得重新认证。 本篇到此结束]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO-05-博客部署]]></title>
    <url>%2Fhexo-05%2F</url>
    <content type="text"><![CDATA[HEXO-05-博客部署首先，以部署到github为例 GitHub官网: https://github.com Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。 123$ hexo deploy或者$ hexo d 在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如： 12deploy: type: git 您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。 12345deploy:- type: git repo:- type: git repo: 缩进YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。 修改配置 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 参数 描述 repo 仓库（Repository）地址 branch 分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。 message 自定义提交信息 默认为当前时间 具体步骤1.在github注册账号，登录，然后新建一个仓库，仓库名称格式：github用户名.github.io 如下图中，我的github用户名是ZhongEagles，于是我就创建了仓库：ZhongEagles.github.io 2.创建好后复制github用户名.github.io仓库的链接，至于复制链接的地方很好找，比如下面这个aaa仓库的连接如下图： 3.将复制下来的连接粘贴到Blog根目录下的_config.yml的文档底部，按ctrl+s保存，如下图： 4.在根目录git bash，敲入以下命令，将网站部署到服务器上。 123$ hexo deploy或者$ hexo d 5.部署好之后，可以看到自己本地的文件以及上传到github仓库里了 6.点击settings选项，往下找，找到GitHub Pages，点击连接即可访问你的博客网站了！ 7.同样的道理，可以部署到coding，这里不再赘述，但是一定要记得coding上新建的仓库名称和仓库地址格式： coding用户名.coding.me 否则你就需要另外配置_config.yml了，涉及到子目录操作。 8.至于如何将本地博客同时部署到github和coding，按照上述教程，写两个deployer即可。 1234567deploy:type: gitrepo:type: gitrepo:]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO-04-文章写作]]></title>
    <url>%2Fhexo-04%2F</url>
    <content type="text"><![CDATA[HEXO-04-文章写作我们之前利用命令行 1hexo new aaa 创建好了一个aaa.md的文件，而且也安装好了PicGO图床神器和Atom+Typora两款编辑器，现在咱们开始研究如何写文章。 PS：Atom+Typora虽然都是编辑器，但是Typora主要用于编辑markdown文档，而Atom主要用于编辑HEXO的相关配置文件，虽然二者角色可以互换，但是各有所长，还是各尽其能的好。 利用Atom编辑文档我们用Atom打开aaa.md进行编辑： 可以看到创建文档时就自动生成好了的文档头部：Front-matter Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： 123title: Hello Worlddate: 2013/7/13 20:46:25--- 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 分类和标签 只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 12345categories:- Diarytags:- PS3- Games 分类方法的分歧 如果您有过使用WordPress的经验，就很容易误解Hexo的分类方式。WordPress支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是Hexo不支持指定多个同级分类。下面的指定方法：categories:- Diary- Life会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分 插入本地图片本地图片统一放在source/images文件夹中例如: source/images/test.jpg 12![](/images/test.jpg)&lt;img src="/images/test.jpg"&gt; 插入网络图片12![](网络图片地址)&lt;img src="网络图片地址"&gt; 我们可以随便在文档里写一些东西，插入一个我们之前用PicGO上传到微博图床上的图片，按ctrl+s保存。 接下来我们到HEXO根目录也就是Blog文件夹下git bash 即在Blog文件夹里右键git bash here打开命令行窗口，依次敲下列命令： 命令行 注释 hexo g hexo generate的简写，生成静态文件 hexo s hexo server的简写，启动本地服务器 浏览器打开http://localhost:4000查看效果！ 利用Typora编辑文档Typora是markdown文档编辑神器，简洁的界面无需任何教学，打开就能使用。这里依然以aaa.md为例： 我们在PicGO相册里随便照一张图片，复制链接，将这个链接粘贴到用Typora打开的aaa.md文档里： 可以看到，链接粘过去直接就显示出图片来了，然鹅你讲链接粘贴到记事本、word、Atom等编辑器那是显示不出图片来的，它只是链接而已。 所以用Typora来编辑markdown文档比用Atom好，Atom还是留着专门用于编辑和修改HEXO的配置文件吧。 利用Editor.md编辑文档 接下来介绍一款开源在线 Markdown 编辑器：Editor.md 我们已经安装了Typora+PicGO+Atom三款神器了，按理来说也够用了，但是尺有所短，寸有所长，Typora简洁而且功能强大，但是Editor.md这款编辑器也具有Typora所没有的特点，那就是“在线编辑” Editor.md的网址： https://pandao.github.io/editor.md/ 在里面查看完整实例，可以找到各种段落格式标题等，如果哪天发现自己在Typora上编辑一个自己想要的文本格式却到处都找不到的如何设置时，可以到这个在线编辑网站直接找到那种格式的文本粘贴过来用。 所以，最好的搭配是Editor.md+Typora搭配使用，至于哪个用的多，就是萝卜青菜各有所爱了。 下回分解：HEXO博客部署]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO-03-写作工具准备]]></title>
    <url>%2Fhexo-03%2F</url>
    <content type="text"><![CDATA[HEXO-03-写作工具准备hexo文章支持采用markdown标记语言写作，上一节中新建的hexo文章aaa也是.md后缀的文件。 本节主要任务是准备两个写作工具：PicGo+Typora 介绍：PicGo PicGo是一款图床神器，我们平时在写markdown文档时肯定会引用很多的图片，然后这些图片是不可以直接贴上去的，我们就会通过一些网站的引用进而使用这些图片。 之前我们在调用照片的时候，先是将其上传到微博或者github等网站上，再通过该图片在网站上对应的路径地址来获取到图片。为了简化该过程，某大神将该流程写成了一套自动化应用。 简单来讲，就是把自己电脑上的本地图片放到了网络图床上，以后自己写markdown文档时，只需要将图片链接粘贴到文档里即可看到该图片了！ PicGo基本操作示例： Typora Typora是一款既接近程序员码字风格，又可以用于普通文本排版的编辑器，堪称用来写markdown文档的神器，PicGo+Typora的搭配更是绝配！ 具体步骤1.官网下载Typora： https://www.typora.io/ 2.下载安装包 https://github.com/Molunerfinn/PicGo/releases PS：如果条件允许，尽量翻墙下载，否则下载速度可能会很慢 3.安装PicGo、Typora，这个很简单，安装完成后Typora可以直接使用了，但是PicGo还需要做如下配置。 4.右键打开PicGo详细窗口，此处以微博图床为例，写好微博用户名和密码，启用使用cookie上传的功能，接下来要去找你的cookie： （1）用浏览器打开微博网址，登录上去： https://weibo.com/ （2）然后进入微博的minipublish页面，可以用浏览器输入以下网址后按F12，找到网络（network） https://weibo.com/minipublish （3）刷新页面，找到minipublish的头部（head），找到cookie，将cookie：后面的东西复制下来，注意不要将“cookie：”这个标识也复制下来了。 （4）将复制下来的内容粘贴到PicGO-&gt;微博图床设置-&gt;设定cookie那里，点击确定即可。 （5）接下来你就可以用PicGO上传图片到相册里了，PicGO里的相册指的是微博图床，而不是你的微博相册，所以不必担心图片会乱窜。 下回分解：HEXO文章写作]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO-02-文章创建]]></title>
    <url>%2Fhexo-02%2F</url>
    <content type="text"><![CDATA[HEXO-02-文章创建你可以执行下列命令来创建一篇新文章 1$ hexo new [layout] &lt;title&gt; 您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 布局（Layout） Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局 路径 post source/_posts page source draft source/_drafts 不要处理我的文章 如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false 。 文件名称Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。 变量 描述 :title 标题（小写，空格将会被替换为短杠） :year 建立的年份，比如， 2015 :month 建立的月份（有前导零），比如， 04 :i_month 建立的月份（无前导零），比如， 4 :day 建立的日期（有前导零），比如， 07 :i_day 建立的日期（无前导零），比如， 7 草稿 刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，您可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。 1$ hexo publish [layout] &lt;title&gt; 草稿默认不会显示在页面中，您可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。 模版（Scaffold）在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： 1$ hexo new photo &quot;My Gallery&quot; 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期 创建文章举例 至此，文章创建成功！ 下回分解：HEXO文章写作]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO-01-本地服务]]></title>
    <url>%2Fhexo-01%2F</url>
    <content type="text"><![CDATA[HEXO-01-本地服务参考自HEXO官网：https://hexo.io/zh-cn/ 什么是 Hexo？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 HEXO安装准备安装 Hexo 只需几分钟时间，利用git bash键入命令行即可。 安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 1$ npm install -g hexo-cli 如果您的电脑中尚未安装所需要的程序，可以参考以下安装指示完成安装。 HEXO安装教程1.下载安装旧版node.js，本次我用的是v6.9.0，下面这个网址那里有历史版本的node.js可以下载 下载地址：https://nodejs.org/dist/ 记住下载.msi后缀名的安装包即可。 PS:之所以用历史版本，是因为最新版或较新的版本会出错。 2.下载安装git和Atom（文件编辑器），二者均可在360软件管家下载，也可以在相应官网下载。 3.在D盘新建HEXO文件夹用作本地仓库，里面的东西可以使用相关命令行上传到github和coding的仓库里。 4.在Blog文件夹里右键git bash here打开命令行窗口，依次敲下列命令，执行完一条再敲下一条命令。 PS:记住用git bash安装东西最好翻个墙，那样速度会快很多。 命令行 注释 npm install hexo -g 全局安装hexo npm install hexo-cli -g 全局安装hexo-cli hexo init 新建一个网站 npm install hexo-deployer-git –save 安装hexo-deployer-git hexo generate 生成静态文件 hexo serve 启动本地服务器 5.右键如下图网址打开本地网站，先预览一下网站效果 6.也可以在浏览器手动输入网址：http://localhost:4000/ 至此，本地的HEXO安装成功！ 上图显示的是HEXO默认主题，接下来咱们可以先挑个好看的主题，主题官网：https://hexo.io/themes/ 此处以NEXT主题为例 NEXT主题安装1.进入HEXO主题官网：https://hexo.io/themes/，搜索并点击NexT，进入其github源码页面 2.下载next主题压缩包 3.将下载好的压缩包解压到themes目录下，原来的压缩包就没用了，可以删除掉 4.将解压出来的文件夹重命名为next 5.接下来修改HEXO根目录下的配置文件，其名称是_config.yml 6.初始时HEXO用的是默认主题landscape，现在将它改成next，改好后记得按ctrl+s进行保存，否则改动不会生效！ 7.接下来在Blog文件夹里右键git bash here打开命令行窗口，依次敲下列命令： 命令行 注释 hexo g hexo generate的简写，生成静态文件 hexo s hexo server的简写，启动本地服务器 8.浏览器打开http://localhost:4000可以看到主题更换成功！ 但是这个主题貌似不怎么漂亮，那是因为现在看到的只是next主题的三个样式里的其中一个默认样式，接下来到next目录下修改_config.yml配置文件，不要进错目录！ 10.将默认样式注释掉，启用Pisces样式，别忘了按ctrl+s保存，否则改动不会生效！ 11.浏览器打开http://localhost:4000可以看到主题样式更换成功！接下来可以参考网上教程美化主题，给自己加个头像等。 下回分解：HEXO文章创建]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[testmd]]></title>
    <url>%2Ftestmd%2F</url>
    <content type="text"><![CDATA[Editor.md 目录 (Table of Contents) [TOCM] [TOC] Heading 1Heading 2Heading 3Heading 4Heading 5Heading 6Heading 1 link Heading linkHeading 2 link Heading linkHeading 3 link Heading linkHeading 4 link Heading link Heading link Heading linkHeading 5 link Heading linkHeading 6 link Heading link标题（用底线的形式）Heading (underline)This is an H1This is an H2字符效果和横线等 删除线 删除线（开启识别HTML标签时）斜体字 斜体字粗体 粗体粗斜体 粗斜体 上标：X2，下标：O2 缩写(同HTML的abbr标签) 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启 The HTML specification is maintained by the W3C. 引用 Blockquotes 引用文本 Blockquotes 引用的行内混合 Blockquotes 引用：如果想要插入空白换行即&lt;br /&gt;标签，在插入处先键入两个以上的空格然后回车即可，普通链接。 锚点与链接 Links普通链接 普通链接带标题 直接链接：https://github.com 锚点链接 mailto:test.test@gmail.com GFM a-tail link @pandao 邮箱地址自动链接 test.test@gmail.com www@vip.qq.com @pandao 多语言代码高亮 Codes行内代码 Inline code执行命令：npm install marked 缩进风格即缩进四个空格，也做为实现类似 &lt;pre&gt; 预格式化文本 ( Preformatted Text ) 的功能。 &lt;?php echo &quot;Hello world!&quot;; ?&gt; 预格式化文本： | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | JS代码 123456789101112131415161718192021222324252627282930313233343536function test() &#123; console.log("Hello world!");&#125;(function()&#123; var box = function() &#123; return box.fn.init(); &#125;; box.prototype = box.fn = &#123; init : function()&#123; console.log('box.init()'); return this; &#125;, add : function(str) &#123; alert("add", str); return this; &#125;, remove : function(str) &#123; alert("remove", str); return this; &#125; &#125;; box.fn.init.prototype = box.fn; window.box =box;&#125;)();var testBox = box();testBox.add("jQuery").remove("jQuery"); HTML 代码 HTML codes1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest="utf-8" /&gt; &lt;meta name="keywords" content="Editor.md, Markdown, Editor" /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;style type="text/css"&gt; body&#123;font-size:14px;color:#444;font-family: "Microsoft Yahei", Tahoma, "Hiragino Sans GB", Arial;background:#fff;&#125; ul&#123;list-style: none;&#125; img&#123;border:none;vertical-align: middle;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class="text-xxl"&gt;Hello world!&lt;/h1&gt; &lt;p class="text-green"&gt;Plain text&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 图片 ImagesImage: Follow your heart. 图为：厦门白城沙滩 图片加链接 (Image + Link)： 图为：李健首张专辑《似水流年》封面 列表 Lists无序列表（减号）Unordered Lists (-) 列表一 列表二 列表三 无序列表（星号）Unordered Lists (*) 列表一 列表二 列表三 无序列表（加号和嵌套）Unordered Lists (+) 列表一 列表二 列表二-1 列表二-2 列表二-3 列表三 列表一 列表二 列表三 有序列表 Ordered Lists (-) 第一行 第二行 第三行 GFM task list GFM task list 1 GFM task list 2 GFM task list 3 GFM task list 3-1 GFM task list 3-2 GFM task list 3-3 GFM task list 4 GFM task list 4-1 GFM task list 4-2 绘制表格 Tables 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 First Header Second Header Content Cell Content Cell Content Cell Content Cell First Header Second Header Content Cell Content Cell Content Cell Content Cell Function name Description help() Display the help window. destroy() Destroy your computer! Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 Item Value Computer $1600 Phone $12 Pipe $1 特殊符号 HTML Entities Codes&copy; &amp; &uml; &trade; &iexcl; &pound;&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot; X&sup2; Y&sup3; &frac34; &frac14; &times; &divide; &raquo; 18&ordm;C &quot; &apos; [========] Emoji表情 :smiley: Blockquotes :star: GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x: :smiley: @mentions, :smiley: #refs, links, formatting, and tags supported :editormd-logo:; list syntax required (any unordered or ordered list supported) :editormd-logo-3x:; [ ] :smiley: this is a complete item :smiley:; []this is an incomplete item test link :fa-star: @pandao; [ ]this is an incomplete item :fa-star: :fa-gear:; :smiley: this is an incomplete item test link :fa-star: :fa-gear:; :smiley: this is :fa-star: :fa-gear: an incomplete item test link; 反斜杠 Escape*literal asterisks* [========] 科学公式 TeX(KaTeX)$$E=mc^2$$ 行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。 $$x &gt; y$$ $$(\sqrt{3x-1}+(1+x)^2)$$ $$\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))$$ 多行公式： 12345\displaystyle\left( \sum\_&#123;k=1&#125;^n a\_k b\_k \right)^2\leq\left( \sum\_&#123;k=1&#125;^n a\_k^2 \right)\left( \sum\_&#123;k=1&#125;^n b\_k^2 \right) 123456789\displaystyle \frac&#123;1&#125;&#123; \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123; \frac25 \pi&#125;&#125; = 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123; 1+\frac&#123;e^&#123;-6\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125; &#123;1+\cdots&#125; &#125; &#125; &#125; 123f(x) = \int_&#123;-\infty&#125;^\infty \hat f(\xi)\,e^&#123;2 \pi i \xi x&#125; \,d\xi 分页符 Page break Print Test: Ctrl + P [========] 绘制流程图 Flowchart12345678st=&gt;start: 用户登陆op=&gt;operation: 登陆操作cond=&gt;condition: 登陆成功 Yes or No?e=&gt;end: 进入后台st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op [========] 绘制序列图 Sequence Diagram1234Andrew-&gt;China: Says HelloNote right of China: China thinks\nabout itChina--&gt;Andrew: How are you?Andrew-&gt;&gt;China: I am good thanks! End]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo!参考教程：documentation参考教程：troubleshooting参考教程：GitHub. 新建文章：1$ hexo new "文章标题" 参考教程: Writing 运行本地服务1$ hexo server 参考教程: Server 生成静态文件1$ hexo generate 参考教程: Generating 部署到远程站点1$ hexo deploy 参考教程: Deployment]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>helloworld</tag>
      </tags>
  </entry>
</search>
