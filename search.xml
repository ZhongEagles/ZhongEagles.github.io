<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[crawler-10 淘宝商品比价定向爬虫]]></title>
    <url>%2Fcrawler-10%2F</url>
    <content type="text"><![CDATA[crawler-10 淘宝商品比价定向爬虫1、目标网站：淘宝网1https://s.taobao.com/ 2、查看robots协议1234567891011https://s.taobao.com/robots.txt#结果User-agent: *Disallow: /#含义禁止任何爬虫爬取所有内容#注意类人行为可以不遵守robots协议，因此这里探讨技术实现可以爬取，但请不要不加限制地爬取该网站 3、注意 这个例子仅探讨技术实现，请不要不加限制的爬取该网！ 4、功能描述1）目标：获取淘宝搜索页面的信息，提取其中的商品名称和价格 2）理解： 淘宝的搜索接口 3）难点：翻页的处理 4）技术路线：requests‐re 5、浏览网站 1）登录之后，在淘宝网搜索“书包”，在结果页面进行翻页，观察网址变化。 12345678#起始页https://s.taobao.com/search?initiative_id=staobaoz_20200119&amp;q=书包#第二页https://s.taobao.com/search?initiative_id=staobaoz_20200119&amp;q=书包&amp;bcoffset=3&amp;ntoffset=3&amp;p4ppushleft=1%2C48&amp;s=44#第三页https://s.taobao.com/search?initiative_id=staobaoz_20200119&amp;q=书包&amp;bcoffset=0&amp;ntoffset=6&amp;p4ppushleft=1%2C48&amp;s=88 2）结果分析 12345678#搜索接口https://s.taobao.com/search?initiative_id=staobaoz_20200119&amp;q=舍弃无关紧要的参数，将接口简化为：https://s.taobao.com/search?q=#翻页的URL对应属性s=44s=88这里可以数一下，淘宝每页书包商品数量恰好是44个，这个s变量表示的是某一页的起始商品的编号 5、程序的结构设计1）提交商品搜索请求，循环获取页面：getHtmlText(url)； 2）对于每个页面，提取商品名称和价格信息：parsePage(ilt,html)； 3）将信息输出到屏幕上：printGoodsList(ilt)； 6、程序实例编写1）程序框架 按照上一步骤中设计好的程序结构，先将程序整体的框架搭建起来，更利于我们有一个清晰的思路来编写代码。此程序整体思路就是，循环获取多个页面的信息，保存到 ilt 列表中，最后将该列表打印。 123456789101112131415161718192021222324252627282930313233343536import requestsimport redef getHtmlText(url): try: r=requests.get(url=url,timeout=30) r.raise_for_status() r.encoding=r.apparent_encoding return r.text except: print(&quot;&quot;)def parsePage(ilt,html): print(&quot;&quot;)def printGoodsList(ilt): print(&quot;&quot;)def main(): goods=&quot;书包&quot; depth=3 #页面深度 start_url=&apos;https://s.taobao.com/search?q=&apos; + goods infoList=[] for i in range(depth): try: url=start_url+&apos;&amp;s=&apos;+str(44*i) #针对每个页面构建其url html=getHtmlText(url) parsePage(infoList,html) except: continue #某一页面爬取异常，不会影响其他页面 printGoodsList(infoList)if __name__ == &apos;__main__&apos;: main() 备注 1234#这里的变量命名ilt：info_listplt：price_listtlt：title_list 2）具体实现a）右键查看网页源代码，如下图，有一款书包价格为149.00，那么可以直接搜索149.00； b）可以看到，价格信息保存在一个view_price键值对里面； c）接下来检索商品名称，同样可以看到商品标题名称保存在raw_title键值对里面。 d）用正则表达式提所需信息 123456789#所需信息在网页源码里面的体现如下&quot;view_price&quot;:&quot;149.00&quot;&quot;raw_title&quot;:&quot;小米双肩包简约休闲多功能书包男女笔记本电脑包时尚潮流旅行背包&quot;在正则表达式的原生字符串表示下，上述字符串的双引号和冒号以及点号都需要转义，不然例如点号在正则表达式里表示任意单个字符，就会证乱套了。因此，上述信息在正则表达式中的体现如下：r&apos;\&quot;view_price\&quot;\:\&quot;149\.00\&quot;&apos;r&apos;\&quot;raw_title\&quot;\:\&quot;小米双肩包简约休闲多功能书包男女笔记本电脑包时尚潮流旅行背包\&quot;&apos; 价格数值匹配举例： 12345678910import rels=re.findall(r&apos;price\:[\d\.]*&apos;,&apos;time:2019 time:2018 time:2017 price:11.2 price:22.3 price:55.5.2.3&apos;)print(ls)#运行结果[&apos;price:11.2&apos;, &apos;price:22.3&apos;, &apos;price:55.5.2.3&apos;]#分析[\d\.]*的含义是：[单个数字或者小数点]前一个字符0次或无限次扩展意思就是对数字或者小数点的无限扩展，因此可以匹配带小数点的这些价格数值 标题匹配举例 12345678910import rels = re.findall(r&apos;\&quot;raw_title\:.*?\&quot;&apos;,&apos;&quot;raw_title:aaa&quot; &quot;raw_title:bbb&quot;&apos;)print(ls)#运行结果[&apos;&quot;raw_title:aaa&quot;&apos;, &apos;&quot;raw_title:bbb&quot;&apos;]#分析.*?的含义是：任意字符无限次扩展，且使用最小匹配（而不是贪婪匹配）这样即可匹配类似&quot;小米双肩包简约休闲多功能书包男女笔记本电脑包时尚潮流旅行背包&quot;这样的标题 综上，提取商品名称和价格所需的正则表达式即如下 12\&quot;view_price\&quot;\:\&quot;[\d\.]*\&quot;\&quot;raw_title\&quot;\:\&quot;.*?\&quot; e）利用eval函数去除双引号， eval() 函数用来执行一个字符串表达式，并返回表达式的值。 12345678910111213141516171819202122import rels = [&apos;&quot;view_price&quot;:&quot;149.00&quot;&apos;,&apos;&quot;view_price&quot;:&quot;145.00&quot;&apos;]print(ls)for i in range(len(ls)): print(eval(ls[i].split(&quot;:&quot;)[1])) print(ls[i].split(&quot;:&quot;)[1])#执行结果[&apos;&quot;view_price&quot;:&quot;149.00&quot;&apos;, &apos;&quot;view_price&quot;:&quot;145.00&quot;&apos;]149.00&quot;149.00&quot;145.00&quot;145.00&quot;#扩展&gt;&gt;&gt;x = 7&gt;&gt;&gt; eval( &apos;3 * x&apos; )21&gt;&gt;&gt; eval(&apos;pow(2,2)&apos;)4 f）parsePage(ilt,html)函数的实现 12345678910def parsePage(ilt,html): try: plt=re.findall(r&apos;\&quot;view_price\&quot;\:\&quot;[\d\.]*\&quot;&apos;,html) tlt=re.findall(r&apos;\&quot;raw_title\&quot;\:\&quot;.*?\&quot;&apos;,html) for i in range(len(plt)): price=eval(plt[i].split(&quot;:&quot;)[1]) title=eval(tlt[i].split(&quot;:&quot;)[1]) ilt.append([price,title]) except: print(&quot;&quot;) g）printGoodsList(ilt)函数的实现 1234567def printGoodsList(ilt): tplt=&quot;&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;&quot; #定义模板tplt,三列长度分别为4/8/16 print(tplt.format(&quot;序号&quot;,&quot;价格&quot;,&quot;商品名称&quot;)) count=0 for g in ilt: count=count+1 print(tplt.format(count,g[0],g[1])) 3）整体源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import requestsimport re def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return &quot;&quot; def parsePage(ilt, html): try: plt = re.findall(r&apos;\&quot;view_price\&quot;\:\&quot;[\d\.]*\&quot;&apos;,html) tlt = re.findall(r&apos;\&quot;raw_title\&quot;\:\&quot;.*?\&quot;&apos;,html) for i in range(len(plt)): price = eval(plt[i].split(&apos;:&apos;)[1]) title = eval(tlt[i].split(&apos;:&apos;)[1]) ilt.append([price , title]) except: print(&quot;&quot;) def printGoodsList(ilt): tplt = &quot;&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;&quot; print(tplt.format(&quot;序号&quot;, &quot;价格&quot;, &quot;商品名称&quot;)) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1])) def main(): goods = &apos;书包&apos; depth = 3 start_url = &apos;http://s.taobao.com/search?q=&apos; + goods infoList = [] for i in range(depth): try: url = start_url + &apos;&amp;s=&apos; + str(44*i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList) if __name__ == &apos;__main__&apos;: main() 7、问题与解决办法 上面的源码并不能爬取淘宝页面的商品，原因是该源码教程均是慕课网上几年前编写的，现在淘宝网做了登录验证功能，即使在浏览器上，打开淘宝网上搜索“书包”也必须要登录才能看到搜索结果。因此对于上述代码必须加以改进才能实现功能。 解决办法：暂时没有，按照网上的教程，加了cookie也没成功。]]></content>
      <categories>
        <category>python</category>
        <category>crawler</category>
        <category>Re</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>crawler</tag>
        <tag>Re</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[crawler-09 Re 正则表达式入门]]></title>
    <url>%2Fcrawler-09%2F</url>
    <content type="text"><![CDATA[crawler-09 Re 正则表达式入门一、概念 正则表达式, Regular Expression （缩写 regex），是用来简洁表达一组字符串的表达式；其特点是简洁，一 行胜千言。 正则表达式是用来简洁表达一组字符串的表达式，是一种通用的字符串表达框架。正则表达式是一种针对字符 串表达“简洁”和“特征”思想的工具 正则表达式可以用来判断某字符串的特征归属。 正则表达式在文本处理中十分常用： 表达文本类型的特征（病毒、入侵等） 同时查找或替换一组字符串 匹配字符串的全部或部分 …… 主要应用在 字符串匹配中。 二、正则表达式语法 正则表达式语法由字符和操作符构成。 1、常用操作符 操作符 说明 实例 . 表示任何单个字符 [ ] 字符集，对单个字符给出取值范围 [abc]表示a、b、c；[a-z]表示小写a到z的单个字符 [^ ] 非字符集，对单个字符给出排除范围 [^abc]表示非a或b或c的单个字符 * 前一个字符0次或无限次扩展 abc*表示ab、abc、abcc、abcccc等 + 前一个字符1次或者无限次扩展 abc+表示abc、abcc、abcccc等 ？ 前一个字符0次或1次扩展 abc?表示ab、abc \ 左右表达式任意一个 abc\ def表示abc或者def {m} 扩展前一个字符m次 ab{2}c表示abbc {m,n} 扩展前一个字符m至n次（包含n） ab{1,2}c表示abc、abbc ^ 匹配字符串的开头 ^abc表示以abc开头的字符串abc $ 匹配字符串的结尾 abc$表示已abc结尾的字符串abc ( ) 分组标记，内部只能使用 \ 操作符 (abc)表示abc，(abc\ def)表示abc、def \d 数字，等价于[0-9] \w 单词字符，等价于[A-Za-z0-9_] 2、经典正则表达式实例123456789101112131415161718192021221）由26个字母组成的字符^[A‐Za‐z]+$ 2）由26个字母和数字组成的字符串 ^[A‐Za‐z0‐9]+$3）整数形式的字符串^‐?\d+$ 4）正整数形式的字符串 ^[0‐9]*[1‐9][0‐9]*$ 5）中国境内邮政编码，6位#意思是邮政编码的首位一定是1-9而不是0；后5位则是任意数字[1‐9]\d&#123;5&#125; 6）匹配中文字符 [\u4e00‐\u9fa5] 7）国内电话号码，010‐68913536#电话号有两种格式，另一种是0397-2865666这种格式\d&#123;3&#125;‐\d&#123;8&#125;|\d&#123;4&#125;‐\d&#123;7&#125; 3、匹配ip地址的正则表达式12345678910111）粗略写法\d+.\d+.\d+.\d+ 2）精确写法\d&#123;1,3&#125;.\d&#123;1,3&#125;.\d&#123;1,3&#125;.\d&#123;1,3&#125;3）精确写法0‐99：[1‐9]?\d 100‐199: 1\d&#123;2&#125; 200‐249: 2[0‐4]\d 250‐255: 25[0‐5] Re库的基本使用 Re库是Python的标准库，主要用于字符串匹配；调用方式： 1import re 1、正则表达式的表示类型1）raw string类型（原生字符串类型） ；re库采用raw string类型表示正则表达式，表示为： r’text’ 例如： 12r&apos;[1‐9]\d&#123;5&#125;&apos; r&apos;\d&#123;3&#125;‐\d&#123;8&#125;|\d&#123;4&#125;‐\d&#123;7&#125;&apos; 注意：raw string是不包含对转义符再次转义的字符串。 2）string类型（字符串类型）；例如： 12&apos;[1‐9]\\d&#123;5&#125;&apos; &apos;\\d&#123;3&#125;‐\\d&#123;8&#125;|\\d&#123;4&#125;‐\\d&#123;7&#125;&apos; 建议：当正则表达式包含转义符时，应该使用raw string，否则会很繁琐。 Re库主要功能函数 函数 说明 re.search() 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 re.match 从一个字符串的开始位置起匹配正则表达式，返回match对象 re.findall() 搜索字符串，以列表类型返回全部能匹配的子串 re.split() 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型 re.finditer() 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 re.sub() 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 1、re.search()12345re.search(pattern,string,flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示 ∙ string : 待匹配字符串 ∙ flags : 正则表达式使用时的控制标记 1）flags : 正则表达式使用时的控制标 常用标记 说明 re.I re.IGNORECASE 忽略正则表达式的大小写，[A‐Z]能够匹配小写字符 re.M re.MULTILINE 正则表达式中的^操作符能够将给定字符串的每行当作匹配开始 re.S re.DOTALL 正则表达式中的.操作符能够匹配所有字符，默认匹配除换行外的所有字符 2）实例 12345678#在字符串&apos;abcd 212000&apos;中匹配出邮编import rematch=re.search(r&apos;[1-9]\d&#123;5&#125;&apos;,&apos;abcd 212000&apos;)if match: print(match.group(0)) #match对象通常用group()函数来提取数据#输出212000 2、re.match12345re.match(pattern,string,flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示 ∙ string : 待匹配字符串 ∙ flags : 正则表达式使用时的控制标记 1） flags和re.search()里的一样，其他参数也一样 2）实例 12345678910import rematch=re.match(r&apos;[1-9]\d&#123;5&#125;&apos;,&apos;abcd 212000&apos;)if match: print(match.group(0))print(match.group(0))#执行结果AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;报错，说是没有这个类型，实际上match这个变量是空的，空变量自然不能调用group。match是空的，原因是re.match函数是从起始位置开始匹配，起始位置是abcd而不是邮编，所以匹配无结果，返回的值便是空的。 3）实例 12345678#判断字符串&apos;212000 abcdefg&apos;的起始位置是否为邮编import rematch=re.match(r&apos;[1-9]\d&#123;5&#125;&apos;,&apos;212000 abcdefg&apos;)if match: print(match.group(0))#输出212000 3、re.findall()12345re.findall(pattern,string,flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示 ∙ string : 待匹配字符串 ∙ flags : 正则表达式使用时的控制标记 1）实例 123456import rels=re.findall(r&apos;[1-9]\d&#123;5&#125;&apos;,&apos;212000abcdefg 202222abc&apos;)print(ls)#输出[&apos;212000&apos;, &apos;202222&apos;] 4、re.split()123456re.split(pattern,string,maxsplit=0,flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示 ∙ string : 待匹配字符串 ∙ maxsplit: 大分割数，剩余部分作为后一个元素输出 ∙ flags : 正则表达式使用时的控制标记 1）实例 123456789import reprint(re.split(r&apos;[1-9]\d&#123;5&#125;&apos;,&apos;212000abcdefg 202222abc&apos;))print(&quot;===================================&quot;)print(re.split(r&apos;[1-9]\d&#123;5&#125;&apos;,&apos;2120#输出[&apos;&apos;, &apos;abcdefg &apos;, &apos;abc&apos;]===================================[&apos;&apos;, &apos;abcdefg 202222abc&apos;] 5、re.finditer()12345re.finditer(pattern,string,flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示 ∙ string : 待匹配字符串 ∙ flags : 正则表达式使用时的控制标记 1）实例 123456789#用for循环可以迭代地获取结果import refor m in re.finditer(r&apos;[1-9]\d&#123;5&#125;&apos;,&apos;212000abcdefg 202222abc&apos;): if m: print(m.group(0))#输出212000202222 6、re.sub()1234567re.sub(pattern,repl, string,count=0,flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示 ∙ repl: 替换匹配字符串的字符串 ∙ string : 待匹配字符串 ∙ count : 匹配的大替换次数 ∙ flags : 正则表达式使用时的控制标记 1）实例 12345import reprint(re.sub(r&apos;[1-9]\d&#123;5&#125;&apos;,&apos;pppppp&apos;,&apos;212000abcdefg 202222abc&apos;))#结果ppppppabcdefg ppppppabc Re库的另一种等价用法 Re库的上述用法是函数式用法，例如：rst=re.search(r’[1-9]\d{5}’,’abcd 212000’)，这里的r’[1-9]\d{5}’只是正则表达式通俗的表示（可以用字符串类型或者原生字符串类型），它需要通过编译之后，才能成为python认可的真正意义上的正则表达式。 因此，上述Re库的函数式用法，实际上是一次性操作，即用到一次Re库就编译一次，如果需要多次使用，那么这样效率也比较低。 Re库的另一种等价用法是：面向对象用法，是先把字符串或者原生字符串编译成正则表达式类型的pattern对象，然后进行多次操作。这种方式的好处是，一次编译，多次使用，可以加速程序运行。 1、re.compile()函数 将正则表达式的字符串形式编译成正则表达式对象。 1234regex = re.compile(pattern,flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示 ∙ flags : 正则表达式使用时的控制标记 2、实例： 1234567import repat=re.compile(r&apos;[1-9]\d&#123;5&#125;&apos;)rst=pat.search(&apos;abcd 212000&apos;) #使用时就无需再加pattern参数了print(rst.group(0))#输出212000 Re库的match对象 Match对象是一次匹配的结果，包含匹配的很多信息，这些信息可以用match对象直接调用出来，例如其属性、函数等。 1、实例123456789import rematch=re.search(r&apos;[1-9]\d&#123;5&#125;&apos;,&apos;abcd 100085&apos;)if match: print(match.group(0))print(type(match))#输出100085&lt;class &apos;re.Match&apos;&gt; 2、match对象的属性 属性 说明 .string 待匹配的文本 .re 匹配时使用的patter对象（正则表达式） .pos 正则表达式搜索文本的开始位置 .endpos 正则表达式搜索文本的结束位置 3、match对象的方法 方法 说明 .group(0) 获得匹配后的字符串 .start() 匹配字符串在原始字符串的开始位置（下标） .end() 匹配字符串在原始字符串的结束位置（下标） .span() 返回(.start(), .end()) 4、综合实例12345678910111213141516171819202122import rem=re.search(r&apos;[1-9]\d&#123;5&#125;&apos;,&apos;abcd212000 efgh212003&apos;)print(&quot;m.string: &quot;,m.string)print(&quot;m.re: &quot;,m.re)print(&quot;m.pos: &quot;,m.pos)print(&quot;m.endpos: &quot;,m.endpos)print(&quot;m.group(0): &quot;,m.group(0))print(&quot;m.start(): &quot;,m.start())print(&quot;m.end(): &quot;,m.end())print(&quot;m.span(): &quot;,m.span())#运行结果m.string: abcd212000 efgh212003m.re: re.compile(&apos;[1-9]\\d&#123;5&#125;&apos;) #程序认为经过compile编译过的才是正则表达式m.pos: 0m.endpos: 21m.group(0): 212000 #search()函数只匹配一个结果，finditer()函数可以返回所有结果m.start(): 4m.end(): 10m.span(): (4, 10) Re库的贪婪匹配和最小匹配1、实例123456import rematch=re.search(r&apos;PY.*N&apos;,&apos;PYANBNCNDN&apos;)print(match.group(0))#输出PYANBNCNDN 如上，此情况下，PY.*N可以匹配PYAN，也可以匹配’PYANBN或者PYANBNCN或者PYANBNCNDN，那么究竟会匹配到哪个呢？答案是PYANBNCNDN。 Re库默认采用贪婪匹配，即输出匹配长的子串。 2、如何使用最小匹配 上例中，如何输出短的子串呢？ 123456import rematch=re.search(r&apos;PY.*?N&apos;,&apos;PYANBNCNDN&apos;)print(match.group(0))#输出PYAN 3、最小匹配操作符 操作符 说明 *? 前一个字符0次或无限次扩展，最小匹配 +? 前一个字符1次或无限次扩展，最小匹配 ?? 前一个字符0次或1次扩展，最小匹配 {m,n}? 扩展前一个字符m至n次（含n），最小匹配 只要长度输出可能不同的，都可以通过在操作符后增加问号?变成最小匹配。 Re库总结]]></content>
      <categories>
        <category>python</category>
        <category>crawler</category>
        <category>Re</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>crawler</tag>
        <tag>Re</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[crawler-08 中国大学排名定向爬虫]]></title>
    <url>%2Fcrawler-08%2F</url>
    <content type="text"><![CDATA[crawler-08 中国大学排名定向爬虫 有人的地方就有江湖，有大学的地方就有排名，这里以最好大学网为例，爬取其中的大学排名情况。 1、项目简介1）网址：http://www.zuihaodaxue.com/Greater_China_Ranking2019_0.html2 2）robots协议：http://www.zuihaodaxue.com/robots.txt 如下图，该网站根目录下没有robots.txt，默认任意爬虫可以无限制地对该网站进行爬取。 2、功能描述1）输入：大学排名URL链接； 2）输出：大学排名信息的屏幕输出（排名，大学名称，总分）； 3）技术路线：requests‐bs4； 4）定向爬虫：仅对输入URL进行爬取，不扩展爬取其他url； 3、项目准备1）可行性分析（法律角度） 该网站根目录下没有robots.txt，默认任意爬虫可以无限制地对该网站进行爬取。 2）可行性分析（技术角度） 需要分析一下，我们要爬取的信息是否都写在了HTML页面之中，因为有一部分数据，可能是通过javascript等脚本语言生成的，即动态网页。动态网页有一部分数据是动态生成和提取的，在这种情况下，用requests‐bs4两个库，是无法获取其动态信息的。 如下图，通过浏览器查看网页源代码，可以看到如下图，所需数据均可以查看到。 如下图，在这个页面查找“香港大学”，将这一行html代码复制下来进行查看。 复制下来的代码如下，每一个 tr 标签索引着一段信息，每一段信息对应一所大学；在每段信息中，每一个 td 标签里，分别存放着我们需要提取的“ 排名，大学名称，总分 ” 这些信息。 123456&lt;tbody&gt; &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td class=&quot;align-left&quot;&gt;&lt;a target=&quot;_blank&quot;href=&quot;World-University-Rankings/Tsinghua-University.html&quot;&gt;&lt;div align=&quot;left&quot;&gt;清华大学（北京）&lt;/div&gt;&lt;/a&gt;&lt;/td&gt;&lt;td&gt;大陆&lt;/td&gt;&lt;td&gt;100&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;87.9&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;7.4&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;55.6&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;87.9&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;56.9&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;44.4&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;21.6&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td class=&quot;align-left&quot;&gt;&lt;a target=&quot;_blank&quot;href=&quot;World-University-Rankings/Peking-University.html&quot;&gt;&lt;div align=&quot;left&quot;&gt;北京大学&lt;/div&gt;&lt;/a&gt;&lt;/td&gt;&lt;td&gt;大陆&lt;/td&gt;&lt;td&gt;80.5&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;81.4&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;10.2&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;54.3&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;77.0&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;55.4&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;55.6&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;29.2&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td class=&quot;align-left&quot;&gt;&lt;a target=&quot;_blank&quot;href=&quot;World-University-Rankings/The-Chinese-University-of-Hong-Kong.html&quot;&gt;&lt;div align=&quot;left&quot;&gt;香港中文大学&lt;/div&gt;&lt;/a&gt;&lt;/td&gt;&lt;td&gt;香港&lt;/td&gt;&lt;td&gt;71.0&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;20.3&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;28.2&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;44.1&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;44.0&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;100&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;0.0&lt;/td&gt;&lt;td class=&quot;hidden-xs&quot;&gt;0.0&lt;/td&gt;&lt;/tr&gt; 略。。。。。。 &lt;/tbody&gt; 4、程序的结构设计1）从网络上获取大学排名网页内容；自定义getHTMLText()方法。 获取内容，用get() 方法即可，加上一个通用代码框架，如下。 12345678def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return &quot;&quot; 2）提取网页内容中信息到合适的数据结构；自定义fillUnivList()方法。 将getHTMLText() 方法得到的html页面，提取相关信息存放入一个ulist列表之中；注意这个函数除了from bs4 import BeautifulSoup类以外，还需要import bs4库，因为要使用其对应的标签类型定义。 isinstance函数检测 tr 标签的类型，如果不是bs4.element.Tag类型，则过滤掉； ulist.append()函数增加了ulist列表的字段：“ 排名，大学名称，总分 ” 。 注意：ulist是一个二维列表；例如ulist[0]表示清华大学那一行，而ulist[0][0]表示的是那一行的第一列，即清华大学的排名“1”。 123456def fillUnivList(ulist, html): soup = BeautifulSoup(html, &quot;html.parser&quot;) for tr in soup.find(&apos;tbody&apos;).children: if isinstance(tr, bs4.element.Tag): tds = tr(&apos;td&apos;) #等价于tds = tr.find_all(&apos;td&apos;) ulist.append([tds[0].string, tds[1].string, tds[3].string]) 3）利用数据结构展示并输出结果；自定义printUnivList()方法。 将ulist列表之中之中的信息打印出来，num参数指定打印的元素数量；用format() 函数完成格式化输出，打印表头和表内容。 12345def printUnivList(ulist, num): print(&quot;&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;&quot;.format(&quot;排名&quot;, &quot;学校名称&quot;, &quot;总分&quot;)) for i in range(num): u = ulist[i] print(&quot;&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;&quot;.format(u[0], u[1], u[2])) 4）总结： 为什么称函数为接口？例如getHTMLText(url) 函数，一头接入url，另一头接出爬取下来的网页内容，看起来就像一个方便好用的转换接头一样； 因此，将函数称为接口，是最形象的比喻； 正如上面的三个函数，一环套一环，一个接口接着另外一个接口，各司其职完成整个程序的功能运行，是最基础的编程思想。 5、程序源代码1）原始代码 此代码已经实现了预期功能，但是大学名称各有长短，导致看起来并不整齐美观，源码如下。 1234567891011121314151617181920212223242526272829303132333435# CrawUnivRankingA.pyimport requestsfrom bs4 import BeautifulSoupimport bs4def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return &quot;&quot;def fillUnivList(ulist, html): soup = BeautifulSoup(html, &quot;html.parser&quot;) for tr in soup.find(&apos;tbody&apos;).children: if isinstance(tr, bs4.element.Tag): tds = tr(&apos;td&apos;) ulist.append([tds[0].string, tds[1].string, tds[3].string])def printUnivList(ulist, num): print(&quot;&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;&quot;.format(&quot;排名&quot;, &quot;学校名称&quot;, &quot;总分&quot;)) for i in range(num): u = ulist[i] print(&quot;&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;&quot;.format(u[0], u[1], u[2]))def main(): uinfo = [] url = &apos;http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html&apos; html = getHTMLText(url) fillUnivList(uinfo, html) printUnivList(uinfo, 20) # 20 univsmain() 运行结果： 2）优化后的代码 问题分析：当中文字符宽度不够时，默认采用西文字符填充；然而中西文字符占用宽度不同，导致第二列不能对齐。下面的代码利用format函数采用中文字符的空格进行填充，解决了第二列的对齐问题。 format() 函数参数定义： 由其填充、宽度定义可知对齐问题的原因。 12345678910#采用中文字符的空格填充，参数如下chr(12288)#修改后的函数如下def printUnivList(ulist, num): tplt = &quot;&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;&quot; #生成输出模板的变量 print(tplt.format(&quot;排名&quot;, &quot;学校名称&quot;, &quot;总分&quot;, chr(12288))) for i in range(num): u = ulist[i] print(tplt.format(u[0], u[1], u[2], chr(12288))) 注意事项：类似上例，对中英文混排输出问题进行优化，是爬虫之中经常要用到的手段，需要熟练掌握 源码： 123456789101112131415161718192021222324252627282930313233343536# CrawUnivRankingB.pyimport requestsfrom bs4 import BeautifulSoupimport bs4def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return &quot;&quot;def fillUnivList(ulist, html): soup = BeautifulSoup(html, &quot;html.parser&quot;) for tr in soup.find(&apos;tbody&apos;).children: if isinstance(tr, bs4.element.Tag): tds = tr(&apos;td&apos;) ulist.append([tds[0].string, tds[1].string, tds[3].string])def printUnivList(ulist, num): tplt = &quot;&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;&quot; print(tplt.format(&quot;排名&quot;, &quot;学校名称&quot;, &quot;总分&quot;, chr(12288))) for i in range(num): u = ulist[i] print(tplt.format(u[0], u[1], u[2], chr(12288)))def main(): uinfo = [] url = &apos;http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html&apos; html = getHTMLText(url) fillUnivList(uinfo, html) printUnivList(uinfo, 20) # 20 univsmain() 运行结果：]]></content>
      <categories>
        <category>python</category>
        <category>crawler</category>
        <category>requests-bs4</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>crawler</tag>
        <tag>requests-bs4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[crawler-07 信息标记与提取方法]]></title>
    <url>%2Fcrawler-07%2F</url>
    <content type="text"><![CDATA[crawler-07 信息标记与提取方法一、信息标记 信息标记，有利于程序对信息的读取，也有利于人对信息的理解。 二、信息标记的三种形式1、XML 扩展标记语言，eXtensibleMarkup Language，采取以标签为主来构建信息、表达信息的形式。先有了HTML，后有XML，二者很相像。 12345#空元素的缩写形式&lt;imgsrc=“china.jpg” size=“10” /&gt;#注释书写形式&lt;!‐‐Thisisacomment, very useful ‐‐&gt; 实例 12345678910&lt;person&gt; &lt;firstName&gt;Tian&lt;/firstName&gt; &lt;lastName&gt;Song&lt;/lastName&gt; &lt;address&gt; &lt;streetAddr&gt;中关村南大街5号&lt;/streetAddr&gt; &lt;city&gt;北京市&lt;/city&gt; &lt;zipcode&gt;100081&lt;/zipcode&gt; &lt;/address&gt; &lt;prof&gt;Computer System&lt;/prof&gt;&lt;prof&gt;Security&lt;/prof&gt; &lt;/person&gt; 2、JSON javaScript中，面向对象的信息表达形式，JavsScript Object Notation，使用有类型的键值对 key:value 。 1234567891011#键值对嵌套用&#123;,&#125;“name” :&#123; “newName” :“北京理工大学”， “oldName” : “延安自然科学院” &#125; #若value含有多个信息，用方括号[]#若需要嵌套键值对，用花括号&#123;&#125;“key” :“value” “key” :[“value1”,“value2”] “key” : &#123;“subkey”:“subvalue”&#125; 实例 123456789&#123; “firstName” :“Tian”, “lastName” :“Song”, “address” : &#123; “streetAddr” :“中关村南大街5号”, “city” :“北京市”, “zipcode” :“100081” &#125; , “prof” :[ “Computer System” ,“Security” ]&#125; 3、YAML YAML不是一个标记语言，YAML Ain’t Markup Language，使用无类型键值对 key:value，对缩进有严格要求。 1234567891011121314#以缩进表达所属关系name: newName:北京理工大学 oldName:延安自然科学院 #用符号 ‐ 表达并列关系name: ‐北京理工大学 ‐延安自然科学院 #用符号 | 表达整块数据，用符号 # 表示注释 text: | #学校介绍这里是一大段内容这里是一大段内容这里是一大段内容这里是一大段内容这里是一大段内容这里是一大段内容这里是一大段内容这里是一大段内容 实例 123456789firstName:Tian lastName:Song address: streetAddr:中关村南大街5号 city :北京市 zipcode:100081 prof: ‐Computer System ‐Security 4、对比1）XML ：最早的通用信息标记语言，可扩展性好，但繁琐（标签太多）；用于Internet上的信息交互与传递； 2）JSON：信息有类型，适合程序处理(js)，较XML简洁；用于移动应用云端和节点的信息通信，即程序对接口处理的地方，作为程序的一部分，但是无注释； 3）YAML：信息无类型，文本信息比例最高（最简洁），可读性好；用于各类系统的配置文件，有注释易读； 三、信息提取1、方法一：完整解析信息的标记形式，再提取关键信息 1）需要标记解析器，例如：bs4库的标签树遍历； 2）优点：信息解析准确； 3）缺点：提取过程繁琐，速度慢； 2、方法二：无视标记形式，直接搜索关键信息1）对信息的文本查找函数即可； 2）优点：提取过程简洁，速度较快； 3）缺点：提取结果准确性与信息内容相关； 3、融合方法：结合形式解析与搜索方法，提取关键信息 1）需要标记解析器及文本查找函数； 2）比前两种方法好； 3）实例：提取HTML中所有URL链接 思路： 1) 搜索到所有 a 标签； 2)解析 a 标签格式，提取href后的链接内容； 1234567&gt;&gt;&gt; for link in soup.find_all(&apos;a&apos;): print(link.get(&apos;href&apos;)) http://www.icourse163.org/course/BIT-268001http://www.icourse163.org/course/BIT-1001870001&gt;&gt;&gt; 四、基于bs4库的HTML内容查找方法1、find_all() 方法 1）第一个参数：对标签名称的检索 12345678910111213141516171819202122232425262728293031323334#查找a标签，返回的列表类型包含了所有a标签&gt;&gt;&gt; soup.find_all(&apos;a&apos;)[&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt;, &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;]#同时查找a标签和b标签，&gt;&gt;&gt; soup.find_all([&apos;a&apos;,&apos;b&apos;])[&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;, &lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt;, &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;]&gt;&gt;&gt; #打印文档中所有标签的名称&gt;&gt;&gt; for tag in soup.find_all(True): print(tag.name)htmlheadtitlebodypbpaa&gt;&gt;&gt; #只显示以b开头的标签，例如b标签、body标签等，用正则表达式即可&gt;&gt;&gt; import re&gt;&gt;&gt; for tag in soup.find_all(re.compile(&apos;b&apos;)): print(tag.name) bodyb&gt;&gt;&gt; 2）第二个参数：对标签属性值的检索字符串，可标注属性检索 12345678910111213141516171819202122#查找p标签中，包含course字符串的信息&gt;&gt;&gt; soup.find_all(&apos;p&apos;,&apos;course&apos;)[&lt;p class=&quot;course&quot;&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt; and &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;]&gt;&gt;&gt; #直接以属性值为根据，查找目标内容#查找id=link1的元素&gt;&gt;&gt; soup.find_all(id=&apos;link1&apos;)[&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt;]&gt;&gt;&gt; #精确赋值信息才能找到，否则不能&gt;&gt;&gt; soup.find_all(id=&apos;link&apos;)[]&gt;&gt;&gt; #加上正则表达式，可以模糊查找&gt;&gt;&gt; import re&gt;&gt;&gt; soup.find_all(id=re.compile(&apos;link&apos;))[&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt;, &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;]&gt;&gt;&gt; 3）第三个参数：是否对子孙全部检索，默认True 12345678#如下，说明soup根标签下的子孙节点里有a标签&gt;&gt;&gt; soup.find_all(&apos;a&apos;)[&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt;, &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;]#如下，说明soup根标签下的儿子节点里没有a标签&gt;&gt;&gt; soup.find_all(&apos;a&apos;,recursive=False)[]&gt;&gt;&gt; 4）第四个参数：对标签中字符串区域的检索字符串 123456789#精确查找&gt;&gt;&gt; soup.find_all(string=&apos;Basic Python&apos;)[&apos;Basic Python&apos;]#模糊查找&gt;&gt;&gt; import re&gt;&gt;&gt; soup.find_all(string=re.compile(&apos;Python&apos;))[&apos;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:\r\n&apos;, &apos;Basic Python&apos;, &apos;Advanced Python&apos;]&gt;&gt;&gt; 5）总结： 1234567891011121314&lt;&gt;.find_all(name,attrs,recursive, string, **kwargs) ∙name : 对标签名称的检索字符串 ∙attrs: 对标签属性值的检索字符串，可标注属性检索 ∙recursive: 是否对子孙全部检索，默认True ∙string: &lt;&gt;…&lt;/&gt;中字符串区域的检索字符串#由于find_all函数太常用了，这里就有了其简写&lt;tag&gt;(..) 等价于&lt;tag&gt;.find_all(..) soup(..) 等价于soup.find_all(..)#例如：&gt;&gt;&gt; soup(string=&apos;Basic Python&apos;)[&apos;Basic Python&apos;]&gt;&gt;&gt; 2、扩展方法]]></content>
      <categories>
        <category>python</category>
        <category>crawler</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[crawler-06 Beautiful Soup]]></title>
    <url>%2Fcrawler-06%2F</url>
    <content type="text"><![CDATA[crawler-06 Beautiful Soup一、概念引入 Beautiful Soup，也称美丽汤，可以对html、xml格式进行解析并且提取其中相关信息；Beautiful Soup可以对你所要求的各种格式进行爬取，并且进行树形解析。 原理：将目标文档当做一锅汤，然后煲制这锅汤。 二、实际使用1、安装 如果有pacharm的话，直接在settings里面的project interpreter点点点安装bs4即可；也可以通过cmd来安装，命令如下： 1pip install beautifulsoup4 2、测试 1）打开下面的链接，右键查看源代码 1https://python123.io/ws/demo.html 2）可以看到源代码的格式 3）用requests爬取这个页面源代码 可以看到打印出来的内容，连个换行都没有，所有内容挤在一起； 123456&gt;&gt;&gt; import requests&gt;&gt;&gt; url=&quot;https://python123.io/ws/demo.html&quot;&gt;&gt;&gt; r=requests.get(url)&gt;&gt;&gt; r.text&apos;&lt;html&gt;&lt;head&gt;&lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;\r\n&lt;body&gt;\r\n&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;\r\n&lt;p class=&quot;course&quot;&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:\r\n&lt;a href=&quot;http://www.icourse163.org/course/BIT-268001&quot; class=&quot;py1&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt; and &lt;a href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; class=&quot;py2&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;\r\n&lt;/body&gt;&lt;/html&gt;&apos;&gt;&gt;&gt; 4）用bs4库处理文本 尽管安装的是beautifulsoup4，但使用的时候用的是简写：bs4； 注意python对大小写很敏感，BeautifulSoup中B和S要大写； html.parser是一种对html格式的解释器； soup=BeautifulSoup(demo,”html.parser”)就熬制了一锅汤，定义了一个soup； 123456789101112&gt;&gt;&gt; demo=r.text&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; soup=BeautifulSoup(demo,&quot;html.parser&quot;)&gt;&gt;&gt; print(soup.prettify)&lt;bound method Tag.prettify of &lt;html&gt;&lt;head&gt;&lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;course&quot;&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt; and &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&gt;&gt;&gt;&gt; 可以看到打印出来的文本变得有序很多，不再是一整段； 5）BeautifulSoup的使用 12from bs4 import BeautifulSoupsoup = BeautifulSoup(&apos;&lt;p&gt;data&lt;/p&gt;&apos;,&apos;html.parser&apos;) 三、BeautifulSoup库的基本元素 Beautiful Soup库是解析、遍历、维护“标签树”的功能库；如下图，各种标签互有上下游的关系，从而组长了标签树；只要你提供的文件是标签树类型的，那么就可以用BeautifulSoup库完成解析。 12345&lt;html&gt; &lt;body&gt; &lt;p class=“title”&gt; … &lt;/p&gt; &lt;/body&gt; &lt;/html 1）Beautiful Soup库标签的理解如下图： 2）BeautifulSoup类的基本元素： 1、引用 Beautiful Soup库，也叫beautifulsoup4 或bs4 约定引用方式如下，即主要是用BeautifulSoup： 12from bs4 import BeautifulSoupimport bs4 2、理解 html文档、标签树、BeautifulSoup类三者等价；BeautifulSoup对应一个HTML/XML文档的全部内容；如下例子中，对象soup是熬制过的html文档。 12soup = BeautifulSoup(&apos;&lt;p&gt;data&lt;/p&gt;&apos;,&apos;html.parser&apos;)soup2 = BeautifulSoup(open(&quot;D://demo.html&quot;),&apos;html.parser&apos;) 3、Beautiful Soup库的解析器 解析器 使用方法 条件 bs4的HTML解析器 BeautifulSoup(mk,’html.parser’) 安装bs4库 lxml的HTML解析器 BeautifulSoup(mk,’lxml’) pip install lxml lxml的XML解析器 BeautifulSoup(mk,’xml’) pip install lxml html5lib的解析器 BeautifulSoup(mk,’html5lib’) pip install html5lib 4、打印BeautifulSoup类的基本元素 1）name和attributes元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; import requests&gt;&gt;&gt; url=&quot;https://python123.io/ws/demo.html&quot;&gt;&gt;&gt; r=requests.get(url)&gt;&gt;&gt; demo=r.text&gt;&gt;&gt; soup=BeautifulSoup(demo,&quot;html.parser&quot;)#直接打印title&gt;&gt;&gt; soup.title&lt;title&gt;This is a python demo page&lt;/title&gt;#将a标签定义为一个tag，然后打印这个tag#文本中其实有两个a标签，但是这里只能获取了第一个a标签的内容&gt;&gt;&gt; tag=soup.a&gt;&gt;&gt; tag&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt;&gt;&gt;&gt; #打印标签的名字，打印该标签父亲的名字&gt;&gt;&gt; soup.a.name&apos;a&apos;&gt;&gt;&gt; soup.a.parent.name&apos;p&apos;&gt;&gt;&gt; soup.a.parent.parent.name&apos;body&apos;&gt;&gt;&gt; #查看标签的属性&gt;&gt;&gt; tag=soup.a&gt;&gt;&gt; tag.attrs&#123;&apos;href&apos;: &apos;http://www.icourse163.org/course/BIT-268001&apos;, &apos;class&apos;: [&apos;py1&apos;], &apos;id&apos;: &apos;link1&apos;&#125;&gt;&gt;&gt; #提取属性字典某一个键值&gt;&gt;&gt; tag.attrs[&apos;class&apos;][&apos;py1&apos;]&gt;&gt;&gt; tag.attrs[&apos;href&apos;]&apos;http://www.icourse163.org/course/BIT-268001&apos;#查看标签属性的类型，如下，该标签属性是字典类型&gt;&gt;&gt; type(tag.attrs)&lt;class &apos;dict&apos;&gt;&gt;&gt;&gt; #直接查看该标签的类型&gt;&gt;&gt; type(tag)&lt;class &apos;bs4.element.Tag&apos;&gt;&gt;&gt;&gt; 2）NavigableString元素（继续使用上面的IDLE，省得重新熬汤） 就是打印标签内的字符串，如下： 1234567891011&gt;&gt;&gt; soup.a&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt;&gt;&gt;&gt; soup.a.string&apos;Basic Python&apos;#下例中，&lt;b&gt;也是p标签内的，但是没有打印，因为NavigableString元素跨越多个标签层次，只打印内容，不打印标签；&gt;&gt;&gt; soup.p&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;&gt;&gt;&gt; soup.p.string&apos;The demo python introduces several python courses.&apos;&gt;&gt;&gt; 3）Comment元素 打印注释内容，不会把&lt;!–这种尖括号的印出来； 123456789&gt;&gt;&gt; newsoup=BeautifulSoup(&quot;&lt;b&gt;&lt;!--This is a comment--&gt;&lt;/b&gt;&quot;)&gt;&gt;&gt; newsoup.b.string&apos;This is a comment&apos;#可以看到其类型，叫做bs4.element.Comment，是一种特殊类型#分析文档时，有时候会对注释进行判断，依据就是这个类型；这种情况不常用，了解即可；&gt;&gt;&gt; type(newsoup.b.string)&lt;class &apos;bs4.element.Comment&apos;&gt;&gt;&gt;&gt; 四、基于bs4库的HTML内容遍历方法1、html基本格式 2、遍历方式 3、标签树的下行遍历 属性 说明 .contents 子节点的列表，将 tag 所有儿子节点存入列表 .children 子节点的迭代类型，与.contents类似，用于循环遍历儿子节点 .descendants 子孙节点的迭代类型，包含所有子孙节点，用于循环遍历 123456789101112131415161718192021222324252627282930#准备工作&gt;&gt;&gt; import requests&gt;&gt;&gt; url=&quot;http://python123.io/ws/demo.html&quot;&gt;&gt;&gt; r=requests.get(url)&gt;&gt;&gt; demo=r.text#验证下行遍历&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; soup=BeautifulSoup(demo,&quot;html.parser&quot;)&gt;&gt;&gt; soup.head&lt;head&gt;&lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;#查看head的儿子节点，.contents返回的是列表&gt;&gt;&gt; soup.head.contents[&lt;title&gt;This is a python demo page&lt;/title&gt;]&gt;&gt;&gt; soup.body.contents[&apos;\n&apos;, &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;, &apos;\n&apos;, &lt;p class=&quot;course&quot;&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt; and &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;, &apos;\n&apos;]&gt;&gt;&gt; #查看body有几个儿子&gt;&gt;&gt; len(soup.body.contents)5&gt;&gt;&gt; #查看body的第一个儿子&gt;&gt;&gt; soup.body.contents[1]&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;&gt;&gt;&gt; 使用for循环进行遍历 1234567#遍历儿子节点for child in soup.body.children: print(child) #遍历子孙节点forchild insoup.body.descendants: print(child) 4、标签树的上行遍历 属性 说明 .parent 节点的父亲标签 .parents 节点先辈标签的迭代类型，用于循环遍历先辈节点 123456789101112131415161718192021222324252627282930313233#title标签的父亲是head标签&gt;&gt;&gt; soup.title.parent&lt;head&gt;&lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;#html标签的父亲是他自己&gt;&gt;&gt; soup.html.parent&lt;html&gt;&lt;head&gt;&lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;course&quot;&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt; and &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;#soup本身是特殊标签，其父亲为空&gt;&gt;&gt; soup.parent&gt;&gt;&gt; #遍历所有先辈节点，包括soup本身，所以要区别判断&gt;&gt;&gt; for parent in soup.a.parents: if parent is None: print(parent) else: print(parent.name) pbodyhtml[document]&gt;&gt;&gt; soup.name&apos;[document]&apos;&gt;&gt;&gt; 5、标签树的平行遍历 属性 说明 .next_sibling 返回按照HTML文本顺序的下一个平行节点标签 .previous_sibling 返回按照HTML文本顺序的上一个平行节点标签 .next_siblings 迭代类型，返回按照HTML文本顺序的后续所有平行节点标签 .previous_siblings 迭代类型，返回按照HTML文本顺序的前续所有平行节点标签 123456789#平行遍历获得的下一个节点不一定是标签类型&gt;&gt;&gt; soup.a.next_sibling&apos; and &apos;&gt;&gt;&gt; soup.a.next_sibling.next_sibling&lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;&gt;&gt;&gt; soup.a.previous_sibling&apos;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:\r\n&apos;&gt;&gt;&gt; soup.a.previous_sibling.previous_sibling&gt;&gt;&gt; 利用for循环完成平行遍历 1234567#遍历后续节点for sibling in soup.a.next_sibling: print(sibling)#遍历前续节点for sibling in soup.a.previous_sibling: print(sibling) 五、基于bs4库的HTML格式输出 如何让html页面更加“友好”地显示？“友好”既针对人，也针对程序。 1、bs4库的prettify()方法 跟右键查看网页源代码一样的格式，打印html代码； 123456789&gt;&gt;&gt; soup.prettify&lt;bound method Tag.prettify of &lt;html&gt;&lt;head&gt;&lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;course&quot;&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt; and &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&gt;&gt;&gt;&gt; 2、bs4库的编码和python3的默认编码一样，都是‘utf-8’，因此可以很方便地显示中文；如果用的是python2，那么就很鸡肋，需要无止尽地做编码转换，以下是python3： 123456&gt;&gt;&gt; soup1=BeautifulSoup(&quot;&lt;p&gt;中文&lt;/p&gt;&quot;,&quot;html.parser&quot;)&gt;&gt;&gt; soup1.p.string&apos;中文&apos;&gt;&gt;&gt; soup1.prettify&lt;bound method Tag.prettify of &lt;p&gt;中文&lt;/p&gt;&gt;&gt;&gt;&gt;]]></content>
      <categories>
        <category>python</category>
        <category>crawler</category>
        <category>Beautiful Soup</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>crawler</tag>
        <tag>Beautiful Soup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[crawler-05 网络爬虫实例]]></title>
    <url>%2Fcrawler-05%2F</url>
    <content type="text"><![CDATA[crawler-05 网络爬虫实例实例1：京东商品页面的爬取 京东商品页面简单地使用get() 方法即可爬取； 1234567891011121314151617import requestsdef jd(): url=&quot;https://item.jd.com/29045327606.html&quot; try: r=requests.get(url) r.raise_for_status() r.encoding=r.apparent_encoding print(r.text[:1000]) #打印前1000个字符 except: print(&quot;爬取失败&quot;)def main(): jd()if __name__ == &apos;__main__&apos;: main() 实例2：亚马逊商品页面的爬取1、爬取报错503，爬取出错 123456789101112&gt;&gt;&gt; import requests&gt;&gt;&gt; url=&quot;https://www.amazon.cn/dp/B01HIUTCA8/ref=sr_1_1?pf_rd_i=1478512071&amp;pf_rd_m=A1U5RCOVU0NYF2&amp;pf_rd_p=c34ba49d-561d-46bc-8df5-4e0f8ddd3dc3&amp;pf_rd_r=9X9CMNAKDR6GCBG1CZ8N&amp;pf_rd_s=merchandised-search-top-1&amp;pf_rd_t=101&amp;qid=1576290684&amp;s=gifts&amp;sr=1-1&quot;&gt;&gt;&gt; r=requests.get(url)&gt;&gt;&gt; r.status_code503&gt;&gt;&gt; r.encoding&apos;ISO-8859-1&apos;&gt;&gt;&gt; r.encoding=r.apparent_encoding&gt;&gt;&gt; r.text···&lt;h4&gt;请输入您在下方看到的字符&lt;/h4&gt;\n &lt;p class=&quot;a-last&quot;&gt;抱歉，我们只是想确认一下当前访问者并非自动程序。为了达到最佳效果，请确保您浏览器上的··· 可以看到r.text返回一些报错信息，这说明爬取出错并非网络问题，而是服务器做了网络爬虫限制；对网络爬虫限制，常见的如下： 1）来源审查：判断User‐Agent进行限制（技术层面限制） 检查来访HTTP协议头的User‐Agent域，只响应浏览器或友好爬虫的访问；2）发布公告：Robots协议（道德层面限制） 告知所有爬虫网站的爬取策略，要求爬虫遵守； 这里判断，可能是网站对User‐Agent进行了限制，下面进行验证。 2、查找出错原因 网站一般只接受有浏览器发起的请求，而对于爬虫的请求可以拒绝；如下，通过查看请求r的头部信息的User-Agent字段，可以看到我们很实在地告知亚马逊我们是一个pyhon爬虫程序而不是浏览器，因此被拒绝导致出错。 123&gt;&gt;&gt; r.request.headers&#123;&apos;User-Agent&apos;: &apos;python-requests/2.21.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Accept&apos;: &apos;*/*&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;&#125;&gt;&gt;&gt; 3、解决错误 Mozilla/5.0是一个标准的浏览器身份标识字段，可能被识别为火狐、谷歌、IE10等； 12345678&gt;&gt;&gt; kv=&#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0&apos;&#125;&gt;&gt;&gt; r=requests.get(url,headers=kv)&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; r.request.headers&#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Accept&apos;: &apos;*/*&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;&#125;&gt;&gt;&gt; r.text[:1000]&apos;&lt;!DOCTYPE html&gt;\n&lt;!--[if lt IE 7]&gt; &lt;html lang=&quot;zh-CN&quot; class=&quot;a-no-js a-lt-ie9 a-lt-ie8 a-lt-ie7&quot;&gt; &lt;![endif]--&gt;\n&lt;!--[if IE 7]&gt; &lt;html lang=&quot;zh-CN&quot; class=&quot;a-no-js a-lt-ie9 a-lt-ie8&quot;&gt; &lt;![endif]--&gt;\n&lt;!--[if IE 8]&gt; &lt;html lang=&quot;zh-CN&quot; class=&quot;a-no-js a-lt-ie9&quot;&gt; &lt;![endif]--&gt;\n&lt;!--[if gt IE 8]&gt;&lt;!--&gt;\n&lt;html class=&quot;a-no-js&quot; lang=&quot;zh-CN&quot;&gt; 4、完整代码 12345678910111213141516171819import requests#亚马逊商品网页对爬虫做了简单的限制，def amx(): url=&quot;https://www.amazon.cn/dp/B01HIUTCA8/ref=sr_1_1?pf_rd_i=1478512071&amp;pf_rd_m=A1U5RCOVU0NYF2&amp;pf_rd_p=c34ba49d-561d-46bc-8df5-4e0f8ddd3dc3&amp;pf_rd_r=9X9CMNAKDR6GCBG1CZ8N&amp;pf_rd_s=merchandised-search-top-1&amp;pf_rd_t=101&amp;qid=1576290684&amp;s=gifts&amp;sr=1-1&quot; kv=&#123;&apos;User-agent&apos;:&apos;Mozilla/5.0&apos;&#125; try: r=requests.get(url,headers=kv) r.raise_for_status() r.encoding=r.apparent_encoding print(r.text[1000:2000]) except: print(&quot;爬取失败&quot;)def main(): amx()if __name__ == &apos;__main__&apos;: main() 实例3：百度/360搜索关键字提交1、了解搜索引擎接口网址 1）百度的关键词接口： http://www.baidu.com/s?wd=keyword 2）360的关键词接口： http://www.so.com/s?q=keyword 3）如何得知接口网址： 如下图，直接百度上搜”草莓“，结果可以看到网址栏“https://www.baidu.com/s?wd=草莓”的信息，从而可以知道百度关键词接口就是该格式。 2、IDLE上进行实操 此处暂时不进行内容解析，只熟悉params参数和关键词接口的使用；360搜索的代码，只需要将wd改为q即可，其余一致。 12345678910&gt;&gt;&gt; import requests&gt;&gt;&gt; kv=&#123;&apos;wd&apos;:&apos;草莓&apos;&#125;&gt;&gt;&gt; url=&quot;http://www.baidu.com/s&quot;&gt;&gt;&gt; r=requests.get(url,params=kv)&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; r.request.url&gt;&gt;&gt; len(r.text)1469&gt;&gt;&gt; 实例4：网络图片的爬取和存储1、IDLE 实操 打开文件路飞.jpeg，定义为文件标识符f，其中r.content表示返回内容的二进制形式，利用f.write可以写入文件。 12345678910111213&gt;&gt;&gt; import requests&gt;&gt;&gt; url=&quot;https://c-ssl.duitang.com/uploads/item/201506/10/20150610095926_E5azR.thumb.700_0.jpeg&quot;&gt;&gt;&gt; path=&quot;D:/路飞.jpeg&quot;&gt;&gt;&gt; r=requests.get(url)&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; with open(path,&apos;wb&apos;) as f: f.write(r.content) 88916&gt;&gt;&gt; f.close()&gt;&gt;&gt; 2、完整代码 异常处理很重要，要考虑周全，功能实现了，不算厉害，要从工程性角度去分析，代码如何执行都不会出错，才是稳定合格的代码。 1234567891011121314151617181920212223242526import requestsimport osdef getPicture(): url = &quot;https://c-ssl.duitang.com/uploads/item/201506/10/20150610095926_E5azR.thumb.700_0.jpeg&quot; root=&quot;D://pictures//&quot; path=root+url.split(&apos;/&apos;)[-1] try: if not os.path.exists(root): #根目录不存在，就需要创建 os.mkdir(root) if not os.path.exists(path): r=requests.get(url) with open(path,&apos;wb&apos;) as f: f.write(r.content) f.close() print(&quot;文件保存成功&quot;) else: print(&quot;文件已存在&quot;) except: print(&quot;爬取失败&quot;)def main(): getPicture()if __name__ == &apos;__main__&apos;: main() 实例5：IP地址归属地的自动查询1、首先获取接口url 1）类似之前百度搜索那样，直接在网站上输入ip进行查询； 2）如下图，可以看到查询出来的接口url是： 1https://m.ip138.com/ip.asp?ip= 2、IDLE 实操 12345678910&gt;&gt;&gt; import requests&gt;&gt;&gt; url=&quot;https://m.ip138.com/ip.asp?ip=&quot;&gt;&gt;&gt; ip=&quot;202.204.80.112&quot;&gt;&gt;&gt; r=requests.get(url+ip)&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; r.text···您查询的IP：202.204.80.112&lt;/h1&gt;&lt;p class=&quot;result&quot;&gt;本站主数据：北京市海淀区 北京理工大学 教育网&lt;/p&gt;&lt;p class=&quot;result&quot;&gt;参考数据一：北京市 北京理工大学··· 3、完整代码 123456789101112131415161718import requestsdef ipFrom(): url=&quot;https://m.ip138.com/ip.asp?ip=&quot; ip = &quot;202.204.80.112&quot; try: r = requests.get(url + ip) r.raise_for_status() r.encoding=r.apparent_encoding print(r.text) except: print(&quot;爬取失败&quot;)def main(): ipFrom()if __name__ == &apos;__main__&apos;: main() 总结 以爬虫视角看待网络内容，静态页面爬取较简单，一切资源都可以看做url，只要将url构建出来，即可进行爬取。 附录 五个实例所有完整代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import requestsimport osdef jd(): url=&quot;https://item.jd.com/29045327606.html&quot; try: r=requests.get(url) r.raise_for_status() r.encoding=r.apparent_encoding print(r.text[:1000]) #打印前1000个字符 except: print(&quot;爬取失败&quot;)#亚马逊商品网页对爬虫做了简单的限制，def amx(): url=&quot;https://www.amazon.cn/dp/B01HIUTCA8/ref=sr_1_1?pf_rd_i=1478512071&amp;pf_rd_m=A1U5RCOVU0NYF2&amp;pf_rd_p=c34ba49d-561d-46bc-8df5-4e0f8ddd3dc3&amp;pf_rd_r=9X9CMNAKDR6GCBG1CZ8N&amp;pf_rd_s=merchandised-search-top-1&amp;pf_rd_t=101&amp;qid=1576290684&amp;s=gifts&amp;sr=1-1&quot; kv=&#123;&apos;User-agent&apos;:&apos;Mozilla/5.0&apos;&#125; try: r=requests.get(url,headers=kv) r.raise_for_status() r.encoding=r.apparent_encoding print(r.text[1000:2000]) except: print(&quot;爬取失败&quot;)def baidu(): url=&quot;http://www.baidu.com/s&quot; kv=&#123;&apos;wd&apos;:&apos;草莓&apos;&#125; try: r = requests.get(url, params=kv) print(r.request.url) r.raise_for_status() print(len(r.text)) except: print(&quot;爬取失败&quot;)def so360(): url=&quot; http://www.so.com/s&quot; kv=&#123;&apos;q&apos;:&apos;草莓&apos;&#125; try: r = requests.get(url, params=kv) print(r.request.url) r.raise_for_status() print(len(r.text)) except: print(&quot;爬取失败&quot;)def getPicture(): url = &quot;https://c-ssl.duitang.com/uploads/item/201506/10/20150610095926_E5azR.thumb.700_0.jpeg&quot; root=&quot;D://pictures//&quot; path=root+url.split(&apos;/&apos;)[-1] try: if not os.path.exists(root): #根目录不存在，就需要创建 os.mkdir(root) if not os.path.exists(path): r=requests.get(url) with open(path,&apos;wb&apos;) as f: f.write(r.content) f.close() print(&quot;文件保存成功&quot;) else: print(&quot;文件已存在&quot;) except: print(&quot;爬取失败&quot;)def ipFrom(): url=&quot;https://m.ip138.com/ip.asp?ip=&quot; ip = &quot;202.204.80.112&quot; try: r = requests.get(url + ip) r.raise_for_status() r.encoding=r.apparent_encoding print(r.text) except: print(&quot;爬取失败&quot;)def main(): #jd() #amx() #baidu() #so360() #getPicture() ipFrom()if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>python</category>
        <category>crawler</category>
        <category>requests</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>crawler</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[crawler-04 网络爬虫安全问题]]></title>
    <url>%2Fcrawler-04%2F</url>
    <content type="text"><![CDATA[crawler-04 网络爬虫安全问题 网络爬虫，盗亦有道。网络爬虫带来的问题很多，因此有很多反对网络爬虫的声音。 一、网络爬虫引发的问题1）性能骚扰 网站服务器默认只接受人类访问，而爬虫爬取资源的速度是人类访问资源的千百倍，消耗了大量的服务器资源。当然，如果对爬取速度和行为在代码上做限制，使得爬虫变成类人行为，即可减少和避免此类问题； 2）法律风险 服务器上的数据有产权归属，网络爬虫获取数据后牟利将带来法律风险； 3）隐私泄露 网络爬虫可能具备突破简单访问控制的能力，获得被保护数据 从而泄露个人隐私； 二、网络爬虫的尺寸 大部分的网络爬虫（&gt;90%），都是小规模爬虫，如下图。 三、网络爬虫和的限制1）来源审查：判断User‐Agent进行限制（技术层面限制） 检查来访HTTP协议头的User‐Agent域，只响应浏览器或友好爬虫的访问；2）发布公告：Robots协议（道德层面限制） 告知所有爬虫网站的爬取策略，要求爬虫遵守； 四、Robots协议 Robots协议（Robots Exclusion Standard，网络爬虫排除标准）1）作用：网站告知网络爬虫哪些页面可以抓取，哪些不行； 2）形式：在网站根目录下的robots.txt文件； 3）举例：京东的robots协议：https://www.jd.com/robots.txt 123456789101112User-agent: * Disallow: /?* Disallow: /pop/*.html Disallow: /pinpai/*.html?* User-agent: EtaoSpider Disallow: / User-agent: HuihuiSpider Disallow: / User-agent: GwdangSpider Disallow: / User-agent: WochachaSpider Disallow: / 基本语法解析： 12345678910111213141516171）*代表所有，/代表根目录 2）User-agent指明哪些爬虫；Disallow代表不允许访问的路径3）任何爬虫不允许访问根目录下以问号开头的路径；以及符合/pop/*.html的路径；以及符合/pinpai/*.html?* 的路径；User-agent: * Disallow: /?* Disallow: /pop/*.html Disallow: /pinpai/*.html?* 4）拒绝EtaoSpider网络爬虫爬取京东的任何资源；User-agent: EtaoSpider Disallow: / 5）同理，拒绝下面三个网络爬虫爬取京东的任何资源；User-agent: HuihuiSpider Disallow: / User-agent: GwdangSpider Disallow: / User-agent: WochachaSpider Disallow: / 4）其他robots协议 注意，www.qq.com和news.qq.com二者的robots协议是不一样的；同时，并不是所有网站都是有robots协议的。 12345http://www.baidu.com/robots.txthttp://news.sina.com.cn/robots.txthttp://www.qq.com/robots.txthttp://news.qq.com/robots.txthttp://www.moe.edu.cn/robots.txt（无robots协议） 5）注意事项 robots协议规定，如果一个网站不提供robots.txt文件，那么默认允许所有爬虫无限制地爬取其内容； 五、Rrobots协议的遵守方式1）网络爬虫：自动或人工识别robots.txt，再进行内容爬取； 2）约束性：Robots协议是建议但非约束性，网络爬虫可以不遵守，但存在法律风险； 3）对于任何网络爬虫，法律、道德层面上，都应该遵守Robots协议； 4）类人行为可不参考Robots协议！]]></content>
      <categories>
        <category>python</category>
        <category>crawler</category>
        <category>robots</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>crawler</tag>
        <tag>robots</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[crawler-03 requests库的request()方法]]></title>
    <url>%2Fcrawler-03%2F</url>
    <content type="text"><![CDATA[crawler-03 requests库的request()方法一、requests库的7个主要方法 二、request() 方法 requests库的request()方法是其余所有方法的基本方法，有三个参数。 123456requests.request(method,url,**kwargs)#参数说明method: 请求方式，对应get、post等7种url: 目标链接**kwargs: 控制访问的参数，共13个 1、method：请求方式 2、**kwargs的13个参数，均可选 1）params：字典或字节序列，能够增加到url中的参数，说白了就是链接的新增后缀； 例如： 1234&gt;&gt;&gt; kv=&#123;&apos;key1&apos;:&apos;value&apos;,&apos;key2&apos;:&apos;value2&apos;&#125;&gt;&gt;&gt; r=requests.request(&apos;GET&apos;,&apos;http://python123.io/ws&apos;,params=kv)&gt;&gt;&gt; print(r.url)http://python.io/ws?key1=value1&amp;key2=value2 2）data：字典，字节序列或文件对象，作为Request的内容，用于提交数据； 例如： 1234567#提交键值对数据&gt;&gt;&gt; kv=&#123;&apos;key1&apos;:&apos;value&apos;,&apos;key2&apos;:&apos;value2&apos;&#125;&gt;&gt;&gt; r=requests.request(&apos;POST&apos;,&apos;http://python123.io/ws&apos;,params=kv)#提交字符串数据&gt;&gt;&gt; body=&quot;hello&quot;&gt;&gt;&gt; r=requests.request(&apos;POST&apos;,&apos;http://python123.io/ws&apos;,params=body) 3）json：JSON格式的数据，作为Request的内容，向服务器提交； 例如： 12&gt;&gt;&gt; kv=&#123;&apos;key1&apos;:&apos;value&apos;,&apos;key2&apos;:&apos;value2&apos;&#125;&gt;&gt;&gt; r=requests.request(&apos;POST&apos;,&apos;http://python123.io/ws&apos;,json=kv) 4）headers：字典，HTTP定制头（模拟浏览器进行访问） 例如：把user-agent改为Chrome/10，模拟Chrome/10版本的浏览器。 12&gt;&gt;&gt; hd=&#123;&apos;user-agent&apos;:&apos;Chrome/10&apos;&#125;&gt;&gt;&gt; r=requests.request(&apos;POST&apos;,&apos;http://python123.io/ws&apos;,jheaders=hd) 5）cookies：字典或CpplieJar,Request中的cookie 6）auth:元祖，支持HTTP认证功能 7）files：字典类型，传输文件 例如：向某一个链接，提交某一个文件 12&gt;&gt;&gt; fs=&#123;&apos;file&apos;:open(&apos;data.xls&apos;,&apos;rb&apos;)&#125;&gt;&gt;&gt; r=requests.request(&apos;POST&apos;,&apos;http://python123.io/ws&apos;,files=fs) 8）timeout:设定超时时间，秒为单位 例如： 1&gt;&gt;&gt; r=requests.request(&apos;GET&apos;,&apos;http://www.baidu.com&apos;,timeout=10) 9）proxies:字典类型，设定访问代理服务器，可以增加登陆认证 例如：访问百度时，使用的ip就是代理服务器的ip地址，有效隐藏用户爬取时所用源ip； 123&gt;&gt;&gt; pxs=&#123;&apos;http&apos;:&apos;http://user:pass@10.10.10.1:1234&apos; &apos;https&apos;:&apos;https://10.10.10.1:4321&apos;&#125;&gt;&gt;&gt; r=requests.request(&apos;GET&apos;,&apos;http://www.baidu.com&apos;,proxies=pxs) 10）allow_redirects:True//False，默认为True，重定向开关 11）stream:True/False,默认为True,获取内容立即下载开关 12）verify:True/False,默认为True，认证SSL证书开关 13）cert：本地SSL证书路径””” 三、其余六种方法 其余六种方法都是基于request() 方法封装而成的，功能一致；但是由于不同方法有不同的常用参数，因此不常用的参数都放到了**kwargs里面。 无论是否在**kwargs里面，参数含义是一致的。 1、get() 方法 get() 方法**kwargs：12和控制访问的参数，是因为params单独拿出来了，加一起就是13个参数 1234567#完整参数requests.get(url,params=None,**kwargs)#参数解析url：目标页面链接params：额外参数，字典或者字节流格式，可选**kwargs：12和控制访问的参数，可选 2、post() 方法 12#完整参数requests.post(url,data=None,json=None,**kwargs) 3、put() 方法 12#完整参数requests.post(url,data=None,**kwargs) 4、patch()方法 1requests.patch(url,data=None,**kwargs) 5、delete()方法 1requests.delete(url,**kwargs) 6、head()方法 1requests.head(url,**kwargs) 本篇到此结束]]></content>
      <categories>
        <category>python</category>
        <category>crawler</category>
        <category>requests</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>crawler</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[crawler-02 requests库入门]]></title>
    <url>%2Fcrawler-02%2F</url>
    <content type="text"><![CDATA[crawler-02 requests库入门 requests库是python的第三方库，是目前公认的爬去网页最好的第三方库，简单简洁。 一、requests库安装使用1、requests库安装 1pip install requests 2、IDLE测试requests库 123456&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&quot;http://www.baidu.com&quot;)&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; r.encoding=&apos;utf-8&apos;&gt;&gt;&gt; r.text 可以看到百度首页的内容已被成功抓取。 3、爬取网页的通用代码框架 网页连接有风险，异常处理很重要，常见异常如下： 123#异常处理方法#能够判断返回状态码是否200r.raise_for_status #如果不是200，产生异常requests.HTTPError 通用代码框架 12345678910#爬取网页通用代码框架def getHTMLText(url): try: r=requests.get(url,timeout=30) r.raise_for_status() #如果返回状态不是200，产生异常requests.HTTPError r.encoding = r.apparent_encoding return r.text except: return &quot;产生异常&quot; 应用举例 12345678910111213141516171819import requestsdef getHTMLText(url): try: r=requests.get(url,timeout=30) r.raise_for_status() #如果返回状态不是200，产生异常requests.HTTPError r.encoding = r.apparent_encoding return r.text except: return &quot;产生异常&quot;def main(): url=&quot;http://www.baidu.com&quot; url1 = &quot;www.baidu.com&quot; print(getHTMLText(url1)) #产生异常 print(&quot;==============================&quot;) print(getHTMLText(url)) #正常返回结果if __name__ == &apos;__main__&apos;: main() 二、requests库的7个主要方法方法说明 http协议对对资源的操作 1、get() 方法 12345678910#简单使用r = requests.get(url)#完整参数requests.get(url,params=None,**kwargs)#参数解析url：目标页面链接params：额外参数，字典或者字节流格式，可选**kwargs：12和控制访问的参数，可选 1）Request：构造一个向服务器请求资源的Request对象； 2）Response：返回一个包含服务器资源的Response对象，包含了爬虫返回的内容； 3）Response对象： 123456789&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&quot;http://www.baidu.com&quot;)&gt;&gt;&gt; r.status_code200 #状态码&gt;&gt;&gt; type(r)&lt;class &apos;requests.models.Response&apos;&gt; #返回类型是一个类，类名Response&gt;&gt;&gt; r.headers #Response返回的头部信息&#123;&apos;Cache-Control&apos;: &apos;private, no-cache, no-store, proxy-revalidate, no-transform&apos;, &apos;Connection&apos;: &apos;Keep-Alive&apos;, &apos;Content-Encoding&apos;: &apos;gzip&apos;, &apos;Content-Type&apos;: &apos;text/html&apos;, &apos;Date&apos;: &apos;Mon, 09 Dec 2019 02:43:53 GMT&apos;, &apos;Last-Modified&apos;: &apos;Mon, 23 Jan 2017 13:28:12 GMT&apos;, &apos;Pragma&apos;: &apos;no-cache&apos;, &apos;Server&apos;: &apos;bfe/1.0.8.18&apos;, &apos;Set-Cookie&apos;: &apos;BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&apos;, &apos;Transfer-Encoding&apos;: &apos;chunked&apos;&#125;&gt;&gt;&gt; 4）解码 r.encoding：其编码方式是从http header中的charset字段获取的。如果header中存在charset字段，那么说明我们访问的服务器对编码方式有要求，该编码被获取回来保存在r.encoding中；如果header中不存在charset字段，则默认编码为’ISO-8859-1’，但是该编码不能解析中文。 r.apparent_encoding：不是从http header获取编码了，而是从网页内容上分析可能出现的文本编码形式，因此这种编码比r.encoding更加准确一些。 1234567891011121314&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&quot;http://www.baidu.com&quot;)&gt;&gt;&gt; r.status_code200 #状态码&gt;&gt;&gt; r.encoding&apos;ISO-8859-1&apos;&gt;&gt;&gt; r.apparent_encoding&apos;utf-8&apos;&gt;&gt;&gt; r.text#此时得到的全是英文&gt;&gt;&gt; r.encoding=r.apparent_encoding&gt;&gt;&gt; r.text#此时得到的包含了中文 如下图： 2、patch和put的区别 3、head() 方法 用少量网络流量获取网络资源的概要信息 1234567&gt;&gt;&gt; import requests&gt;&gt;&gt; r=requests.head(&apos;http://httpbin.org/get&apos;)&gt;&gt;&gt; r.headers&#123;&apos;Access-Control-Allow-Credentials&apos;: &apos;true&apos;, &apos;Access-Control-Allow-Origin&apos;: &apos;*&apos;, &apos;Content-Encoding&apos;: &apos;gzip&apos;, &apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Date&apos;: &apos;Mon, 09 Dec 2019 03:37:52 GMT&apos;, &apos;Referrer-Policy&apos;: &apos;no-referrer-when-downgrade&apos;, &apos;Server&apos;: &apos;nginx&apos;, &apos;X-Content-Type-Options&apos;: &apos;nosniff&apos;, &apos;X-Frame-Options&apos;: &apos;DENY&apos;, &apos;X-XSS-Protection&apos;: &apos;1; mode=block&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;&#125;&gt;&gt;&gt; r.text&apos;&apos;&gt;&gt;&gt; 4、post() 方法 向服务器提交新增数据，如下，字典payload保存键值对，post() 方法提交该字典。当我们向url去post一个字典或者键值对的时候，该键值对默认是保存在form表单等字段下的。 1234567891011121314151617181920212223242526&gt;&gt;&gt; import requests&gt;&gt;&gt; payload = &#123;&apos;key1&apos;: &apos;value1&apos;,&apos;key2&apos;: &apos;value2&apos;&#125;&gt;&gt;&gt; r=requests.post(&apos;http://httpbin.org/post&apos;,data=payload)&gt;&gt;&gt; print(r.text)&#123; &quot;args&quot;: &#123;&#125;, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: &#123;&#125;, &quot;form&quot;: &#123; &quot;key1&quot;: &quot;value1&quot;, #键值对保存到了表单里 &quot;key2&quot;: &quot;value2&quot; &#125;, &quot;headers&quot;: &#123; &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Length&quot;: &quot;23&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.21.0&quot; &#125;, &quot;json&quot;: null, &quot;origin&quot;: &quot;112.24.5.77, 112.24.5.77&quot;, &quot;url&quot;: &quot;https://httpbin.org/post&quot;&#125;&gt;&gt;&gt; 假如提交的不是键值对，例如下面，提交的就是普通字符串，保存到了data字段下 1234567891011121314151617181920&gt;&gt;&gt; r=requests.post(&apos;http://httpbin.org/post&apos;,data=&apos;ABC&apos;)&gt;&gt;&gt; print(r.text)&#123; &quot;args&quot;: &#123;&#125;, &quot;data&quot;: &quot;ABC&quot;, #字符串保存到了data字段下 &quot;files&quot;: &#123;&#125;, &quot;form&quot;: &#123;&#125;, &quot;headers&quot;: &#123; &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Length&quot;: &quot;3&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.21.0&quot; &#125;, &quot;json&quot;: null, &quot;origin&quot;: &quot;112.24.5.77, 112.24.5.77&quot;, &quot;url&quot;: &quot;https://httpbin.org/post&quot;&#125;&gt;&gt;&gt; 本篇到此结束]]></content>
      <categories>
        <category>python</category>
        <category>crawler</category>
        <category>requests</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>crawler</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[crawler-01 网络爬虫简介]]></title>
    <url>%2Fcrawler-01%2F</url>
    <content type="text"><![CDATA[crawler-01 网络爬虫简介一、概念引入 网络爬虫与信息提取，需要掌握定向网络数据爬取和网页解析的基本能力。“The Website is the API”，网站提供数据，我们的软件将网站当成API，即可获取想要的数据。 二、知识点1、requests库 获取网页信息，自动爬取html页面，自动提交网络请求。 2、robots协议 网络爬虫排除标准，合理合法使用爬虫。 3、beautiful soup库 解析html页面，解析相关内容。 4、项目实战 projects，多做项目才能掌握爬虫。 5、re库 正则表达式，提取页面关键信息。 6、scrapy 专业网络爬虫框架，中规模快速爬虫实现。 三、python开发工具 常用的python IDE（集成开发环境）工具包括文本工具类IDE和集成工具类IDE，各有特点，没有最好的，只有最适合自己的。 1、文本工具类IDE1）IDLE：python自带，右键.py文件选择IDLE打开即可 2）notepad++ 3）sublime text：程序员专用，第三方专用编程工具，免注册免费 4）vim &amp; emacs 5）Atom 6）Komodo Edit 2、集成工具类IDE1）pycharm：社区版免费，简单，适合复杂工程 2）wing：专业，收费，功能丰富，支持版本控制、版本同步等，适用于多人共同开发 3）pydev&amp;eclipse：原用于java，需要用户使用pydev自定义python开发环境，比较复杂 4）visual studio&amp;PTVS：需要用户使用PTVS自定义python开发环境 5）anaconda&amp;spyder：开源免费，很好用 6）canopy：收费，适用于科学计算领域应用开发 四、注意事项1、python大小写敏感；]]></content>
      <categories>
        <category>python</category>
        <category>crawler</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memcache-02 memcached命令使用]]></title>
    <url>%2Fmemcache-02%2F</url>
    <content type="text"><![CDATA[memcache-02 memcached命令使用memcached命令分类 Memcached提供了为数不多的几个命令来完成与服务器端的交互，这些命令基于memcached的协议实现。 1）存储类命令：set, add, replace, append, prepend2）获取数据类命令：get, delete, incr/decr3）统计类命令：stats, stats items, stats slabs, stats sizes4）清理命令： flush_all 存储类命令1、set1）作用 将 value(数据值) 存储在指定的 key(键)中，若该key已存在，则更新key对应的数据值。 2）语法 12345678910set key flags exptime bytes [noreply] value #第二行输入数据值#参数说明key：键值 key-value 结构中的 key，用于查找缓存值flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 3）实例 123456789101112131415161718192021222324[root@localhost ~]# telnet localhost 11211Trying ::1...Connected to localhost.Escape character is &apos;^]&apos;.^] #输入ctrl+]，回车telnet&gt; #直接回车set k 0 20 3 #设置k的数值有效期20秒，数值长度3字节（UTF-8中一个应为字母占一个字节）abc #输入数据值STORED #STORED表示保存成功get k #查找k缓存值VALUE k 0 3 #输出k所在键值对的flags 数据值长度abc #输出数据值ENDget kVALUE k 0 3abcENDget k #20秒过后再次查询，由于就会发现数据过期，就没有输出了ENDget kENDquit #退出telnetConnection closed by foreign host.[root@localhost ~]# 4）结果 12STORED：保存成功ERROR： 保存失败 5）注意事项 123456781、exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）其中，“永远”有效并非是真正意义上的永远首先，memcached默认最长有效期30天，即使设exptime为0，30天后也会失效其次，重启memcached服务会导致数据清空，数据也就不存在了2、set方法可以理解为add方法和replace方法的集合体。1）若要设置的key不存在时，则set方法与add方法的效果一致；2）若要设置的key已经存在时，则set方法与replace方法效果一样。 2、add1）作用 将 value(数据值)存储在指定的 key(键) 中，如果要设置的key不存在，则add方法与set方法的效果一致；如果要设置的key已经存在，add不会改变其值，返回 NOT_STORED（保存失败）。 2）语法 和set方法一样 3）实例 12345678910111213141516171819[root@localhost ~]# telnet localhost 11211Trying ::1...Connected to localhost.Escape character is &apos;^]&apos;.^]telnet&gt; add k1 0 30 4 testSTOREDadd k1 0 30 4ttttNOT_STOREDget k1VALUE k1 0 4test #可以看到其值不变，add不能修改已存在的key的值ENDquitConnection closed by foreign host.[root@localhost ~]# 4）结果 12STORED： 保存成功NOT_STORED ：保存失败 3、replace1）作用 替换已存在的key的value，若key不存在，则替换失败且返回NOT_STORED 2）语法 和set方法一样 3）实例 1234567891011121314151617181920212223242526[root@localhost ~]# telnet localhost 11211Trying ::1...Connected to localhost.Escape character is &apos;^]&apos;.^]telnet&gt; replace k2 0 30 3 aaaNOT_STORED #若key不存在则保存失败add k2 0 30 3 #将k2对应值设为bbbbbbSTOREDget k2VALUE k2 0 3bbbENDreplace k2 0 30 3 #将k2对应值替换为ddddddSTOREDget k2VALUE k2 0 3dddENDquitConnection closed by foreign host.[root@localhost ~]# 4）结果 12STORED： 保存成功NOT_STORED ：保存失败 4、append 命令1）作用 用于向已存在 key(键) 的 value(数据值) 后面追加数据 2）语法 和set方法一样 3）实例 12345678910111213141516171819202122[root@localhost ~]# telnet localhost 11211Trying ::1...Connected to localhost.Escape character is &apos;^]&apos;.^]telnet&gt; append k3 0 0 3aaaNOT_STORED #append尝试追加不存在的key，会提示保存失败add k3 0 0 3aaaSTOREDappend k3 0 0 3bbbSTOREDget k3VALUE k3 0 6aaabbb #追加成功ENDquitConnection closed by foreign host.[root@localhost ~]# 4）结果 123STORED： 保存成功NOT_STORED ： 保存失败，该键在 Memcached 上不存在CLIENT_ERROR：执行错误。 5、prepend1）作用 用于向已存在 key(键) 的 value(数据值) 前面追加数据 2）语法 和set方法一样 3）实例 12345678910111213141516171819202122232425[root@localhost ~]# telnet localhost 11211Trying ::1...Connected to localhost.Escape character is &apos;^]&apos;.^]telnet&gt; prepend k4 0 0 3aaaNOT_STORED #prepend尝试追加不存在的key，会提示保存失败add k4 0 0 3aaaSTOREDprepend k4 0 0 3bbbSTOREDprepend k4 0 0 3cccSTOREDget k4VALUE k4 0 9cccbbbaaa #追加成功ENDquitConnection closed by foreign host.[root@localhost ~]# 4）结果 123STORED： 保存成功NOT_STORED ： 保存失败，该键在 Memcached 上不存在CLIENT_ERROR：执行错误。 6、CAS 略 获取数据类命令（查找命令）1、get1）作用 用于获取存储在 key(键) 中的 value(数据值) ，如果 key 不存在，则返回空 2）语法 12get keyget key1 key2 key3 2、gets1）作用 用于获取带有 CAS 令牌存 的 value(数据值) ，如果 key 不存在，则返回空 2）语法 12gets keygets key1 key2 key3 3、delete1）作用 用于删除已存在的 key(键)。 2）语法 12345delete key [noreply]参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。noreply（可选）： 该参数告知服务器不需要返回数据 3）结果 123DELETED： 删除成功。ERROR： 语法错误或删除失败。NOT_FOUND：key 不存在。 4、 incr 与 decr 1）作用 用于对已存在的 key(键) 的数字值进行自增或自减操作。 2）语法 12incr key increment_value（增加的数值）decr key decrement_value（减少的数值） 3）实例（以incr为例，decr与之一样） 12345678910111213141516171819202122[root@localhost ~]# telnet localhost 11211Trying ::1...Connected to localhost.Escape character is &apos;^]&apos;.^]telnet&gt; set k6 0 0 16STOREDincr k6 1 #加一7incr k6 2 #加二9incr k6 312get k6VALUE k6 0 212ENDquitConnection closed by foreign host.[root@localhost ~]# 4）结果 123NOT_FOUND： key不存在。CLIENT_ERROR： 自增值不是对象。ERROR： 其他错误，如语法错误等。 统计类命令1、stats1）作用 用于返回统计信息例如 PID(进程号)、版本号、连接数等。 2）语法 1stats 3）实例 12345678[root@localhost ~]# telnet localhost 11211Trying ::1...Connected to localhost.Escape character is &apos;^]&apos;.^]telnet&gt; stats#略 4）结果 1234567891011121314151617181920212223242526272829303132333435363738pid： memcache服务器进程IDuptime：服务器已运行秒数time：服务器当前Unix时间戳version：memcache版本pointer_size：操作系统指针大小rusage_user：进程累计用户时间rusage_system：进程累计系统时间curr_connections：当前连接数量total_connections：Memcached运行以来连接总数connection_structures：Memcached分配的连接结构数量cmd_get：get命令请求次数cmd_set：set命令请求次数cmd_flush：flush命令请求次数get_hits：get命令命中次数get_misses：get命令未命中次数delete_misses：delete命令未命中次数delete_hits：delete命令命中次数incr_misses：incr命令未命中次数incr_hits：incr命令命中次数decr_misses：decr命令未命中次数decr_hits：decr命令命中次数cas_misses：cas命令未命中次数cas_hits：cas命令命中次数cas_badval：使用擦拭次数auth_cmds：认证命令处理的次数auth_errors：认证失败数目bytes_read：读取总字节数bytes_written：发送总字节数limit_maxbytes：分配的内存总大小（字节）accepting_conns：服务器是否达到过最大连接（0/1）listen_disabled_num：失效的监听数threads：当前线程数conn_yields：连接操作主动放弃数目bytes：当前存储占用的字节数curr_items：当前存储的数据总数total_items：启动以来存储的数据总数evictions：LRU释放的对象数目reclaimed：已过期的数据条目来存储新数据的数目 2、其他统计命令略清理命令flush_all1）作用 用于用于清理缓存中的所有 key=&gt;value(键=&gt;值) 对 2）语法 12345flush_all [time] [noreply]参数说明：time（可选）：用于在制定的时间后执行清理缓存操作noreply（可选）： 该参数告知服务器不需要返回数据 3）实例 12345678910111213141516171819202122232425[root@localhost ~]# telnet localhost 11211Trying ::1...Connected to localhost.Escape character is &apos;^]&apos;.^]telnet&gt; add k11 0 0 3aaaSTOREDadd k12 0 0 3bbbSTOREDget k11 k12 VALUE k11 0 3aaaVALUE k12 0 3bbbENDflush_allOK #清除成功get k11 k12ENDquitConnection closed by foreign host.[root@localhost ~]#]]></content>
      <categories>
        <category>linux</category>
        <category>linux-memcache</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>memcache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memcache-01 MC介绍和安装]]></title>
    <url>%2Fmemcache-01%2F</url>
    <content type="text"><![CDATA[memcache-01 MC介绍和安装概念引入 memcache是一款开源、高性能、分布式内存对象缓存系统，可应用各种需要缓存的场景，其主要目的是通过降低对Database的访问来加速web应用程序。它是一个基于内存的“键值对”存储，用于存储数据库调用、API调用或页面引用结果的直接数据，如字符串、对象等。 memcache通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动的速度，大幅降低数据库负载。 特点1）简单key-value存储 服务器不关心数据本身的意义及结构，只要是可序列化数据即可。存储项由“键、过期时间、可选的标志及数据”四个部分组成； 2）功能的实现一半依赖于客户端，一半基于服务器端 客户负责发送存储项至服务器端、从服务端获取数据以及无法连接至服务器时采用相应的动作；服务端负责接收、存储数据，并负责数据项的超时过期； 3）各服务器间彼此无视 不在服务器间进行数据同步； 4）O(1)的执行效率 5）清理超期数据 默认情况下，Memcached是一个LRU（Least Recently Used）缓存，同时，它按事先预订的时长清理超期数据；但事实上，memcached不会删除任何已缓存数据，只是在其过期之后不再为客户所见；而且，memcached也不会真正按期限清理缓存，而仅是当get命令到达时检查其时长； 另外，内容容量达到指定值之后，就基于LRU算法自动删除不使用的缓存。memcached本身是为缓存而设计的服务器，因此并未过多考虑数据的永久性问题。 6）存储方式 为了提高性能，memcached中保存的数据都存储在内存中，重启操作系统、重启memcached、断电等均会导致数据全部消失。 7）通信分布式 memcached尽管是“分布式”缓存服务器，但是服务器端并没有分布式功能。各个memcached不会互相通信以共享信息，分布式取决于客户端的实现。 MC缓存原理 1）浏览器首次访问应用服务器时，应用服务器先在memecached查找所需要的数据，可是memecached里却没有相应数据，因此应用服务器再去RDBMS（关系型数据库）中取数据，将数据保存到memecached，同时将数据显示到网页上。（下图紫色箭头） 2）浏览器第二次以及二次之后，应用服务器直接在memecached查找所需要的数据，并且显示早网页上。（下图绿色箭头） memcached命令分类 Memcached提供了为数不多的几个命令来完成与服务器端的交互，这些命令基于memcached的协议实现。 1）存储类命令：set, add, replace, append, prepend2）获取数据类命令：get, delete, incr/decr3）统计类命令：stats, stats items, stats slabs, stats sizes4）清理命令： flush_all 安装memcached1、安装1234[root@localhost ~]# yum install -y memcached[root@localhost ~]# systemctl restart memcached[root@localhost ~]# systemctl enable memcached[root@localhost ~]# netstat -tpnl 如上图，启动memcached之后，其默认对应端口11211会处于监听状态。 2、memcached的常用选项说明1234567891011121314[root@localhost ~]# memcached -h-l &lt;ip_addr&gt;：指定进程监听的地址；-d 以守护进程模式运行；-u &lt;username&gt;：以指定的用户身份运行memcached进程；-m &lt;num&gt;：用于缓存数据的最大内存空间，单位为MB，默认为64MB；-c &lt;num&gt;：最大支持的并发连接数，默认为1024；-p &lt;num&gt;: 指定监听的TCP端口，默认为11211；-U &lt;num&gt;：指定监听的UDP端口，默认为11211，0表示关闭UDP端口；-t &lt;threads&gt;：用于处理入站请求的最大线程数，仅在memcached编译时开启了支持线程才有效；-f &lt;num&gt;：设定Slab Allocator定义预先分配内存空间大小固定的块时使用的增长因子；-M 当内存空间不够使用时返回错误信息，而不是按LRU算法利用空间；-n 指定最小的slab chunk大小；单位是字节；-S 启用sasl进行用户认证； 3、配置文件 123456[root@localhost ~]# cat /etc/sysconfig/memcached PORT=&quot;11211&quot; # 默认监听tcp/udp 11211端口USER=&quot;memcached&quot; # 运行用户MAXCONN=&quot;1024&quot; # 最大连接数CACHESIZE=&quot;64&quot; # 最大内存使用量64MOPTIONS=&quot;&quot; 4、相关文件 12345[root@localhost ~]# rpm -ql memcached/etc/sysconfig/memcached # 配置文件/usr/bin/memcached # 主程序/usr/bin/memcached-tool # 命令行工具/usr/lib/systemd/system/memcached.service # Unit File 连接memcached命令 1telnet HOST PORT 实例1 12345678910111213[root@localhost ~]# telnet localhost 11211Trying ::1...Connected to localhost.Escape character is &apos;^]&apos;.^] #按ctrl+]telnet&gt; #直接回车stats #stats 命令用于返回统计信息例如 PID(进程号)、版本号、连接数等。#中间显示的内容省略#。。。。。。ENDquitConnection closed by foreign host.[root@localhost ~]#]]></content>
      <categories>
        <category>linux</category>
        <category>linux-memcache</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>memcache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell-script-05 shell脚本常见问题]]></title>
    <url>%2Fshell-script-05%2F</url>
    <content type="text"><![CDATA[shell脚本常见问题1、[ $a == $b ] 和 [ $a -eq $b ] 有什么区别12[ $a == $b ] 用于字符串比较[ $a -eq $b ] 用于数字比较 2、bash中如何使用数组12345678910111213141516171）在bash中定义数组array=(&quot;Hi&quot; &quot;my&quot; &quot;name&quot; &quot;is&quot;)2）打印数组的第一个元素echo $&#123;array[0]&#125;3）打印数组的所有元素echo $&#123;array[@]&#125;4)打印数组索引echo $&#123;!array[@]&#125;5)移除数组中索引为3的元素unset array[3]6)添加array[100]array[100]=&apos;num-100&apos; 3、shell如何获取输入值1）使用参数 1./script.sh param1 param2 2）（交互式输入）使用read命令，如下例 12345678[root@localhost ~]# cat read.sh #!/bin/bashread -p &quot;Please input:&quot; inputecho $input[root@localhost ~]# . read.shPlease input:hellohello[root@localhost ~]# 4、 bash里如何给变量赋值1）直接给变量赋值 123456[zyfzone@yfeng ~]$ bash[zyfzone@yfeng ~]$ a=10[zyfzone@yfeng ~]$ echo aa[zyfzone@yfeng ~]$ echo $a10 2）将命令执行结果给变量赋值 12345678[zyfzone@yfeng ~]$ b=`date`[zyfzone@yfeng ~]$ echo $bTue Oct 1 11:10:44 CST 2019[zyfzone@yfeng ~]$ echo bb[zyfzone@yfeng ~]$ 注意：变量b中保存的永远是Tue Oct 1 11:10:44 CST 2019这个值，如需获取当前时间，需要输入date命令 3）实例（结论是mem那一行的total=used+free+buff/cache） 1234567891011121314[zyfzone@yfeng ~]$ free -h total used free shared buff/cache availableMem: 1.8G 603M 98M 96M 1.1G 942MSwap: 1.0G 0B 1.0G[zyfzone@yfeng ~]$ bash[zyfzone@yfeng ~]$ mem_total=`free -h | grep &apos;Mem&apos; | awk &apos;&#123;print $2&#125;&apos;`[zyfzone@yfeng ~]$ mem_used=`free -h | grep &apos;Mem&apos; | awk &apos;&#123;print $3&#125;&apos;`[zyfzone@yfeng ~]$ mem_free=`free -h | grep &apos;Mem&apos; | awk &apos;&#123;print $4&#125;&apos;`[zyfzone@yfeng ~]$ mem_cache=`free -h | grep &apos;Mem&apos; | awk &apos;&#123;print $6&#125;&apos;`[zyfzone@yfeng ~]$ echo $mem_total &apos;=&apos; $mem_used &apos;+&apos; $mem_free &apos;+&apos; $mem_cache1.8G = 605M + 96M + 1.1G[zyfzone@yfeng ~]$ exitexit[zyfzone@yfeng ~]$ 5、两个整数相加的多种方法12345678910111213141516[root@localhost ~]# cat add.sh #!/bin/basha=1b=2let c1=$a+$becho $c1echo $[$a+$b]echo $(($a+$b))echo &quot;$a+$b&quot; | bc[root@localhost ~]# . add.sh 3333[root@localhost ~]# 6、与或运算同时使用1）在shell中&amp;&amp; 和||没有优先级之分，它只是从左向右执行。 1234[root@localhost ~]# echo 0 || echo 1 &amp;&amp; echo 101[root@localhost ~]# 2）注意&amp;&amp;需要前一条命令（或脚本）成功地执行完成之后，才执行后一条命令（或脚本）。 123[root@localhost ~]# cat abc.txt &amp;&amp; echo 1cat: abc.txt: No such file or directory[root@localhost ~]# 3）如下，从左到右 123[root@localhost ~]# name=tom &amp;&amp; echo $nametom[root@localhost ~]# 7、如何在后台运行脚本1）在后台运行脚本，方式1 12command &amp;#此时主进程会继续往下执行，而子进程会在后台启动运行。 2）在后台运行脚本，方式2 12nohup command &amp;#正如名字所声称的，忽略所有发送给子命令的挂断（SIGHUP）信号，即使按下ctrl+c，脚本依然还在继续执行。 3）举例（下面一个例子“sleep睡眠”中定义了b.sh） 12345678910111213141516171819#方式1[root@localhost ~]# . b.sh &amp;[1] 19368[root@localhost ~]# kill 19368[root@localhost ~]# #此时脚本运行停止#方式2[root@localhost ~]# nohup: ignoring input and appending output to ‘nohup.out’^C[root@localhost ~]# #此时脚本依然在后台运行#可以找出进程id，将之kill掉即可终止掉其运行[root@localhost ~]# ps -aux | grep /bin/bashroot 19458 0.0 0.1 113176 1452 pts/1 S Oct01 0:00 /bin/bash ./b.shroot 20872 0.0 0.0 112704 968 pts/2 R+ 00:03 0:00 grep --color=auto /bin/bash[root@localhost ~]# kill -9 19458[root@localhost ~]# 8、sleep睡眠在有的shell（比如linux中的bash）中，sleep支持睡眠（分，小时） 1234sleep 1 睡眠1秒sleep 1s 睡眠1秒sleep 1m 睡眠1分sleep 1h 睡眠1小时 如下例 12345678910111213141516171819[root@localhost ~]# cat b.sh #!/bin/bashwhile [ 0 ];do echo `date` &gt;&gt; t.txt sleep 1done[root@localhost ~]# cat t.txtTue Oct 1 23:48:57 EDT 2019Tue Oct 1 23:48:58 EDT 2019Tue Oct 1 23:48:59 EDT 2019Tue Oct 1 23:49:00 EDT 2019Tue Oct 1 23:49:01 EDT 2019Tue Oct 1 23:49:02 EDT 2019Tue Oct 1 23:49:03 EDT 2019Tue Oct 1 23:49:04 EDT 2019Tue Oct 1 23:49:05 EDT 2019Tue Oct 1 23:49:06 EDT 2019Tue Oct 1 23:49:07 EDT 2019[root@localhost ~]#]]></content>
      <categories>
        <category>shell</category>
        <category>script</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>shell</tag>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell-script-04 参数与运算符]]></title>
    <url>%2Fshell-script-04%2F</url>
    <content type="text"><![CDATA[shell-script-04 参数与运算符1、shell脚本参数12345678$# 是传给脚本的参数个数$0是脚本本身的名字$1是传递给该shell脚本的第一个参数$2是传递给该shell脚本的第二个参数$@是传给脚本的所有参数的列表$* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个$$ 是脚本运行的当前进程ID号$? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误 2、可用的整数比较运算符1）下列运算用于带方括号的if语句，例如if [ $# -eq 3 ] 运算符 作用 对应单词 对应运算符 -eq 是否等于 -equal = -ne 是否不等于 -not equal != -gt 是否大于 -greater then &gt; -lt 是否小于 -less then &lt; -le 是否等于或小于 -less equal &lt;= -ge 是否大于或等于 -greater equal &gt;= 2）下列运算用于带双括号的if语句，例如if ((“$i” &lt; “$min”))，在上一个例子中，使用的就是双括号。 运算符 作用 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 3、与或非运算1）非运算 12345678910111213[root@localhost ~]# vim not.sh[root@localhost ~]# cat not.sh #!/bin/bashif [ $# != 1 ];then echo &apos;参数个数不为1&apos;else echo &apos;参数个数是1&apos;fi[root@localhost ~]# . not.sh 9参数个数是1[root@localhost ~]# . not.sh 9 8 7参数个数不为1[root@localhost ~]# 2）与运算 123456789[root@localhost ~]# vim and.sh[root@localhost ~]# cat and.sh #!/bin/bashif [ $1 == 1 ] &amp;&amp; [ $2 == 2 ];then echo &apos;1、2&apos;fi[root@localhost ~]# . and.sh 1 21、2[root@localhost ~]# 3）或运算 123456789101112[root@localhost ~]# vim or.sh[root@localhost ~]# cat or.sh #!/bin/bashif [ $1 == 1 ] || [ $2 == 2 ];then echo &apos;1 or 2&apos;fi[root@localhost ~]# . or.sh 1 11 or 2bash: [: ==: unary operator expected[root@localhost ~]# . or.sh 2 21 or 2[root@localhost ~]#]]></content>
      <categories>
        <category>shell</category>
        <category>script</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>shell</tag>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell-script-03 脚本实例]]></title>
    <url>%2Fshell-script-03%2F</url>
    <content type="text"><![CDATA[shell-script-03 脚本实例1、演示函数参数的返回值1）简单的加法 123456789101112131415[root@localhost ~]# vim test_add.sh[root@localhost ~]# cat test_add.sh #!/bin/bash#数字相加 function add()&#123; sum=$[$1+$2] return $sum&#125;[root@localhost ~]# source test_add.sh [root@localhost ~]# add 3 4[root@localhost ~]# echo $?7[root@localhost ~]# 解析 sum=$[$1+$2]不能用sum=$1+$2来计算，因为这样得到的sum值为“3+4”这样一个字符串； sum=$[$1+$2]也不能写成sum=$[1+2]，因为这样得到的sum值恒为3； 2）利用for循环计算0加到100 12345678910111213[root@localhost ~]# ./sum.sh 0+1+2+3+4+5+6+7+8+9+10+11+12+13+14+15+16+17+18+19+20+21+22+23+24+25+26+27+28+29+30+31+32+33+34+35+36+37+38+39+40+41+42+43+44+45+46+47+48+49+50+51+52+53+54+55+56+57+58+59+60+61+62+63+64+65+66+67+68+69+70+71+72+73+74+75+76+77+78+79+80+81+82+83+84+85+86+87+88+89+90+91+92+93+94+95+96+97+98+99+100=5050[root@localhost ~]# cat sum.sh #!/bin/bashsum=0numbers=0for i in `seq 100`do numbers=$numbers+$i sum=$[sum+i]doneecho &quot;$numbers=$sum&quot;[root@localhost ~]# 解析 numbers=$numbers+$i得到的是字符串 sum=$[sum+i]得到的是计算结果 2、测试ping某个网址的丢包率1234567891011121314[root@localhost ~]# vim loss.sh[root@localhost ~]# cat loss.sh #!/bin/bash#判断ping某个网址的丢包率所占百分比，ping次数在脚本内修改if [ $# == 1 ];then ping $1 -c 2 | grep &apos;packet loss&apos; | awk &#123;&apos;print $6&apos;&#125;else echo &quot;Usage: /root/ping.sh &lt;url&gt;&quot;fi[root@localhost ~]# . loss.sh Usage: /root/ping.sh &lt;url&gt;[root@localhost ~]# . loss.sh baidu.com0%[root@localhost ~]# 3、计算三个数中最大值、最小值以及平均值123456789101112131415161718192021222324252627282930313233[root@localhost ~]# vim cal.sh [root@localhost ~]# cat cal.sh #!/bin/bash#计算三个数中最大值、最小值以及平均值if [ $# != 3 ];then echo &apos;/root/1.sh number1 number2 number3&apos; exit 1fimin=$1max=$1sum=0for i in $@ do if ((&quot;$i&quot; &gt; &quot;$max&quot;));then max=$i fi if ((&quot;$i&quot; &lt; &quot;$min&quot;));then min=$i fi sum=$[ sum +i ] doneecho &quot;max is $max&quot;echo &quot;min is $min&quot;echo &quot;scale=2; $sum / $#&quot; | bc[root@localhost ~]# . cal.sh 1 2 4max is 4min is 12.33[root@localhost ~]# . cal.sh 7 8 9max is 9min is 78.00[root@localhost ~]# 注意：安装后才能使用bc（linux字符界面下的计算器） 1234567891011121314[root@localhost ~]# yum install bc -y[root@localhost ~]# echo &quot;scale = 2; 5 / 3&quot; | bc1.66[root@localhost ~]# #bc很实用，如下：[root@localhost ~]# echo 5/35/3[root@localhost ~]# echo 5/3 | bc1[root@localhost ~]# echo &quot;scale=2;5/3&quot; | bc1.66[root@localhost ~]# 4、 去除字符串中的所有空格123[root@localhost ~]# echo &quot;a b c hello world&quot; | sed &apos;s/ //g&apos;abchelloworld[root@localhost ~]# 5、写一个输出数字 0 到 100 中 3 的倍数(0 3 6 9 …)的脚本123456789101112131415[root@localhost ~]# vim for.sh[root@localhost ~]# cat for.sh #!/bin/bashfor (( i=0; i&lt;=100; i+=3 ));do echo $idone[root@localhost ~]# . for.sh 0369……9699[root@localhost ~]# 6、判断文件是否为目录1234567891011121314151617181920212223242526272829303132333435[root@localhost ~]# vim test_alg.sh [root@localhost ~]# chmod +x test_alg.sh [root@localhost ~]# mkdir aaa[root@localhost ~]# echo &quot;hello&quot; &gt; hello.txt[root@localhost ~]# ./test_alg.sh Usage: /root/tes_alg.sh filename[root@localhost ~]# ./test_alg.sh aaaaaa is a directory[root@localhost ~]# ./test_alg.sh hello.txt hello.txt is a file[root@localhost ~]# ./test_alg.sh hhhhhhhhhhhh is not found[root@localhost ~]# cat test_alg.sh #!/bin/bash#判断文件是目录、普通文件还是二者皆非if [ $# != 1 ];then echo &quot;Usage: /root/tes_alg.sh filename&quot;else file=$1 if [ -d $file ];then echo &quot;$file is a directory&quot; else if [ -f $file ];then if [ -e $file ];then echo &quot;$file is a file&quot; else echo &quot;$file is neither a file nor a directory&quot; fi else echo &quot;$file is not found&quot; fi fifi[root@localhost ~]# 解析 -d，判断是否为目录 -f，判断是否存在 -e，判断是否为文件 7、使用shift写一个遍历参数的脚本 shift的作用是以空格作为分隔符，截去第一个参数 ，然后将剩余参数左移。 1）如下例中，a先被截去，剩余参数就变为b c d ……；然后b被截去，以此类推，参数个数逐减。 12345678910111213141516[root@localhost ~]# cat test_shift.sh #!/bin/bashwhile [ $# != 0 ]do echo &quot;now, first param is $1, param counts is $#&quot; shiftdone[root@localhost ~]# . test_shift.sh a b c d e f gnow, first param is a, param counts is 7now, first param is b, param counts is 6now, first param is c, param counts is 5now, first param is d, param counts is 4now, first param is e, param counts is 3now, first param is f, param counts is 2now, first param is g, param counts is 1[root@localhost ~]# 2）shift也可以设置截去参数的个数，如下例 注意：由于一次性跨越俩参数，因此while循环条件有所变化 123456789101112[root@localhost ~]# cat test_shift.sh #!/bin/bashwhile [ $# -gt 1 ]do echo &quot;now, first param is $1, param counts is $#&quot; shift 2done[root@localhost ~]# . test_shift.sh a b c d e f gnow, first param is a, param counts is 7now, first param is c, param counts is 5now, first param is e, param counts is 3[root@localhost ~]#]]></content>
      <categories>
        <category>shell</category>
        <category>script</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>shell</tag>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell-script-02 source与export]]></title>
    <url>%2Fshell-script-02%2F</url>
    <content type="text"><![CDATA[shell-script-02 source与export先来看一个脚本，由实例来入手分析 1、查看某一用户是否登录1）脚本内容 12345678910111213#!/bin/bash#查看某用户是否登录#语法：user_login loginnamefunction user_login()&#123; if who | grep $1 &gt;/dev/null then echo &quot;user $1 is on&quot; else echo &quot;user $1 is off&quot; fi&#125; 2） &gt;/dev/null（位桶/黑洞）意思是将输出重定向到这个文件夹，不要把信息输出到屏幕；该文件夹用于丢弃不需要的输出流，而读取它时只能读到空。 12345[root@localhost ~]# who | grep rootroot pts/0 2019-10-01 05:22 (192.168.141.1)[root@localhost ~]# who | grep root &gt;/dev/null[root@localhost ~]# cat /dev/null[root@localhost ~]# 3）if who | grep $1 &gt;/dev/null；意思是判断该用户是否登录，如下命令中，当前root用户是登录状态，故who命令结果中有root这一行，因此返回状态码为0（正确，条件为真）；而当前abcdefg用户目前没有登录，故who命令结果中没用abcdefg那一行，因此返回状态码为1（错误，条件为假）。 12345678[root@localhost ~]# who | grep rootroot pts/0 2019-10-01 05:22 (192.168.141.1)[root@localhost ~]# echo $?0[root@localhost ~]# who | grep abcdefg[root@localhost ~]# echo $?1[root@localhost ~]# 注意：shell 语言中 0 代表 true，0 以外的值代表 false。 12345678910111213[root@localhost ~]# vim a.sh[root@localhost ~]# cat a.sh #!/bin/bashif [ 0 ];then echo &quot;0&quot;elif [ 1 ];then echo &quot;1&quot;else echo &quot;others&quot;fi[root@localhost ~]# . a.sh 0[root@localhost ~]# 4）总结：条件为真时，输出该用户is on，否则输出该用户is off。 5）执行过程 123456789101112131415161718192021[root@localhost ~]# vim user_login.sh [root@localhost ~]# cat user_login.sh #!/bin/bash#查看某用户是否登录#语法：user_login loginnamefunction user_login()&#123; if who | grep $1 &gt;/dev/null then echo &quot;user $1 is on&quot; else echo &quot;user $1 is off&quot; fi&#125;[root@localhost ~]# source user_login.sh [root@localhost ~]# user_login rootuser root is on[root@localhost ~]# user_login abcuser abc is off[root@localhost ~]# 6）注意：source 命令以及脚本的执行方式 source命令其实是读取脚本里的语句，在当前shell中执行（并未建立新的子shell）；使用该命令后，脚本里面所有新建、改变变量的语句都会保存在当前shell里面。 12#例如上面的source user_login.sh，执行之后，user_login()函数就在当前shell中完成了定义；此时执行命令：user_login root 就相当于执行函数user_login()且其参数为root。 脚本执行方式和区别Linux执行shell脚本有两种方式，主要区别在于是否建立子shell。 1、不创建子shell123#在当前shell环境下读取并执行filename中的命令，相当于顺序执行filename里面的命令1）source filename2）. filename 2、创建子shell1234#在当前bash环境下创建子shell，在子shell中执行filename中的命令#子shell继承父shell的变量，但子shell不能使用父shell的变量，除非使用export1）bash filename2）./filename 3、区别1）如果你需要再当前shell中使用脚本里的变量，那么就不创建子shell； 2）如果你需要在子shell中使用父shell中的变量，那么就创建子shell且用上export命令； 3）如下，在子shell中不能使用父shell中定义的变量： 123456789[root@localhost ~]# now_date=`date`[root@localhost ~]# vim test_export.sh [root@localhost ~]# cat test_export.sh #!/bin/bashecho $now_date[root@localhost ~]# chmod +x test_export.sh [root@localhost ~]# ./test_export.sh [root@localhost ~]# 4）如下，在子shell中可以使用父shell中定义的变量，因为加了export： 12345678[root@localhost ~]# export export_date=`date`[root@localhost ~]# vim test_export.sh [root@localhost ~]# cat test_export.sh #!/bin/bashecho $export_date[root@localhost ~]# ./test_export.sh Tue Oct 1 06:54:14 EDT 2019[root@localhost ~]# 4、附录1）子Shell从父Shell继承得来的属性如下： 当前工作目录 环境变量 标准输入、标准输出和标准错误输出 所有已打开的文件标识符 忽略的信号 2）子Shell不能从父Shell继承的属性，归纳如下： 除环境变量和.bashrc文件中定义变量之外的Shell变量 未被忽略的信号处理]]></content>
      <categories>
        <category>shell</category>
        <category>script</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>shell</tag>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell-script-01 shell中 $? 的基本使用]]></title>
    <url>%2Fshell-script-01%2F</url>
    <content type="text"><![CDATA[shell-script-01 shell中 $? 的基本使用 shell中，$? 表示获取上一个命令的退出状态；也可以用于表示函数返回值。 实例1、获取上一个脚本的退出状态123456789101112131415161718192021222324[root@localhost ~]# vim test.sh[root@localhost ~]# chmod +x test.sh [root@localhost ~]# cat test.sh #!/bin/bashif [ &quot;$1&quot; == 100 ]then exit 0 #参数正确，退出状态为0else exit 1 #参数错误，退出状态1fi[root@localhost ~]# #运行 test.sh 时传递参数 100：[root@localhost ~]# ./test.sh 100[root@localhost ~]# echo $?0[root@localhost ~]# #运行 test.sh 时传递参数 101：[root@localhost ~]# ./test.sh 101[root@localhost ~]# echo $?1[root@localhost ~]# 2、求和，得到函数返回值12345678910111213141516171819202122232425262728[root@localhost ~]# vim add.sh[root@localhost ~]# chmod +x add.sh [root@localhost ~]# cat add.sh #!/bin/bash#得到两个数相加的和function add()&#123; return `expr $1 + $2`&#125;add 23 50 #调用函数echo $? #获取函数返回值[root@localhost ~]# ./add.sh73[root@localhost ~]# #也可以这样写[root@localhost ~]# vim add.sh[root@localhost ~]# cat add.sh #!/bin/bash#得到两个数相加的和function add()&#123; return `expr $1 + $2`&#125;add $1 $2 #调用函数echo $? #获取函数返回值[root@localhost ~]# ./add.sh 10 20 30[root@localhost ~]# 3、用来判断ping的结果12345678910111213141516171819[root@localhost ~]# ping baidu.com -c 2PING baidu.com (39.156.69.79) 56(84) bytes of data.64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=1 ttl=128 time=35.8 ms64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=2 ttl=128 time=33.4 ms--- baidu.com ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1000msrtt min/avg/max/mdev = 33.472/34.647/35.822/1.175 ms[root@localhost ~]# echo $?0[root@localhost ~]# ping google.com -c 2PING google.com (172.217.27.142) 56(84) bytes of data.--- google.com ping statistics ---2 packets transmitted, 0 received, 100% packet loss, time 999ms[root@localhost ~]# echo $?1[root@localhost ~]# 如下图，可以看到对于能ping通的baidu.com返回值是0，对于ping不通的google.com返回值是1。]]></content>
      <categories>
        <category>shell</category>
        <category>script</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>shell</tag>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-14 并发控制]]></title>
    <url>%2Fmysql-14%2F</url>
    <content type="text"><![CDATA[mysql-14 并发控制概念引入1、并发控制 事务是并发控制的基本单位，并发操作可能会带来数据不一致性，包括丢失修改、不可重复读和读脏数据三种。 如上图三例中： 1）丢失修改：T2提交的结果破坏了T1提交的结果； 2）不可重复读：T1为了校对，重新读取B值，却与之前读取的不一致； 3）读脏数据：T2读的数据是即将需要被T1回滚的数据；即T2读取到的是T1撤销掉的操作里的数据，即脏数据。 2、封锁1）共享锁（S锁，读锁） 2）排它锁（X锁，写锁） 3）一级封锁协议：事务T在修改数据R之前必须对其加X锁，知道事务结束（提交或回滚）才释放； 4）二级封锁协议：在一级封锁协议的基础上，增加事务T在读取数据R之前必须先对其加S锁，读完即可释放S锁； 4）三级封锁协议：在一级封锁协议的基础上，增加事务T在读取数据R之前必须先对其加S锁，事务结束才释放； 3、活锁和死锁1）活锁：T1先封锁数据R，然后T2、T3、T4……申请封锁R，可是T1释放R之后，系统批准了T3，T2只能等待；之后给了T4、T5、T6……，造成T2有可能永远等待，这就是活锁； 2）死锁：T1，T2均需要数据（X，Y），T1先封锁了X，而T2先封锁了Y；然后T1等待T2释放Y，同时T2等待T1释放X，造成两个事务永远也不能结束，形成死锁。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-mysql</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-13 数据库恢复技术]]></title>
    <url>%2Fmysql-13%2F</url>
    <content type="text"><![CDATA[mysql-13 数据库恢复技术一、相关概念1、事务1）定义 事务是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 2）定义事务的语句 begin transaction：开始 commit：提交（事务正常结束） rollback：回滚（事务运行故障，撤销所有已完成操作） 3）注意事项 事务通常以begin transaction开始，以commit或rollback结束； 4）事务特性（ACID） Atomic（原子性） 指整个数据库事务是不可分割的工作单位。只有使据库中所有的操作执行成功，才算整个事务成功；事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。 Consistency（一致性） 指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。例如对银行转帐事务，不管事务成功还是失败，应该保证事务结束后转账方和收款方存款总额不变。 Isolation（隔离性） 指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。 Durability（持久性） 指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。 2、故障1）事务内部故障 非预期，不能由应用程序处理；例如运算移除、并发事务思索而被选中撤销该事务、违反了某些完整性限制而被终止等； 恢复方法：回滚 2）系统故障（俗称“软故障”） 造成系统停止运转的任何时间，使得系统需要重启；例如CPU故障、操作系统故障、DBMS代码错误、系统断电等； 恢复方法：回滚+重做（已完成事务） 3）介质故障（俗称“硬故障”，此故障最为严重） 外存故障，例如磁盘损坏、磁头碰撞、瞬间强磁场干扰等； 恢复方法：重装（数据库）+重做（已完成事务） 4）计算机病毒（数据库系统的主要威胁） 人为的故障或破坏； 3、日志 日志文件可以用来进行实物故障恢复和系统故障恢复，并协助后备副本进行介质故障恢复； 登记日志文件的两条原则 1）登记次序必须严格按照并发事务执行的时间顺序； 2）必须先写日志文件，后写数据库； 说明：先写日志文件，按照日志文件恢复时，只不过多了一些undo操作，不会影响数据库正确性；而先写到数据库后写到日志文件，有可能在此二者之间发生故障。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-mysql</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-12 数据库完整性与关系数据理论]]></title>
    <url>%2Fmysql-12%2F</url>
    <content type="text"><![CDATA[mysql-12 数据库完整性与关系数据理论概念1）安全性：保护数据库以防止不合法使用所造成的数据泄露、更改或破坏； 2）完整性：指数据的正确性和相容性，即防止数据库中存在不符合语义（或不正确）的数据； 3）PK：Primary Key 4）FK：Foreign Key 1、实体完整性（primary key）1）可以在表级或者列级定义primary key 2）若主码由多个属性构成，那么只能在表级定义primary key 12345678910111213141516171819#在列级定义主码create table student( sno char(9) primary key, sname char(20), ssex char(2)); #在表级定义主码create table student( sno char(9), sname char(20), ssex char(2), primary key(sno)); #主码由多个属性构成，那么只能在表级定义primary keycreate table sc( sno char(9), cno char(4), grade smallint, primary key(sno,cno)); 2、参照完整性（foreign key）123456789101112131415161718192021#定义sc表的参照完整性create table sc( sno char(9), cno char(4), grade smallint, primary key(sno,cno), foreign key(sno) references student(sno), foreign key(cno) references course(cno)); #定义sc表的参照完整性create table sc( sno char(9), cno char(4), grade smallint, primary key(sno,cno), foreign key(sno) references student(sno) on delete cascade on update cascade, foreign key(cno) references course(cno) on delete no action on update cascade);1）第一行on delete cascade 表示当删除student表中元组时，级联删除sc表中对应元组2）第一行on update cascade 表示当更新student表中sno时，级联更新sc表中对应元组3）第二行on delete no action 表示当删除course表中元组造成与sc表不一致时，拒绝删除4）第二行on update cascade 表示当更新course表中cno时，级联更新sc表中对应元组 3、用户定义的完整性（约束条件）1）约束条件包括 列值非空（not null） 列值唯一（unique） 检查列值是否满足一个条件表达式（check 短语） 12345create table sc( sno char(9) not null, cno char(4) unique not null, grade smallint check(grade&gt;=0 and grade&lt;=100), primary key(sno,cno)); 4、完整性约束命名子句（constraint）1）语法 1234constraint &lt;约束名&gt; &lt;约束条件&gt;约束条件包括：not null，unique，primary key，foreign key，check短语等 2）举例 建立学生表student，要求学生学号在1~99之间，姓名不能取空值，年龄小于30，性别只能是男或者女。 12345678910create table student( sno numeric(6) constraint c1 check(sno between 1 and 99), sname char(20) constraint c2 not null, sage numeric(3) constraint c3 check(sage&lt;30), ssex char(2) constraint c4 check(ssex in(&apos;男&apos;,&apos;女&apos;))， constraint studentkey primary key(sno)); 去掉上例中对性别的限制 1drop constraint c4; 将上例中年龄改为25岁以下 1234alter table student drop constraint c3;alter table student add constraint c3 check(sage&lt;25); 注意：修改约束只能删除原有约束再新建约束。 5、断言（assertion） 断言可以定义涉及多个表或聚集操作的比较复杂的完整性约束，断言创建以后，任何对断言中所涉及关系的操作都会触发关系数据库的管理系统对断言的检查，任何使断言部位真值的操作都会被拒绝执行。 1）语法 1create assertion &lt;断言名&gt; &lt;check子句&gt; 2）举例 限制数据库课程最多60名学生选修。（涉及到两个表） 1234create assertion a1 check(60&gt;= (select count(*) from sc,course where sc.cno=course.cno and couese.sname=&apos;数据库&apos;)); 每当学生选修课程的时候，将在sc表中插入一条元组（sno，cno，null）,断言a1会被出发检查，如果此时数据库课程选课人数已经超过60人，则check子句返回 ‘假’，那么此插入操作会被拒绝。 限制每个学期每门课程最多只能60名学生选修。 12345alter table sc add term date;create assertion a2 check(60&gt;= all(select count(*) from sc group by cno,term)); 注意： 上例中，先新增一个属性列term，其格式为date，指的是这一列专门用来区分课程是哪个学期的；然后增加断言a2，以cno，term为准分组，即按照不同学期的不同课程分组。 3）删除断言 如果断言很复杂，那么系统在检测和维护断言上的开销较高，这时就该考虑是否删除断言了。 1drop assertion &lt;断言名&gt; 6、触发器（trigger） 触发器又叫“事件-条件-动作”规则，当指定事件发生，对条件检查，若条件成立则执行规则，否则不执行。规则的动作体可以很复杂，可以涉及其他表和其他数据库对象。 1）语法 12345create trigger &lt;触发器名&gt;&#123;before|after&#125; &lt;触发事件&gt; on &lt;表名&gt;referencing new|old row as &lt;变量&gt;for each &#123;row|statement&#125;[when &lt;触发条件&gt;] &lt;触发动作体&gt; 2）说明 只有表的创建者（拥有者）才可以在表上创建触发器，且触发器数量有限（由RDBMS决定）； 触发器名必须唯一； 触发器只能定义在基本表上，不能定义在视图上； before|after表示激活触发器的时机，before表示在触发事件的操作执行之前激活触发器； row|statement表示行级触发器和语句级触发器； when &lt;触发条件&gt;在触发器被激活后检查条件是否为真，为真则触发器动作体执行，否则不执行； when &lt;触发条件&gt;可以省略，即省略了检查条件的步骤，相当于没有“where”子句一样； 有时候由于动作提设计有误等原因，触发动作体执行失败，那么此时，激活触发器的事件就会终止执行； 3）触发器执行顺序 一个数据表上可能定义了多个触发器，如多个before触发器、多个after触发器等，同一个表上的多个触发器激活时的执行顺序如下 执行该表上的before触发器 激活触发器的sql语句 执行该表上的after语句 4）举例 将每次对表student的插入操作所增加的学生个数记录到表snum中。 1234567create trigger scountafter insert on studentreferencing new table as delta for each statement insert into snum(numbers) select count(*) from delta; 5）删除触发器 每一次访问一个表都可能触发一个触发器，因此很容易影响系统性能，需要慎重使用。 1drop trigger &lt;触发器名&gt; on &lt;表名&gt; 7、范式1）相关概念 关系数据库中的关系需要满足一定要求，满足不同程度要求的为不同范式。 X-&gt;Y：X函数确定Y，或者说Y函数依赖于X； 若候选码多于一个，则选定其中一个作为主码； 包含在任何一个候选码中的属性称为主属性； 不包含在任何候选码的属性称为非主属性； 整个属性组是码时，称为全码； 2）找候选码的三个准则 未出现在函数依赖中的属性 未出现在函数依赖右边的属性 只在右边出现的属性一定不是候选码的一部分 注意：由候选码可以决定所有属性 3）举例 123456789101112131415161718191、R(&#123;W,X,Y,Z&#125;,&#123;X-&gt;Z,WX-&gt;Y&#125; KEY=(W,X)解析：1）排除Z和Y（准则3）2）仅由X无法决定所有属性，需要再加一个W，因此KEY=(W,X)2、R(&#123;A,B,C,D,E,I&#125;,&#123;A-&gt;D,AB-&gt;E,E-&gt;C,BI-&gt;E,CD-&gt;I&#125;) KEY=(A,B)解析：1）函数依赖右边无A、B，（准则2）2）仅由A、B觉可以推出其他属性了，所以KEY=(A,B)3、R(&#123;J,S,P&#125;,&#123;(S,J)-&gt;P,(J,P)-&gt;S&#125;) KEY=(J,S)或者KEY=(J,P)，此时主属性为J,S,P解析：1）确定J为候选码的一部分（准则2）2）验证发现(J,S)或者(J,P)均可决定所有属性，因此KEY=(J,S)或者KEY=(J,P)，此时主属性为J,S,P。 4）各个范式关系（这里&lt;不是小于号，是包含于的意思） 15NF&lt;4NF&lt;BCNF&lt;3NF&lt;2NF&lt;1NF]]></content>
      <categories>
        <category>linux</category>
        <category>linux-mysql</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-11 数据库安全性以及权限操作]]></title>
    <url>%2Fmysql-11%2F</url>
    <content type="text"><![CDATA[mysql-11 数据库安全性以及权限操作概念1）安全性：保护数据库以防止不合法使用所造成的数据泄露、更改或破坏； 2）完整性：指数据的正确性和相容性，即防止数据库中存在不符合语义（或不正确）的数据； 关系数据库系统中的存取权限 对象类型 对象 操作类型 数据库模式 模式 create，schema 数据库模式 基本表 create table，alter table 数据库模式 视图 create view 数据库模式 索引 create index 数据 基本表和视图 select，insert，update，delete，references，all privileges 数据 属性列 select，insert，update，references，all privileges 相关语法举例1、授权（grant）12345678910#将对student和course表的全部操作权限授予用户u2和u3，并且允许将此权限再授予其他用户grant all privilegeson table student,courseto u2,u3with grant option;#将查询student表和修改学生学号的权限授予所有用户grant select,update(sno)on table studentto public; 2、收回权限（revoke）123456789#收回所有用户对student表的查询权限revoke selecton table studentfrom public;#收回用户u5对sc表的insert权限，同时级联收回用户u5赋予其他用户的对应权限，以及其他用户又赋予其他用户的对应权限（就是级联的意思）revoke inserton table scfrom u5 cascade; 数据库角色 数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。常用做法是为一组具有相同权限的用户创建一个角色，以此简化授权的过程。 1、通过角色实现将一组权限授权给用户1234567891011121314151617181920#创建角色r1create role r1;#使用grant语句，使角色r1拥有student表的select、update、insert权限grant select,update,inserton table studentto r1;#将这个角色授予wang、zhao，使他俩具有角色r1所包含的全部权限grant r1to wang,zhao;#一次性回收wang对student表的select、update、insert权限revoke r1from wang;#修改角色权限(在原基础上新增delete权限)grant deleteon table studentto r1; 视图机制 除了角色，还可以给不同的用户定义不同的视图，将数据对象限制在一定范围内，为数据提供一定程度的安全保护（不同用户视图不同，例如学生A不能看到学生B的成绩）。 举例1234567891011121314#建立计算机系学生的视图，把对该视图的select权限授予wang（老师），将该视图的所有权限授予zhang（系主任）create view cs_studentasselect *from studentwhere sdept=&apos;cs&apos;;grant selecton cs_studentto wang;grant all privilegeson cs_studentto zhang;]]></content>
      <categories>
        <category>linux</category>
        <category>linux-mysql</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-10 数据库相关概念总结]]></title>
    <url>%2Fmysql-10%2F</url>
    <content type="text"><![CDATA[mysql-10 数据库相关概念总结一、 1）安全性：保护数据库以防止不合法使用所造成的数据泄露、更改或破坏； 2）完整性：防止数据库中存在不符合语义（即不正确）的数据； 完整性又分为 ACIDAtomic（原子性）Consistency（一致性）Isolation（隔离性）Durability（持久性） Atomic（原子性）：指整个数据库事务是不可分割的工作单位。只有使据库中所有的操作执行成功，才算整个事务成功；事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。 Consistency（一致性）：指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。例如对银行转帐事务，不管事务成功还是失败，应该保证事务结束后ACCOUNTS表中Tom和Jack的存款总额为2000元。 Isolation（隔离性）：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。 Durability（持久性）：指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-mysql</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-09 视图]]></title>
    <url>%2Fmysql-09%2F</url>
    <content type="text"><![CDATA[mysql-09 视图 视图是从一个或几个基本表（或视图）中导出的表，是一个虚表。数据库中之存放视图的定义，而不存放视图对应的数据，数据仍存放于原基本表中。 注意点1）一旦基本表中数据发生变化，从视图中查询出的数据也会随之变化； 2）基本表别称：实表； 3）视图别称：虚表； 4）视图属性列与基本表的属性列所对应，若修改了基本表的结构，最好是删除由该基本表导出的视图后再重建； 视图的作用 有了视图，就可以灵活地查看基本表中我们所需要的部分信息。例如网络工程系的老师，需要查看网络工程系学生时，总不好每回都执行一次查询语句；定义一个网络系学生视图后，直接看这个视图就很方便。 1）简化用户操作 2）多角度看同一数据 3）机密数据安全保护（不同用户不同视图） 4）其他（略） 举例1）建立视图 1234567#建立信息学生的视图，，且要求进行插入、修改和删除操作时，仍需保证该视图只有信息系的学生。create view is_studentasselect sno,sname,sagefrom studentwhere sdept=&apos;is&apos;with check option; 上例注意点 select语句不执行，上述语句只是将视图定义存到了数据字典； with check option使得之后对该视图进行插入、修改和删除操作时，RDBMS会自动加上sdept=’is’的条件； 2）建立分组视图 123456#将学号和平均成绩定义为一个视图create view s_g(sno,gavg)asselect sno,avg(grade)from scgroup by sno; 3）删除视图 123#删除is_student视图drop ciew is_student[cascade]; 注意点 删除某视图时，若该视图还导出了其它视图，则需加cascade级联删除； 基本表删除后，由其导出的视图无法使用，则需要执行删除操作，清除的是视图在数据字典的定义； 4）查询视图 视图定义好之后，用户可以向查询基本表一样查询视图； 视图消解：将视图定义中的子查询和用户另加的查询结合，转换为对基本表的查询，这转换过程为视图消解； 5）更新视图 由于视图实际上不存在，因此更新视图实际要转化为对基本表进行更新； 在RDBMS中，并非所有视图均可进行更新（有些视图更新无法唯一地转换为对应基本表的更新）； 操作语法和对基本表一样，此处略]]></content>
      <categories>
        <category>linux</category>
        <category>linux-mysql</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-08 数据更新]]></title>
    <url>%2Fmysql-08%2F</url>
    <content type="text"><![CDATA[mysql-08 数据更新数据更新包括增、删、改 1、插入数据，例如 12345678910#插入一条新学生数据insert into student()values(&apos;201215128&apos;,&apos;张成明&apos;，&apos;男&apos;,18，&apos;cs&apos;);#插入一条选课记录（刚选的课，还没有成绩），此时会在grade列赋空值insert into sc(sno,cno)values(&apos;201215121&apos;,&apos;1&apos;);或者insert into sc()values(&apos;201215121&apos;,&apos;1&apos;，NULL); 2、修改数据，例如 12345678#将学生201215121的年龄改为21岁update studentset sage=21where sno=&apos;201215121&apos;;#将所有学生成绩增加一岁update studentset sage=sage+1; 3、删除数据，例如 123456#删除学生201215121delete from studentwhere sno=&apos;201215121&apos;;#删除整个学生表delete from student; 注意：不要因为手抖就少了where条件，会很尴尬。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-mysql</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-07 数据查询]]></title>
    <url>%2Fmysql-07%2F</url>
    <content type="text"><![CDATA[mysql-07 数据查询数据查询是数据库的核心操作 常见格式123456select all|distinct 目标表达式from 表名|视图名where 条件表达式group by 列名1having 条件表达式order by 列名2 ASC|DESC 执行顺序1）from 2）join 3）on 4）where 5）group by（按照后续条件分组） 6）聚集函数（avg，sum等） 7）having（按照后续条件筛选分组） 8）计算所有表达式 9）select 10）distinct（删除重复行） 11）order by（对结果排序） 注意1）select 默认是all，如果想去掉结果表中的重复行，必须加上distinct。 2）where 子句常用的查询条件中，and优先级高于or； 3）where 子句常用的查询条件中，between and包括了上下限，例如[20,23]包括了20和23； 4）同样的，not between and结合上一条来理解，not [20,23]表示结果表里不会有20和23； 5）where 子句常用的查询条件中，!=，&lt;&gt;均表示不等于 1、where子句常用查询条件 查询条件 谓词 比较 =，&gt;，&lt;，&gt;=，&lt;=，!=，&lt;&gt;，!&gt;，!&lt; 确定范围 between and，not between and 确定集合 in，not in 字符匹配 like，not like 空值 is null，is not null 多重条件 and，or，not 举例 123456#查询20~23岁（包括20,23）的学生的姓名select sname from student where sage between 20 and 23;或者select sname from student where sage in (20,21,22,23);或者select sname from student where sage=20 or sage=21 or sage=22 or sage=23; PS：in谓词实际上是多个or运算的缩写 2、字符匹配查询12345#语法[not] like &apos;匹配串&apos; [escape &apos;转码字符&apos;]#匹配串可以是完整字符串或者带通配符的字符串 1）通配符 % 代表任意长度（包括0），例如a%b可以是abc，abbbc，ab等。 _ （下横线）代表任意单个字符，例如a_b可以是abc，afc等。 2）转义如果用户要查询的字符串本身就有通配符%和_，那么就需要使用escape进行转义换码了。 举例 1234567查询以 DB_ 开头的且倒数第三个字符为i的课程的详细情况select * from coursewhere cname like &apos;DB\_%i__&apos; escape&apos;\&apos;;#解析1）escape&apos;\&apos; 表示反斜杠\作为转义字符，紧跟在\之后的那一个字符将不再具有通配符含义，将被转义为普通字符；2）匹配字符串&apos;DB\_%i__&apos;中，第一个下划线被转义为普通字符，%和i后面的两个_仍然作为通配符。 3、对结果排序1）ASC（默认）：升序 2）DESC：降序 关于空值空值可以按照假想的最大值来看，如下： 升序时，含空值的行最后显示； 降序时，含空值的行最先显示； 举例12345#查询全体学生情况，查询结果按照系号升序排列，同一系学生按照年龄降序排列select * from studentorder by sdept,sage DESC;PS：先按照系号排序，然后再分别针对每个系按年龄排序 4、聚集函数 函数 功能 count（*） 统计行数 count（[distinct\ all] 列名） 统计一列中值的个数 sum（[distinct\ all] 列名） 统计总和（必须是数值型） avg（[distinct\ all] 列名） 统计平均值（必须是数值型） max（[distinct\ all] 列名） 求最大值 min（[distinct\ all] 列名） 求最小值 1）distinct：取消重复值 2）all（默认）：不取消重复值 注意1）当上述函数遇到空值，除了count（*）外，其他函数均跳过空值；因为该函数仅仅是统计行数而已，某行的部分列取空值不影响它统计行数。 2）where子句中不能用聚集函数作为条件表达式。聚集函数只用于select子句和group by中的having子句。 5、group by子句 group by子句将查询结果按照某一列或者多列的值分组，值相等的为一组；如果未对查询结果分组，聚集函数会作用于整个查询结果（即，将整个查询结果当成一个组），分组后聚集函数分别作用于每一个组，即每一个组有各自的函数值。 举例1）查询选修了三门以上课程的学生的学号 123select sno from scgroup by snohaving count(*)&gt;3; 这里先按学号分组，每一组表示一个学生的选课情况，再用count（*）统计出每一组的行数（即选课数量）。 2）查询平均成绩大于等于90分的学生的学号 123456789#错解select sno from scwhere avg(grade)&gt;=90group by sno;#正解select sno from scgroup by snohaving avg(grade)&gt;=90; 解析：where子句中不能用聚集函数作为条件表达式，那么，为什么不可以呢？因为sql关键字的执行顺序where是在gourp by之前，也就是说会在分组之前计算平均值，因此计算出来的平均值并不是某个学生的平均成绩，而是全体学生的平均成绩。所以，不可以在where子句中使用聚集函数，因为那个根本没有意义。 6、连接查询 若一个查询同时设计两个或以上的表，就需要用到连接查询。连接查询是关系数据库中最主要的查询，主要包括等值连接、非等值连接、自然连接、自身连接、外连接等。 1）等值连接（运算符为 = ） 2）非等值连接（运算符是除了 = 之外的其他运算符） PS：连接谓词中的列名称为字段，连接条件中各个连接字段的名字不必相同，但是字段类型必须是可比的。如果同一个字段在查询的两个或多个表都出现了，则需要加上表名前缀；如果是唯一的字段，那么可以不必加表名前缀。 举例1）等值连接查询 12345#查询选修2号课程且成绩在90分以上的所有学生的学号和姓名select student.sno,sname from student，scwhere student.sno=sc.snoand sc.cno=2and sc.grade&gt;90; 2）自身连接查询 12345#查询每一门课的间接先修课，即先修课的先修课#要查询同一个表两次，因此要为course表定义两个别名：first、secondselect first.cno,second.cpnofrom course first,course secondwhere first.cpno=second.cno; 注意：上述语句逻辑关系是，1表的cpno等于2表的cno，然后select出2表对应的cpno，就完成了从1表的cpno到2表的cpno的过程，查询到了先修课的先修课。 3）自然连接 悬浮元组：两个表做自然连接时，互相之间不存在公共属性值上相等的某些元组会被舍弃，这些被舍弃的元组称为悬浮元组，如上图中，R的第四个元组和S的第五个元组皆是被舍弃的悬浮元组。 4）外连接查询 外连接（outer join）：如果把悬浮元组也保存在关系（表）中，而在其他属性上填上空值null，则称作外连接； 左外连接（left outer join或left joi）：只保留左边关系R的悬浮元组； 右外连接（right outer join或right join）：只保留右边关系S的悬浮元组； 如下图： 外连接查询语句举例 12345678#查询每个学生机器选修课程的情况1）使用基本关系运算select student.*,sc.* from student,scwhere student.sno=sc.sno;2）使用左外连接查询select student.sno,sname,ssex,sage,sdept,cno,gradefrom student left outer join sc on (student.sno=sc.sno) 5）多表连接查询 1234#查询每个学生学号、姓名、选修课程名以及成绩（涉及三张表）select student.sno,sname,cname,gradefrom student,course,scwhere student.sno=sc.sno and sc.cno=course.cno; 6）注意 八种常见数据库关系代数运算中，5中基本运算（并、差、笛卡尔积、选择、投影）可以用以表达另外三种运算（交、连接、除），这三种运算虽然可以简化表达，但是理解起来有点难度而且不太好记，建议掌握5钟基本运算即可。 7、嵌套查询（nested query）1）查询块：一个select-from-where语句称为一个查询块； 2）嵌套查询：一个查询块嵌套在另一个查询块的where子句或者having短语条件中，称为嵌套查询； 举例7.1、不相关子查询：子查询独立，不依赖于父查询（整个查询称为不相关嵌套查询）12345678910111213#查询与“刘晨”在同一个系学习的学生的学号select sno from studentwhere sdept in( select sdept from student where sname=&quot;刘晨&quot;); #查询选修了课程名为“信息系统”的学生的学号和姓名select sno,sname from studentwhere sno in( select sno from sc where cno in( select cno from course where cname=&quot;信息系统&quot;))； 2）相关子查询：子查询不独立，需要依赖于父查询（整个查询称为相关嵌套查询）1234567#找出每个学生超过他自己选修课程平均成绩的课程号select sno,cno from sc xwhere grade&gt;=( select avg(grade) from sc y where y.sno=x.sno); 上述语句中，x，y均为sc表的别名，又称元组变量，可以表示sc表的一个元组。内层查询查的是某个学生的平均成绩，那么”某个“具体指哪个，就需要由外层查询里x.sno来指定了，内外层相关联，故称为相关嵌套查询。 可以分步骤理解： 12345678910111）假设外层查询传入内层的学号是“201215121”，则执行内层查询select avg(grade) from sc ywhere y.sno=&apos;201215121&apos;;2）假设上一步骤查询结果是88分，则执行外层查询select sno,cnofrom sc xwhere grade&gt;=88;3）外层查询取出下一个元组，重复上述步骤，知道外层所有sc的元组都处理完毕。 3）any、all谓词子查询12345&gt; any 大于子查询结果中某个值&gt; all 大于子查询结果中所有值!=（或&lt;&gt;） any 不等于子查询结果中的某个值!=（或&lt;&gt;） all 不等于子查询结果中的任何一个值其余描述省略 举例1）查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄1234567select sname,sagefrom studentwhere sage&lt;any( select sage from student where sdept=&apos;cs&apos;)and sdept&lt;&gt;&apos;cs&apos;; 2）查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名和年龄 1把上例中的any改为all即可 4）exists子查询 exists子查询不返回任何数据，只返回逻辑值“true”或者“false”；若内层查询非空，则返回true；否则返回false；而not exists返回则刚好相反。 举例 1）查询选修了1号课程的学生姓名 123456select snamefrom studentwhere exsits( select * from sc where sno=student.sno and cno=&apos;1&apos;); 2）查询没有选修1号课程的学生姓名 123456select snamefrom studentwhere not exsits( select * from sc where sno=student.sno and cno=&apos;1&apos;); 8、集合查询集合操作主要包括并（union）、交（intersect）、差（except）三种操作。 1）查询计算机科学系学生，以及年龄大于19岁的学生学号 12345select sno from studentwhere sdept=&apos;cs&apos;unionselect sno from studentwhere sage&gt;19; 2）查询计算机科学系中，年龄大于19岁的学生学号 12345select sno from studentwhere sdept=&apos;cs&apos;intersectselect sno from studentwhere sage&gt;19; 3）查询计算机科学系中，年龄不大于19岁的学生学号 12345select sno from studentwhere sdept=&apos;cs&apos;exceptselect sno from studentwhere sage&gt;19; 注意：除了上述方法，当然还可以在where中加入and等条件完成查询。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-mysql</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-06 SQL]]></title>
    <url>%2Fmysql-06%2F</url>
    <content type="text"><![CDATA[mysql-06 SQL基础概念 SQL（Structured Query Languege）结构化查询语言，是关系数据库的标准语言，功能强大，是一种通用的关系数据库语言。 关于大小写 SQL Server和mysql对英文字母大小写不敏感，如下图，无论是关键字select、where等，还是被查找的内容字符串，亦或者是表名，一律对大小写不敏感。 SQL语句执行顺序1）from 2）join 3）on 4）where 5）group by（按照后续条件分组） 6）聚集函数（avg，sum等） 7）having（按照后续条件筛选分组） 8）计算所有表达式 9）select 10）distinct（删除重复行） 11）order by（对结果排序） 举例 1234567select sname from student where student.sno=&apos;31606&apos;;1）from studen 确定要查的是学生表2）where student.sno=&apos;31606&apos; 确定要查的是该表中学号为31606那一行的数据3）select sname 确定要查的数该行的sname属性值总结：哪个表---&gt;哪一行---&gt;哪个属性值 SQL数据定义语句 对象\操作 增 删 改 模式 create schema drop schema 先删，再增加 表 create table drop table alter table 视图 create view drop view 先删，再增加 索引 create index drop index alter index 举例1、定义模式 定义模式实际上定义了一个命名空间，在这个空间中可以进一步创建基本表、视图和定义授权。 1234567#为用户zhang 创建一个模式test，并且在其中定义一个表tab1create schema test authorization zhangcreate table tab1(name char(20),age (int));#先为用户zhang 创建一个模式test，然后在其中定义一个表tab1create schema test authorization zhang;create table test.tab1; 2、删除模式 1）cascade（级联）：删除模式的同时，删除其中所有数据库对象（表、视图等）； 2）restrict（限制）：删除模式时，若其中有数据库对象（表、视图等），则拒绝执行此删除操作，直接报错；而当其中没有任何下属对象时才可以成功执行drop schema语句。 121）drop schema zhang cascade;2）drop table tab1; drop schema zhang restrict; 3、定义基本表（基表） 1）建表的同时，通常会加入完整性约束条件，通常有以下几种 primary key（主码） unique（唯一值） not null（不能取空值） foreign key（外码） PS：参照表和被参照表可以是一个表 2）建表时还要考虑数据类型，以下是常用的几种（不同关系数据库管理系统支持的数据类型不完全相同） 数据类型 含义 char（n） 定长字符串，长度为n varchar（n） 变长字符串，最大长度为n int 长整数，4B（字节） smallint 短整数，2B bigint 大整数，8B float 可选精度的浮点数，精度至少n位数字 boolean 逻辑布尔量 date 日期，格式YYYY-MM-DD time 时间，格式HH:MM:SS 3）定长变长的区别 char(n)是定长格式，格式为char(n)的字段固定占用n个字符宽度，如果实际存放的数据长度超过n将被截取多出部分，如果长度小于n就用空字符填充。 varchar(n)是变长格式，这种格式的字段根据实际数据长度分配空间，不浪费对应的空间，但是搜索数据的速度会慢一点。 实例：学生数据库 123456789101112131415161718192021222324252627#学生表#学号 姓名 性别 年龄 系别create table student（sno char(9) primary key,sname char(20) unique,ssex char(2),sage smallint,sdept char(20));#课程表#课程号 课程名 先修课 学分值create table course(cno char(4) primary key,cname char(40) not null,cpno char(4),ccredit smallint,foreign key(cpno) reference course(cno));#选课表#学号 课程号 成绩create table sc(sno char(9),cno char(4),grade smallint,primary key(sno,cno),foreign key(sno) reference student(sno),foreign key(cno) reference course(cno)); 4、修改基本表 1）注意drop某一列的时候也有cascade（级联）和restrict（限制）的区别 cascade（级联）：删除列的同时，级联删除引用了该列的其他对象（例如视图）； restrict（限制）：删除列时，如果该列被其他对象引用，则RDBMS拒绝此删除操作，直接报错；如果此时该列未被任何其他对象引用，则可以成功drop。 格式 123456alter table 表名 add column 列名 数据类型 约束 add 表级约束 drop column 列名 cascade|restrict drop constraint 约束名 cascade|restrict alter column 列名 数据类型 举例 12345678910111213141516171819202122#向student表增加一列“资产”，要求不能取空值alter table studentadd smoney char(20) not null;#将资产改为int型alter table studentalter column smoney int;#去掉“资产”那一列不能取空值的约束alter table studentalter smoney char(20);#删除“资产”列alter table studentdrop column smoney cascade;#增加课程名必须取唯一值的约束（表级）alter table courseadd unique(cname);#删除课程名必须取唯一值的约束（表级）drop constraint unique(cname) cascade; 5、删除基本表 1drop table 表名 restrict|cascade 1）cascade（级联）：删除表的同时，相关的依赖对象（例如视图）也会被一起删除；不仅数据和表的定义被删除，而且此表上建立的索引、触发器等对象也都将被删除；如果该表被其他表引用，则会牵连其他表一起被删除。（例如SC表外码sno引用student，删除student后，SC也会被级联删除）。 2）restrict（限制）：删除表时，若该表被其他表约束所引用，例如（check、foreign key等），删除会失败；若该表有视图、触发器、存储过程或者函数等依赖该表的对象，则删除会失败。 6、建立索引 当表的数据量比较大时，查询操作会比较耗时，建立索引可以加快查询速度。 1create [unique][cluster] index 索引名 on 表名(列名 次序，列名，次序，~) 参数解析 1）unique：此索引每一个索引值只对应唯一的数据记录 2）cluster：此索引为聚簇索引 3）次序：默认为ASC（升序），另一个DESC（降序） 举例 12345678910111213141516#SC表按学号升序、课程号降序建立唯一索引create unique index scno on sc(sc asc,cno desc);PS:先将学生按学号升序排列，这样出现多组，每一组是一个学生所选多个课程，对组内课程降序排列#修改索引名alter index scno rename to scsno;#删除索引drop index scsno; 注意 索引可以减少查询操作的时间，但是若数据增删改频繁，则系统要话费许多时间来维护索引吗，得不偿失反而降低查询效率，这时就需要删除一些不必要的索引了。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-mysql</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-05 关系数据库]]></title>
    <url>%2Fmysql-05%2F</url>
    <content type="text"><![CDATA[mysql-05 关系数据库关系基本概念1）域 自足具有相投数据类型的值的集合，例如 {男，女} 2）笛卡尔积 3）关系 分类： 基本关系（基本表、基表）：实际存在的表 查询表：查询结果表 视图表：由基本表或其他视图表导出的表，是一种虚表 4）码 候选码：若关系中某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码； 主码：选定其中一个候选码为主码； 主属性：候选码属性组里的属性 关系的完整性1）实体完整性：主属性不能取空值 2）参照完整性：A表中的某列必须参照B表的某列，例如学生所在专业在成绩表上不能与在信息表上不一致。 3）用户定义的完整性：针对某一关系型数据库的约束条件，例如自定义学生姓名不能为空等 关系运算 基本关系运算有：选择、并、差、笛卡尔积、投影共5种，其他三种交、连接、除运算可由5种基本运算表达，下面是两种比较容易遗忘的运算。 1）笛卡尔积运算（两个表的乘积） 如下图，用嵌套循环即可，即用R表的第一行连上S表的三行；然后用R表的第二行连上S表的三行，以此类推，最终3*3得9行。 2）投影 即选出若干属性组成新表。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-mysql</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-04 数据库系统]]></title>
    <url>%2Fmysql-04%2F</url>
    <content type="text"><![CDATA[mysql-04 数据库系统基本概念1、数据（data）：描述事物的符号 2、数据库（DB）：长期存储在计算机内、有组织的、可共享的大量数据的集合 3、数据库管理系统（DBMS）：位于用户与操作系统之间的一层数据管理软件 4、数据库系统（DBS）：由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员组成的存储、管理、处理和维护数据的系统。 数据库系统特点1）数据结构化 2）共享性高、冗余度低且易扩充 3）数据独立性高 数据独立性1）物理独立性：应用程序与物理存储相独立 2）逻辑独立性：应用程序与数据库的逻辑结构相独立 数据库事物的四大特性（ACID） 1） 安全性：保护数据以防止不合法使用造成的数据泄密和破坏 完成性：指数据的正确性、有效性和相容性 数据模型分类1、概念模型（信息模型） 2、逻辑模型和物理模型 数据模型的组成要素1、数据结构：随系统静态特性的描述 2、数据操作：增删改查 3、数据的完整性约束：一组完整性规则 概念模型 以人的观点，对现实世界抽象化为信息和数据的模型，主要用于数据库设计阶段。 逻辑模型 以计算机的观点，对数据进行建模。主要包括层次模型、网状模型、关系模型等，主要用于数据库管理系统的实现。 物理模型 面向计算机系统，是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法。从逻辑模型到物理模型主要由数据库管理系统完成，用户不必考虑细节。 总结 现实数据－人脑的抽象认识－概念模型－逻辑模型－物理模型 概念模型基本概念１）实体：例如一个学生、一个教师 ２）属性：例如学生的姓名、学生的学号 ３）码：例如学生的学号（唯一） ４）实体型：例如：学生（学号，姓名，性别） ５）实体集：例如：全体学生 ６）联系：一对一、一对多、多对多 概念模型的表示方法 实体-联系 方法，又称E-R图 关系模型关系模型的数据结构1）关系：表 2）元组：行 3）属性：列 4）码：某列（例如学号列，可用于唯一确定某行） 5）域：例如性别的域是（男，女） 6）分量：某行的一个属性值，即某行某列的值 7）关系模式：对关系的描述，例如：学生（学号，姓名，年龄） 关系模型规范化：不允许表中有表 数据库系统的三级模式结构如下图： 1）模式（逻辑模式） 数据库数据在逻辑上的视图，程序员视图 2）外模式（子模式或用户模式） 数据库用户的数据视图，一个数据库可有多个外模式（多个用户），A用户只能看到A用户对应的外模式中的数据，对其余数据不可见，因此外模式是保证数据库安全性的有力措施。 3）内模式（存储模式） 机器视角，是数据物理结构和存储方式的描述，一个数据库只有一个内模式。 二级映像 上述三个模式是三个抽象层次，二级映像实现三者间联系和转化 1）外模式/模式映像 当出现增加表、列等操作（模式改变）时，由DBA使用sql语句完成即可，使得外模式/模式的映像做出改变，而不用去改变外模式。即不用修改应用程序，保障了数据与程序的逻辑独立性。 2）模式/内模式映像 当存储结构改变，DBA对模式/内模式映像做出改变，不用改模式以及应用程序，保障了数据与程序的物理独立性。 人员视图]]></content>
      <categories>
        <category>linux</category>
        <category>linux-mysql</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-03 mysql 一主多从+主从复制+读写分离]]></title>
    <url>%2Fmysql-03%2F</url>
    <content type="text"><![CDATA[mysql-03 mysql 一主多从+主从复制+读写分离概念引入 利用mysql主从复制技术，可以在保证主从数据库数据同步的前提下，实现读写分离。在master上完成写操作，在slave上完成读操作，可以分担master的压力，从而减少主数据库的连接，降低数据库崩溃、数据丢失等风险。mysql读写分离技术非常适用于读操作量比较大的场景，slave也可以设置多台，可大幅减轻master的压力。 常见mysql读写分离分类一、基于程序代码内部实现 在代码中根据select 、insert进行路由分类，这类方法也是目前生产环境下应用最广泛的。优点是性能较好，因为程序在代码中实现，不需要增加额外的硬件开支，缺点是需要开发人员来实现，运维人员无从下手。 二、基于中间代理层实现 代理一般介于应用服务器和数据库服务器之间，代理数据库服务器接收到应用服务器的请求后根据判断后转发到，后端数据库，有以下代表性的应用程序。 1）mysql_proxy：mysql_proxy是Mysql的一个开源项目，通过其自带的lua脚本进行sql判断。（要求具有lua编程能力，严重依赖lua脚本，需要不停给mysql_proxy打补丁，修复一些缺陷，mysql官方并不建议将此程序在生产环境使用）。 2）Atlas：是由 Qihoo 360, Web平台部基础架构团队开发维护的一个基于MySQL协议的数据中间层项目。它是在mysql-proxy 0.8.2版本的基础上，对其进行了优化，增加了一些新的功能特性。360内部使用Atlas运行的mysql业务，每天承载的读写请求数达几十亿条。支持事物以及存储过程。 3）Amoeba：由阿里巴巴集团在职员工陈思儒使用序java语言进行开发，阿里巴巴集团将其用户生产环境下，但是它并不支持事物以及存数过程。（只需要针对xml配置文件配置即可，功能强大配置简单，无需依赖额外脚本） 4）Cobar：基于Amoeba上开发的，主要实现分库，这里不做详细介绍。 注意：一般来讲，当在程序代码中实现读写分离对代码的改动较大时，会选择是由中间代理层来实现读写分离。 实验准备slave1：192.168.141.53/24 slave2：192.168.141.69/24 master：192.168.141.12/24 proxy：192.168.141.16/24 client：192.168.141.132/24 实现方法：基于中间代理层实现，使用mysql_proxy程序实现。 实验拓扑： 实验步骤1、下载mysql_proxy1）打开mysql官网www.mysql.com，找到download-&gt;MySQL Community (GPL) Downloads ，如下图 2）点击Download Archives 3）点击Mysql_Proxy 4）选择最新版本，对应通用的Linux-Generic操作系统，选择适合你的linux系统的包下载，例如我的虚拟机是64位的，就下载64位的。 2、配置proxy服务器1）安装lua，新建代理用户 12[root@proxy ~]# yum install lua -y[root@proxy ~]# useradd -r mysql-proxy 2）安装lrzsz，将刚刚下载好的mysql_proxy压缩包上传到proxy服务器 1234567891011[root@proxy ~]# rz[root@proxy ~]# ls[root@proxy ~]# tar -xf mysql-proxy-0.8.5-linux-glibc2.3-x86-64bit.tar.gz -C /usr/local[root@proxy ~]# cd /usr/local[root@proxy local]# ls[root@proxy local]# ln -sv mysql-proxy-0.8.5-linux-glibc2.3-x86-64bit/ mysql-proxy[root@proxy local]# ll 如下图 3、了解mysql_proxy 123456789101112131415[root@proxy local]# cd mysql-proxy[root@proxy mysql-proxy]# ls bin/mysql-binlog-dump mysql-myisam-dump mysql-proxy[root@proxy mysql-proxy]# #新建目录，用以存放配置文件和文件夹[root@proxy mysql-proxy]# mkdir conf logs #为了方便访问bin/目录下的mysql-proxy命令，运行以下脚本，运行环境变量[root@proxy mysql-proxy]# vim /etc/profile.d/mysql-proxy.sh[root@proxy mysql-proxy]# cat /etc/profile.d/mysql-proxy.shexport PATH=$PATH:/usr/local/mysql-proxy/bin[root@proxy mysql-proxy]# . /etc/profile.d/mysql-proxy.sh[root@proxy mysql-proxy]# 注意：查找帮助加–help-all即可 1[root@proxy mysql-proxy]# mysql-proxy --help-all 注意：若正在64位linux系统装了32位的mysql_proxy，运行mysql-proxy –help-all命令会出错，如下： 123[root@proxy mysql-proxy]# mysql-proxy --help-all/usr/local/mysql-proxy/bin/mysql-proxy: /usr/local/mysql-proxy/libexec/mysql-proxy: /lib/ld-linux.so.2: bad ELF interpreter: 没有那个文件或目录/usr/local/mysql-proxy/bin/mysql-proxy:行52: /usr/local/mysql-proxy/libexec/mysql-proxy: 成功 参数解释1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374[root@proxy mysql-proxy]# mysql-proxy --help-allUsage: mysql-proxy [OPTION...] - MySQL Proxy#命令帮助提示Help Options: -?, --help Show help options --help-all Show all help options --help-proxy Show options for the proxy-module#代理模块配置proxy-module #代理服务器proxy-server主机地址使用ip+端口 -P, --proxy-address=&lt;host:port&gt; listening address:port of the proxy-server (default: :4040) #只读后端slave-server -r, --proxy-read-only-backend-addresses=&lt;host:port&gt; address:port of the remote slave-server (default: not set) #可读可写的后端backend-servers -b, --proxy-backend-addresses=&lt;host:port&gt; address:port of the remote backend-servers (default: 127.0.0.1:3306) --proxy-skip-profiling disables profiling of queries (default: enabled) --proxy-fix-bug-25371 fix bug #25371 (mysqld &gt; 5.1.12) for older libmysql versions #lua脚本路径 -s, --proxy-lua-script=&lt;file&gt; filename of the lua script (default: not set) --no-proxy don&apos;t start the proxy-module (default: enabled) --proxy-pool-no-change-user don&apos;t use CHANGE_USER to reset the connection coming from the pool (default: enabled) #连接超时时长 --proxy-connect-timeout connect timeout in seconds (default: 2.0 seconds) #读超时时长 --proxy-read-timeout read timeout in seconds (default: 8 hours) #写超时时长 --proxy-write-timeout write timeout in seconds (default: 8 hours)Application Options: -V, --version Show version #默认读取的配置文件 --defaults-file=&lt;file&gt; configuration file --verbose-shutdown Always log the exit code when shutting down #以守护进程模式运行，否则运行在前台 --daemon Start in daemon-mode #刚刚我们建的用户mysql-proxy，就是为了以普通用户身份运行mysql-proxy而建立的。 --user=&lt;user&gt; Run mysql-proxy as user --basedir=&lt;absolute path&gt; Base directory to prepend to relative paths in the config --pid-file=&lt;file&gt; PID file in case we are started as daemon #加载插件，某个插件或者某个目录下所有插件 --plugin-dir=&lt;path&gt; path to the plugins --plugins=&lt;name&gt; plugins to load #日志级别 --log-level=(error|warning|info|message|debug) log all messages of level ... or higher #日志文件 --log-file=&lt;file&gt; log all messages in a file #使用sys-log --log-use-syslog log all messages to syslog --log-backtrace-on-crash try to invoke debugger on crash #若proxy宕机了，自动尝试重启 --keepalive try to restart the proxy if it crashed --max-open-files maximum number of open files (ulimit -n) --event-threads number of event-handling threads (default: 1) --lua-path=&lt;...&gt; set the LUA_PATH --lua-cpath=&lt;...&gt; set the LUA_CPATH 关于插件 1234567[root@proxy mysql-proxy]# ll lib/mysql-proxy/plugins/总用量 232-rwxr-xr-x. 1 7161 wheel 45824 8月 19 2014 libadmin.so-rwxr-xr-x. 1 7161 wheel 38100 8月 19 2014 libdebug.so-rwxr-xr-x. 1 7161 wheel 86104 8月 19 2014 libproxy.so-rwxr-xr-x. 1 7161 wheel 56043 8月 19 2014 libreplicant.so[root@proxy mysql-proxy]# 其中有一个libadmin.so管理接口比较常用，可以看看当前后端有几个服务器，这些服务器在何种状态等。使用这个管理接口：–plugins=admin 4、搭建主从复制后端架构1234567#节点slave1：192.168.141.53/24slave2：192.168.141.69/24master：192.168.141.12/24#可参考上一篇博客完成命令理解，url：https://hexo.yfengzone.com/mysql-02/ 初始配置slave1、slave2、master上执行以下命令 123456yum -y install mariadb mariadb-serversystemctl restart mariadbsystemctl enable mariadbfirewall-cmd --add-port=3306/tcp --permanent firewall-cmd --reloadmysql_secure_installation master123456789101112131415161718192021222324252627282930[root@master ~]# vim /etc/my.cnf#找到[mysqld]段，在其中加入下面两行代码server-id=1log-bin=mysql-bin[root@master ~]# systemctl restart mariadb[root@master ~]#[root@master ~]# mysql -u root -pEnter password: MariaDB [(none)]&gt; grant replication slave on *.* to &apos;tongbu&apos;@&apos;%&apos; identified by &apos;123456&apos;;MariaDB [(none)]&gt; show master status;+------------------+----------+--------------+------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000001 | 389 | | |+------------------+----------+--------------+------------------+1 row in set (0.00 sec)MariaDB [(none)]&gt; #记录下bin-log文件名（mysql-bin.000001）以及position（389） slave1123456789101112131415[root@slave1 ~]# vim /etc/my.cnf#找到[mysqld]段，在其中加入下面1行代码server-id=2[root@slave1 ~]# systemctl restart mariadb[root@slave1 ~]# mysql -u root -pEnter password: MariaDB [(none)]&gt; change master to master_host = &apos;192.168.141.12&apos;,master_user=&apos;tongbu&apos;,master_password=&apos;123456&apos;,master_log_file=&apos;mysql-bin.000001&apos;,master_log_pos=389;MariaDB [(none)]&gt; MariaDB [(none)]&gt; slave start;MariaDB [(none)]&gt; show slave status\G slave2123456789101112131415[root@slave2 ~]# vim /etc/my.cnf#找到[mysqld]段，在其中加入下面1行代码server-id=3[root@slave2 ~]# systemctl restart mariadb[root@slave2 ~]# mysql -u root -pEnter password: MariaDB [(none)]&gt; change master to master_host = &apos;192.168.141.12&apos;,master_user=&apos;tongbu&apos;,master_password=&apos;123456&apos;,master_log_file=&apos;mysql-bin.000001&apos;,master_log_pos=389;MariaDB [(none)]&gt; MariaDB [(none)]&gt; slave start;MariaDB [(none)]&gt; show slave status\G 两个slave的结果均如下图： 验证结果master 12345678910111213141516171819202122232425262728293031323334353637383940414243MariaDB [(none)]&gt; create database test charset=utf8;Query OK, 1 row affected (0.01 sec)MariaDB [(none)]&gt; use test;Database changedMariaDB [test]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || test |+--------------------+4 rows in set (0.00 sec)MariaDB [test]&gt; create table t (id varchar(20),name varchar(20));Query OK, 0 rows affected (0.01 sec)MariaDB [test]&gt; show tables;+----------------+| Tables_in_test |+----------------+| t |+----------------+1 row in set (0.00 sec)MariaDB [test]&gt; insert into t values (&quot;01&quot;,&quot;abcd&quot;);Query OK, 1 row affected (0.01 sec)MariaDB [test]&gt; insert into t values (&quot;02&quot;,&quot;efgh&quot;);Query OK, 1 row affected (0.00 sec)MariaDB [test]&gt; select * from t;+------+------+| id | name |+------+------+| 01 | abcd || 02 | efgh |+------+------+2 rows in set (0.00 sec)MariaDB [test]&gt; slave1、slave2上查看数据是否同步 123456789101112131415MariaDB [(none)]&gt; use test;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [test]&gt; select * from t;+------+------+| id | name |+------+------+| 01 | abcd || 02 | efgh |+------+------+2 rows in set (0.00 sec)MariaDB [test]&gt; 5、在proxy上启动mysql-proxy1）先回顾一下各个节点ip 12345slave1：192.168.141.53/24slave2：192.168.141.69/24master：192.168.141.12/24proxy：192.168.141.16/24client：192.168.141.132/24 2）编辑配置文件 12345678910111213[root@proxy mysql-proxy]# vim /usr/local/mysql-proxy/conf/mysql-proxy.conf[root@proxy logs]# cat /usr/local/mysql-proxy/conf/mysql-proxy.conf[mysql-proxy]user=rootproxy-address=0.0.0.0:3306proxy-backend-addresses=192.168.141.12:3306proxy-read-only-backend-addresses=192.168.141.53:3306,192.168.141.69:3306proxy-lua-script=/usr/local/mysql-proxy/share/doc/mysql-proxy/rw-splitting.lualog-file=/usr/local/mysql-proxy/logs/mysql-proxy.loglog-level=debugdaemon=truekeepalive=true[root@proxy logs]# 3）提升配置文件的权限，修改lua脚本（:set nu查看行号，编辑第40、41行） 注意：rw-splitting.lua是指读写分离脚本 12345678910[root@proxy mysql-proxy]# chmod 660 conf/mysql-proxy.conf[root@proxy mysql-proxy]# vim /usr/local/mysql-proxy/share/doc/mysql-proxy/rw-splitting.lua 38 if not proxy.global.config.rwsplit then 39 proxy.global.config.rwsplit = &#123; 40 min_idle_connections = 1, 41 max_idle_connections = 2, 42 43 is_debug = false 44 &#125; 上述命令修改了两个参数，最小连接数和最大连接数，修改后，mysql-proxy的调度机制就变成了，如果连接的客户端，超过两台，就会执行读写分离策略。 4）启动mysql-proxy（如果无法正常启动，根据报错修改配置文件） 12345[root@proxy mysql-proxy]# mysql-proxy --defaults-file=/usr/local/mysql-proxy/conf/mysql-proxy.conf#验证0.0.0.0:4040已在listen状态。（netstat需要yum install net-tools后可以使用）[root@proxy logs]# netstat -tnlp 可以看到mysql-proxy启动成功。 可以通过查看日志来确定mysql-proxy启动是否成功，以及后端服务器是否加入成功。 123[root@proxy logs]# pwd/usr/local/mysql-proxy/logs[root@proxy logs]# cat mysql-proxy.log 6、在master上进行数据库授权123MariaDB [(none)]&gt; use mysql;MariaDB [mysql]&gt; grant all on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;123456&apos;;MariaDB [mysql]&gt; 7、测试1）在proxy放行3306端口 12[root@proxy logs]# firewall-cmd --permanent --add-port=3306/tcp[root@proxy logs]# firewall-cmd --reload 2）在client连接proxy的数据库 123[root@client ~]# yum install mariadb -y[root@client ~]# mysql -h 192.168.141.16 -u root -p123456MariaDB [(none)]&gt; 3）在proxy查看连接 12[root@proxy ~]# yum install lsof -y[root@proxy ~]# lsof -i:3306 如下图，数据指向是proxy-&gt;192.168.141.12，也就是由代理服务器指向了master。因此，在client连接proxy的数据库时，事实上连接到的是master的数据库。 4）在client验证，可以看到主数据库master上，我们刚刚建的表格t和插入的相关数据。 12345678910111213141516MariaDB [(none)]&gt; use test;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [test]&gt; select * from t;+------+------+| id | name |+------+------+| 01 | abcd || 02 | efgh || 03 | hijk |+------+------+3 rows in set (0.00 sec)MariaDB [test]&gt; 5）再开一个窗口，在client上建立第二个连接 12[root@client ~]# mysql -h 192.168.141.16 -u root -p123456MariaDB [(none)]&gt; 6）在proxy查看连接 1[root@proxy ~]# lsof -i:3306 如下图，此时由于在client上开了两个连接，因此除了proxy-&gt;master外，连接指向多了一个proxy-&gt;slave1。 7）再开一个窗口，在client上建立第三个连接 12[root@client ~]# mysql -h 192.168.141.16 -u root -p123456MariaDB [(none)]&gt; 8）在proxy查看连接 1[root@proxy ~]# lsof -i:3306 如下图，没啥不同的，暂时忽略。 9）再开一个窗口，在client上建立第四个连接 12[root@client ~]# mysql -h 192.168.141.16 -u root -p123456MariaDB [(none)]&gt; 10）在proxy查看连接 1[root@proxy ~]# lsof -i:3306 如下图，除了proxy-&gt;master、proxy-&gt;slave1外，连接指向多了一个proxy-&gt;slave2。 至此，master、slave1、slave2均用上了，一主多从模式配置成功。 验证读写分离 读写分离的验证，可以在slave1、slave2的数据库上分别插入不同的数据，由于主从同步是单向的，salve数据改变时，master仍然不变，我们可以利用这一特性来验证读写分离是否成功。 1）首先在master上清空原来的t表，salve1和slave2的t表也会同步被清空master： 12345678910[root@master ~]# mysql -u root -pMariaDB [(none)]&gt; use test;MariaDB [test]&gt; delete from t;MariaDB [test]&gt; select * from t;Empty set (0.00 sec)MariaDB [test]&gt; slave1： 1234MariaDB [test]&gt; select * from t;Empty set (0.00 sec)MariaDB [test]&gt; slave2： 1234MariaDB [test]&gt; select * from t;Empty set (0.00 sec)MariaDB [test]&gt; 2）接着在master、slave1、slave2上分别插入不同的语句。12345678master：MariaDB [test]&gt; insert into t values (&quot;01&quot;,&quot;i am database&quot;);slave1：MariaDB [test]&gt; insert into t values (&quot;01&quot;,&quot;i am slave1&quot;);slave2：MariaDB [test]&gt; insert into t values (&quot;01&quot;,&quot;i am slave2&quot;); 3）然后分别在master、slave1、slave2上分别查询表t内容。12345678910111213141516171819202122232425262728master：MariaDB [test]&gt; select * from t;+------+---------------+| id | name |+------+---------------+| 01 | i am database |+------+---------------+slave1：MariaDB [test]&gt; select * from t;+------+---------------+| id | name |+------+---------------+| 01 | i am database || 01 | i am slave1 |+------+---------------+slave2：MariaDB [test]&gt; select * from t;+------+---------------+| id | name |+------+---------------+| 01 | i am database || 01 | i am slave2 |+------+---------------+ 如上，可以看到master、slave1、slave2上t表的内容各有不同，我们在client之前打开的四个窗口上分别查询t表，结果如下： 由上图可知，client查表，是从slave1上读取的数据，而非从master上读取的，否则就不会读取到“i am slave1”这一行内容了。 4）接下来在客户端插入一行数据 如上图，前一句是插入，后一句是读取。由“i am slave1”这一行内容我们可以判断出这次读取是从slave上读取的数据，那么新写入的“this is insert”究竟是写入到了slave1上，还是写入到master由slave1同步过来的呢？ 结果如下图 master： slave1： slave2： 综合上面三图可知，“this is insert”这一行内容是插入到master之后，同步到两个slave的。因此，可以总结出，写操作是针对于master完成的，而读操作，是针对slave完成的，读写分离实现成功。 5）测试slave之间的切换功能现在将slave1关机 然后在client上，查看表t的内容 如上图，可以看到之前client尚且还是读取slave1上的数据，此时已经读取到了slave2上的数据，说明slave之间可以正常切换。 附：重启mysql-proxy的方法1234[root@proxy logs]# netstat -tnlp[root@proxy logs]# kill 11659（这里填mysql-proxy对应PID）[root@proxy logs]# mysql-proxy --defaults-file=/usr/local/mysql-proxy/conf/mysql-proxy.conf[root@proxy ~]# cat /usr/local/mysql-proxy/logs/mysql-proxy.log 如下图，可以看到mysql-proxy重启成功。 重启后，暂时尚未出现连接 1[root@proxy ~]# lsof -i:3306]]></content>
      <categories>
        <category>linux</category>
        <category>linux-mysql</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-02 mysql-主从复制实验]]></title>
    <url>%2Fmysql-02%2F</url>
    <content type="text"><![CDATA[mysql-主从复制实验实验准备node3：192.168.141.12 （master） node4：192.168.141.132 （backup） 1、在node3、node4安装mariadb 12345[root@localhost ~]# yum -y install mariadb mariadb-server[root@localhost ~]# systemctl restart mariadb[root@localhost ~]# systemctl enable mariadb[root@localhost ~]# firewall-cmd --add-port=3306/tcp --permanent [root@localhost ~]# firewall-cmd --reload 2、在node3、node4初始化mariadb数据库服务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[root@localhost ~]# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&apos;ll need the currentpassword for the root user. If you&apos;ve just installed MariaDB, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] yNew password: Re-enter new password: Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from &apos;localhost&apos;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] y ... Success!By default, MariaDB comes with a database named &apos;test&apos; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you&apos;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB![root@localhost ~]# 3、node3 编辑配置文件 123456789[root@node3 ~]# vim /etc/my.cnf#找到[mysqld]段，在其中加入下面两行代码server-id=1log-bin=mysql-bin[root@node3 ~]# systemctl restart mariadb[root@node3 ~]# 4、在node3上创建用户”tongbu”，设置其密码为123456，查看bin-log文件以及position点 123456789101112131415[root@node3 ~]# mysql -u root -pEnter password: MariaDB [(none)]&gt; grant replication slave on *.* to &apos;tongbu&apos;@&apos;%&apos; identified by &apos;123456&apos;;MariaDB [(none)]&gt; show master status;+------------------+----------+--------------+------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000001 | 633 | | |+------------------+----------+--------------+------------------+1 row in set (0.00 sec)MariaDB [(none)]&gt; 如下图，记录下bin-log文件名（mysql-bin.000001）以及position（633） 5、配置node4（slave节点） slave节点无需开启bin-log功能，但是其server-id需要和master不同。 1234567[root@node4 ~]# vim /etc/my.cnf#找到[mysqld]段，在其中加入下面1行代码server-id=2[root@node4 ~]# systemctl restart mariadb 6、slave指定master的IP（master的IP不要写错）、用户名、密码、bin-log文件名（mysql-bin.000001）以及position（633） 123456[root@node4 ~]# mysql -u root -pEnter password: MariaDB [(none)]&gt; change master to master_host = &apos;192.168.141.12&apos;,master_user=&apos;tongbu&apos;,master_password=&apos;123456&apos;,master_log_file=&apos;mysql-bin.000001&apos;,master_log_pos=633;MariaDB [(none)]&gt; MariaDB [(none)]&gt; slave start;MariaDB [(none)]&gt; show slave status\G 如下图，查看到如下两个yes，代表slave已经正常连接到了master实现了同步。 12Slave_IO_Running: Yes #I/O线程状态yesSlave_SQL_Running: Yes #SQL线程状态yes 扩展知识 ​ 7、在node3（master）端创建数据库test和t表 12345678910111213141516171819202122232425262728293031MariaDB [mysql]&gt; create database test charset=utf8;Query OK, 1 row affected (0.00 sec)MariaDB [mysql]&gt; use test;Database changedMariaDB [test]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || test |+--------------------+4 rows in set (0.00 sec)MariaDB [test]&gt; MariaDB [test]&gt; create table t (id varchar(20),name varchar(20));Query OK, 0 rows affected (0.03 sec)MariaDB [test]&gt; show tables;+----------------+| Tables_in_test |+----------------+| t |+----------------+1 row in set (0.00 sec)MariaDB [test]&gt; 8、在node4（slave）查看数据是否同步过来了 12345678910111213141516171819202122232425MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || test |+--------------------+4 rows in set (0.00 sec)MariaDB [(none)]&gt; use test;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [test]&gt; show tables;+----------------+| Tables_in_test |+----------------+| t |+----------------+1 row in set (0.00 sec)MariaDB [test]&gt; 如上，slave从master复制数据成功，mysql主从架构至此配置成功。 9、测试 1）在node3（master）上插入两条数据 12345678910111213141516MariaDB [test]&gt; insert into t values (&quot;01&quot;,&quot;abcd&quot;);Query OK, 1 row affected (0.01 sec)MariaDB [test]&gt; insert into t values (&quot;02&quot;,&quot;efgh&quot;);Query OK, 1 row affected (0.00 sec)MariaDB [test]&gt; select * from t;+------+------+| id | name |+------+------+| 01 | abcd || 02 | efgh |+------+------+2 rows in set (0.00 sec)MariaDB [test]&gt; 2）在node4（slave）上查看数据是否同步 12345678910MariaDB [test]&gt; select * from t;+------+------+| id | name |+------+------+| 01 | abcd || 02 | efgh |+------+------+2 rows in set (0.00 sec)MariaDB [test]&gt; 至此， 验证结束，mysql主从复制实验成功完成。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-mysql</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-01 mysql+运维]]></title>
    <url>%2Fmysql-01%2F</url>
    <content type="text"><![CDATA[mysql+运维 如何实现后端mysql数据库的冗余备份、实时同步和优化改造呢？可以使用高可用、主从复制、读写分离、拆分库、拆分表等方法。 MySQL 主从复制 MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。 主要用途读写分离 在开发工作中，有时候会遇见某个sql 语句需要锁表，导致暂时不能使用读的服务，这样就会影响现有业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。 实时灾备 数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换，避免影响业务。 负载分担 随着系统中业务访问量的增大，如果是单机部署数据库，就会导致I/O访问频率过高。有了主从复制，增加多个数据存储节点，将负载分布在多个从节点上，降低单机磁盘I/O访问的频率，提高单个机器的I/O性能。 过程分析1）在master上开启bin-log日志功能（bin-log日志用于记录在master库中执行的增删改、更新操作的sql语句），Slave上执行slave start，Slave IO线程会通过在Master创建的授权用户连接上至Master，并请求master从指定的文件和位置之后发送bin-log日志内容； 2）Master接收到来自slave IO线程的请求后，master IO线程根据slave发送的指定bin-log日志position点之后的内容，然后返回给slave的IO线程。 3）返回的信息中除了bin-log日志内容外，还有master最新的binlog文件名以及在binlog中的下一个指定更新position点； 4）Slave IO线程接收到信息后，将接收到的日志内容依次添加到Slave端的relay-log文件的最末端，并将读取到的Master端的 bin-log的文件名和position点记录到master.info文件中，以便在下一次读取的时候能告知master从响应的bin-log文件名及最后一个position点开始发起请求； 5）Slave Sql 线程检测到relay-log中内容有更新，会立刻解析relay-log的内容成在Master真实执行时候的那些可执行的SQL语句，将解析的SQL语句并在Slave里执行，执行成功后，Master库与Slave库保持数据一致。 MySQL支持的复制类型1）基于语句的复制（默认）：在服务器上执行sql语句，在从服务器上执行同样的语句，mysql默认采用基于语句的复制，执行效率高。 2）基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍。 3）混合类型的复制：默认采用基于语句的复制，一旦发现基于语句无法精确复制时，就会采用基于行的复制。 同步、异步、半同步复制1）同步复制：master的变化，必须等待slave-1,slave-2,…,slave-n完成后才能返回。 2）异步复制（默认）：master只需要完成自己的数据库操作即可，至于slaves是否收到二进制日志，是否完成操作，不用关心。 3）半同步复制：master只保证slaves中的一个操作成功，就返回，其他slave不管。这个功能，是由google为MYSQL引入的。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-mysql</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-command-06 nmcli]]></title>
    <url>%2Fcommand-06%2F</url>
    <content type="text"><![CDATA[linux-command-06 nmcli概念解析Nmcli NetworkManager command line tool 基于会话的网络管理。在CentOS7中默认使用NetworkManager守护进程来监控和管理网络设置。 nmcli是命令行的NetworkManager工具，会自动把配置写到/etc/sysconfig/network-scripts/目录下面。NetworkManager最初由 Redhat 公司开发，现在由 GNOME 管理。 CentOS7之前的网络管理是通过ifcfg文件配置管理接口(device)，而现在是通过NetworkManager服务管理连接(connection)。一个接口(device)可以有多个连接(connection)，但是同时只允许一个连接(connection)处于激活（active）状态。 简单理解就是，一个连接就是(connection)就是/etc/sysconfig/network-scripts/目录下的一个配置文件，接口(device)是物理设备，一个物理设置可以拥有多个配置文件，但只能有一个配置文件属于使用(active)状态；配置文件的生成与使用状态均由NetworkManager控制。 当然，依旧支持ifcfg文件配置管理网络，但不推荐。 区分： 设备 – 正在使用的网络接口 连接 – 一组配置设置，对于一个单一的设备可以有多个连接，可以在连接之间切换。 实例解析1.显示所有网络连接 1234[root@node4 ~]# nmcli connection show NAME UUID TYPE DEVICE ens33 cf2ef9f2-6e2f-4d89-9b73-b0d9bcf57990 ethernet ens33 [root@node4 ~]# 可以看到只有一个连接，就是物理网卡ens33所用连接 2.显示活动网络连接（active状态） 1234[root@node4 ~]# nmcli connection show -activeNAME UUID TYPE DEVICE ens33 cf2ef9f2-6e2f-4d89-9b73-b0d9bcf57990 ethernet ens33 [root@node4 ~]# 3.显示某连接的详情（按空格翻页，按ctrl+z退出） 1234567891011121314151617181920212223242526272829303132[root@node4 ~]# nmcli connection show ens33connection.id: ens33connection.uuid: cf2ef9f2-6e2f-4d89-9b73-b0d9bcf57990connection.stable-id: --connection.type: 802-3-ethernetconnection.interface-name: ens33connection.autoconnect: 是connection.autoconnect-priority: 0connection.autoconnect-retries: -1 (default)connection.auth-retries: -1connection.timestamp: 1555898135connection.read-only: 否connection.permissions: --connection.zone: publicconnection.master: --connection.slave-type: --connection.autoconnect-slaves: -1 (default)connection.secondaries: --connection.gateway-ping-timeout: 0connection.metered: 未知connection.lldp: default802-3-ethernet.port: --802-3-ethernet.speed: 0802-3-ethernet.duplex: --802-3-ethernet.auto-negotiate: 否802-3-ethernet.mac-address: --802-3-ethernet.cloned-mac-address: --802-3-ethernet.generate-mac-address-mask:--802-3-ethernet.mac-address-blacklist: --[2]+ 已停止 nmcli connection show ens33[root@node4 ~]# 4.查看网络设备状态 12345[root@node4 ~]# nmcli device statusDEVICE TYPE STATE CONNECTION ens33 ethernet 连接的 ens33 lo loopback 未托管 -- [root@node4 ~]# 5.创建新的连接，名称不能随便起，这里叫“dhcp”，表示用的是dhcp协议。 1234567[root@node4 ~]# nmcli connection add con-name &quot;dhcp&quot; type ethernet ifname ens33连接“abc”(18a4d225-0d61-455a-9837-19d86df4e632) 已成功添加。[root@node4 ~]# nmcli connection showNAME UUID TYPE DEVICE ens33 cf2ef9f2-6e2f-4d89-9b73-b0d9bcf57990 ethernet ens33 dhcp 18a4d225-0d61-455a-9837-19d86df4e632 ethernet -- [root@node4 ~]# 以上参数解析 1234567connection add – 添加新的连接con-name – 连接名，同时也是该连接使用的协议名type – 设备类型ifname – 接口名上面这个命令会使用dhcp协议添加连接，也就是其ip地址由dhcp分配得到。可以看到dhcp那一行的 DEVICE字段是 -- ，这表示这个连接没有占用设备ens33，也就是该连接未被激活。只有一个连接能处于激活状态，ens33网卡设备现在被ens33连接占用着呢。 查看该连接的配置文件，可以看到BOOTPROTO=dhcp，表示协议类型dhcp。 1234567891011121314151617[root@node4 ~]# cat /etc/sysconfig/network-scripts/ifcfg-dhcp TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=dhcpDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=dhcpUUID=0fa3aa5d-d694-42cf-bc50-426a7cbf3e74DEVICE=ens33ONBOOT=yes[root@node4 ~]# 6.删除名称为“dhcp”的连接 123[root@node4 ~]# nmcli con delete dhcp成功删除连接 &apos;dhcp&apos;（e157a832-7e5d-4292-829e-3e46d8d0c7a0）。[root@node4 ~]# 7.创建新的连接，名称叫“static”，即协议类型为none，对应的是静态ip地址。 1234567[root@node4 ~]# nmcli connection add con-name &quot;static&quot; ifname ens33 autoconnect no type ethernet ip4 192.168.141.133 gw4 192.168.141.1连接“static”(431b7aae-961e-4ede-a996-188cbabbc936) 已成功添加。[root@node4 ~]# nmcli connection show NAME UUID TYPE DEVICE ens33 cf2ef9f2-6e2f-4d89-9b73-b0d9bcf57990 ethernet ens33 static 431b7aae-961e-4ede-a996-188cbabbc936 ethernet -- [root@node4 ~]# 8.激活ens33网卡的“static”连接，随着本次激活成功，xshell连接也会断开，因为ip地址变成了我们刚刚新建的“static”连接的IP地址了。 12345678910111213141516171819202122232425262728[root@node4 ~]# nmcli connection up static Socket error Event: 32 Error: 10053.Connection closing...Socket close.Connection closed by foreign host.Disconnected from remote host(node4) at 10:47:36.Type `help&apos; to learn how to use Xshell prompt.[C:\~]$ [C:\~]$ ssh root@192.168.141.133 #现在对新的ip进行连接Connecting to 192.168.141.133:22...Connection established.To escape to local shell, press &apos;Ctrl+Alt+]&apos;.WARNING! The remote SSH server rejected X11 forwarding request.Last login: Mon Apr 22 07:51:07 2019 from 192.168.141.1[root@node4 ~]# [root@node4 ~]# nmcli connection show NAME UUID TYPE DEVICE static 431b7aae-961e-4ede-a996-188cbabbc936 ethernet ens33 ens33 cf2ef9f2-6e2f-4d89-9b73-b0d9bcf57990 ethernet -- [root@node4 ~]# 可以看到，现在占用ens33网卡设备的连接以及从原来的“ens33”连接变成了现在的“static”连接了。 现在ens33网卡有两个连接，那么在/etc/sysconfig/network-scripts/目录下会有这两个连接对应的配置文件。仔细看看ifcfg-static 里面BOOTPROTO=none这一行，说明我们现在采用静态ip的。 12345678910111213141516171819202122232425262728293031323334353637[root@node4 ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens33TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;dhcp&quot;DEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;cf2ef9f2-6e2f-4d89-9b73-b0d9bcf57990&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;ZONE=[root@node4 ~]# cat /etc/sysconfig/network-scripts/ifcfg-static TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=noneIPADDR=192.168.141.133PREFIX=32GATEWAY=192.168.141.1DEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=staticUUID=431b7aae-961e-4ede-a996-188cbabbc936DEVICE=ens33ONBOOT=no[root@node4 ~]# 看着上面ifcfg-static配置文件还缺少dns，于是我们在这里可以给他加上去。先加一个，然后追加一个。 12[root@node4 ~]# nmcli connection modify &quot;static&quot; ipv4.dns 114.114.114.114[root@node4 ~]# nmcli connection modify &quot;static&quot; +ipv4.dns 8.8.8.8 再次查看ifcfg-static配置文件，可以看到新加的俩dns都在里面了。 12345678910111213141516171819202122[root@node4 ~]# cat /etc/sysconfig/network-scripts/ifcfg-static TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=noneIPADDR=192.168.141.133PREFIX=32GATEWAY=192.168.141.1DEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=staticUUID=431b7aae-961e-4ede-a996-188cbabbc936DEVICE=ens33ONBOOT=noDNS1=114.114.114.114DNS2=8.8.8.8[root@node4 ~]# 现在尝试给static连接追加一个ip地址 这里注意一下细节，原来只有IPADDR，现在追加了一个就多了一个IPADDR1，再追加则是IPADDR2 。要注意的是，此处没有IPADDR0这一说。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[root@node4 ~]# nmcli connection modify &quot;static&quot; +ipv4.addresses 192.168.141.134/24[root@node4 ~]# cat /etc/sysconfig/network-scripts/ifcfg-static TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=noneIPADDR=192.168.141.133PREFIX=32GATEWAY=192.168.141.1DEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=staticUUID=431b7aae-961e-4ede-a996-188cbabbc936DEVICE=ens33ONBOOT=noDNS1=114.114.114.114DNS2=8.8.8.8IPADDR1=192.168.141.134PREFIX1=24[root@node4 ~]# #再次刷新（激活）一下static连接就可以用ip add看到这个新的ip了[root@node4 ~]# nmcli connection up static连接已成功激活（D-Bus 活动路径：/org/freedesktop/NetworkManager/ActiveConnection/6）[root@node4 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:98:66:4e brd ff:ff:ff:ff:ff:ff inet 192.168.141.133/32 brd 192.168.141.133 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.134/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::1285:ca89:dfc2:a732/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node4 ~]# 命令行和配置文件的对应关系 命令行 配置文件 con-name *** ifcfg-*** ipv4.method manual BOOTPROTO=none ipv4.method auto BOOTPROTO=dhcp ipv4.addresses 192.0.2.1/24 IPADDR=192.0.2.1&amp;PREFIX0=24 ipv4.gateway 192.0.2.254 GATEWAY=192.0.2.254 ipv4.dns 8.8.8.8 DNS0=8.8.8.8 ipv4.dns-search example.com DOMAIN=example.com ipv4.ignore-auto-dns true PEERDNS=no connection.autoconnect yes ONBOOT=yes connection.id eth0 NAME=eth0 connection.interface-name eth0 DEVICE=eth0 connection.interface-name eth0 DEVICE=eth0 802-3-ethernet.mac-address . . . HWADDR= . . . 1.举例分析auto和manual区别 例如，我们把“static”连接改为使用dhcp协议 12345678910111213141516171819202122232425[root@node4 ~]# nmcli connection modify &quot;static&quot; ipv4.method auto[root@node4 ~]# cat /etc/sysconfig/network-scripts/ifcfg-static TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=dhcpIPADDR=192.168.141.133PREFIX=32GATEWAY=192.168.141.1DEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=staticUUID=431b7aae-961e-4ede-a996-188cbabbc936DEVICE=ens33ONBOOT=noDNS1=114.114.114.114DNS2=8.8.8.8IPADDR1=192.168.141.134PREFIX1=24[root@node4 ~]# 可以看到BOOTPROTO=dhcp这一行。 现在把“static”连接改回使用none协议（静态ip） 12345678910111213141516171819202122232425[root@node4 ~]# nmcli connection modify &quot;static&quot; ipv4.method manual[root@node4 ~]# cat /etc/sysconfig/network-scripts/ifcfg-static TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=noneIPADDR=192.168.141.133PREFIX=32GATEWAY=192.168.141.1DEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=staticUUID=431b7aae-961e-4ede-a996-188cbabbc936DEVICE=ens33ONBOOT=noDNS1=114.114.114.114DNS2=8.8.8.8IPADDR1=192.168.141.134PREFIX1=24[root@node4 ~]# 可以看到BOOTPROTO=none这一行。 2.按照上面的表格添加一个连接 1234567891011121314151617181920212223242526[root@node4 ~]# nmcli connection add con-name &quot;System eth0&quot; ipv4.addresses 192.168.141.139 ipv4.gateway 192.168.141.254 ipv4.method manual ipv4.dns 114.114.114.114 type ethernet ifname ens33 连接“System eth0”(c5ea01ea-6454-416f-8b85-a02b6806d82d) 已成功添加。[root@node4 ~]# [root@node4 ~]# cat /etc/sysconfig/network-scripts/ifcfg-System_eth0 TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=noneIPADDR=192.168.141.139PREFIX=32GATEWAY=192.168.141.254DNS1=114.114.114.114DEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=&quot;System eth0&quot;UUID=c5ea01ea-6454-416f-8b85-a02b6806d82dDEVICE=ens33ONBOOT=yes[root@node4 ~]# 上面的命令中，没有给ip指定掩码，默认的就是32位掩码。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>command</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-command-05 nl和EOF]]></title>
    <url>%2Fcommand-05%2F</url>
    <content type="text"><![CDATA[linux-command-05 nl和EOFnl概念解析 nl是一个LINUX命令，可以为输出列加上编号。nl 提供了非常多的参数使用，可以定义到很细很细的程序来制定它下好编号的输出。 通俗来讲，nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。 语法1nl [选项]... [文件]... 参数12345678910111213141516-w ：行号栏位的占用的位数。-p 在逻辑定界符处不重新开始计算。 -b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)； -b t ：如果有空行，空的那一行不要列出行号(默认值)；-n ：列出行号表示的方法，主要有三种： -n ln ：行号在萤幕的最左方显示； -n rn ：行号在自己栏位的最右方显示，且不加 0 ； -n rz ：行号在自己栏位的最右方显示，且加 0 ；-d, --section-delimiter=CC 使用指定的CC 分割逻辑页数-f, --footer-numbering=样式 使用指定样式编号文件的页脚行目-h, --header-numbering=样式 使用指定样式编号文件的页眉行目-i, --page-increment=数值 设置每一行遍历后的自动递增值-l, --join-blank-lines=数值 设置数值为多少的若干空行被视作一行-s, --number-separator=字符串 可能的话在行号后添加字符串-v, --starting-line-number=数字 每个逻辑页上的第一行的行号 解析 nl 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。 输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用 -p 标志，nl 命令在每个逻辑页开始的地方重新设置行号。 可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。 实例解析首先准备测试文件 12345678910111213141516171819202122[root@node4 ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# cat -n 1.txt 1 1 2 3 4 5 2 6 7 8 9 10 3 a b c d e 4 hello world and awk 5 languege php,java,python 6 LANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# nl 1.txt 1 1 2 3 4 5 2 6 7 8 9 10 3 a b c d e 4 hello world and awk 5 languege php,java,python 6 LANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 可以看到，cat -n具有将输出内容加上行号的功能，nl不加参数时显示的结果和其一模一样。 我们现在在1.txt每一行后面追加一行空行 1[root@node4 ~]# sed -i &apos;G&apos; 1.txt 1.显示空行行号和不显示空行行号 12[root@node4 ~]# nl -b a 1.txt[root@node4 ~]# nl -b a 1.txt 2.让行号前面自动补上0，统一输出格式，用参数-n rz ：行号在萤幕的最左方显示。默认的行号为6位数。 1[root@node4 ~]# nl -b a -n rz 1.txt 3.让行号前面自动补上0，统一输出格式，用参数-n rz ：行号在萤幕的最左方显示。设置行号为3位数。 1[root@node4 ~]# nl -b a -n rz -w 3 1.txt 4.用EOF将标准输入的内容编号 123456789[root@node4 ~]# nl &lt;&lt;EOF&gt; line1&gt; line2&gt; line3&gt; EOF 1 line1 2 line2 3 line3[root@node4 ~]# EOF概念解析 EOF是END Of File的缩写，表示自定义终止符。在平时的运维工作中，我们经常会碰到这样一个场景：执行脚本的时候，需要往一个文件里自动输入N行内容。如果是少数的几行内容，还可以用echo追加方式，但如果是很多行，那么单纯用echo追加的方式就显得愚蠢之极了！这个时候，就可以使用EOF结合cat命令进行行内容的追加了。 语法123&lt;&lt;EOF //开始....EOF //结束 实例解析EOF+cat1.将输入内容输出显示 1234567[root@node4 ~]# cat &lt;&lt; EOF&gt; hello&gt; world&gt; EOFhelloworld[root@node4 ~]# 2.将输入内容输出到2.txt。（不用提前touch创建2.txt，因为EOF输出内容到2.txt时会自动创建2.txt） 12345678[root@node4 ~]# cat &lt;&lt; EOF &gt;2.txt&gt; hello&gt; world&gt; EOF[root@node4 ~]# cat 2.txt helloworld[root@node4 ~]# 3.将输入内容追加到2.txt 12345678910[root@node4 ~]# cat &lt;&lt; EOF &gt;&gt; 2.txt &gt; apple&gt; banana&gt; EOF[root@node4 ~]# cat 2.txt helloworldapplebanana[root@node4 ~]# 4.将输入内容覆盖2.txt的原内容 12345678910[root@node4 ~]# cat &lt;&lt; EOF &gt; 2.txt &gt; java&gt; php&gt; web&gt; EOF[root@node4 ~]# cat 2.txt javaphpweb[root@node4 ~]# 5.使用自定义的EOF，例如随便起个名字abc 1234567891011[root@node4 ~]# cat &lt;&lt; abc &gt;&gt; 2.txt &gt; python&gt; scala&gt; abc[root@node4 ~]# cat 2.txt javaphpwebpythonscala[root@node4 ~]# 对比之下，echo的追加和覆盖可以看到如果要加很多行的话，用echo是很麻烦的。 12345678910111213141516[root@node4 ~]# echo &quot;hello 14&quot; &gt; 4.txt [root@node4 ~]# cat 4.txt hello 14[root@node4 ~]# echo &quot;hello 24&quot; &gt;&gt; 4.txt [root@node4 ~]# cat 4.txt hello 14hello 24[root@node4 ~]# echo &quot;hello 34&quot; &gt;&gt; 4.txt [root@node4 ~]# cat 4.txt hello 14hello 24hello 34[root@node4 ~]# echo &quot;hello 44444444&quot; &gt; 4.txt [root@node4 ~]# cat 4.txt hello 44444444[root@node4 ~]# EOF+nl 我们将标准输入内容加上行号后再输出到3.txt里面。结果如下，3.txt里面每一行内容都具有了行号，如果此时依然用nl显示3.txt，就会出现两排行号的尴尬情况。 1234567891011121314[root@node4 ~]# nl &lt;&lt; EOF &gt; 3.txt&gt; hello 13&gt; hello 23&gt; hello 33&gt; EOF[root@node4 ~]# cat 3.txt 1 hello 13 2 hello 23 3 hello 33[root@node4 ~]# [root@node4 ~]# nl 3.txt 1 1 hello 13 2 2 hello 23 3 3 hello 33 EOF+CAT+脚本123456789101112131415[root@node4 ~]# vim eof.sh[root@node4 ~]# cat eof.sh #!/bin/bashcat &gt; /root/5.txt &lt;&lt; EOFhello 15hello 25hello 35EOF[root@node4 ~]# chmod +x eof.sh [root@node4 ~]# ./eof.sh [root@node4 ~]# cat 5.txt hello 15hello 25hello 35[root@node4 ~]# 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>command</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-command-04 ss]]></title>
    <url>%2Fcommand-04%2F</url>
    <content type="text"><![CDATA[linux-command-04 ss概念解析 ss 是 Socket Statistics 的缩写。ss 命令可以用来获取 socket 统计信息，它显示的内容和 netstat 类似。但 ss 的优势在于它能够显示更多更详细的有关 TCP 和连接状态的信息，而且比 netstat 更快。当服务器的 socket 连接数量变得非常大时，无论是使用 netstat 命令还是直接 cat /proc/net/tcp，执行速度都会很慢。ss 命令利用到了 TCP 协议栈中 tcp_diag。tcp_diag 是一个用于分析统计的模块，可以获得 Linux 内核中第一手的信息，因此 ss 命令的性能会好很多。 ss命令用于显示socket状态。他可以显示PACKET sockets, TCP sockets, UDP sockets, DCCP sockets, RAW sockets，Unix domain sockets等等统计。它比其他工具展示等多tcp和state信息。 它是一个非常实用、快速、有效的跟踪IP连接和sockets的新工具。SS命令可以提供如下信息： 所有的TCP sockets 所有的UDP sockets 所有ssh/ftp/ttp/https持久连接 所有连接到Xserver的本地进程 使用state（例如：connected, synchronized, SYN-RECV, SYN-SENT,TIME-WAIT）、地址、端口过滤 所有的state FIN-WAIT-1 tcpsocket连接以及更多 很多流行的Linux发行版都支持ss以及很多监控工具使用ss命令。熟悉这个工具有助于您更好的发现与解决系统性能问题。强烈建议使用ss命令替代netstat部分命令,例如netsat -ant/lnt等。 总之，netstat 已经过时了，ss 是功能更强大的命令 。 ss 和 netstat 效率对比用time来计时 netstat 1[root@node4 ~]# time netstat -a ss 1[root@node4 ~]# time ss -a 可以看到，一个是秒级的，一个是毫秒级的。在敲下time netstat -a我们也能明显感觉到需要等两秒，很心塞。然而在敲下time ss -a时，瞬间就显示出了所有结果，高下立见。 注意（1）netstat命令是net-tools工具集中的一员（2）ss命令是iproute工具集中的一员 所以要使用ss命令的话，需要先安装iproute、iproute-doc 1[root@node4 ~]# yum install iproute iproute-doc -y 常用参数 123456789101112-h, --help 帮助-V, --version 显示版本号-t, --tcp 显示 TCP 协议的 sockets-u, --udp 显示 UDP 协议的 sockets-x, --unix 显示 unix domain sockets，与 -f 选项相同-n, --numeric 不解析服务的名称，如 &quot;22&quot; 端口不会显示成 &quot;ssh&quot;-l, --listening 只显示处于监听状态的端口-p, --processes 显示监听端口的进程(Ubuntu 上需要 sudo)-a, --all 对 TCP 协议来说，既包含监听的端口，也包含建立的连接-r, --resolve 把 IP 解释为域名，把端口号解释为协议名称-s, --summary 显示 Sockets 摘要-m, --memory 显示内存情况 所有参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485如果没有指定任何参数，则ss列出所有已经建立、并不处在listen的TCP 套接字。-h, –help列出选项概要-V,–version 输出版本信息-n, –numeric 不尝试解析服务的名字-r,–resolve 尝试解析数字地址/端口-a,–all 显示处在listening 和 非listening 状态的套接字（对TCP来说，这意味所有已建立的连接）。-l,–listening 只显示处在 listening 状态的套接字（默认情况下它们是被忽略的）* -o, –options* 显示定时器信息-e,–extended 显示详细的套接字信息-m,–memory 显示套接字的内存使用信息-p, –process 显示使用套接字的进程-i, –info 显示TCP内部信息-s,–summary 显示概要统计。该选项不分析来自不同来源的套接字概要信息。 当套接字的数量很大导致分析/proc/net/tcp 很痛苦时，它很有用。-Z,–context 同 -p 选项，不过还显示进程的安全上下文-z,–contexts 同 -Z, 不过还显示套接字的上下文。 该套接字上下文是从inode里取出的、并不是内核持有的实际的socket上下文。 套接子通常以创建它的进程上下文标记， 但该上下文会反映已应用上的policy role, type and/or range , 因此这是个很有用的参考。-b,-bpf 显示套接字的BPF过滤（只有管理员能获取这些信息）-4,–ipv4 只显示IPv4 套接字（-f inet的别名）-6,–ipv6 只显示IPv6 套接字（-f inet6的别名）-0,–packet 显示PACKET 套接字（-f link的别名）-t,–tcp 显示 TCP 套接字-u,–udp 显示UDP 套接字-d,–dccp 显示 DCCP 套接字-w,–raw 显示 RAW 套接字-x,–unix 显示 Unix Domain 套接字（-f unix的别名）-f FAMILY,–family=FAMILY 显示类型为FAMILY的套接字。 支持以下几个family： unix, inet,inet6,link,netlink-A QUERY, –query=QUERY, –socket=QUERY 列出需要倒出的套接字列表，用逗号隔开。 支持以下标识符： all, inet, tcp, udp, raw, unix, packet, netlink, unix_dgram, unix_stream, unix_seqpacket, packet_raw, packet_dgram-D FILE, –diag=FILE 不显示任何内容，仅把原始TCP套接字信息存入文件FILE。 如果FILE为 - ， 则使用stdout作为输出。-F FILE, –filter=FILE 从文件FILE中读取信息。 文件的每一行被认为是单个命令行参数。 如果FILE为 - ， 则使用stdin。* FILTER := [ state TCP-STATE ] [ EXPRESSION ] * 请参考filter的官方文档（debian 包 iproute-doc). 实例解析1.查看进每个程具体打开的socket 1[root@node4 ~]# ss -pl 2.找出打开某套接字或某端口的应用程序 1[root@node4 ~]# ss -pl | grep 622 3.显示所有的连接（按回车换行，按空格翻页，按ctrl+z退出） 1[root@node4 ~]# ss | less 4.把TCP连接过滤出来 1[root@node4 ~]# ss -at 5.把UDP连接过滤出来 1[root@node4 ~]# ss -au 6.不解析主机名 为了加快输出的速度，用”n”选项防止ss 解析IP地址到主机名。不过这同样阻止了对端口名的解析。 1[root@node4 ~]# ss -ant 7.只显示监听的套接字（参数l） 1[root@node4 ~]# ss -lnt 和之前的netstat一样，用参数l的时候不要用参数a，才能只显示监听状态的连接 8.打印进程名和进程号（p参数） 1[root@node4 ~]# ss -ltp 9.打印统计概要 1[root@node4 ~]# ss -s 10.仅显示IPv4 或 IPv6 连接 12[root@node4 ~]# ss -tl4[root@node4 ~]# ss -tl6 列出处在 time-wait 状态的套接字，下图这里一个也没有。 1[root@node4 ~]# ss state time-wait 那我们换个状态列出处在established状态的套接字 1[root@node4 ~]# ss state established 上面通过 TCP 的状态进行过滤，支持的 TCP 协议中的状态有： 1234567891011establishedsyn-sentsyn-recvfin-wait-1fin-wait-2time-waitclosedclose-waitlast-acklisteningclosing 12.显示所有源端口或目的端口为 ssh 的套接字（注意空格） 1[root@node4 ~]# ss -at &apos;( dport = :ssh or sport = :ssh )&apos; 13.显示目的端口是443或61769的套接字 1[root@node4 ~]# ss -ant &apos;( dst :443 or dst :61769 )&apos; 14.同时对目的地址和端口过滤 1[root@node4 ~]# ss -nt dst 192.168.141.1:61769 15.仅过滤目的端口 1[root@node4 ~]# ss -nt dport = :61769 除了等于，也可以设置大于小于关系 12[root@node4 ~]# ss -nt dport \&lt; :100 [root@node4 ~]# ss -nt dport \&gt; :100 16.显示所有已建立的ssh连接 1[root@node4 ~]# ss -o state established &apos;( dport = :ssh or sport = :ssh )&apos; 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>command</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-command-03 ping]]></title>
    <url>%2Fcommand-03%2F</url>
    <content type="text"><![CDATA[linux-command-03 ping概念解析PING PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序。Ping发送一个ICMP（Internet Control Messages Protocol）即因特网信报控制协议；回声请求消息给目的地并报告是否收到所希望的ICMPecho （ICMP回声应答）。它是用来检查网络是否通畅或者网络连接速度的命令。作为一个生活在网络上的管理员或者黑客来说，ping命令是第一个必须掌握的DOS命令，它所利用的原理是这样的：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。 ping （网络诊断工具） Ping是Windows、Unix和Linux系统下的一个命令。ping也属于一个通信协议，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。应用格式：ping空格IP地址。该命令还可以加许多参数使用，具体是键入ping按回车即可看到详细说明。 语法1ping [-dfnqrRv][-c&lt;完成次数&gt;][-i&lt;间隔秒数&gt;][-I&lt;网络界面&gt;][-l&lt;前置载入&gt;][-p&lt;范本样式&gt;][-s&lt;数据包大小&gt;][-t&lt;存活数值&gt;][主机名称或IP地址] 参数1234567891011121314ket的SO_DEBUG功能。-c&lt;完成次数&gt; 设置完成要求回应的次数。-f 极限检测。-i&lt;间隔秒数&gt; 指定收发信息的间隔时间。-I&lt;网络界面&gt; 使用指定的网络接口送出数据包。-l&lt;前置载入&gt; 设置在送出要求信息之前，先行发出的数据包。-n 只输出数值。-p&lt;范本样式&gt; 设置填满数据包的范本样式。-q 不显示指令执行过程，开头和结尾的相关信息除外。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。-R 记录路由过程。-s&lt;数据包大小&gt; 设置数据包的大小。-t&lt;存活数值&gt; 设置存活数值TTL的大小。-v 详细显示指令的执行过程。 实例解析1.ping一个目标需要手动打断：ctrl+c 1[root@node4 ~]# ping baidu.com 指定发送ping包的网卡，-I后接网卡名或者网卡的IP地址都是可以的。适合多网卡的场景。 1[root@node4 ~]# ping -I ens33 www.baidu.com 2.加参数c，设置收发包的数量为3 1[root@node4 ~]# ping -c 3 baidu.com 3.多参数使用，每间隔3秒收发一次信息，每个数据包大小1024字节（byte）,TTL设置为255，收发包的数量为5 1[root@node4 ~]# ping -i 3 -s 1024 -t 255 -c 5 baidu.com 如下图，-s 选项可以设置ICMP数据部分的大小，可以看到数据部分1024个字节，加上8字节的ICMP头，则ICMP包大小为1032字节。再加上20字节的IP头，IP包大小为1052字节。图中的是ICMP包大小：1032字节。 但是，明明我们设置了TTL为255，为何这里依然显示的是128呢？因为这里显示的是服务器回复我们的数据包，而非我们发过去的数据包。 我们可以用wireshark抓取这台虚拟机node4所对应虚拟网卡VMnet8的数据包，经过筛选，可以看到总共有10个数据包。可以看到，源地址和目的地址分别为192.168.141.132，123.125.114.144的数据包有5个，反过来的也有五个，正是一去一回的一一对应关系。 仔细看看TTL字段，可以发现发出去的数据包TTL=255，接收到的应答包TTL=128，两种数据包各5个。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>command</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-command-02 netstat]]></title>
    <url>%2Fcommand-02%2F</url>
    <content type="text"><![CDATA[linux-command-02 netstat概念解析Netstat 在Internet RFC标准中，Netstat的定义是： Netstat是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。 Netstat是控制台命令,是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息。Netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。 如果你的计算机有时候接收到的数据包导致出错数据或故障，你不必感到奇怪，TCP/IP可以容许这些类型的错误，并能够自动重发数据包。但如果累计的出错情况数目占到所接收的IP数据报相当大的百分比，或者它的数目正迅速增加，那么你就应该使用Netstat查一查为什么会出现这些情况了。 netstat命令的功能是显示网络连接、路由表和网络接口信息，可以让用户得知有哪些网络连接正在运作。使用时如果不带参数，netstat显示活动的 TCP 连接。 注意（1）netstat命令是net-tools工具集中的一员（2）ss命令是iproute工具集中的一员 所以要使用netstat命令的话，需要先安装net-tools 1234567891011121314151617[root@node4 ~]# netstat -tanl-bash: /usr/bin/netstat: 没有那个文件或目录[root@node4 ~]# [root@node4 ~]# yum install net-tools -y[root@node4 ~]# netstat -tanlActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN tcp 0 52 192.168.141.132:22 192.168.141.1:61769 ESTABLISHEDtcp 0 0 192.168.141.132:34518 221.181.204.229:80 TIME_WAIT tcp6 0 0 :::80 :::* LISTEN tcp6 0 0 :::22 :::* LISTEN tcp6 0 0 ::1:25 :::* LISTEN [root@node4 ~]# 总结Linux netstat命令用于显示网络状态。 利用netstat指令可让你得知整个Linux系统的网络情况。 一般用netstat -an 来显示所有连接的端口并用数字表示。 语法1netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip] 参数说明 1[root@node4 ~]# netstat ? 123456789101112131415161718192021222324-a或--all 显示所有连线中的Socket。-A&lt;网络类型&gt;或--&lt;网络类型&gt; 列出该网络类型连线中的相关地址。-c或--continuous 持续列出网络状态。-C或--cache 显示路由器配置的快取信息。-e或--extend 显示网络其他相关信息。-F或--fib 显示FIB。-g或--groups 显示多重广播功能群组组员名单。-h或--help 在线帮助。-i或--interfaces 显示网络界面信息表单。-l或--listening 显示监控中的服务器的Socket。-M或--masquerade 显示伪装的网络连线。-n或--numeric 直接使用IP地址，而不通过域名服务器。-N或--netlink或--symbolic 显示网络硬件外围设备的符号连接名称。-o或--timers 显示计时器。-p或--programs 显示正在使用Socket的程序识别码和程序名称。-r或--route 显示Routing Table。-s或--statistice 显示网络工作信息统计表。-t或--tcp 显示TCP传输协议的连线状况。-u或--udp 显示UDP传输协议的连线状况。-v或--verbose 显示指令执行过程。-V或--version 显示版本信息。-w或--raw 显示RAW传输协议的连线状况。-x或--unix 此参数的效果和指定&quot;-A unix&quot;参数相同。--ip或--inet 此参数的效果和指定&quot;-A inet&quot;参数相同。 常用选项netstat -a 本选项显示一个所有的有效连接信息列表，包括已建立的连接（ESTABLISHED），也包括监听连接请求（LISTENING）的那些连接。 netstat -b 该参数可显示在创建网络连接和侦听端口时所涉及的可执行程序。 netstat -s 本选项能够按照各个协议分别显示其统计数据。如果你的应用程序（如Web浏览器）运行速度比较慢，或者不能显示Web页之类的数据，那么你就可以用本选项来查看一下所显示的信息。你需要仔细查看统计数据的各行，找到出错的关键字，进而确定问题所在。 netstat -e 本选项用于显示关于以太网的统计数据，它列出的项目包括传送数据报的总字节数、错误数、删除数，包括发送和接收量（如发送和接收的字节数、数据包数 [1] ），或有广播的数量。可以用来统计一些基本的网络流量。 netstat -r 本选项可以显示关于路由表的信息，类似于后面所讲使用routeprint命令时看到的信息。除了显示有效路由外，还显示当前有效的连接。 netstat -n 显示所有已建立的有效连接。 netstat -p 显示协议名查看某协议使用情况 常见状态 即连接状态。在原模式中没有状态，在用户数据报协议中也经常没有状态，于是状态列可以空出来。若有状态，通常取值为： LISTEN侦听来自远方的TCP端口的连接请求 SYN-SENT在发送连接请求后等待匹配的连接请求 SYN-RECEIVED在收到和发送一个连接请求后等待对方对连接请求的确认 ESTABLISHED代表一个打开的连接 FIN-WAIT-1等待远程TCP连接中断请求，或先前的连接中断请求的确认 FIN-WAIT-2从远程TCP等待连接中断请求 CLOSE-WAIT等待从本地用户发来的连接中断请求 CLOSING等待远程TCP对连接中断的确认 LAST-ACK等待原来的发向远程TCP的连接中断请求的确认 TIME-WAIT等待足够的时间以确保远程TCP接收到连接中断请求的确认 CLOSED没有任何连接状态 实例解析1.显示详细的网络状况 1[root@node4 ~]# netstat -a 2.显示当前UDP连接状况，下图中可以看到一个UDP连接也没有 1[root@node4 ~]# netstat -nu 3.显示UDP端口号的使用情况 1[root@node4 ~]# netstat -apu 4.显示TCP端口号的使用情况，加不加参数n的对比。可以看到在local字段，没加n之前显示的是主机名和服务名称，加了n之后显示的是IP地址和端口号。 12[root@node4 ~]# netstat -apt[root@node4 ~]# netstat -atnp 常用命令netstat查看当前服务和监听端口加p的话，会多显示一个字段：PID/Program name，表示进程号和进程名 注意：使用 -p 选项时，netstat 必须运行在 root 权限之下，不然它就不能得到运行在 root 权限下的进程名，而很多服务包括 http 和 ftp 都运行在 root 权限之下。 12[root@node4 ~]# netstat -atun[root@node4 ~]# netstat -atunp 只查看监听（LISTEN）中的连接1[root@node4 ~]# netstat -ntl 如下图，和-ant参数对比呢，-ntl显示的连接只有LISTEN状态的连接。 注意：如果只查看监听（LISTEN）中的连接，就不要使用 -a 选项，否则 netstat 会列出所有连接，而不仅仅是监听端口。 获取进程名、进程号以及用户 ID 查看端口和连接的信息时，能查看到它们对应的进程名和进程号对系统管理员来说是非常有帮助的。举个栗子，Apache 的 httpd 服务开启80端口，如果你要查看 http 服务是否已经启动，或者 http 服务是由 apache 还是 nginx 启动的，这时候你可以看看进程名。 这里需要使用 -p 选项查看进程信息。 注意：使用 -p 选项时，netstat 必须运行在 root 权限之下，不然它就不能得到运行在 root 权限下的进程名，而很多服务包括 http 和 ftp 都运行在 root 权限之下。 1[root@node4 ~]# netstat -nplt 如下图，和不加p时候对比，加了p一目了然地看到了httpd服务连接也是监听状态。 三条命令的对比如下，使用 -ep 选项可以同时查看进程名和用户名。 123[root@node4 ~]# netstat -nplt[root@node4 ~]# netstat -plt[root@node4 ~]# netstat -eplt 打印统计数据netstat 可以打印出网络统计数据，包括某个协议下的收发包数量。 下面列出所有网络包的统计情况： 这里如果想只打印出 TCP 或 UDP 协议的统计数据，只要加上对应的选项（-t 和 -u）即可 1[root@node4 ~]# netstat -s 显示内核路由信息 使用 -r 选项打印内核路由信息。打印出来的信息与 route 命令输出的信息一样。我们也可以使用 -n 选项禁止域名解析。 1[root@node4 ~]# netstat -nr 打印网络接口（网卡）使用-i参数打印网络接口信息，配合-e参数就像ip add命令一样 netstat 持续输出加个-c参数即可持续输出，按ctrl+c打断 1[root@node4 ~]# netstat -iec netstat配合grep使用1[root@node4 ~]# netstat -antp | grep ESTABLISHED 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>command</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-command-01 scp]]></title>
    <url>%2Fcommand-01%2F</url>
    <content type="text"><![CDATA[linux-command-01 scp概念解析安全复制协议 安全复制（英语：Secure copy，缩写SCP）是指在本地主机与远程主机或者两台远程主机之间基于Secure Shell（SSH）协议安全地传输计算机文件。“SCP”通常指安全复制协议或者程序本身。SCP是一种基于BSDRCP协议的网络传输协议，支持同一个网络上主机之间传输文件。SCP使用Secure Shell（SSH）完成数据传输，并使用同时用它进行身份认证，从而确保数据传输时的真实性和保密性。客户端可以向服务器发送（上传）文件，可选包含其基本属性（权限、时间戳）。客户端也可以请求（下载）一个服务器的文件或目录。SCP默认通过TCP端口22运行。 Linux scp命令 Linux scp命令用于Linux之间复制文件和目录。scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。 语法完整写法 123scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file] [-l limit] [-o ssh_option] [-P port] [-S program][[user@]host1:]file1 [...] [[user@]host2:]file2 简易写法 1scp [可选参数] file_source file_target 可选参数1234567891011121314151617-1： 强制scp命令使用协议ssh1-2： 强制scp命令使用协议ssh2-4： 强制scp命令只使用IPv4寻址-6： 强制scp命令只使用IPv6寻址-B： 使用批处理模式（传输过程中不询问传输口令或短语）-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）-p：保留原文件的修改时间，访问时间和访问权限。-q： 不显示传输进度条。-r： 递归复制整个目录。-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。-l limit： 限定用户所能使用的带宽，以Kbit/s为单位。-o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，-P port：注意是大写的P, port是指定数据传输用到的端口号-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 实验准备准备两台干净的虚拟机 node3：192.168.141.12 node4：192.168.141.132 准备测试文件和测试目录 node3 123456[root@node3 ~]# echo &quot;hello,i come from node3&quot; &gt; node3.txt[root@node3 ~]# mkdir directory3[root@node3 ~]# cd directory3/[root@node3 directory3]# pwd/root/directory3[root@node3 directory3]# node4 123456[root@node4 ~]# echo &quot;hello,i come from node4&quot; &gt; node4.txt[root@node4 ~]# mkdir directory4[root@node4 ~]# cd directory4/[root@node4 directory4]# pwd/root/directory4[root@node4 directory4]# 实例解析1.在node3上将node3.txt发送到node4的/root/directory4目录下 这里指定了用户名，命令执行后就不需要输入用户名 12345678910[root@node3 directory3]# scp /root/node3.txt root@192.168.141.132:/root/directory4The authenticity of host &apos;192.168.141.132 (192.168.141.132)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:mJVa6J0b/NaWyJ+cbVho0hHnUDY9utS7iWUGq91HvpM.ECDSA key fingerprint is MD5:d3:6c:dc:1c:76:df:3a:d1:b9:ef:6c:17:82:64:76:6e.Are you sure you want to continue connecting (yes/no)? yes #这里敲yes加回车Warning: Permanently added &apos;192.168.141.132&apos; (ECDSA) to the list of known hosts.root@192.168.141.132&apos;s password: #这里输入密码node3.txt 100% 24 4.7KB/s 00:00 [root@node3 directory3]# #上面的100%表示传输完成 我们到node4上验证一下，然后删掉node3.txt，继续做下一步实验。 1234567[root@node4 directory4]# lsnode3.txt[root@node4 directory4]# cat node3.txt hello,i come from node3[root@node4 directory4]# rm -f node3.txt [root@node4 directory4]# ls[root@node4 directory4]# 2.在node3上将node4.txt拷贝node3的/root/directory3目录下 12345678[root@node3 directory3]# scp root@192.168.141.132:/root/node4.txt /root/directory3root@192.168.141.132&apos;s password: node4.txt 100% 24 22.4KB/s 00:00 [root@node3 directory3]# lsnode4.txt[root@node3 directory3]# cat node4.txt hello,i come from node4[root@node3 directory3]# 说明1.如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号。先在node4上放行4555端口，关闭selinux，将ssh端口改为4555 。 1234567891011[root@node4 directory4]# firewall-cmd --add-port=4555/tcp --permanent success[root@node4 directory4]# firewall-cmd --reload success[root@node4 directory4]# setenforce 0[root@node4 directory4]# cd /etc/ssh[root@node4 ssh]# cat sshd_config | grep &quot;Port&quot;Port 4555#GatewayPorts no[root@node4 ssh]# systemctl restart sshd 然后尝试用4555端口，在node3上将node3.txt发送到node4的/root/directory4目录下 1234[root@node3 directory3]# scp -P 4555 /root/node3.txt root@192.168.141.132:/root/directory4root@192.168.141.132&apos;s password: node3.txt 100% 24 6.9KB/s 00:00 [root@node3 directory3]# 最后验证一下 123456[root@node4 ssh]# cd /root/directory4/[root@node4 directory4]# lsnode3.txt[root@node4 directory4]# cat node3.txt hello,i come from node3[root@node4 directory4]# 实验做完了别忘了将sshd端口改回来且重启。 1234567[root@node4 directory4]# sed -n &apos;17p&apos; /etc/ssh/sshd_config Port 4555[root@node4 directory4]# sed -i &apos;s/Port 4555/#Port 22/g&apos; /etc/ssh/sshd_config [root@node4 directory4]# sed -n &apos;17p&apos; /etc/ssh/sshd_config #Port 22[root@node4 directory4]# systemctl restart sshd[root@node4 directory4]# 2.使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的。 上面我们用的都是root用户，所以不用担心权限不够。但是我们在管理真实的服务器时，出于安全考虑，一般会禁止root远程登录服务器 。所以我们在服务器给自己创建的用户必须做好相应权限分配，避免scp时权限不够导致出错。如果因为权限不够而传送不了文件，那么sudo root借用root权限后，给自己分配相应权限，然后回头再用scp传文件就不会传不了了。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>command</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-shell-05 shell-脚本四剑客-sed]]></title>
    <url>%2Fshell-05%2F</url>
    <content type="text"><![CDATA[linux-shell-05 shell-脚本四剑客-sed概念解析 SED是一项Linux指令，功能同awk类似，差别在于，sed简单，对列处理的功能要差一些，awk的功能复杂，对列处理的功能比较强大。sed是一个非交互式文本编辑器，它可以对文本文件和标准输入进行编辑，标志输入可以来自键盘输入、文本重定向、字符串、变量、甚至来自于管道符。 特点： sed命令利用script来处理文本文件。 sed可依照script的指令，来处理、编辑文本文件。 逐行处理内容，一次只处理一行内容。 sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。 语法1sed [-hnV] [-e&lt;script&gt;][-f&lt;script文件&gt;] [文本文件] 参数说明： 12345-e&lt;script&gt;或--expression=&lt;script&gt; 以选项中指定的script来处理输入的文本文件。-f&lt;script文件&gt;或--file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。-h或--help 显示帮助。-n或--quiet或--silent 仅显示script处理后的结果。-V或--version 显示版本信息。 动作说明： 123456- a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～- c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！- d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；- i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；- p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～- s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！ sed工作流程1、读新的一行到缓存空间（pattern space）2、从指定的操作指令中依次取出指令执行，判断是否匹配缓存空间内容3、如果不匹配则忽略后续的编辑命令，回到第2步继续取出下一条指令4、如果匹配，则针对缓存的行执行后续的编辑命令；完成后，回到第2步继续取出下一条指令5、当所有指令都应用之后，输出缓存行的内容；回到第1步继续读入下一行内容6、当所有行都处理完之后，结束； sed操作的所有数据都是pattern space缓存空间内的数据，原文件并没有发生该表。如果想保留sed操作后的数据，可以使用重定向符输出到新的文件中。或者使用- i参数更改原文件。 实例解析首先查看1.txt文件原文内容 12345678[root@node4 ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 打印第1到5行内容 1234567[root@node4 ~]# sed -n &apos;1,5p&apos; 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,python[root@node4 ~]# 打印文件最后一行的内容， 下面$ 代表的是最后一行 123456789101112[root@node4 ~]# sed -n &apos;$p&apos; 1.txt LANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 如果少敲了$符号，就直接打印文件全部内容[root@node4 ~]# sed -n &apos;p&apos; 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON 然后在1.txt文件的第2行后添加一行，并将结果输出到标准输出 123456789[root@node4 ~]# sed -e 2a\newline 1.txt1 2 3 4 56 7 8 9 10newlinea b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 再次查看文件内容，发现文件内容实际上是没有变化的。 12345678[root@node4 ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 然后在1.txt文件的第2行后添加一行，内容为11 12 13 14 15，并将结果输出到标准输出 123456789[root@node4 ~]# sed &apos;2a 11 12 13 14 15&apos; 1.txt 1 2 3 4 56 7 8 9 1011 12 13 14 15a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 然后在1.txt文件的第3行前面插入一行，内容为11 12 13 14 15，并将结果输出到标准输出 123456789[root@node4 ~]# sed &apos;3i 11 12 13 14 15&apos; 1.txt1 2 3 4 56 7 8 9 1011 12 13 14 15a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 增加两行或者以上 12345678910111213[root@node4 ~]# sed &apos;2a 11 12 13 14 15\ #这里敲\加回车可以就输入，敲&apos;表示输入完毕16 17 18 19 20\21 22 23 24 25&apos; 1.txt 1 2 3 4 56 7 8 9 1011 12 13 14 1516 17 18 19 2021 22 23 24 25a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 在文件最后一行后追加一行：this is the last raw 123456789[root@node4 ~]# sed &apos;$a this is the last raw&apos; 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHONthis is the last raw[root@node4 ~]# 以行为单位的新增/删除将 1.txt的内容列出并且列印行号，同时，请将第 2~5 行删除！ 1234567891011[root@node4 ~]# nl 1.txt | sed &apos;2,5d&apos; 1 1 2 3 4 5 6 LANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 将 1.txt的内容列出并且列印行号，同时，请将含有java的行删除！ 12345678910111213[root@node4 ~]# sed &apos;/java/,$d&apos; 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awk[root@node4 ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 删除第 3 到最后一行 1234[root@node4 ~]# sed &apos;3,$d&apos; 1.txt 1 2 3 4 56 7 8 9 10[root@node4 ~]# 以行为单位的替换与显示将第2-5行的内容取代成为：xxxxxxxxxx 12345[root@node4 ~]# sed &apos;2,5c xxxxxxxxxx&apos; 1.txt1 2 3 4 5xxxxxxxxxxLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 数据的搜寻并替换语法 1sed &apos;s/要被取代的字串/新的字串/g&apos; 把java换成web 12345678[root@node4 ~]# sed -e &apos;s/java/web/g&apos; 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,web,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 多点编辑用一条sed命令完成：删除第2~4行且把java换成web 12345[root@node4 ~]# sed -e &apos;2,4d&apos; -e &apos;s/java/web/g&apos; 1.txt 1 2 3 4 5languege php,web,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 直接修改文件内容(危险动作) sed 可以直接修改文件的内容，不必使用管道命令或数据流重导向！ 不过，由于这个动作会直接修改到原始的文件，所以请你千万不要随便拿系统配置来测试！ 我们还是使用文件 1.txt 文件来测试看看吧！ 在上述命令的基础上加上参数：-i，即可直接修改文件内容。 原数据 12345678[root@node4 ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 利用 sed 直接在1.txt 最后一行加入：This is the last row 与之前我们的命令相比，只多了个：-i，于是便直接修改了文件内容。 12345678910[root@node4 ~]# sed -i &apos;$a this is the last raw&apos; 1.txt [root@node4 ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHONthis is the last raw[root@node4 ~]# 常用实例1.将本主机上的selinux设为disabled。这样修改需要重启服务器后才生效，所以要加setenforce 0 。 12345678910111213141516171819202122232425262728293031323334353637[root@node4 ~]# cat /etc/selinux/config # This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=enforcing# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection.SELINUXTYPE=targeted [root@node4 ~]# sed -i &apos;s/=enforcing/=disabled/g&apos; /etc/selinux/config[root@node4 ~]# cat /etc/selinux/config # This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=disabled# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection.SELINUXTYPE=targeted [root@node4 ~]# getenforce Enforcing[root@node4 ~]# setenforce 0[root@node4 ~]# getenforce Permissive[root@node4 ~]# 2.查看sshd端口号，修改它，然后改回来。 12345678910111213141516[root@node4 ~]# sed -n &apos;17p&apos; /etc/ssh/sshd_config#Port 22[root@node4 ~]# sed -i &apos;s/#Port 22/Port 4555/g&apos; /etc/ssh/sshd_config [root@node4 ~]# sed -n &apos;17p&apos; /etc/ssh/sshd_configPort 4555[root@node4 ~]# systemctl restart sshd[root@node4 ~]# sed -i &apos;s/Port 4555/#Port 22/g&apos; /etc/ssh/sshd_config [root@node4 ~]# sed -n &apos;17p&apos; /etc/ssh/sshd_config #Port 22[root@node4 ~]# systemctl restart sshd如下，用指定内容二不是指定行来搜索并且显示出来也可以[root@node4 ~]# sed -n &apos;/Port/p&apos; /etc/ssh/sshd_config #Port 22#GatewayPorts no[root@node4 ~]# sed+空行关于空行，sed又有另外的讲究，这里我们来研究一下。 用1.txt作为测试文档 12345678[root@node4 ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 实例解析（下列实例均直接修改文件内容）1.在每行文本后面加一行空行 123456789101112131415[root@node4 ~]# sed -i G 1.txt [root@node4 ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 2.删除文档中所有的空行。其中”^$”表示空行。 123456789[root@node4 ~]# sed -i &apos;/^$/d&apos; 1.txt[root@node4 ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 3.在每行文本后面加两行空行，加完记得删掉 1234567891011121314151617181920212223242526272829[root@node4 ~]# sed -i &apos;G;G&apos; 1.txt [root@node4 ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# sed -i &apos;/^$/d&apos; 1.txt[root@node4 ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 4.在匹配行之前加空行 12345678910[root@node4 ~]# sed -i &apos;/a b c/ &#123;x;p;x&#125;&apos; 1.txt [root@node4 ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 5.在匹配行之后加空行 1234567891011[root@node4 ~]# sed -i &apos;/a b c/ G&apos; 1.txt [root@node4 ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 6.现在a b c d e这行前后都有空行，如果再次给每行加一行空行，a b c d e前后就会各自出现两行空行。现在用一下命令，不管文本内原本有没有空行，都保证文本每行之间只有一个空行。其实说白了也就是先删掉原本存在的所有空行，再给每一行文本后面增加一行空行。 123456789101112131415[root@node4 ~]# sed -i &apos;/^$/d;G&apos; 1.txt [root@node4 ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@node4 ~]# 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-shell-04 shell-脚本四剑客-awk]]></title>
    <url>%2Fshell-04%2F</url>
    <content type="text"><![CDATA[linux-shell-04 shell-脚本四剑客-awk概念解析 AWK是一种处理文本文件的语言，是一个强大的文本分析工具。之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。 awk本身就是一种编程语言，它支持条件判断、循环、数组遍历等功能。我们可以使用它来对文本进行分析和处理。与sed相比，sed是逐行处理文本内数据，awk也是，不过awk又在此基础上实现对每一行每一列的操作。专业的角度来讲awk是一个报告生成器，因为awk可以对行和列进行操作，所以在awk命令下，一个文本就像是一个表格。默认列之间的分隔符是空格，行之间分隔符是\n，可以通过-F或者-v FS:指定分割符。 语法123awk [选项参数] &apos;script&apos; var=value file(s)或awk [选项参数] -f scriptfile var=value file(s) 选项参数说明 1234567891011121314151617181920212223242526272829303132333435363738-F fs or --field-separator fs指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。-v var=value or --asign var=value赋值一个用户定义变量。-f scripfile or --file scriptfile从脚本文件中读取awk命令。-mf nnn and -mr nnn对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。-W compact or --compat, -W traditional or --traditional在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。-W copyleft or --copyleft, -W copyright or --copyright打印简短的版权信息。-W help or --help, -W usage or --usage打印全部awk选项和每个选项的简短说明。-W lint or --lint打印不能向传统unix平台移植的结构的警告。-W lint-old or --lint-old打印关于不能向传统unix平台移植的结构的警告。-W posix打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符**和**=不能代替^和^=；fflush无效。-W re-interval or --re-inerval允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。-W source program-text or --source program-text使用program-text作为源代码，可与-f命令混用。-W version or --version打印bug报告信息的版本。 基本用法用法一 1awk &apos;&#123;pattern + action&#125;&apos; &#123;filenames&#125; 1.基本语法参数1.单引号‘’：为了和shell语法分开，防止混淆，行匹配语句 awk ‘’ 只能用单引号2.大括号{}：用来表示一组命令3.pattern：一个过滤器，表示匹配pattern的条件的行才可以执行action4.pattern可以是以下任意一种-正则表达式：使用通配符匹配-关系表达式：使用关系运算符-模式匹配表达式：使用运算符~或者！~匹配5.action：处理动作，一系列命令，常见的动作为print 实例：每行按空格或TAB分割，输出文本中的1、4项 1234567891011121314151617181920212223[root@localhost ~]# vim 1.txt[root@localhost ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,python[root@localhost ~]# awk &apos;&#123;print $1,$4&#125;&apos; 1.txt 1 46 9a dhello awklanguege [root@localhost ~]# awk &apos;&#123;print $1,$2&#125;&apos; 1.txt 1 26 7a bhello worldlanguege php,java,python [root@localhost ~]# 用法二 1awk -F #-F相当于内置变量FS, 指定分割字符 实例： 使用”,”作为分割字符 12345678[root@localhost ~]# awk -F, &apos;&#123;print $1,$2&#125;&apos; 1.txt 1 2 3 4 5 6 7 8 9 10 a b c d e hello world and awk languege php java [root@localhost ~]# 用法三 1awk -v # 设置变量 实例：设置一个叫做xxx的变量，值为100，那么$1+xxx=每行第一个项加100的和，$1xxx表示每行第一个项与xxx衔接的结果。 12345678910111213141516[root@localhost ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,python[root@localhost ~]# awk -v xxx=100 &apos;&#123;print $1,$1+xxx,$1xxx&#125;&apos; 1.txt 1 101 11006 106 6100a 100 a100hello 100 hello100languege 100 languege100 100 100[root@localhost ~]# 用法四 1awk -f &#123;awk脚本&#125; &#123;文件名&#125; 实例： 12345678910[root@localhost ~]# vim test.awk [root@localhost ~]# cat test.awk #! /usr/bin/awk -fBEGIN &#123; printf &quot;%s&quot;,&quot;Writing my first awk executable script!\n&quot; &#125;[root@localhost ~]# chmod +x test.awk [root@localhost ~]# ./test.awk Writing my first awk executable script![root@localhost ~]# awk -f test.awk Writing my first awk executable script![root@localhost ~]# awk脚本首行都是#! /usr/bin/awk -f，以为awk解释器的路径就是 /usr/bin/awk。 运算符 运算符 描述 = += -= *= /= %= ^= **= 赋值 ?: C条件表达式 \ \ 逻辑或 &amp;&amp; 逻辑与 ~ ~! 匹配正则表达式和不匹配正则表达式 &lt; &lt;= &gt; &gt;= != == 关系运算符 空格 连接 + - 加，减 * / % 乘，除与求余 + - ! 一元加，减和逻辑非 ^ *** 求幂 ++ – 增加或减少，作为前缀或后缀 $ 字段引用 in 数组成员 运算符实例过滤出第一列大于2的行 12345678910111213[root@localhost ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,python[root@localhost ~]# awk &apos;$1&gt;2&apos; 1.txt 6 7 8 9 10a b c d ehello world and awklanguege php,java,python[root@localhost ~]# 过滤第一列等于6的行 123[root@localhost ~]# awk &apos;$1==6&apos; 1.txt 6 7 8 9 10[root@localhost ~]# 过滤第一列大于2并且第二列等于7的行 123[root@localhost ~]# awk &apos;$1&gt;2&amp;&amp; $2==7&apos; 1.txt 6 7 8 9 10[root@localhost ~]# 使用正则，字符串匹配输出第二列包含 “python”的那一行的第1列与第2列。 123[root@localhost ~]# awk &apos;$2 ~ /python/ &#123;print $1,$2&#125;&apos; 1.txt languege php,java,python[root@localhost ~]# 注意：~ 表示模式开始。// 中是模式。 输出包含”java” 的行 123[root@localhost ~]# awk &apos;/java/&apos; 1.txt languege php,java,python[root@localhost ~]# 给1.txt增加一行大写内容 123456789[root@promote ~]# vim 1.txt[root@promote ~]# cat 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awklanguege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@promote ~]# 输出包含java的行，不区分大小写 1234567[root@promote ~]# awk &apos;BEGIN&#123;IGNORECASE=1&#125; /java/&apos; 1.txt languege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@promote ~]# awk &apos;BEGIN&#123;IGNORECASE=1&#125; /JavA/&apos; 1.txt languege php,java,pythonLANGUEGE PHP,JAVA,PYTHON[root@promote ~]# 输出不包含java的行，不区分大小写 123456[root@promote ~]# awk &apos;BEGIN&#123;IGNORECASE=1&#125; !/JavA/&apos; 1.txt 1 2 3 4 56 7 8 9 10a b c d ehello world and awk[root@promote ~]# awk脚本helloworld 12345678[root@promote ~]# vim a.awk[root@promote ~]# cat a.awk #!/bin/awk -fBEGIN &#123; print &quot;Hello, world!&quot; &#125;[root@promote ~]# chmod +x a.awk [root@promote ~]# ./a.awk Hello, world![root@promote ~]# 关于awk脚本，我们需要注意两个关键词BEGIN和END。 BEGIN{ 这里面放的是执行前的语句 } END {这里面放的是处理完所有的行后要执行的语句 } 中间{这里面放的是处理每一行时要执行的语句} 12345[root@node4 ~]# cat a.awk #!/bin/awk -fBEGIN &#123; print &quot;before execute&quot; &#125;&#123; print &quot;now is executing&quot; &#125;END &#123; print &quot;after execute&quot;&#125; 执行结果如下： 敲回车后进入到中间部分的代码 可是现在无论如何敲回车，也没有办法退出该部分代码，进入不到end部分。原因是执行脚本的时候没有参数。 先建一个2.txt作为测试对象 1234[root@node4 ~]# cat 2.txt 1 2 3 4 56 7 8 9 10[root@node4 ~]# 修改脚本，然后执行 123456789101112131415161718[root@node4 ~]# vim a.awk [root@node4 ~]# cat a.awk #!/bin/awk -fBEGIN &#123; printf &quot;before execute\n&quot; &#125;&#123; printf &quot;now is executing, print_file_content:\n&quot;printf $0printf &quot;\n&quot;&#125;END &#123; printf &quot;after execute\n&quot;&#125;[root@node4 ~]# awk -f a.awk 2.txt before executenow is executing, print_file_content:1 2 3 4 5now is executing, print_file_content:6 7 8 9 10after execute[root@node4 ~]# awk用于分割字符串awk在写脚本的时候，用得比较多的是awk -F来切割字符串的场景。 12345678910111213141516171819202122#默认情况下awk以空格作为分隔符[root@localhost ~]# echo &quot;hello world&quot; | awk &apos;&#123;print $1;print $2&#125;&apos;helloworld[root@localhost ~]# #awk -F可以指定分隔符[root@localhost ~]# echo &quot;age:23 color:red&quot; | awk -F &apos;:&apos; &apos;&#123;print $1;print $2;print $3&#125;&apos;age23 colorred[root@localhost ~]# #如何同时取出&quot;age:23 color:red&quot;里面的 “23”和“red”值呢？[root@localhost ~]# echo &quot;age:23 color:red&quot; | awk &apos;&#123;print $1;print $2&#125;&apos;age:23color:red[root@localhost ~]# echo &quot;age:23 color:red&quot; | awk &apos;&#123;print $1;print $2&#125;&apos; | awk -F &apos;:&apos; &apos;&#123;print $2&#125;&apos;23red[root@localhost ~]# awk支持多个记录分隔符的写法1234567891011121314151617181920212223#如何同时取出&quot;age:23 color:red&quot;里面的 “23”和“red”值呢？[root@localhost ~]# echo &quot;age:23 color:red&quot; | awk -F &apos;[ :]&apos; &apos;&#123;print $2;print $4&#125;&apos;23red[root@localhost ~]# 注意，上面这条命令中，&apos;[ :]&apos;表示分隔符是空格和冒号。#上面的分割方式一般不常用，因为文档里有可能出现两个分割服恰好在一起的情况[root@localhost ~]# echo &quot;age:23 : : color:red&quot; | awk -F &apos;[ :]&apos; &apos;&#123;print $2;print $4&#125;&apos;23[root@localhost ~]# 此时输出的$4就是一个空格了，显然“ : : ”在这里是算5次分割，而不是1次。#&apos;[ :]+&apos;比之前多了一个加号，表明将连续出现的记录分隔符当做一个来处理，这个比较常用[root@localhost ~]# echo &quot;age:23 : : color:red&quot; | awk -F &apos;[ :]+&apos; &apos;&#123;print $2;print $4&#125;&apos;23red[root@localhost ~]# 多个分隔符之间用管道符隔开 12345678910111213141516171819202122#注意分割后的段数为NF[root@localhost ~]# echo &quot;abc 1 def 1 ghi 1 jkl&quot; | awk -F &apos;1&apos; &apos;&#123;print &quot;切割后段数为：&quot; NF&#125;&apos;切割后段数为：4[root@localhost ~]# #如何以one和two为分割符，换行输出句子里的其他部分。[root@localhost ~]# echo &quot;i have one pen and i have two cups&quot; | awk -F &apos;one|two&apos; &apos;&#123;for(i=1;i&lt;=NF;i++)print $i&#125;&apos;i have pen and i have cups[root@localhost ~]# #如何以one和two和three为分割符，换行输出句子里的其他部分。[root@localhost ~]# echo &quot;i have one pen and i have two cups and i have three apples&quot; | awk -F &apos;one|two|three&apos; &apos;&#123;for(i=1;i&lt;=NF;i++)print $i&#125;&apos;i have pen and i have cups and i have apples[root@localhost ~]# 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-shell-03 shell-脚本四剑客-grep+正则表达式]]></title>
    <url>%2Fshell-03%2F</url>
    <content type="text"><![CDATA[linux-shell-03 shell-脚本四剑客-grep+正则表达式概念解析grep Linux grep命令用于查找文件里符合条件的字符串。grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为”-“，则grep指令会从标准输入设备读取数据。grep是一种强大的文本搜索工具，可以与正则表达式配合搜索文本，并把匹配的行打印出来。 正则表达式 正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，模式描述在搜索文本时要匹配的一个或多个字符串。总之，正则表达式就是为了处理大量的文本|字符串而定义的一套规则和方法。通过定义的这些特殊符号的辅助，系统管理员就可以快速过滤，替换或输出需要的字符串。Linux正则表达式一般以行为单位处理。 在linux运维工作中，针对大量过滤日志工作，正则表达式可以化繁为简，用起来简单、高效。 grep参数123456789101112131415161718192021222324252627-a 或 --text : 不要忽略二进制的数据。-A&lt;显示行数&gt; 或 --after-context=&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。-b 或 --byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。-B&lt;显示行数&gt; 或 --before-context=&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。-c 或 --count : 计算符合样式的列数。-C&lt;显示行数&gt; 或 --context=&lt;显示行数&gt;或-&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前后的内容。-d &lt;动作&gt; 或 --directories=&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。-e&lt;范本样式&gt; 或 --regexp=&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。-E 或 --extended-regexp : 将样式为延伸的普通表示法来使用。-f&lt;规则文件&gt; 或 --file=&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。-F 或 --fixed-regexp : 将样式视为固定字符串的列表。-G 或 --basic-regexp : 将样式视为普通的表示法来使用。-h 或 --no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。-H 或 --with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。-i 或 --ignore-case : 忽略字符大小写的差别。-l 或 --file-with-matches : 列出文件内容符合指定的样式的文件名称。-L 或 --files-without-match : 列出文件内容不符合指定的样式的文件名称。-n 或 --line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。-o 或 --only-matching : 只显示匹配PATTERN 部分。-q 或 --quiet或--silent : 不显示任何信息。-r 或 --recursive : 此参数的效果和指定&quot;-d recurse&quot;参数相同。-s 或 --no-messages : 不显示错误信息。-v 或 --revert-match : 显示不包含匹配文本的所有行。-V 或 --version : 显示版本信息。-w 或 --word-regexp : 只显示全字符合的列。-x --line-regexp : 只显示全列符合的列。-y : 此参数的效果和指定&quot;-i&quot;参数相同。 正则表达式字符12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273\：将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\\n”匹配\n。“\n”匹配换行符。序列“\\”匹配“\”而“\(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。^：匹配输入字行首。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。$：匹配输入行尾。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。*：匹配前面的子表达式任意次。例如，zo*能匹配“z”，也能匹配“zo”以及“zoo”。*等价于&#123;0,&#125;。+：匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于&#123;1,&#125;。?：匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”。?等价于&#123;0,1&#125;。&#123;n&#125;：n是一个非负整数。匹配确定的n次。例如，“o&#123;2&#125;”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。&#123;n,&#125;：n是一个非负整数。至少匹配n次。例如，“o&#123;2,&#125;”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o&#123;1,&#125;”等价于“o+”。“o&#123;0,&#125;”则等价于“o*”。&#123;n,m&#125;：m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o&#123;1,3&#125;”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o&#123;0,1&#125;”等价于“o?”。请注意在逗号和两个数之间不能有空格。?：当该字符紧跟在任何一个其他限制符（*,+,?，&#123;n&#125;，&#123;n,&#125;，&#123;n,m&#125;）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少地匹配所搜索的字符串，而默认的贪婪模式则尽可能多地匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多地匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少地匹配“o”，得到结果 [&apos;o&apos;, &apos;o&apos;, &apos;o&apos;, &apos;o&apos;].：匹配除“\n”和&quot;\r&quot;之外的任何单个字符。要匹配包括“\n”和&quot;\r&quot;在内的任何字符，请使用像“[\s\S]”的模式。(pattern)：匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。(?:pattern)：非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分时很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。(?=pattern)：非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?!pattern)：非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。(?&lt;=pattern)：非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。(?&lt;!patte_n)：非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。x|y：匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[z|f]ood”则匹配“zood”或“food”。[xyz]：字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。[^xyz]：负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”任一字符。[a-z]：字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身[^a-z]：负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。\b：匹配一个单词的边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”；“\b1_”可以匹配“1_23”中的“1_”，但不能匹配“21_3”中的“1_”。\B：匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。\cx：匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。\d：匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持\D：匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持\f：匹配一个换页符。等价于\x0c和\cL。\n：匹配一个换行符。等价于\x0a和\cJ。\r：匹配一个回车符。等价于\x0d和\cM。\s：匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。\S：匹配任何可见字符。等价于[^ \f\n\r\t\v]。\t：匹配一个制表符。等价于\x09和\cI。\v：匹配一个垂直制表符。等价于\x0b和\cK。\w：匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的&quot;单词&quot;字符使用Unicode字符集。\W：匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 正则表达式匹配实例12345匹配手机号码：^1[3|4|5|7|8][0-9]&#123;9&#125;$匹配IP地址：[0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125; 不准确匹配电子邮箱：/^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.&#123;1,2&#125;[a-z]+)+$/匹配URL：/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\/\w \.-]*)*\/?$/匹配6-18位的密码：/^[a-z0-9_-]&#123;6,18&#125;$/ 正则表达式的分类POSIX规范将正则表达式的分为了两种 基本正则表达式（BRE，basic regular expression） 高级功能：扩展正则表达式（ERE，extended regular expression） BRE和ERE的区别仅仅是元字符的不同 BRE（基础正则表达式）只承认的元字符有^$.[]*其他字符识别为普通字符：() ERE(扩展正则表达式）则添加了（）{}?+|等 只有在用反斜杠“”进行转义的情况下，字符（）{}才会在BRE被当作元字符处理，而ERE中，任何元符号前面加上反斜杠反而会使其被当作普通字符来处理。 如何区分通配符和正则表达式 不需要思考的判断方法：在三剑客awk，sed，grep，egrep都是正则，其他都是通配符 区别通配符和正则表达式最简单的方法： 12（1）文件目录名===&gt;通配符（2）文件内容（字符串，文本【文件】内容）===&gt;正则表达式 3.通配符和正则表达式都有“*”，“?”，“【】”，但是通配符的这些符号都能自身代表任意字符，而正则表达式的这些符号只能代表这些符号前面的字符 实例解析注意：grep严格区分大小写，如下例中，grep SELINUX是有结果的，而grep selinux却没有结果。 1.在当前目录下查找config文件中带有SELINUX字符串的行并打印出来。 12345678910111213141516171819202122232425[root@localhost ~]# cd /etc/selinux[root@localhost selinux]# lsconfig final semanage.conf targeted tmp[root@localhost selinux]# cat config # This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=enforcing# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection.SELINUXTYPE=targeted [root@localhost selinux]# grep SELINUX config # SELINUX= can take one of these three values:SELINUX=enforcing# SELINUXTYPE= can take one of three two values:SELINUXTYPE=targeted [root@localhost selinux]# grep selinux config [root@localhost selinux]# 2.在当前目录下针对文件名中含有“onfi”字样的文件，查找该文件中带有SELINUX字符串的行并打印出来。 12345678[root@localhost selinux]# lsconfig final semanage.conf targeted tmp[root@localhost selinux]# grep SELINUX *onfi* # SELINUX= can take one of these three values:SELINUX=enforcing# SELINUXTYPE= can take one of three two values:SELINUXTYPE=targeted [root@localhost selinux]# 其实，含有“onfi”字样的文件只有一个，那就是config。这里的 1*onfi* 之中的*号就是个用于匹配字符的正则表达式。如下，这样也是可以的： 123456[root@localhost selinux]# grep SELINUX *nfi* # SELINUX= can take one of these three values:SELINUX=enforcing# SELINUXTYPE= can take one of three two values:SELINUXTYPE=targeted [root@localhost selinux]# 3.反向查找。查找config文件中没有SELINUX字符串的行并打印出来 123456789101112[root@localhost selinux]# grep -v SELINUX config # This file controls the state of SELinux on the system.# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection.[root@localhost selinux]# 4.递归查找。查找/etc/selinux目录下所有文件及其子目录（如果有的话）中所有文件中包含字符串“SELINUXTYPE”的文件，并且打印出该字符串所在行的内容。 12345[root@localhost selinux]# cd[root@localhost ~]# grep -r SELINUXTYPE /etc/selinux//etc/selinux/config:# SELINUXTYPE= can take one of three two values:/etc/selinux/config:SELINUXTYPE=targeted [root@localhost ~]# 5.grep结合管道符|也可以使用。在当前目录下查找config文件中带有SELINUX字符串的行并打印出来。 1234[root@localhost selinux]# cat config | grep SELINUXTYPE# SELINUXTYPE= can take one of three two values:SELINUXTYPE=targeted [root@localhost selinux]# 6.其他例子： 1234567891011121314151617181920212223[root@localhost selinux]# cat config # This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=enforcing# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection.SELINUXTYPE=targeted [root@localhost selinux]# grep &quot;^S&quot; config #表示以S开头的行SELINUX=enforcingSELINUXTYPE=targeted [root@localhost selinux]# [root@localhost selinux]# grep &quot;g$&quot; config #表示以g结尾的行SELINUX=enforcing[root@localhost selinux]# 12345678910111213[root@localhost selinux]# grep &quot;[a-d]&quot; config #表示有匹配a-d字符的行# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=enforcing# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection.SELINUXTYPE=targeted [root@localhost selinux]# 效果其实是有高亮的，一目了然： 1234567[root@localhost selinux]# grep &quot;[a-d][a-d]&quot; config #表示匹配连续两个a-d的字符所在的行# SELINUX= can take one of these three values:# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.# SELINUXTYPE= can take one of three two values:# minimum - Modification of targeted policy. Only selected processes are protected. [root@localhost selinux]# 以此类推可以匹配连续三个、四个、多个a-d的字符所在的行。 匹配以大写字母开头的行 1234[root@localhost selinux]# grep &quot;^[A-Z]&quot; config SELINUX=enforcingSELINUXTYPE=targeted [root@localhost selinux]# 匹配enforcing或者targeted所在的行 12345[root@localhost selinux]# grep -E &quot;enforcing | targeted&quot; config # enforcing - SELinux security policy is enforced.# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected. [root@localhost selinux]# 常用实例1.显示selinux配置文件中非注释的所有行（-v表示取反，^表示首行） 1234567[root@node4 ~]# grep -v ^# /etc/selinux/config SELINUX=disabledSELINUXTYPE=targeted [root@node4 ~]# 2.统计文本中某单词的出现的次数 1234567[root@localhost ~]# echo &quot;abc 1 def 1 ghi 1 jkl&quot; | grep -o &apos;1&apos;111[root@localhost ~]# echo &quot;abc 1 def 1 ghi 1 jkl&quot; | grep -o &apos;1&apos; | wc -l3[root@localhost ~]# 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-shell-02 shell-脚本四剑客-find]]></title>
    <url>%2Fshell-02%2F</url>
    <content type="text"><![CDATA[linux-shell-02 shell-脚本四剑客-find概念解析 Linux的find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。 语法12345find path -option [ -print ] [ -exec -ok command ] &#123;&#125; \;-print ：表示find命令将匹配的文件输出到标准输出中，默认执行该命令-exec ：表示find命令对匹配的文件执行该参数给出的shell命令。相应命令的形式为 cmd &#123;&#125; \;-ok ：它的作用和-exec一样，只是需要用户交互，更安全 其中，-exec 可以理解为承接命令。 其用法格式： -exec [命令] {} \; 查找文件后跟-exec表示承接，后跟要操作的命令 {}:查找到的结果，\;反斜杠分号结尾。 例如： 123find . -name &quot;*.txt&quot; #查找当前目录下所有以.txt结尾的文件find . -name &quot;*.txt&quot; -exec mv &#123;&#125; /document/ \; #查找当前目录下所有以.txt结尾的文件并移到/document目录下 参数说明option参数说明 1234567891011121314151617181920212223242526-name ：按照文件名查找文件-perm ：按照权限查找文件-prune ：使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略-user ： 按照文件属主来查找文件-group ：按照文件数组来查找文件-mtime -n +n ：按照文件的更改时间来查找文件 -n ：表示从此刻算起，文件的更改是在n天以内 +n ：表示文件的更改时间是在n天以前-atime -n +n ： 按文件访问时间来查询-ctime -n +n ：按文件创建时间来查询 -nogroup ：查找无有效属组的文件，即该文件所属的组在/etc/groups中不存在-nouser :：查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在-newer file1 ！ file2 :查找更改时间比file1新但比file2旧的文件-type b：表示块设备文件 block d：表示目录 directory c：表示字符设备文件 char p：表示管道文件 pipe l：表示符号链接文件 link f：表示普通文件 file-depth ：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找-fstype ：表示查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息-mount ：表示在查找文件时不跨越文件系统的mount点-follow ：表示如果find命令遇到符号链接文件，就跟踪至链接所指向的文件-cpio ：表示对匹配的文件使用cpio命令，将这些文件备份至磁带设备中-size n : 文件大小是n。单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。 举例分析把原本在test1里面的三个txt文件转移到test2里面。 12345678910111213141516[root@localhost ~]# mkdir test1 test2[root@localhost ~]# [root@localhost ~]# cd test1[root@localhost test1]# touch 1.txt 2.txt 3.txt[root@localhost test1]# ls1.txt 2.txt 3.txt[root@localhost test1]# find . -name &quot;*.txt&quot; #查找当前目录下所有以.txt结尾的文件./1.txt./2.txt./3.txt[root@localhost test1]# find . -name &quot;*.txt&quot; -exec mv &#123;&#125; /root/test2/ \;[root@localhost test1]# ls[root@localhost test1]# cd /root/test2[root@localhost test2]# ls1.txt 2.txt 3.txt[root@localhost test2]# 查找当前目录下大小等于0k的普通文件，并在删除之前询问它们： 123456789[root@localhost test2]# ls1.txt 2.txt 3.txt[root@localhost test2]# find . -type f -size 0k -ok rm &#123;&#125; \;&lt; rm ... ./1.txt &gt; ? y&lt; rm ... ./2.txt &gt; ? y&lt; rm ... ./3.txt &gt; ? n[root@localhost test2]# ls3.txt[root@localhost test2]# 查找当前目录中，文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件： 说白了也就是查找664权限的文件 1234567891011121314151617[root@localhost test2]# ll总用量 0-rw-r--r--. 1 root root 0 4月 15 10:37 3.txt#一开始是3.txt权限是644[root@localhost test2]# find . -type f -perm 644 -exec ls -l &#123;&#125; \;-rw-r--r--. 1 root root 0 4月 15 10:37 ./3.txt[root@localhost test2]# find . -type f -perm 755 -exec ls -l &#123;&#125; \;[root@localhost test2]##将3.txt权限改为755[root@localhost test2]# chmod 755 3.txt [root@localhost test2]# find . -type f -perm 755 -exec ls -l &#123;&#125; \;-rwxr-xr-x. 1 root root 0 4月 15 10:37 ./3.txt[root@localhost test2]# find . -type f -perm 644 -exec ls -l &#123;&#125; \;[root@localhost test2]# 查找/root/test目录下以.txt结尾并且创建时间在1天以内的文件 1234[root@localhost test2]# cd[root@localhost ~]# find /root/test2 -name &quot;*.txt&quot; -ctime -1/root/test2/3.txt[root@localhost ~]# 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-shell-01 shell-基础学习]]></title>
    <url>%2Fshell-01%2F</url>
    <content type="text"><![CDATA[linux-shell-01 shell-基础学习概念解析shell Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。 实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，Shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。 Shell本身是一个用C语言编写的程序，它是用户使用Linux的桥梁。Shell既是一种命令语言，又是一种程序设计语言。作为命令语言，它交互式地解释和执行用户输入的命令；作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。 它虽然不是Linux系统核心的一部分，但它调用了系统核心的大部分功能来执行程序、建立文件并以并行的方式协调各个程序的运行。因此，对于用户来说，shell是最重要的实用程序，深入了解和熟练掌握shell的特性极其使用方法，是用好Linux系统的关键。 可以说，shell使用的熟练程度反映了用户对Linux使用的熟练程度。 shell脚本优点• 简单性：Shell是一个高级语言；通过它，你可以简洁地表达复杂的操作。• 可移植性：使用POSIX所定义的功能，可以做到脚本无须修改就可在不同的系统上执行。• 开发容易：可以在短时间内完成一个功能强大又妤用的脚本。 shell脚本当命令不在命令行中执行，而是从一个文件中执行时，该文件就称为 Shell 脚本。• Shell 脚本是纯文本文件。• Shell 脚本通常以 .sh 作为后缀名，但不是必须。• Shell 脚本是以行为单位的，在执行脚本的时候会分解成一行一行依次执行。• Shell 是一种功能强大的解释型编程语言，通常用于完成特定的、较复杂的系统管理任务。•Shell 脚本语言非常擅长处理文本类型的数据 基础入门由于本篇文章和之前的文章实验内容会有大量重复，所以按照之前的这篇文章把命令敲一遍就差不多了。 https://zhongeagles.github.io/linux-09/ 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-keepalived-05 keepalived+HAProxy+Mysql（双主）部署]]></title>
    <url>%2Fkeepalived-05%2F</url>
    <content type="text"><![CDATA[linux-keepalived-05 keepalived+HAProxy+Mysql（双主）部署环境准备node1（HAProxy1+keepalived主）：192.168.141.53node2（HAProxy2+keepalived从）：192.168.141.69node3（Mysql1主）：192.168.141.12node4（Mysql2主）：192.168.141.132VIP：192.168.10.100 Mysql部署（双主）node3 1234567891011121314151617181920212223242526272829303132333435363738394041[root@node3 ~]# vim node3.sh[root@node3 ~]# cat node3.sh #!/bin/bashIp_addr=&quot;192.168.141.132&quot; # 修改为对端的node地址User_pwd=&quot;000000&quot;systemctl stop firewalldsetenforce 0yum install mariadb-server -ysed -i &apos;/^\[mysqld\]$/a\binlog-ignore = information_schema&apos; /etc/my.cnf.d/server.cnfsed -i &apos;/^\[mysqld\]$/a\binlog-ignore = mysql&apos; /etc/my.cnf.d/server.cnfsed -i &apos;/^\[mysqld\]$/a\skip-name-resolve&apos; /etc/my.cnf.d/server.cnfsed -i &apos;/^\[mysqld\]$/a\auto-increment-increment = 1&apos; /etc/my.cnf.d/server.cnf # 注意node4节点上必须不同sed -i &apos;/^\[mysqld\]$/a\log-bin = mysql-bin&apos; /etc/my.cnf.d/server.cnfsed -i &apos;/^\[mysqld\]$/a\auto_increment_offset = 1&apos; /etc/my.cnf.d/server.cnf # 注意node4节点上必须不同sed -i &apos;/^\[mysqld\]$/a\server-id = 1&apos; /etc/my.cnf.d/server.cnf # 注意node4节点上必须不同systemctl restart mariadbmysql -uroot -e &quot;grant replication slave on *.* to &apos;repuser&apos;@&apos;$Ip_addr&apos; identified by &apos;$User_pwd&apos;;&quot;[root@node3 ~]# chmod +x ./node3.sh [root@node3 ~]# ./node3.sh node4:[root@node4 ~]# vim node4.sh[root@node4 ~]# cat node4.sh #!/bin/bashIp_addr=&quot;192.168.141.12&quot; # 修改为对端的node地址User_pwd=&quot;000000&quot;systemctl stop firewalldsetenforce 0yum install mariadb-server -ysed -i &apos;/^\[mysqld\]$/a\binlog-ignore = information_schema&apos; /etc/my.cnf.d/server.cnfsed -i &apos;/^\[mysqld\]$/a\binlog-ignore = mysql&apos; /etc/my.cnf.d/server.cnfsed -i &apos;/^\[mysqld\]$/a\skip-name-resolve&apos; /etc/my.cnf.d/server.cnfsed -i &apos;/^\[mysqld\]$/a\auto-increment-increment = 2&apos; /etc/my.cnf.d/server.cnf # 注意node3节点上必须不同sed -i &apos;/^\[mysqld\]$/a\log-bin = mysql-bin&apos; /etc/my.cnf.d/server.cnfsed -i &apos;/^\[mysqld\]$/a\auto_increment_offset = 2&apos; /etc/my.cnf.d/server.cnf # 注意node3节点上必须不同sed -i &apos;/^\[mysqld\]$/a\server-id = 2&apos; /etc/my.cnf.d/server.cnf # 注意node3节点上必须不同systemctl restart mariadbmysql -uroot -e &quot;grant replication slave on *.* to &apos;repuser&apos;@&apos;$Ip_addr&apos; identified by &apos;$User_pwd&apos;;&quot;[root@node4 ~]# chmod +x ./node4.sh [root@node4 ~]# ./node4.sh 初始化数据库，初始密码为空，直接回车即可。然后设置数据库root密码为123456，之后一路敲y回车即可。node3如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[root@node3 ~]# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&apos;ll need the currentpassword for the root user. If you&apos;ve just installed MariaDB, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] yNew password: Re-enter new password: Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from &apos;localhost&apos;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] y ... Success!By default, MariaDB comes with a database named &apos;test&apos; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you&apos;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB![root@node3 ~]# node4如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[root@node4 ~]# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&apos;ll need the currentpassword for the root user. If you&apos;ve just installed MariaDB, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] yNew password: Re-enter new password: Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from &apos;localhost&apos;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] y ... Success!By default, MariaDB comes with a database named &apos;test&apos; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you&apos;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB![root@node4 ~]# 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576[root@node3 ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 12Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; show master status;+------------------+----------+--------------+--------------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+--------------------------+| mysql-bin.000003 | 1642 | | mysql,information_schema |+------------------+----------+--------------+--------------------------+1 row in set (0.00 sec)MariaDB [(none)]&gt; 查询node4节点master状态[root@node4 ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 11Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; show master status;+------------------+----------+--------------+--------------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+--------------------------+| mysql-bin.000003 | 1721 | | mysql,information_schema |+------------------+----------+--------------+--------------------------+1 row in set (0.00 sec)MariaDB [(none)]&gt;在node3节点执行连接命令：MariaDB [(none)]&gt; change master to master_host=&apos;192.168.141.132&apos;,master_port=3306,master_user=&apos;repuser&apos;,master_password=&apos;000000&apos;,master_log_file=&apos;mysql-bin.000003&apos;,master_log_pos=1642;Query OK, 0 rows affected (0.01 sec)MariaDB [(none)]&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [mysql]&gt; start slave;Query OK, 0 rows affected (0.00 sec)MariaDB [mysql]&gt; 在node4节点执行连接命令：MariaDB [(none)]&gt; change master to master_host=&apos;192.168.141.12&apos;,master_port=3306,master_user=&apos;repuser&apos;,master_password=&apos;000000&apos;,master_log_file=&apos;mysql-bin.000003&apos;,master_log_pos=1721;Query OK, 0 rows affected (0.02 sec)MariaDB [(none)]&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [mysql]&gt; start slave;Query OK, 0 rows affected (0.00 sec)MariaDB [mysql]&gt; 注意：master_user=’repuser’,master_password=’000000’设置的用户名密码， master_log_file=’mysql-bin.000003’,master_log_pos=1721中的值对应的是上面的File和Position的值。 HAProxy部署在node1和node2上执行以下脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667[root@node1 ~]# vim node1_haproxy.sh[root@node1 ~]# cat node1_haproxy.sh #!/bin/bashyum install haproxy -ymv /etc/haproxy/haproxy.cfg&#123;,.bak&#125;cat &gt; /etc/haproxy/haproxy.cfg &lt;&lt; EOFglobal log 127.0.0.1 local2 chroot /var/lib/haproxy pidfile /var/run/haproxy.pid maxconn 4000 user haproxy group haproxy daemon stats socket /var/lib/haproxy/statslisten mysql_proxy bind 0.0.0.0:3306 mode tcp balance source server mysqldb1 192.168.141.12:3306 weight 1 check server mysqldb2 192.168.141.132:3306 weight 2 checklisten stats mode http bind 0.0.0.0:8080 stats enable stats uri /dbs stats realm haproxy\ statistics stats auth admin:adminEOFsystemctl start haproxy[root@node1 ~]# chmod +x node1_haproxy.sh [root@node1 ~]# ./node1_haproxy.sh node2和node1脚本内容是一样的[root@node2 ~]# vim node2_haproxy.sh[root@node2 ~]# cat node2_haproxy.sh #!/bin/bashyum install haproxy -ymv /etc/haproxy/haproxy.cfg&#123;,.bak&#125;cat &gt; /etc/haproxy/haproxy.cfg &lt;&lt; EOFglobal log 127.0.0.1 local2 chroot /var/lib/haproxy pidfile /var/run/haproxy.pid maxconn 4000 user haproxy group haproxy daemon stats socket /var/lib/haproxy/statslisten mysql_proxy bind 0.0.0.0:3306 mode tcp balance source server mysqldb1 192.168.141.12:3306 weight 1 check server mysqldb2 192.168.141.132:3306 weight 2 checklisten stats mode http bind 0.0.0.0:8080 stats enable stats uri /dbs stats realm haproxy\ statistics stats auth admin:adminEOFsystemctl start haproxy[root@node2 ~]# chmod +x ./node2_haproxy.sh [root@node2 ~]# ./node2_haproxy.sh 注意：bind 0.0.0.0:8080指的是8080端口 stats auth admin:admin表示haproxy的用户名密码均为admin 测试haproxy的可用性 node1 node2 测试成功，成功登录上了haproxy的服务界面 Keepalived部署这个脚本建立在node1上即可，node2不需要。 12345678910111213[root@node1 ~]# vim /usr/local/src/check_proxy_pid.sh[root@node1 ~]# cat /usr/local/src/check_proxy_pid.sh#!/bin/bashA=`ps -C haproxy --no-header |wc -l` if [ $A == 0 ];then exit 1 else exit 0 fi[root@node1 ~]# cd /usr/local/src/[root@node1 src]# chmod +x ./check_proxy_pid.sh [root@node1 src]# cd[root@node1 ~]# 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071node1上执行脚本：[root@node1 ~]# vim node1_keepalived.sh [root@node1 ~]# cat node1_keepalived.sh #!/bin/bashyum install keepalived -ymv /etc/keepalived/keepalived.conf&#123;,.bak&#125;cat &gt; /etc/keepalived/keepalived.conf &lt;&lt; EOF! Configuration File for keepalivedglobal_defs &#123; router_id node1&#125;vrrp_script chk_http_port &#123; script &quot;/usr/local/src/check_proxy_pid.sh&quot; interval 1 weight -20&#125;vrrp_instance VI_1 &#123; state MASTER interface ens33 virtual_router_id 10 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; track_script &#123; chk_http_port &#125; virtual_ipaddress &#123; 192.168.141.100 &#125;&#125;EOFsystemctl start keepalivedsystemctl stop firewalld[root@node1 ~]# chmod +x node1_keepalived.sh [root@node1 ~]# ./node1_keepalived.sh node2上执行脚本：[root@node2 ~]# vim node2_keepalived.sh[root@node2 ~]# cat node2_keepalived.sh #!/bin/bashyum install keepalived -ymv /etc/keepalived/keepalived.conf&#123;,.bak&#125;cat &gt; /etc/keepalived/keepalived.conf &lt;&lt; EOF! Configuration File for keepalivedglobal_defs &#123; router_id node2&#125;vrrp_instance VI_1 &#123; state MASTER interface ens33 virtual_router_id 10 priority 90 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.141.100 &#125;&#125;EOFsystemctl start keepalivedsystemctl stop firewalld[root@node2 ~]# chmod +x ./node2_keepalived.sh [root@node2 ~]# ./node2_keepalived.sh 测试测试vip的可用性，访问http://192.168.141.100:8080/dbs 用户名密码均为admin 可以看到vip是可用的。 检测keepalived的vip是否可以正常漂移 首先记住要关闭node1和node2的防火墙！ 12[root@node1 ~]# systemctl stop firewalld[root@node2 ~]# systemctl stop firewalld node1 12345678910111213141516[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# node2 1234567891011121314[root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 停止node1的Keepalived服务，观察VIP是否漂移，访问正常 123456789101112131415[root@node1 ~]# systemctl stop keepalived[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# 可以看到vip现在已经转移到了node2上面 12345678910111213141516[root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 测试漂移后的vip的可用性 由于keepalived主设备的选举默认是抢占模式的，所以我们重启node1的keepalived之后，vip能够重新自node2上面漂移回到node1上面。 1234567891011121314151617[root@node1 ~]# systemctl restart keepalived[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# 可以看到vip已经漂移回到node1上了 1234567891011121314[root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 停止node1节点上的HAProxy服务，观察VIP是否漂移，vip是否还能正常访问 123456789101112131415161718192021222324252627282930313233[root@node1 ~]# systemctl stop haproxy[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# [root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 可以看到vip正常漂移到了node2上面，而且vip仍然可以正常访问 然后重启node1节点上的HAProxy服务，观察VIP是否漂移回来，vip是否还能正常访问 1234567891011121314151617181920212223242526272829303132333435[root@node1 ~]# systemctl restart haproxy[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# [root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 可以看到vip漂移回到了node1上面，而且vip仍然可以正常访问。 现在开始检测haproxy对后端两台mysql服务器的监控 开启node3的mariadb服务 12[root@node3 ~]# systemctl restart mariadb[root@node3 ~]# systemctl enable mariadb 再看监控界面，可以看到mysqldb1那一行变成了绿色 同理，将node4的mariadb服务也开启一下 12[root@node4 ~]# systemctl restart mariadb[root@node4 ~]# systemctl enable mariadb 再看监控界面，可以看到mysqldb2那一行也变成了绿色 因此，当node3或者node4的mariadb服务发生异常的时候，我们可以通过监控界面及时发现。 接下来进行mysql远程连接测试 先在360软件管家下载一个navicat 可以看到它的有效期是14天，很鸡肋，这是百度经验上如何激活navicat的教程，亲测有效 https://jingyan.baidu.com/article/495ba841b239e638b20ede4a.html 先在node3上的mysql里创建test用户 12345678910111213141516171819202122232425262728[root@node3 ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 6Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; create user test@localhost identified by &apos;123456&apos;;MariaDB [(none)]&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [mysql]&gt; select Host,User,Password from user where User= &apos;test&apos;;+-----------+------+-------------------------------------------+| Host | User | Password |+-----------+------+-------------------------------------------+| localhost | test | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |+-----------+------+-------------------------------------------+1 row in set (0.01 sec)MariaDB [mysql]&gt; MariaDB [mysql]&gt; quitBye[root@node3 ~]# 授权允许任意远程主机以test的身份连接node3的数据库 12345678910111213141516171819202122[root@node3 ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 7Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; update mysql.user set host = &apos;%&apos; where user =&apos;test&apos; limit 1;Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 1MariaDB [(none)]&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; quitBye[root@node3 ~]# systemctl restart mariadb.service #如果是阿里云服务器，这里会让比输入服务器的root密码进行验证，而且如果你不放行阿里云服务器的3306端口的话，是无法用navicat连接上服务器上面的数据库的。[root@node3 ~]# 再使用远程主机连接192.168.141.12的3306端口，这里我们的windows对于node3就算是远程主机了。 可以看到连接是成功的 测试完这个连接，我们现在需要把它删除掉 然后测试远程主机连接192.168.141.100的3306端口，可以发现被拒了，是不是很难受？分析一下，可以发现拒绝我们的并非是node3，而是当前vip所在主机也就是node1。 我们之前已经关闭了node1的防火墙和selinux，可以通过vip正常访问haproxy监控页面，可以正常连接node3的数据库，然而通过远程连接vip的3306端口来连接后端数据库居然是被拒绝的，为什么？ 因为，在这种服务体系架构中，一旦别人可以通过远程连接vip的3306端口来连接后端数据库，那还了得？那还有什么安全性可言呢？ 例如现在咱们在node3后node4上面都搭建了一个wordpress博客，博客所用数据库就放在node3和node4上面。我们的node1和node2通过反向代理，让别人通过访问node1和node2来访问后端的node3和node4上面的wordpress博客，可以避免我们的后端数据库直接暴露在访问者的面前。现在我们实现了高可用，别人访问我们的wordpress博客，看到的只是vip：192.168.141.100，他们不会知道后端node3和node4的具体存在，这让我们得以保护好弄得3和node4上面的数据库，然后又不妨碍我们内部人员知道node3和node4这些后端具体服务器ip的人去连接数据库。 所以，远程主机连接192.168.141.100的3306端口被拒绝是正常的，这是我们对后端数据库的保护措施。 接下来，重新使用远程主机连接node3也就是192.168.141.12的3306端口，可以看到连接成功。 现在关闭node3上的mariadb服务，再次查看连接可以看到连接失败。 1[root@node3 ~]# systemctl stop mariadb 现在重启node3上的mariadb服务，再次查看连接可以看到连接成功。 1[root@node3 ~]# systemctl restart mariadb 还记得我们初始化数据库时设置的root密码吗？往上翻翻可以看到是123456。接下来我们使用root用户来连接一下node3的数据库，可以看到连接失败。 现在我们要让root用户也可以连接node3的数据库。 123456789101112131415161718192021[root@node3 ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 6Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; update mysql.user set host = &apos;%&apos; where user =&apos;root&apos; limit 1;Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 1MariaDB [(none)]&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; quitBye[root@node3 ~]# systemctl restart mariadb.service [root@node3 ~]# 再次使用root用户来连接一下node3的数据库，可以看到连接成功。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-keepalived-04 keepalived+Nginx+Apache部署]]></title>
    <url>%2Fkeepalived-04%2F</url>
    <content type="text"><![CDATA[linux-keepalived-04 keepalived-+Nginx+Apache部署实验要求：node1、node2作为nginx代理服务器 node3、node4作为web服务器接，搭建apache服务即可。 在nginx配置中使用 修改日志格式，加上客户端的源ip，让web能知道是谁访问了他 初始准备实验环境node1（nginx1+keepalived主）：192.168.141.53node2（nginx2+keepalived从）：192.168.141.69node3（web1）：192.168.141.12node4（web2）：192.168.141.132VIP：192.168.10.100 node1、node2 注意：node1、node2的防火墙必须关闭掉，不能像noed3、node4一样仅仅添加策略放行相应端口。如果node1、node2的防火墙没有关闭掉，那么会出现Nginx + keepalived高可用主备服务器均有VIP的问题。另外，如果二者keepalived的配置文件中virtual_router_id不同的话，也会出现Nginx + keepalived高可用主备服务器均有VIP的问题。 123456789101112[root@node1 ~]# systemctl stop firewalld[root@node1 ~]# vim /etc/selinux/config [root@node1 ~]# cat /etc/selinux/config |grep SELINUX# SELINUX= can take one of these three values:SELINUX=disabled# SELINUXTYPE= can take one of three two values:SELINUXTYPE=targeted [root@node1 ~]#[root@node1 ~]# setenforce 0[root@node1 ~]# getenforce Permissive[root@node1 ~]# noed3、node4 12345678910111213141516[root@node3 ~]# firewall-cmd --add-port=&#123;80,8080&#125;/tcp --permanentsuccess[root@node3 ~]# firewall-cmd --reloadsuccess[root@node3 ~]# [root@node3 ~]# vim /etc/selinux/config [root@node3 ~]# cat /etc/selinux/config |grep SELINUX# SELINUX= can take one of these three values:SELINUX=disabled# SELINUXTYPE= can take one of three two values:SELINUXTYPE=targeted [root@node3 ~]#[root@node3 ~]# setenforce 0[root@node3 ~]# getenforce Permissive[root@node3 ~]# nginx部署node1、node2 12[root@node2 ~]# yum install epel-release -y[root@node2 ~]# yum install nginx -y node1 123456789101112131415161718[root@node1 ~]# cd /etc/nginx/conf.d/[root@node1 conf.d]# vim proxy.conf [root@node1 conf.d]# cat proxy.conf upstream websers&#123; server 192.168.141.12; server 192.168.141.132;&#125;server&#123; listen 8080; server_name 192.168.141.53; location / &#123; proxy_pass http://websers; &#125;&#125;[root@node1 conf.d]# [root@node1 conf.d]# systemctl restart nginx[root@node1 conf.d]# nginx -s reload[root@node1 conf.d]# node2 123456789101112131415161718[root@node1 ~]# cd /etc/nginx/conf.d/[root@node1 conf.d]# vim proxy.conf [root@node1 conf.d]# cat proxy.conf upstream websers&#123; server 192.168.141.12; server 192.168.141.132;&#125;server&#123; listen 8080; server_name 192.168.141.69; location / &#123; proxy_pass http://websers; &#125;&#125;[root@node1 conf.d]# [root@node1 conf.d]# systemctl restart nginx[root@node1 conf.d]# nginx -s reload[root@node1 conf.d]# 注意：这里也可以设置权重和端口号 1234upstream websers &#123;server 192.168.141.12:8080 weight=3;# 可以加上weight=5; 这样的语法设置权重server 192.168.141.132:8080 down;&#125; node3 1234[root@node3 ~]# yum install httpd -y[root@node3 ~]# echo &quot;i am web1&quot; &gt; /var/www/html/index.html[root@node3 ~]# systemctl restart httpd[root@node3 ~]# systemctl enable httpd node4 1234[root@node4 ~]# yum install httpd -y[root@node3 ~]# echo &quot;i am web2&quot; &gt; /var/www/html/index.html[root@node4 ~]# systemctl restart httpd[root@node4 ~]# systemctl enable httpd 检查node3、node4的apache服务是否正常 检查node1、node2的nginx服务是否正常 node1 node2 检测完毕，如上图，apache和nginx服务都是正常的。 Keepalived部署node1 12345678910111213141516171819202122232425262728[root@node1 conf.d]# cd[root@node1 ~]# vim keepalive.sh[root@node1 ~]# cat keepalive.sh #!/bin/bashyum install keepalived -ymv /etc/keepalived/keepalived.conf&#123;,.bak&#125;cat &gt; /etc/keepalived/keepalived.conf &lt;&lt; EOF! Configuration File for keepalivedglobal_defs &#123; router_id node1 # node2修改&#125;vrrp_instance VI_1 &#123; state MASTER # node2节点BACKUP interface ens33 virtual_router_id 10 priority 100 # node2节点小于100 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.141.100 &#125;&#125;EOF[root@node1 ~]# chmod +x ./keepalive.sh [root@node1 ~]# ./keepalive.sh node2 12345678910111213141516171819202122232425262728[root@node2 conf.d]# cd[root@node2 ~]# vim keepalive.sh[root@node2 ~]# cat keepalive.sh #!/bin/bashyum install keepalived -ymv /etc/keepalived/keepalived.conf&#123;,.bak&#125;cat &gt; /etc/keepalived/keepalived.conf &lt;&lt; EOF! Configuration File for keepalivedglobal_defs &#123; router_id node2&#125;vrrp_instance VI_1 &#123; state BACKUP interface ens33 virtual_router_id 10 priority 90 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.141.100 &#125;&#125;EOF[root@node2 ~]# chmod +x ./keepalive.sh [root@node2 ~]# ./keepalive.sh keepalived+nginx实现高可用的特点 如上图，我们需要自定义脚本检测nginx服务是否正常 node1 123456789101112131415161718192021222324252627282930313233给keepalived配置文件增加script内容[root@node1 ~]# vim /etc/keepalived/keepalived.conf[root@node1 ~]# cat /etc/keepalived/keepalived.conf! Configuration File for keepalivedglobal_defs &#123; router_id node1 # node2修改&#125;# 定义scriptvrrp_script chk_http_port &#123; script &quot;/usr/local/src/check_nginx_pid.sh&quot; interval 1 weight -20 # 优先级-20&#125;vrrp_instance VI_1 &#123; state MASTER # node2节点BACKUP interface ens33 virtual_router_id 10 priority 100 # node2节点小于100 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; # 调用script脚本 track_script &#123; chk_http_port &#125; virtual_ipaddress &#123; 192.168.141.100 &#125;&#125;[root@node1 ~]# script解析： 123456789# 定义scriptvrrp_script chk_http_port &#123; script &quot;/usr/local/src/check_nginx_pid.sh&quot; #check_nginx_pid.sh是判断nginx是否正常的脚本，值为1执行 weight -20，否则不执行weight -20 interval 1 #每秒钟检测一次check_nginx_pid.sh的返回值，或者说每秒执行一次脚本 weight -20 # 优先级-20&#125; 注意：优先级减少之后需不需要加回来？不需要，从起nginx后自动回到初始值，也就是把nginx关了重启之后其优先级自动恢复到100，不需要你手动去加。 node1定义判断nginx是否正常的脚本，down的话返回1，正常的话返回0 12345678910111213[root@node1 ~]# vim /usr/local/src/check_nginx_pid.sh[root@node1 ~]# cat /usr/local/src/check_nginx_pid.sh#!/bin/bashA=`ps -C nginx --no-header |wc -l` if [ $A == 0 ];then exit 1 else exit 0 fi[root@node1 ~]# cd /usr/local/src/[root@node1 src]# chmod +x ./check_nginx_pid.sh [root@node1 src]# cd[root@node1 ~]# systemctl restart keepalived node2不需要上述改动，因为总共就两台nginx服务器，所以检测nginx运行是否正常的机器只需要一台就够了。 1[root@node2 ~]# systemctl restart keepalived 测试keepalived的vip是否在主服务器上 node1 12345678910111213141516[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# node2 1234567891011121314[root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 检测vip是否可用 解析：这里curl vip:8080，之所以要加上端口，是因为keepalived只将vip转换为真实ip：192.168.141.53&amp;69，而之前我们定义的nginx反向代理所监听的端口是8080，所以就要加上端口才能访问了。但是这个访问到的并非是web上的80端口，例如直接访问：192.168.141.12:8080是打不开页面的。我们之前做的反向代理是将web服务器上的192.168.141.12:80和192.168.141.132:80反向代理成192.168.141.53:8080或者192.168.141.69:8080。 停止node1的Keepalived服务，观察VIP是否漂移，访问正常 123456789101112131415[root@node1 ~]# systemctl stop keepalived[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# 可以看到vip现在已经转移到了node2上面 12345678910111213141516[root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 测试漂移后的vip的可用性 由于keepalived主设备的选举默认是抢占模式的，所以我们重启node1的keepalived之后，vip能够重新自node2上面漂移回到node1上面。 1234567891011121314151617[root@node1 ~]# systemctl restart keepalived[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# 1234567891011121314[root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 可以看到vip已经漂移回到node1上了 我们解析一下之前用来判断nginx是否关闭的脚本 123456789[root@node1 ~]# cat /usr/local/src/check_nginx_pid.sh#!/bin/bashA=`ps -C nginx --no-header |wc -l` if [ $A == 0 ];then exit 1 else exit 0 fi[root@node1 ~]# 这个脚本里有个变量A=ps -C nginx –no-header |wc -l 停止node1的nginx服务，查看一下变量A的值，可以看到关闭了nginx的话，A=0。 1234[root@node1 ~]# systemctl stop nginx[root@node1 ~]# ps -C nginx --no-header |wc -l0[root@node1 ~]# 对比与node1，我们来看看node2这台nginx并未关闭时A的值，可以看到A!=0 123[root@node2 ~]# ps -C nginx --no-header |wc -l2[root@node2 ~]# 停止node1的nginx服务，观察VIP是否漂移，访问正常 123456789101112131415[root@node1 ~]# systemctl stop nginx[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# 可以看到vip已经漂移到了node2 12345678910111213141516[root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 测试漂移后的vip的可用性 现在将node1的nginx服务器重启，看看vip能都漂移回来 1234567891011121314151617[root@node1 ~]# systemctl restart nginx[root@node1 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.100/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node1 ~]# node2 1234567891011121314[root@node2 ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@node2 ~]# 可以看到vip已经漂移回node1上面了 最终测试一下漂移回来的vip的可用性 将node3上的httpd服务关闭 12[root@node3 ~]# systemctl stop httpd[root@node3 ~]# 访问vip 重新启动node3的httpd服务 12[root@node3 ~]# systemctl restart httpd[root@node3 ~]# 再次访问vip 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-keepalived-03 Nginx+Apache部署]]></title>
    <url>%2Fkeepalived-03%2F</url>
    <content type="text"><![CDATA[linux-keepalived-03 Nginx+Apache部署说明 本篇做一个小实验，主要是为后面keepalived+Nginx+Apache部署做准备，所以把这篇文章归类为keepalived一类里面。 实验要求 完成nginx代理服务器 在nginx配置中使用proxy_set_header X-Real-IP $remote_addr;并且去httpd服务器定义日志格式 LogFormat “ \”%{X-Real-IP}i\” %h %l %u %t \”%r\” %&gt;s %b \”%{Referer}i\” \”%{User-Agent}i\”” combined 最后观察日志前后是否有客户端访问的真实IP地址 实验环境node1（nginx）：192.168.141.53node3（web1）：192.168.141.12node4（web2）：192.168.141.132 实验准备node1 123456789101112[root@node1 ~]# systemctl stop firewalld[root@node1 ~]# vim /etc/selinux/config [root@node1 ~]# cat /etc/selinux/config |grep SELINUX# SELINUX= can take one of these three values:SELINUX=disabled# SELINUXTYPE= can take one of three two values:SELINUXTYPE=targeted [root@node1 ~]#[root@node1 ~]# setenforce 0[root@node1 ~]# getenforce Permissive[root@node1 ~]# noed3、node4 12345678910111213141516[root@node3 ~]# firewall-cmd --add-port=80/tcp --permanentsuccess[root@node3 ~]# firewall-cmd --reloadsuccess[root@node3 ~]# [root@node3 ~]# vim /etc/selinux/config [root@node3 ~]# cat /etc/selinux/config |grep SELINUX# SELINUX= can take one of these three values:SELINUX=disabled# SELINUXTYPE= can take one of three two values:SELINUXTYPE=targeted [root@node3 ~]#[root@node3 ~]# setenforce 0[root@node3 ~]# getenforce Permissive[root@node3 ~]# 实验步骤nginx部署node1 123456789101112131415161718192021[root@node1 ~]# yum install epel-release -y[root@node1 ~]# yum install nginx -y[root@node1 ~]# cd /etc/nginx/conf.d/[root@node1 conf.d]# vim proxy.conf [root@node1 conf.d]# cat proxy.conf upstream websers&#123; server 192.168.141.12; server 192.168.141.132;&#125;server&#123; listen 80; server_name 192.168.141.53; location / &#123; proxy_pass http://websers; &#125;&#125;[root@node1 conf.d]# [root@node1 conf.d]# systemctl restart nginx[root@node1 conf.d]# systemctl enable nginx[root@node1 conf.d]# nginx -s reload[root@node1 conf.d]# apache部署node3 1234[root@node3 ~]# yum install httpd -y[root@node3 ~]# echo &quot;i am web1&quot; &gt; /var/www/html/index.html[root@node3 ~]# systemctl restart httpd[root@node3 ~]# systemctl enable httpd node4 1234[root@node4 ~]# yum install httpd -y[root@node3 ~]# echo &quot;i am web2&quot; &gt; /var/www/html/index.html[root@node4 ~]# systemctl restart httpd[root@node4 ~]# systemctl enable httpd 检查node3、node4的apache服务是否正常 用cmd检查node1的nginx服务是否正常 查看apache服务日志 12345678910111213141516171819[root@node3 ~]# cat /var/log/httpd/access_log192.168.141.1 - - [09/Apr/2019:07:25:13 -0400] &quot;GET / HTTP/1.1&quot; 200 10 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0&quot;192.168.141.1 - - [09/Apr/2019:07:25:13 -0400] &quot;GET /favicon.ico HTTP/1.1&quot; 404 209 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0&quot;192.168.141.53 - - [09/Apr/2019:07:28:21 -0400] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;192.168.141.53 - - [09/Apr/2019:07:28:23 -0400] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;192.168.141.53 - - [09/Apr/2019:07:28:24 -0400] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;192.168.141.53 - - [09/Apr/2019:07:28:25 -0400] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;192.168.141.53 - - [09/Apr/2019:07:28:25 -0400] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;[root@node3 ~]# [root@node4 ~]# cat /var/log/httpd/access_log192.168.141.1 - - [09/Apr/2019:19:25:26 +0800] &quot;GET / HTTP/1.1&quot; 200 10 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0&quot;192.168.141.1 - - [09/Apr/2019:19:25:26 +0800] &quot;GET /favicon.ico HTTP/1.1&quot; 404 209 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0&quot;192.168.141.53 - - [09/Apr/2019:19:28:22 +0800] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;192.168.141.53 - - [09/Apr/2019:19:28:23 +0800] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;192.168.141.53 - - [09/Apr/2019:19:28:24 +0800] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;192.168.141.53 - - [09/Apr/2019:19:28:25 +0800] &quot;GET / HTTP/1.0&quot; 200 10 &quot;-&quot; &quot;curl/7.55.1&quot;[root@node4 ~]# 可以看到，node3与node4日志记录里，访问自己的是node1：192.168.141.53。那么问题来了，如果某用户通过node1的代理在node3上登录了我们的网站，他刷新网页的时候，万一刷新的网页数据被node1负载均衡转发给了node4，然而node4上面是没有其对应session的，这样的话，该用户就不得不再次输入账号和密码，是很荒唐的一件事情。但是其实呢，nginx用的七层代理可以避免这种情况的发生，所以不需要进行手动干预，这些在我前几篇博客中有详细的介绍，这里只是提一下。 为了方便我们运维人员来观察是谁访问了我们的apache服务器，我们需要修改一下日志格式。 首先看一下官方文档： http://httpd.apache.org/docs/2.2/mod/mod_log_config.html 查看当前apache服务日志格式 12345[root@node3 ~]# cat /etc/httpd/conf/httpd.conf | grep LogFormat LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot;&quot; combined LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b&quot; common LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot; %I %O&quot; combinedio[root@node3 ~]# 可以看到，若要在apache日志文件中看到客户端ip，需要加一个 \”%{X-Real-IP}i\” ，其中X-Real-IP是我们在nginx定义的变量，气质为客户端的真实ip地址。 这也就是我们的第二个实验要求： 在nginx配置中使用proxy_set_header X-Real-IP $remote_addr;并且去httpd服务器定义日志格式LogFormat “ \”%{X-Real-IP}i\” %h %l %u %t \”%r\” %&gt;s %b \”%{Referer}i\” \”%{User-Agent}i\”” combined node1上： 12345678910111213[root@node1 ~]# cd /etc/nginx/conf.d/[root@node1 conf.d]# vim proxy.conf 在location / &#123; proxy_pass http://websers; &#125;里面加上：proxy_set_header X-Real-IP $remote_addr;保存退出[root@node1 ~]# systemctl restart nginx[root@node1 ~]# nginx -s reload[root@node1 ~]# node3上 1234567[root@node3 ~]# vim /etc/httpd/conf/httpd.conf将196行修改为：LogFormat &quot; \&quot;%&#123;X-Real-IP&#125;i\&quot; %h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot;&quot; combined保存退出[root@node3 ~]# systemctl restart httpd node4上 1234567[root@node4 ~]# vim /etc/httpd/conf/httpd.conf将196行修改为：LogFormat &quot; \&quot;%&#123;X-Real-IP&#125;i\&quot; %h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot;&quot; combined保存退出[root@node4 ~]# systemctl restart httpd 同上。 现在再次用cmd来访问192.168.141.53 然后回到node3上查看日志： 1[root@node3 ~]# cat /var/log/httpd/access_log 然后回到node4上查看日志： 1[root@node4 ~]# cat /var/log/httpd/access_log 可以看到相比于之前的日志，日志条目最前面多了一个ip，这个ip显然就是我的电脑的ip，如下： 这样我们修改apache日志格式的目的就已经达到了。 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-keepalived-02 keepalived+LVS+Apache部署]]></title>
    <url>%2Fkeepalived-02%2F</url>
    <content type="text"><![CDATA[linux-keepalived-02 keepalived-+LVS+Apache部署概念解析 LVS是Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。 可伸缩网络服务的几种结构，它们都需要一个前端的负载调度器（或者多个进行主从备份）。我们先分析实现虚拟网络服务的主要技术，指出IP负载均衡技术是在负载调度器的实现技术中效率最高的。在已有的IP负载均衡技术中，主要有通过网络地址转换（Network Address Translation）将一组服务器构成一个高性能的、高可用的虚拟服务器，我们称之为VS/NAT技术（Virtual Server via Network Address Translation）。在分析VS/NAT的缺点和网络服务的非对称性的基础上，我们提出了通过IP隧道实现虚拟服务器的方法VS/TUN （Virtual Server via IP Tunneling），和通过直接路由实现虚拟服务器的方法VS/DR（Virtual Server via Direct Routing），它们可以极大地提高系统的伸缩性。VS/NAT、VS/TUN和VS/DR技术是LVS集群中实现的三种IP负载均衡技术。 lvs官网：http://www.linuxvirtualserver.org 如下图： 当web服务器太多时，RS就压力很大，所以引入DS。 重要参数：arp_announcearp_ignore 优点1、开源，免费2、在网上能找到一些相关技术资源3、具有软件负载均衡的一些优点 缺点1、最核心的就是没有可靠的支持服务，没有人对其结果负责；2、功能比较简单，支持复杂应用的负载均衡能力较差，如算法较少等；3、开启隧道方式需重编译内核；4、配置复杂；5、主要应用于LINUX，目前没有专门用于WINDOWS的版本，不过可以通过配置，使windows成为LVS集群中的real server（win2003、win2008中）。 LVS相关概念ipvs：ipvs称之为IP虚拟服务器（IP Virtual Server，简写为IPVS），是运行在LVS下的提供负载平衡功能的一种技术。工作于内核当中，定义转发规则。ipvsadm：工作于用户空间，是一个工具，同时它也是一条命令，用于管理LVS的策略规则。DS：前端负载均衡节点 direct-serverRS：后端真实节点 real-serverDIP：负载均衡节点的IP地址VIP：虚拟IP地址，必须要与RS在同一网段RIP：真实节点的IP地址CIP：客户端IP地址 LVS/NAT模型 RS的网关必须为DIP DIP要和RIP处于同一网络 RS支持任意操作系统 RIP必须为私网地址 DS支持端口映射 LVS/DR模型 前端路由必须发送给DS VIP要和RIP处于同一网络 RS的网关不能够指向DIP 不支持端口映射 RS响应报文绝不通过DS 在环回口上配置VIP地址，因为环回口本来没有ip LVS/TUN模型 主要是解决DR转发到不同数据中心的RS lvs负载均衡算法 rr：轮询 wrr：加权轮询 lc：最少连接数 wlc：加权最少连接数 ip hash：源地址哈希 sip hash：目的地址哈希 实验环境DR1:192.168.141.53DR2:192.168.141.69RS1：192.168.141.12RS2:192.168.141.132VIP：192.168.141.99（单主模型） RS部署12345678910111213141516171819202122232425262728293031323334353637383940在rs1和执行下面的脚本：[root@rs1 ~]# vim rs1.sh[root@rs1 ~]# cat rs1.sh #!/bin/bashyum install net-tools httpd -ysystemctl stop firewalldsetenforce 0vip=&quot;192.168.141.99&quot;mask=&quot;255.255.255.255&quot;ifconfig lo:0 $vip broadcast $vip netmask $mask uproute add -host $vip lo:0echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignoreecho &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announceecho &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignoreecho &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announceecho &quot;&lt;h1&gt;This is RS1&lt;/h1&gt;&quot; &gt; /var/www/html/index.htmlsystemctl restart httpdsystemctl enable httpd[root@rs1 ~]# . rs1.sh 在rs2和执行下面的脚本：[root@rs2 ~]# vim rs2.sh[root@rs2 ~]# cat rs2.sh #!/bin/bashyum install net-tools httpd -ysystemctl stop firewalldsetenforce 0vip=&quot;192.168.141.99&quot;mask=&quot;255.255.255.255&quot;ifconfig lo:0 $vip broadcast $vip netmask $mask uproute add -host $vip lo:0echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignoreecho &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announceecho &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignoreecho &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announceecho &quot;&lt;h1&gt;This is RS2&lt;/h1&gt;&quot; &gt; /var/www/html/index.htmlsystemctl restart httpdsystemctl enable httpd[root@rs2 ~]# . rs2.sh DR部署123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144dr1设置为主，dr2设置为从，二者配置文件的差异在于：dr1state MASTER priority 100router_id node1dr2state BACKUPpriority 90router_id node2[root@dr1 ~]# yum install keepalived ipvsadm -y[root@dr1 ~]# systemctl stop firewalld[root@dr1 ~]# setenforce 0[root@dr1 ~]# cd /etc/keepalived/[root@dr1 keepalived]# [root@dr1 keepalived]# mv keepalived.conf&#123;,.bak&#125;[root@dr1 keepalived]# vim keepalived.conf[root@dr1 keepalived]# cat keepalived.conf! Configuration File for keepalivedglobal_defs &#123; router_id node1 # 设置lvs的id，一个网络中应该唯一&#125;vrrp_instance VI_1 &#123; state MASTER # 指定Keepalived的角色，主是MASTER，从是BACKUP interface ens33 # 网卡 virtual_router_id 10 # 虚拟路由器ID，主备需要一样 priority 100 # 优先级越大越优，backup路由器需要设置比这小！可以设置为90 advert_int 1 # 检查间隔1s authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.141.99 # 定义虚拟IP地址，可以定义多个 &#125;&#125;# 定义虚拟主机，对外服务的IP和portvirtual_server 192.168.141.99 80 &#123; delay_loop 6 # 设置健康检查时间，单位是秒 lb_algo wrr # 负责调度算法 lb_kind DR # LVS负载均衡机制 persistence_timeout 0 protocol TCP# 指定RS主机IP和port real_server 192.168.141.12 80 &#123; weight 2 # 定义TCP健康检查 TCP_CHECK &#123; connect_timeout 10 nb_get_retry 3 delay_before_retry 3 connect_port 80 &#125; &#125; real_server 192.168.141.132 80 &#123; weight 1 TCP_CHECK &#123; connect_timeout 10 nb_get_retry 3 delay_before_retry 3 connect_port 80 &#125; &#125;&#125;[root@dr1 keepalived]# systemctl restart keepalived[root@dr1 keepalived]# ipvsadm -lnIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 192.168.141.99:80 wrr -&gt; 192.168.141.12:80 Route 2 0 0 -&gt; 192.168.141.132:80 Route 1 0 0 [root@dr1 keepalived]# dr2按照上面的同样配置，唯一差异在于：state BACKUP priority 90[root@dr2 ~]# yum install keepalived ipvsadm -y[root@dr2 ~]# systemctl stop firewalld[root@dr2 ~]# setenforce 0[root@dr2 ~]# cd /etc/keepalived/[root@dr2 keepalived]# [root@dr2 keepalived]# mv keepalived.conf&#123;,.bak&#125;[root@dr2 keepalived]# vim keepalived.conf[root@dr2 keepalived]# cat keepalived.conf! Configuration File for keepalivedglobal_defs &#123; router_id node2 # 设置lvs的id，一个网络中应该唯一&#125;vrrp_instance VI_1 &#123; state BACKUP # 指定Keepalived的角色，主是MASTER，从是BACKUP interface ens33 # 网卡 virtual_router_id 10 # 虚拟路由器ID，主备需要一样 priority 90 # 优先级越大越优，backup路由器需要设置比这小！ advert_int 1 # 检查间隔1s authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.141.99 # 定义虚拟IP地址，可以定义多个 &#125;&#125;# 定义虚拟主机，对外服务的IP和portvirtual_server 192.168.141.99 80 &#123; delay_loop 6 # 设置健康检查时间，单位是秒 lb_algo wrr # 负责调度算法 lb_kind DR # LVS负载均衡机制 persistence_timeout 0 protocol TCP# 指定RS主机IP和port real_server 192.168.141.12 80 &#123; weight 2 # 定义TCP健康检查 TCP_CHECK &#123; connect_timeout 10 nb_get_retry 3 delay_before_retry 3 connect_port 80 &#125; &#125; real_server 192.168.141.132 80 &#123; weight 1 TCP_CHECK &#123; connect_timeout 10 nb_get_retry 3 delay_before_retry 3 connect_port 80 &#125; &#125;&#125;[root@dr2 keepalived]# systemctl restart keepalived[root@dr2 keepalived]# ipvsadm -lnIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 192.168.141.99:80 wrr -&gt; 192.168.141.12:80 Route 2 0 0 -&gt; 192.168.141.132:80 Route 1 0 0 [root@dr2 keepalived]# 如果用浏览器测试的话，因为有缓存的原因，现象就不是那么的准确。所以我们这里采用windows的cmd来进行测试，多次输入命令：curl 192.168.141.99即可。 1234567891011121314151617181920212223242526C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS2&lt;/h1&gt;C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS1&lt;/h1&gt;C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS1&lt;/h1&gt;C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS2&lt;/h1&gt;C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS1&lt;/h1&gt;C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS1&lt;/h1&gt;C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS2&lt;/h1&gt;C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS1&lt;/h1&gt;C:\Users\zhong&gt;curl 192.168.141.99&lt;h1&gt;This is RS1&lt;/h1&gt; 可以看到，访问同一个ip：192.168.141.99得到的却是不同的结果，而且访问到RS1和RS2主页的比例正如我们在上面配置文件里设置好的那样，是2:1。 验证keepalive的健康检查功能将RS1的httpd关掉，查看dr1上转发目的主机列表，列表里已经没有RS1了 1234567891011[root@rs1 ~]# systemctl stop httpd[root@rs1 ~]# [root@dr1 keepalived]# ipvsadm -lnIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 192.168.141.99:80 wrr -&gt; 192.168.141.132:80 Route 1 0 3 [root@dr1 keepalived]# 将RS1的httpd重新开启，再次查看dr1上转发目的主机列表，列表里又有RS1了 12345678910[root@rs1 ~]# systemctl restart httpd[root@dr1 keepalived]# ipvsadm -lnIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 192.168.141.99:80 wrr -&gt; 192.168.141.12:80 Route 2 0 0 -&gt; 192.168.141.132:80 Route 1 0 0 [root@dr1 keepalived]# 验证keepalive的vip切换功能分别查看DR1和DR2的ip，可以看到vip：192.168.141.99在DR1的ens33网卡上 1234567891011121314151617181920212223242526272829303132[root@dr1 keepalived]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.99/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@dr1 keepalived]# [root@dr2 keepalived]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@dr2 keepalived]# 关掉dr1的keepalived 1[root@dr1 keepalived]# systemctl stop keepalived 再次查看DR1和DR2的ip，可以看到vip：192.168.141.99在DR2的ens33网卡上，切换成功！ 123456789101112131415161718192021222324252627282930313233[root@dr1 keepalived]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@dr1 keepalived]# [root@dr2 keepalived]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.99/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@dr2 keepalived]# 重启DR1的keepalived 1[root@dr1 keepalived]# systemctl restart keepalived 再次查看DR1和DR2的ip，可以看到vip：192.168.141.99在DR1的ens33网卡上，切换成功！ 123456789101112131415161718192021222324252627282930313233[root@dr1 keepalived]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8b:6f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.141.99/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::45c1:b728:e8e7:a1fa/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@dr1 keepalived]# [root@dr2 keepalived]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:56:58:3c brd ff:ff:ff:ff:ff:ff inet 192.168.141.69/24 brd 192.168.141.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::1edf:37bf:62b9:68e2/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@dr2 keepalived]# 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-keepalived-01 keepalived-基础学习]]></title>
    <url>%2Fkeepalived-01%2F</url>
    <content type="text"><![CDATA[linux-keepalived-01 keepalived-基础学习简介 Keepalived是Linux下一个轻量级别的高可用解决方案，Keepalived起初是为LVS设计的，专门用来监控集群系统中各个服务节点的状态，如果某个服务器节点出现故障，Keepalived将检测到后自动将节点从集群系统中剔除。 后来Keepalived又加入了VRRP的功能，VRRP（VritrualRouterRedundancyProtocol,虚拟路由冗余协议)出现的目的是解决静态路由出现的单点故障问题，通过VRRP可以实现网络不间断稳定运行，因此Keepalvied一方面具有服务器状态检测和故障隔离功能，另外一方面也有HAcluster功能。 健康检查和失败切换是keepalived的两大核心功能。所谓的健康检查，就是采用tcp三次握手，icmp请求，http请求，udp echo请求等方式对负载均衡器后面的实际的服务器(通常是承载真实业务的服务器)进行保活；而失败切换主要是应用于配置了主备模式的负载均衡器，利用VRRP维持主备负载均衡器的心跳，当主负载均衡器出现问题时，由备负载均衡器承载对应的业务，从而在最大限度上减少流量损失，并提供服务的稳定性。 VRRP协议 VRRP协议是一种容错的主备模式的协议，保证当主机的下一跳路由出现故障时，由另一台路由器来代替出现故障的路由器进行工作，通过VRRP可以在网络发生故障时透明的进行设备切换而不影响主机之间的数据通信。 虚拟路由器：VRRP组中所有的路由器，拥有虚拟的IP+MAC(00-00-5e-00-01-VRID)地址 主路由器：虚拟路由器内部通常只有一台物理路由器对外提供服务，主路由器是由选举算法产生，对外提供各种网络功能。 备份路由器：VRRP组中除主路由器之外的所有路由器，不对外提供任何服务，只接受主路由的通告，当主路由器挂掉之后，重新进行选举算法接替master路由器。 VRRP选举机制 三种状态： Initialize状态：系统启动后进入initialize状态 Master状态 Backup状态 选举机制： 优先级 抢占模式下，一旦有优先级高的路由器加入，即成为Master 非抢占模式下，只要Master不挂掉，优先级高的路由器只能等待 工作原理 网络层：通过ICMP协议向后端服务器集群中发送数据报文 传输层：利用TCP协议的端口连接和扫描技术检测后端服务器集群是否正常 应用层：自定义keepalived工作方式（脚本） 体系结构 SchedulerI/OMultiplexer是一个I/O复用分发调度器，它负载安排Keepalived所有内部的任务请求 Memory Mngt是一个内存管理机制，这个框架提供了访问内存的一些通用方法； Control Plane 是keepalived的控制版面，可以实现对配置文件编译和解析； Core componets Watchdog：是计算机可靠领域中极为简单又非常有效的检测工具，Keepalived正是通过它监控Checkers和VRRP进程的。 Checkers:这是Keepalived最基础的功能，也是最主要的功能，可以实现对服务器运行状态检测和故障隔离。 VRRP Stack:这是keepalived后来引用VRRP功能，可以实现HA集群中失败切换功能。负责负载均衡器之间的失败切换FailOver IPVS wrapper:这个是IPVS功能的一个实现，IPVSwarrper模块将可以设置好的IPVS规则发送的内核空间并且提供给IPVS模块，最终实现IPVS模块的负载功能。 Netlink Reflector：用来实现高可用集群Failover时虚拟IP(VIP)的设置和切换 keepalived运行时，会启动3个进程： core：负责主进程的启动，维护和全局配置文件的加载； check：负责健康检查 vrrp：用来实现vrrp协议 对比 Keepalived的目的是模拟路由器的高可用 Heartbeat或Corosync的目的是实现Service的高可用 Keepalived是实现前端高可用，常用的前端高可用的组合有，就是我们常见的LVS+Keepalived、Nginx+Keepalived、HAproxy+Keepalived Heartbeat或Corosync是实现服务的高可用，常见的组合有Heartbeat v3(Corosync)+Pacemaker+NFS+Httpd 实现Web服务器的高可用、Heartbeat v3(Corosync)+Pacemaker+NFS+MySQL 实现MySQL服务器的高可用。 keepalived相关路径/etc/keepalived/keepalived.conf # 主配置文件/etc/sysconfig/keepalived # 系统进程/usr/bin/genhash # hash计算工具/usr/lib/systemd/system/keepalived.service # 守护进程/usr/sbin/keepalived # 命令工具 keepalived主从选举 keepalived默认采用抢占模式，谁的优先级最高，谁就可以抢占到vip。例如node1的优先级是100，node2的优先级是90，一开始vip在node1上面。关闭node1上面的keepalived后，vip会漂移到node2上，可是一旦node1的keepalived再次开启，那么vip还是会漂移回到node1的。 选举机制： ​ 通过优先级​ 设置抢占和非抢占的参数：nopreempt（默认为抢占模式） 抢占模式：当某台优先级更高的节点加入集群中，立即重现选举master 非抢占模式：当master挂掉之后，才会重新选举 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-servers-06 数据库]]></title>
    <url>%2Fservers-06%2F</url>
    <content type="text"><![CDATA[linux-servers-06 数据库概念解析数据库 数据库是以表格形式保存数据的特定结构。支持通过基于表格结构的数据流的软件称为数据库管理系统（DBMS）。使用最广泛的数据库管理系统（DBMS）是关系数据库管理系统（RDBMS）。数据库管理系统（DBMS）是一种计算机软件应用程序，可与终端用户，其他应用程序和数据库本身交互以捕获数据。通用数据库管理系统允许定义，创建，查询，更新和管理数据库。 相关概念 数据库（Data Base，DB)是按一定结构组织并长期存储在计算机内的、可共享的大量数据的有机集合。其实就是存放数据的仓库，只不过这些数据存在一定的关联、并按一定的格式存放在计算机上。例如，把一个学校的学生、课程、学生成绩等数据有序的组织并存放在计算机内，就可以构成一个数据库。 数据库管理系统（Data Base Management System，DBMS）是管理和维护数据库的系统软件。常用的DBMS有：Oracle、DB2、SqlServer、MySql等 数据库管理员（Date Base Administrator ,DBA)管理操作数据库人员。 数据库系统（Data Base System，DBS）是实现有组织的、动态地存储大量关联数据、方便多用户访问的计算机软件、硬件和数据资源组成的系统，简化为：DBS=计算机系统（硬件、软件平台、人）+DBMS+DB 关系型数据库管理系统（Relational Database Management System，RDBMS） 非关系型数据库，又被称为NoSQL（Not Only SQL )，意为不仅仅是SQL。 关系型数据库 关系数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系模型是由埃德加·科德于1970年首先提出的，并配合“科德十二定律”。现如今虽然对此模型有一些批评意见，但它还是数据存储的传统标准。标准数据查询语言SQL就是一种基于关系数据库的语言，这种语言执行对关系数据库中数据的检索和操作。 关系模型由关系数据结构、关系操作集合、关系完整性约束三部分组成。简单说，关系型数据库是由多张能互相联接的二维行列表格组成的数据库。 关系模型就是指二维表格模型,因而一个关系型数据库就是由二维表及其之间的联系组成的一个数据组织。当前主流的关系型数据库有Oracle、DB2、PostgreSQL、Microsoft SQL Server、Microsoft Access、MySQL、浪潮K-DB等。 实体关系模型（Entity-Relationship Model)，简称E-R Model是陈品山（Peter P.S Chen)博士于1976年提出的一套数据库的设计工具，他运用真实世界中事物与关系的观念，来解释数据库中的抽象的数据架构。实体关系模型利用图形的方式（实体-关系图（Entity-Relationship Diagram））来表示数据库的概念设计，有助于设计过程中的构思及沟通讨论。 非关系型数据库 非关系型数据库，又被称为NoSQL（Not Only SQL )，意为不仅仅是SQL（ Structured QueryLanguage，结构化查询语言)，据维基百科介绍，NoSQL最早出现于1998 年，是由Carlo Storzzi最早开发的个轻量、开源、不兼容SQL 功能的关系型数据库，2009 年，在一次分布式开源数据库的讨论会上，再次提出了NoSQL 的概念，此时NoSQL主要是指非关系型、分布式、不提供ACID (数据库事务处理的四个基本要素)的数据库设计模式。同年，在亚特兰大举行的“NoSQL(east)”讨论会上，对NoSQL 最普遍的定义是“非关联型的”，强调Key-Value 存储和文档数据库的优点，而不是单纯地反对RDBMS，至此，NoSQL 开始正式出现在世人面前。 非关系型数据库的分类 NoSQL描述的是大量结构化数据存储方法的集合，根据结构化方法以及应用场合的不同，主要可以将NoSQL分为以下几类。 (1)Column-Oriented 面向检索的列式存储，其存储结构为列式结构，同于关系型数据库的行式结构，这种结构会让很多统计聚合操作更简单方便，使系统具有较高的可扩展性。这类数据库还可以适应海量数据的增加以及数据结构的变化，这个特点与云计算所需的相关需求是相符合的，比如GoogleAppengine的BigTable以及相同设计理念的Hadoop子系统HaBase就是这类的典型代表。需要特别指出的是，Big Table特别适用于MapReduce处理，这对于云计算的发展有很高的适应性。 (2)Key-Value。 面向高性能并发读/写的缓存存储，其结构类似于数据结构中的Hash表，每个Key分别对应一个Value,能够提供非常快的查询速度、大数据存放量和高并发操作，非常适合通过主键对数据进行查询和修改等操作。Key-Value数据库的主要特点是具有极高的并发读/写性能，非常适合作为缓存系统使用。MemcacheDB、BerkeleyDB、Redis、Flare就是Key-Value数据库的代表。 (3)Document-Oriented。 面向海量数据访问的文档存储，这类存储的结构与Key-Value非常相似，也是每个Key分别对应一个Value，但是这个Value主要以JSON(JavaScriptObjectNotations)或者XML等格式的文档来进行存储。这种存储方式可以很方便地被面向对象的语言所使用。这类数据库可在海量的数据中快速查询数据，典型代表为MongoDB、CouchDB等。 NoSQL具有扩展简单、高并发、高稳定性、成本低廉等优势，也存在一些问题。例如，NoSQL暂不提供SQL的支持，会造成开发人员的额外学习成本;NoSQL大多为开源软件其成熟度与商用的关系型数据库系统相比有差距;NoSQL的架构特性决定了其很难保证数据的完整性，适合在一些特殊的应用场景使用。 举例分析关系型数据库如mysql等用于存放具有约束性的关系模型（表）。 非关系型数据库如mongodb hbase等用于存放图片、文本等。 MariaDB与MySQLmysql MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。 MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。 MariaDB MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，使用XtraDB（英语：XtraDB）来代替MySQL的InnoDB。 MariaDB由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。MariaDB名称来自Michael Widenius的女儿Maria的名字。 MariaDB与MySQL的渊源 MySQL之父Widenius先生离开了Sun之后，觉得依靠Sun/Oracle来发展MySQL，实在很不靠谱，于是决定从新开发代码全部开源免费关系型数据库，这就是MariaDB。在navicat中操作mariaDB的界面和提示符还是mysql端口也是3306 外人看起来除了数据库名字改了其他和mysql完全一致，但是看一下性能比较，大多数人认为MariaDB更优于MySQL。 MySQL的特点关系数据库管理系统： MySQL支持所有功能，这使得它成为一个完整的关系数据库管理系统（RDBMS）。它支持完整的SQL作为查询和更新数据的标准化语言，并且可以管理数据库。 简单而安全： 与其他数据库管理系统（DBMS）软件相比，MySQL使用非常简单且具有交互性，并且具有可靠的数据安全层，可为数据提供高效的加密，因此非常安全。 客户机/服务器体系结构： 其简单的客户机/服务器体系结构可帮助终端用户创建一个与许多客户机连接的服务器，以便与服务器进行通信进行插入，更新和管理数据库。 可伸缩性： MySQL可以处理大量数据而不会出现任何卡顿 – 多达5000万行。它可以处理高达8TB的数据而没有任何问题。 跨平台：与几乎所有操作系统兼容，如UNIX，Windows，Linux，MAC OS X等。 高性能，灵活且高效的生产力： MySQL提供更快速，高度可靠，便宜的存储解决方案，并支持大量嵌入式应用程序。它利用触发器，程序和视图来提高生产力。 MariaDB的特点 MariaDB可用于GPL，LGPL和BSD。 它包括广泛的存储引擎选择，包括高性能存储引擎，用于与其他关系数据库管理系统（RDBMS）数据源一起工作。 它使用标准和流行的查询语言。 MariaDB在许多操作系统上运行，并支持各种编程语言。 它提供对PHP的支持，PHP是最流行的Web开发语言之一。 它提供Galera群集技术。 MariaDB还提供了很多在MySQL中不可用的操作和命令，并消除/取代了对性能产生负面影响的功能。 MariaDB和MySQL的比较分析 MariaDB拥有大量新功能，这使得它在性能和用户导向方面更加出色。mysql是centos6默认使用的数据库，mariadb是centos7默认使用的数据库。 MariaDB优点 MariaDB针对性能进行了优化，对于大型数据集，它比MySQL强大得多。从其他数据库系统可以优雅的迁移到MariaDB是另一个好处。 从MySQL切换到MariaDB相对容易，这对于系统管理员来说好像是一块蛋糕。 MariaDB通过引入微秒级精度和扩展用户统计数据提供更好的监控。 MariaDB增强了KILL命令，使您可以杀死用户的所有查询（KILL USER 用户名）或杀死查询ID（KILL QUERY ID query_id）。MariaDB也转而使用Perl兼容的正则表达式（PCRE），它提供比标准MySQL正则表达式支持更强大和更精确的查询。 MariaDB为与磁盘访问，连接操作，子查询，派生表和视图，执行控制甚至解释语句相关的查询应用了许多查询优化。 MariaDB纯粹是开源的，而不是MySQL使用的双重授权模式。一些仅适用于MySQL Enterprise客户的插件在MariaDB中具有等效的开源实现。 与MySQL相比，MariaDB支持更多的引擎（SphinxSE，Aria，FederatedX，TokuDB，Spider，ScaleDB等）。 MariaDB提供了一个用于商业用途的集群数据库，它也支持多主复制。任何人都可以自由使用它，并且不需要依赖MySQL Enterprise系统。 缺点 从版本5.5.36开始，MariaDB无法迁移回MySQL。 对于MariaDB的新版本，相应的库（用于Debian）不会及时部署，由于依赖关系，这将导致必需升级到较新的版本。 MariaDB的群集版本不是很稳定。 MySQL和MariaDB之间的一些重要差异 数据库的使用情况：自1995年以来，MySQL一直被视为迄今为止实施最为广泛且最广泛使用的开源数据库。许多像Twitter，YouTube，Netflix和PayPal这样的IT巨头，以及美国国家航空航天局，美国国防部队和沃尔玛都利用这个数据库。最近才到来的MariaDB也在各种IT巨头组织（如Google，Red Hat，CentOS和Fedora）中作为后端软件因此得到了强大的基础。 数据库和索引的结构： MySQL是一个纯粹的关系数据库，集成了一个ANSI标准的信息模式，由表，列，视图，过程，触发器，游标等组成。MySQL的结构化查询语言（SQL）是ANSI SQL 99。而MariaDB是MySQL的一个分支，因此具有相同的数据库结构和索引。该功能使MariaDB成为希望直接切换或升级后端的用户的理想选择，而无需升级数据库和数据结构。当从MySQL升级到MariaDB时，所有内容（从数据，表格定义，结构和API）都保持一致。 二进制和实现： MySQL是使用C和C ++开发的，并且完全兼容几乎所有操作系统，如Microsoft Windows，MAC OS X，Linux，FreeBSD，UNIX，NetBSD，Novell Netware和其他许多操作系统。MariaDB使用C，C ++，Bash和Perl开发。它与Microsoft Windows，Linux，MAC OS X，FreeBSD，Solaris等各种操作系统兼容。 复制和集群： MySQL通过主从主复制和主从复制提供强大的复制和集群，并利用Galera集群实现多主集群。MariaDB为主终端用户提供与主从主复制和主从复制相同的复制和集群功能。它还使用10.1版以后的Galera Cluster。 对数据库的支持：通过Oracle全天候提供MySQL技术支持服务，支持团队由专业开发人员和工程师组成，他们提供各种工具，如错误修复，修补程序和版本发布。Oracle根据用户的需求提供MySQL首要支持，扩展支持和持续支持。MariaDB通过开源社区，在线论坛甚至通过专家为用户提供强有力的支持。MariaDB通过企业订阅提供24小时全天候支持，尤其适用于任务关键型生产系统。 安全性：就安全性而言，MySQL为表空间数据提供了强大的加密机制。它提供了强大的安全参数，包括选择好的密码，不给用户不必要的特权，并通过防止SQL注入和数据损坏来确保应用程序安全。MariaDB在内部安全和密码检查，验证模块（PAM）和轻量级目录访问协议（LDAP）认证，Kerberos，用户角色以及对表空间，表格和日志的强大加密等安全功能方面取得了重大进展。 可扩展性：支持可扩展系统的数据库可以用许多不同的方式进行扩展，如添加新的数据类型，函数，运算符，聚集函数，索引方法和过程语言。MySQL不支持可扩展性。MariaDB建立在现代架构的基础之上，可以在每一层 – 客户端，集群，内核和存储上进行扩展。这种可扩展性提供了两个主要优势。它允许通过插件实现持续的社区创新，这意味着可以通过MariaDB的可扩展架构集成各种存储引擎，如MariaDB ColumnStore或Facebook的MyRocks。此外，它使客户能够轻松配置MariaDB以支持从联机事务处理（OLTP）到联机分析处理（OLAP）的各种用例。 JSON支持： MySQL支持本地JSON数据类型，可以在JSON（JavaScript Object Notation）文档中高效地访问数据。与将JSON格式的字符串存储在字符串列中相比，JSON数据类型提供了以下优点： 自动验证存储在JSON列中的JSON文档。无效的文档会产生错误。 优化的存储格式：存储在JSON列中的JSON文档被转换为允许快速读取文档元素的内部格式。当服务器稍后必须读取以这种二进制格式存储的JSON值时，不需要从文本表示中解析该值。二进制格式的结构使服务器能够直接通过键或数组索引查找子对象或嵌套值，而无需读取文档中的所有值。另一方面，MariaDB Server 10.2引入了一整套用于读写JSON文档的24个函数。另外，JSON_VALID函数可以与校验约束一起使用，而像JSON_VALUE这样的函数可以与动态列一起使用来索引特定的字段。 授权许可： MySQL在GPL下以开放源代码提供代码，并以MySQL Enterprise形式提供非GPL商业分发选项。MariaDB只能使用GPL，因为它的工作源于该许可条款下的MySQL源代码。 性能： MariaDB通过MySQL的许多创新实现了同类最佳性能。其中包括线程池管理以最大限度地提高处理效率，以及InnoDB数据存储区内的碎片整理等广泛的优化功能。因此，当从InnoDB表中删除行时，可用空间立即可供操作系统使用。不需要将旧表中的数据复制到新表中，并且表空间中没有空闲。MariaDB还提供与引擎无关的表统计信息，以改善优化程序的性能，加快对表的大小和结构进行查询处理和数据分析。如果没有这些增强功能，MySQL的性能就会下降。MySQL中的线程利用率是次优的，InnoDB表随着时间的推移变得碎片化，从而影响性能。 扩展知识如何连接数据库apache、nginx：通过调用数据库接口、模块连接数据库；php：用的是php-mysql模块python：用的是py-mysql模块lnmp：php-fpm模块让nginx得以连接数据库，使用的是fastCGI协议，该协议需要php-fpm模块去建立fpm-server，即nginx的内置代理：pass-proxy 127.0.0.1:9000，得以连接到动态站点。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-servers</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>servers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-servers-05 网站资源动静分离]]></title>
    <url>%2Fservers-05%2F</url>
    <content type="text"><![CDATA[linux-servers-05 网站资源动静分离概念解析 所谓动静分离就是通过nginx（或apache等）来处理用户端请求的静态页面，通过tomcat（或weblogic等）处理动态页面，从而达到动静页面访问时通过不同的容器来处理。 静态文件：图片，视频，音乐，JS，CSS，HTML等可直接访问的文件。 动态文件：需要服务器进行编译运行的文件（.jsp .php等）。 举例分析 一般普通建站，只需一台服务器即可，这就意味着一个网站的所有资源全部存放于同一台服务器里。随着网站的数据日益增加，服务器磁盘逐渐变小，网站的处理速度会越来越慢，此时你就该考虑换服务器了。但是，其实服务器80%的磁盘被图片等媒体资源占用，把这些资源用专门的容器存储起来（对象存储）即可以实现简单的动静分离。 动静分离优点1.降低Web服务器负载，加快网站访问速度 服务器只需编译运行动态文件，大大降低了服务器负载。因为不用加载那些静态文件，所以降低了服务器带宽需求。网站瞬间加载，不会出现卡顿的问题。 2.海量存储空间存储费用最低 服务器在磁盘满了之后，扩容所需的投资是巨大的。而使用对象存储基本是不用在意的。 3.流量费用低 服务器流量基本是以带宽计费，费用也是高的不行。如果用服务器存放图片等媒体文件，加载慢不说，还特别贵。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-servers</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>servers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-servers-04 session和cookie]]></title>
    <url>%2Fservers-04%2F</url>
    <content type="text"><![CDATA[linux-servers-04 session和cookie概念解析cookie 位于用户的计算机上，用来维护用户计算机中的信息，直到用户删除。比如我们在网页上登录某个软件时输入用户名及密码时如果保存为cookie，则每次我们访问的时候就不需要登录网站了。我们可以在浏览器上保存任何文本，而且我们还可以随时随地的去阻止它或者删除。我们同样也可以禁用或者编辑cookie，但是有一点需要注意不要使用cookie来存储一些隐私数据，以防隐私泄露 session session称为会话信息，位于web服务器上，主要负责访问者与网站之间的交互，当访问浏览器请求http地址时，将传递到web服务器上并与访问信息进行匹配， 当关闭网站时就表示会话已经结束，网站无法访问该信息了，所以它无法保存永久数据，我们无法访问以及禁用网站 共同点session和cookie都用于会话保持。 session与cookie的区别（1）Cookie以文本文件格式存储在本地浏览器中，而session存储在远端服务器，它存储了限制数据量。它只允许4kb它没有在cookie中保存多个变量。 （2）cookie的存储限制了数据量，只允许4KB，而session是无限量的 （3）我们可以轻松访问cookie值但是我们无法轻松访问会话值，因此它更安全 （4）设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。 总结：如果我们需要经常登录一个站点时，最好用cookie来保存信息，要不然每次登陆都特别麻烦，如果对于需要安全性高的站点以及控制数据的能力时需要用会话效果更佳，当然我们也可以结合两者，使网站按照我们的想法进行运行。 数据的转发在OSI七层模型中，数据包的转发分为四层代理和七层代理。 四层代理：效率高，数据包封装到四层转发给后端。七层代理：效率相对较低，数据包封装到七层转发给后端。 在登录某网站时，发送请求报文，接受响应报文（内含cookie），web服务器保存了cookie对应的值，将cookie存在本地浏览器中，刷新页面就不用再次输入密码账号了。但是如果刚刚登录的是web1，而且还是用的四层代理，那么刷新页面后，由于cookie工作在4层以上，代理服务器识别不了，不知道该和转发给web1还是web2，如果转发给web2了，你就得再次输入账号和密码进行登录。所以用七层代理就不会有这个问题，用七层代理时，刷新页面后，代理服务器可以识别出应该转发给web1还是web2，从而使得数据包转发给上一次登录的服务器，这样就不用再次输入账号和密码。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-servers</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>servers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-servers-03 web服务器方案]]></title>
    <url>%2Fservers-03%2F</url>
    <content type="text"><![CDATA[linux-servers-03 web服务器方案常用web服务器方案lighttpd Lighttpd是一个具有非常低的内存开销，cpu占用率低，效能好，以及丰富的模块等特点。lighttpd是众多开源轻量级的web server中较为优秀的一个。支持FastCGI, CGI, Auth, 输出压缩(output compress), URL重写, Alias等重要功能。Lighttpd使用fastcgi方式运行php,它会使用很少的PHP进程响应很大的并发量。 Fastcgi的优点在于： 从稳定性上看, fastcgi是以独立的进程池运行来cgi,单独一个进程死掉,系统可以很轻易的丢弃,然后重新分配新的进程来运行逻辑。从安全性上看, fastcgi和宿主的server完全独立, fastcgi怎么down也不会把server搞垮，从性能上看, fastcgi把动态逻辑的处理从server中分离出来, 大负荷的IO处理还是留给宿主server, 这样宿主server可以一心一意作IO,对于一个普通的动态网页来说, 逻辑处理可能只有一小部分, 大量的图片等静态IO处理完全不需要逻辑程序的参与。从扩展性上讲, fastcgi是一个中立的技术标准, 完全可以支持任何语言写的处理程序(php,java,python…) apache apache是世界排名第一的web服务器, 根据netcraft(www.netsraft.co.uk)所作的调查,世界上百分之五十以上的web服务器在使用apache。 1995年4月, 最早的apache(0.6.2版)由apache group公布发行. apache group 是一个完全通过internet进行运作的非盈利机构, 由它来决定apache web服务器的标准发行版中应该包含哪些内容. 准许任何人修改隐错, 提供新的特征和将它移植到新的平台上, 以及其它的工作. 当新的代码被提交给apache group时, 该团体审核它的具体内容, 进行测试, 如果认为满意, 该代码就会被集成到apache的主要发行版中。 apache 的特性: 1) 几乎可以运行在所有的计算机平台上. 2) 支持最新的http/1.1协议 3) 简单而且强有力的基于文件的配置(httpd.conf). 4) 支持通用网关接口(cgi) 5) 支持虚拟主机. 6) 支持http认证. 7) 集成perl. 8) 集成的代理服务器 9) 可以通过web浏览器监视服务器的状态, 可以自定义日志. 10) 支持服务器端包含命令(ssi). 11) 支持安全socket层(ssl). 12) 具有用户会话过程的跟踪能力. 13) 支持fastcgi 14) 支持java servlets nginx Nginx是俄罗斯人编写的十分轻量级的HTTP服务器,Nginx，它的发音为“engine X”， 是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP 代理服务器．Nginx是由俄罗斯人 Igor Sysoev为俄罗斯访问量第二的 Rambler.ru站点开发。 Nginx以事件驱动的方式编写，所以有非常好的性能，同时也是一个非常高效的反向代理、负载均衡。其拥有匹配 Lighttpd的性能，同时还没有Lighttpd的内存泄漏问题，而且Lighttpd的mod_proxy也有一些问题并且很久没有更新。但是Nginx并不支持cgi方式运行，原因是可以减少因此带来的一些程序上的漏洞。所以必须使用FastCGI方式来执行PHP程序。 nginx做为HTTP服务器，有以下几项基本特性： 1）处理静态文件，索引文件以及自动索引。 2）无缓存的反向代理加速，简单的负载均衡和容错。 3）FastCGI，简单的负载均衡和容错。 4）模块化的结构。包括gzipping, byte ranges, chunked responses,以及 SSI-filter等filter。如果由FastCGI或其它代理服务器处理单页中存在的多个SSI，则这项处理可以并行运行，而不需要相互等待。 5）Nginx专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率。它支持内核Poll模型，能经受高负载的考验,有报告表明能支持高达 50,000个并发连接数。 6）Nginx具有很高的稳定性。其它HTTP服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前apache一旦上到200个以上进程，web响应速度就明显非常缓慢了。而Nginx采取了分阶段资源分配技术，使得它的CPU与内存占用率非常低。nginx官方表示保持10,000个没有活动的连接，它只占2.5M内存，所以类似DOS这样的攻击对nginx来说基本上是毫无用处的。就稳定性而言,nginx比lighthttpd更胜一筹。 7）Nginx支持热部署。它的启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。 三种web服务器方案比较 server Apache Nginx Lighttpd Proxy代理 非常好 非常好 一般 Rewriter 好 非常好 一般 Fcgi 不好 好 非常好 热部署 不支持 支持 不支持 系统压力比较 很大 很小 比较小 稳定性 好 非常好 不好 安全性 好 一般 一般 技术支持 非常好 很少 一般 静态文件处理 一般 非常好 好 Vhosts虚拟主机 支持 不支持 支持 反向代理 一般 非常好 一般 Session sticky 支持 不支持 不支持 总结 一般我们选择httpd而不选择nginx的原因是Apache有较久远的历史，就算曾经有过bug但是现在也被改好了，然而，nginx还相对比较新，所以apache bug是比nginx少的，用起来也超级稳定。此外还有windows的IIS，和新出来的轻量级的lighttpd，但是总而言之，主流的web方案还是Apache。 注：在相对比较大的网站，节约下来的服务器成本无疑是客观的。而有些小型网站往往服务器不多，如果采用 Apache 这类传统 Web 服务器，似乎也还能撑过去。但有其很明显的弊端： Apache 在处理流量爆发的时候(比如爬虫或者是 Digg 效应) 很容易过载，这样的情况下采用 Nginx 最为合适。 建议方案： Apache 后台服务器（主要处理php及一些功能请求 如：中文url） Nginx 前端服务器（利用它占用系统资源少得优势来处理静态页面大量请求） Lighttpd 图片服务器 总体来说，随着nginx功能日渐完善，nginx应该会成为今后web server的主流方案。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-servers</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>servers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-servers-02 高可用]]></title>
    <url>%2Fservers-02%2F</url>
    <content type="text"><![CDATA[高可用在上一篇文章中，我们的反向代理+负载均衡实例如下 实例node1（反向代理+负载均衡）：192.168.141.53node3（web1）：192.168.141.12node4（web2）：192.168.141.132 但是，如果node1（反向代理+负载均衡服务器）挂掉了怎么办？是不是会导致我们的网站无法访问，从而造成损失？ 这时候就需要引入高可用方案了，例如keepalived、hearbeat、coresync等。 高可用性 高可用性HA（High Availability）指的是通过尽量缩短因日常维护操作（计划）和突发的系统崩溃（非计划）所导致的停机时间，以提高系统和应用的可用性。它与被认为是不间断操作的容错技术有所不同。HA系统是目前企业防止核心计算机系统因故障停机的最有效手段。 高可用架构高可用架构应具备但不限于以下特征： 1、主从切换 很好理解，当其中一台机器的服务宕机后，对于服务调用者来说，能够迅速的切换到其他可用服务，从服务升级为主服务，这种切换速度应当控制在秒级别（几秒钟）。 当宕机的服务恢复之后，自动变为从服务，主从服务角色切换。主从切换一定是要付出代价的，所以当主服务恢复之后，也就不再替换现有的主服务。 2、负载均衡 当服务的请求量比较高的时候，一台服务不能满足需求，这时候需要多台机器提供同样的服务，将所有请求分发到不同机器上。 高可用架构中应该具有丰富的负载均衡策略和易调节负载的方式。 甚至可以自动化智能调节，例如由于机器性能的原因，响应时间可能不一样，这时候可以向性能差的机器少一点分发量，保证各个机器响应时间的均衡。 3、易横向扩展 当用户量越来越多，已有服务不能承载更多的用户的时候，便需要对服务进行扩展，扩展的方式最好是不触动原有服务，对于服务的调用者是透明的。 实例解析node1（反向代理+负载均衡）：192.168.141.53node2（反向代理+负载均衡）：192.168.141.69node3（web1）：192.168.141.12node4（web2）：192.168.141.132 为了防止node1挂掉导致客户端无法访问我们搭建在node3和node4上面的web网站，所以我们加了一台反向代理+负载均衡服务器：node2。 可是新的问题随之而来，node1和node2的ip地址是不同的，客户端究竟应该访问node1还是node2呢？这就需要引入高可用方案keepalive+虚拟ip（vip）了。 实例解析node1（反向代理+负载均衡+keepalive主）：192.168.141.53node2（反向代理+负载均衡+keepalive从）：192.168.141.69node3（web1）：192.168.141.12node4（web2）：192.168.141.132vip：192.168.141.100 vip是基于vrrp协议的。vrrp组里有一台虚拟路由器，其具有虚拟ip+mac地址，该ip即vip。 VRRP：Virtual Router Redundancy Protocol，虚拟路由冗余协议。VRRP说白了就是实现地址漂移的，是一种容错协议，在提高可靠性的同时，简化了主机的配置。该协议能够实现将可以承担网关功能的一组路由器加入到备份组中，形成一台虚拟路由器，由VRRP的选举机制决定哪台路由器承担转发任务，局域网内的主机只需将虚拟路由器配置为缺省网关。 同样的道理，在服务器架构中，nginx1、nginx2的两个对外接口做一个vrrp对外提供一个虚拟ip，成为vip。有了vip的存在，让客户访问同一个vip即可，客户请求从vip转发到node1或者node2的真实网卡ip上，实现对node3和node4上面web的访问。nginx1、nginx2两服务器互相监测对方nginx是否正常运行，二者之间有一个监控机制。nginx1、nginx2之间，从服务器对主服务器始终进行心跳检测（组播、广播），主服务器挂了则从服务器顶上，这个机制类似于OSPF协议中的DR/BDR。 在lnamp架构中，最前面是nginx做反向代理加负载均衡和反向代理，后面有apache，再后面就是mysql，然后mysql后面是硬盘。apache服务器与mysql服务器交互，同时与缓存服务器（redies memcache）交互，因为从内存读取数据总比从直接从硬盘读数据快。nginx同时与apache的web1、web2交互，而web1、web2使用共享存储技术使得网站得以同步。 keepalived：单主模型：包括一主一从、一主多从模型 双主模型： 例如web1的主是node1，从是node2；而对于web2的主是node2，从是node1。双主可以防止资源浪费，不然会有一台或者多台从服务器呆着啥也不干浪费资源。 生产环境还有：三主、五主模型等 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-servers</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>servers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-servers-01 反向代理+负载均衡]]></title>
    <url>%2Fservers-01%2F</url>
    <content type="text"><![CDATA[linux-servers-01 反向代理+负载均衡概念解析概念引入 我们在一台服务器node4上搭建一个网站了，那么别人来访问我们的网站的时候，访问的是node4的ip地址。但是，随着业务量增加，一台服务器必然不堪重负。为了防止服务器宕机导致业务骤停而造成损失，我们需要增加一台服务器node4，平时帮node3分担压力，如果node3崩溃宕机的时候node4还在也不会导致网站无法访问。 那么现在我们就有了两台web服务器。但是，node4的ip地址与node3的ip地址是不同的，访问网站的时候到底去访问哪台服务器好呢？ 此外，还会出现这样的情况： 某时刻有很多人访问node3但是node4无人问津，那么node3的的压力会很大，而node4出现大量的资源闲置。那么如何解决两台web服务器ip地址不一样，而且二者访问量无法合理均衡的问题呢？ 反向代理和负载均衡技术就很好地解决了这些问题。 反向代理 在计算机网络中，反向代理是代理服务器的一种。服务器根据客户端的请求，从其关系的一组或多组后端服务器（如Web服务器）上获取资源，然后再将这些资源返回给客户端，客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器簇的存在。 与前向代理不同，前向代理作为客户端的代理，将从互联网上获取的资源返回给一个或多个的客户端，服务端（如Web服务器）只知道代理的IP地址而不知道客户端的IP地址；而反向代理是作为服务器端（如Web服务器）的代理使用，而不是客户端。客户端借由前向代理可以间接访问很多不同互联网服务器（簇）的资源，而反向代理是供很多客户端都通过它间接访问不同后端服务器上的资源，而不需要知道这些后端服务器的存在，而以为所有资源都来自于这个反向代理服务器。 负载均衡服务器 负载均衡服务器（load-balancing server）是进行负载分配的服务器。通过负载均衡服务器，将服务请求均衡分配到实际执行的服务中，从而保证整个系统的响应速度。 “负载均衡服务器”是本系统的控制服务器，所有用户的请求都首先到此服务器，然后由此服务器根据各个实际处理服务器状态将请求具体分配到某个实际处理服务器中，对外公开的域名与IP地址都是这台服务器。负载均衡控制与管理软件安装在这台服务器上，这台服务器一般只做负载均衡任务分配，但不是实际对网络请求进行处理的服务器。 常用方案负载均衡方案：lvs（/nat,dr,tun,fulltun）并发量小用nat，一般常用lvs/dr，还有haproxy、nginx（nginx负载均衡通过ngx_http_upstream_module模块 ）反向代理方案：varnish（web加速器）、nginx、haproxy正向代理方案：squid高可用方案：keepalived、hearbeat、coresync 实例解析node1（反向代理+负载均衡）：192.168.141.53node3（web1）：192.168.141.12node4（web2）：192.168.141.132 反向代理工作方式 通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。 由于外部网络上的主机并不会配置并使用这个代理服务器，普通代理服务器也被设计为在Internet上搜寻多个不确定的服务器,而不是针对Internet上多个客户机的请求访问某一个固定的服务器，因此普通的Web代理服务器不支持外部对内部网络的访问请求。当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。此时代理服务器对外就表现为一个Web服务器，外部网络就可以简单把它当作一个标准的Web服务器而不需要特定的配置。不同之处在于，这个服务器没有保存任何网页的真实数据，所有的静态网页或者CGI程序，都保存在内部的Web服务器上。因此对反向代理服务器的攻击并不会使得网页信息遭到破坏，这样就增强了Web服务器的安全性。 三种常见的代理服务器1． 标准的代理缓冲服务器 一个标准的代理缓冲服务被用于缓存静态的网页（例如：html文件和图片文件等）到本地网络上的一台主机上（即代理服务器）。当被缓存的页面被第二次访问的时候，浏览器将直接从本地代理服务器那里请求数据而不再向原web站点请求数据。这样就节省了宝贵的网络带宽，而且提高了访问速度。但是，要想实现这种方式，必须在每一个内部主机的浏览器上明确指明代理服务器的IP地址和端口号。客户端上网时，每次都把请求送给代理服务器处理，代理服务器根据请求确定是否连接到远程web服务器获取数据。如果在本地缓冲区有目标文件，则直接将文件传给用户即可。如果没有的话则先取回文件，先在本地保存一份缓冲，然后将文件发给客户端浏览器。 2． 透明代理缓冲服务器 透明代理缓冲服务和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。透明代理服务器阻断网络通信，并且过滤出访问外部的HTTP（80端口）流量。如果客户端的请求在本地有缓冲则将缓冲的数据直接发给用户，如果在本地没有缓冲则向远程web服务器发出请求，其余操作和标准的代理服务器完全相同。对于Linux操作系统来说，透明代理使用Iptables或者Ipchains实现。因为不需要对浏览器作任何设置，所以，透明代理对于ISP（Internet服务器提供商）特别有用。 3． 反向代理缓冲服务器 反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。它位于本地WEB服务器和Internet之间，处理所有对WEB服务器的请求，阻止了WEB服务器和Internet的直接通信。如果互联网用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发送给用户。这种方式通过降低了向WEB服务器的请求数从而降低了WEB服务器的负载。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-servers</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>servers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-docker-03 docker的使用]]></title>
    <url>%2Fdocker-03%2F</url>
    <content type="text"><![CDATA[linux-docker-03 docker的使用Docker基础命令我们以在容器内运行输出”Hello world”为例 123[root@localhost ~]# docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;Hello world[root@localhost ~]# 各个参数解析： docker: Docker 的二进制执行文件。 run:与前面的 docker 组合来运行一个容器。 ubuntu:15.10指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。 /bin/echo “Hello world”: 在启动的容器里执行的命令 以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 /bin/echo “Hello world”，然后输出结果。 运行交互式的容器我们通过docker的两个参数 -i -t，让docker运行的容器实现交互式 1234[root@localhost ~]# lsanaconda-ks.cfg[root@localhost ~]# docker run -i -t ubuntu:15.10 /bin/bashroot@4b780a9c7b0d:/# 参数解析： -t:在新容器内指定一个伪终端或终端。 -i:允许你对容器内的标准输入 (STDIN) 进行交互。 此时我们已进入一个 ubuntu15.10系统的容器 我们尝试在容器中运行命令 cat /proc/version和ls分别查看当前系统的版本信息和当前目录下的文件列表 123456root@4b780a9c7b0d:/# lsbin dev home lib64 mnt proc run srv tmp varboot etc lib media opt root sbin sys usrroot@4b780a9c7b0d:/# cat /proc/versionLinux version 3.10.0-862.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC) ) #1 SMP Fri Apr 20 16:44:24 UTC 2018root@4b780a9c7b0d:/# 我们可以通过运行exit命令或者使用CTRL+D来退出容器。 123root@4b780a9c7b0d:/# exitexit[root@localhost ~]# 启动容器（后台模式）使用以下命令创建一个以进程方式运行的容器 123[root@localhost ~]# docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;9c56a911ebcc7c20400257b9b8cb431c1d5af0e377b57ea0be12401cc0011bc0[root@localhost ~]# 在输出中，我们没有看到期望的”hello world”，而是一串长字符 9c56a911ebcc7c20400257b9b8cb431c1d5af0e377b57ea0be12401cc0011bc0 这个长字符串叫做容器ID，对每个容器来说都是唯一的，我们可以通过容器ID来查看对应的容器发生了什么。 首先，我们需要确认容器有在运行，可以通过 docker ps 来查看 1[root@localhost ~]# docker ps 字段解析CONTAINER ID:容器ID NAMES:自动分配的容器名称 在容器内使用docker logs命令，查看容器内的标准输出 1[root@localhost ~]# docker logs 9c56a911ebcc 1[root@localhost ~]# docker logs awesome_cray 停止容器我们使用 docker stop 命令来停止容器: 1[root@localhost ~]# docker stop 9c56a911ebcc 通过docker ps查看，容器已经停止工作 1[root@localhost ~]# docker ps 也可以用docker stop 容器名称来停止容器 1[root@localhost ~]# docker stop awesome_cray Docker 容器使用Docker 客户端输入 docker 命令来查看到 Docker 客户端的所有命令选项 1[root@localhost ~]# docker 可以通过命令 docker command –help 更深入的了解指定的 Docker 命令使用方法。 例如我们要查看 docker stats 指令的具体使用方法： 1[root@localhost ~]# docker stats --help 运行一个web应用使用 docker 构建一个 web 应用程序。 我们在docker容器中运行一个 Python Flask 应用来运行一个web应用。 1234[root@localhost ~]# docker pull training/webapp[root@localhost ~]# docker run -d -P training/webapp python app.py613b5d636ac49a6bb6f49f666e78f652187e077eb2748e4f3c39df80e38cfcd1[root@localhost ~]# 参数说明: -d:让容器在后台运行。 -P:将容器内部使用的网络端口映射到我们使用的主机上。 查看 WEB 应用容器使用 docker ps 来查看我们正在运行的容器，这里多了端口信息。 Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32768 上，这时我们可以通过浏览器访问WEB应用 我们也可以通过 -p 参数来设置不一样的端口 1[root@localhost ~]# docker run -d -p 5000:5000 training/webapp python app.py 再次查看正在运行的容器 1[root@localhost ~]# docker ps 现在浏览器访问http://192.168.141.84:5000或者http://192.168.141.84:32768均可看到hello world 查看容器的网络端口可以用docker port 容器名称查看 12[root@localhost ~]# docker port awesome_kepler5000/tcp -&gt; 0.0.0.0:5000 也可以用docker port 容器ID查看 12[root@localhost ~]# docker port 613b5d636ac45000/tcp -&gt; 0.0.0.0:32768 查看 WEB 应用程序日志docker logs [ID或者名字] 可以查看容器内部的标准输出。 1234[root@localhost ~]# docker logs -f awesome_kepler * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)192.168.141.1 - - [27/Mar/2019 00:58:10] &quot;GET / HTTP/1.1&quot; 200 -192.168.141.1 - - [27/Mar/2019 00:58:10] &quot;GET /favicon.ico HTTP/1.1&quot; 404 - -f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。 从上面，我们可以看到应用程序使用的是 5000 端口并且能够查看到应用程序的访问日志。 查看WEB应用程序容器的进程我们还可以使用 docker top 来查看容器内部运行的进程 1[root@localhost ~]# docker top awesome_kepler 检查 WEB 应用程序 使用 docker inspect 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。 1[root@localhost ~]# docker inspect awesome_kepler 停止、重启 WEB 应用容器123[root@localhost ~]# docker stop awesome_kepler[root@localhost ~]# docker restart awesome_kepler docker ps -l 查询最后一次创建的容器： 1[root@localhost ~]# docker ps -l 移除WEB应用容器删除容器时，容器必须是停止状态，否则会报如下错误 123[root@localhost ~]# docker rm awesome_keplerError response from daemon: You cannot remove a running container f1b70c57f98806b11fe24c05dadacc331f6932069336d16d6a63429f62996335. Stop the container before attempting removal or force remove[root@localhost ~]# 我们可以使用 docker rm 命令来删除不需要的且已经停止的容器 1[root@localhost ~]# docker rm awesome_kepler 移除该容器之后，可以看到该网页已经打不开了。 查看所有容器1[root@localhost ~]# docker ps -a Docker使用镜像镜像基本操作列出镜像列表我们可以使用 docker images 来列出本地主机上的镜像。 123456[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest fce289e99eb9 2 months ago 1.84kBubuntu 15.10 9b9cb95443b5 2 years ago 137MBtraining/webapp latest 6fae60ef3446 3 years ago 349MB[root@localhost ~]# 各个字段说明: REPOSITORY：表示镜像的仓库源 TAG：镜像的标签 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如ubuntu仓库源里，有15.10、14.04等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。 例如，我们如果要使用版本为15.10的ubuntu系统镜像来运行容器时，命令如下： 12[root@localhost ~]# docker run -t -i ubuntu:15.10 /bin/bash root@5e800258838a:/# 如果要使用版本为14.04的ubuntu系统镜像来运行容器时，命令如下： 1[root@localhost ~]# docker run -t -i ubuntu:14.04 /bin/bash 可以看到二者的差别仅仅是15.10与14.04的不同，但是如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。 查找镜像我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： https://hub.docker.com 这个网址需要翻墙才能打开，哎~ docker在中国的镜像仓库： https://www.docker-cn.com/registry-mirror 我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个httpd的镜像来作为我们的web服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。 1[root@localhost ~]# docker search httpd NAME:镜像仓库源的名称 DESCRIPTION:镜像的描述 OFFICIAL:是否docker官方发布 获取镜像 Docker运行容器前需要本地存在对应的镜像，如果镜像不存在，Docker 会从公共镜像仓库下载（默认Docker Hub） 1234567891011[root@localhost ~]# docker pull httpdUsing default tag: latestlatest: Pulling from library/httpd27833a3ba0a5: Pull complete 7df2f4a2bf95: Pull complete bbda6f884d14: Pull complete eb331aac1c31: Pull complete ef7c5393eddd: Pull complete Digest: sha256:a7810e999e74d7e2a350ceabb11874cb4a2fbbd0e53b90dcdee40bc7532e2a06Status: Downloaded newer image for httpd:latest[root@localhost ~]# 下载完成后，我们可以直接使用这个镜像来运行容器。 1[root@localhost ~]# docker run httpd 创建镜像当我们从docker镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。 1.从已经创建的容器中更新镜像，并且提交这个镜像 2.使用 Dockerfile 指令来创建一个新的镜像 更新镜像更新镜像之前，我们需要使用镜像来创建一个容器。 在运行的容器内使用 apt-get update 命令进行更新。 在完成操作之后，输入 exit命令来退出这个容器。 12345[root@localhost ~]# docker run -t -i ubuntu:15.10 /bin/bashroot@6f96516f979d:/# apt-get updateroot@6f96516f979d:/# exitexit[root@localhost ~]# 此时ID为6f96516f979d的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit来提交容器副本。 12345678910111213141516[root@localhost ~]# docker commit -m=&quot;has update&quot; -a=&quot;feng&quot; 6f96516f979d my/ubuntu:v2sha256:3042e8d9219ab4a49990f0262a1ebe5162667ff2b7c2620d39953ee8b0479597[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmy/ubuntu v2 3042e8d9219a 5 seconds ago 137MBhttpd latest 5eace252f2f2 14 hours ago 132MBhello-world latest fce289e99eb9 2 months ago 1.84kBubuntu 15.10 9b9cb95443b5 2 years ago 137MB[root@localhost ~]# #docker commit的参数说明Options: -a, --author string Author (e.g., &quot;John Hannibal Smith &lt;hannibal@a-team.com&gt;&quot;) -c, --change list Apply Dockerfile instruction to the created image -m, --message string Commit message -p, --pause Pause container during commit (default true) 使用我们的新镜像 my/ubuntu 来启动一个容器 12345678[root@localhost ~]# docker run -d my/ubuntu:v2 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;58e904d93bfd755a1466b58304b1529a3854ce4f7ef098ffe5bbae6dfa483411[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES58e904d93bfd my/ubuntu:v2 &quot;/bin/sh -c &apos;while t…&quot; 3 seconds ago Up 2 seconds nostalgic_perlmanbc08980f2672 ubuntu:15.10 &quot;/bin/bash&quot; 13 minutes ago Up 11 minutes elated_edison14400b5c2c28 training/webapp &quot;python app.py&quot; 22 minutes ago Up 22 minutes 0.0.0.0:32768-&gt;5000/tcp practical_bardeen[root@localhost ~]# 如下图，因为sleep和while循环，所以这个进程得以一直持续，才能用docker ps查看到，否则已执行完的进行在ps里是看不到的。 构建镜像 我们使用命令 docker build ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。 1234567891011[root@localhost ~]# cat Dockerfile FROM centos:6.7MAINTAINER Fisher &quot;fisher@sudops.com&quot;RUN /bin/echo &apos;root:123456&apos; |chpasswdRUN useradd testRUN /bin/echo &apos;test:123456&apos; |chpasswdRUN /bin/echo -e &quot;LANG=\&quot;en_US.UTF-8\&quot;&quot; &gt;/etc/default/localEXPOSE 22EXPOSE 80CMD /usr/sbin/sshd -D 每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。 第一条FROM，指定使用哪个镜像源 RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。 然后，我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。 1[root@localhost ~]# docker build -t test/centos:6.7 . 参数说明： -t ：指定要创建的目标镜像名 . ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径 使用docker images 查看创建的镜像已经在列表中存在,镜像ID为 f7fc7dac3d4b 123456789[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest/centos 6.7 f7fc7dac3d4b About a minute ago 191MBmy/ubuntu v2 3042e8d9219a 21 minutes ago 137MBhttpd latest 5eace252f2f2 15 hours ago 132MBcentos 6.7 9f1de3c6ad53 12 days ago 191MBhello-world latest fce289e99eb9 2 months ago 1.84kBubuntu 15.10 9b9cb95443b5 2 years ago 137MB[root@localhost ~]# 我们可以使用新的镜像来创建容器 可以看到新镜像已经包含我们创建的用户test 12345678[root@localhost ~]# docker run -t -i test/centos:6.7 /bin/bash[root@ed188df5e15d /]# lsbin dev etc home lib lib64 lost+found media mnt opt proc root sbin selinux srv sys tmp usr var[root@ed188df5e15d /]# id testuid=500(test) gid=500(test) groups=500(test)[root@ed188df5e15d /]# exitexit[root@localhost ~]# 设置镜像标签我们可以使用 docker tag 命令，为镜像添加一个新的标签。 12345678910111213141516171819[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest/centos 6.7 f7fc7dac3d4b 3 minutes ago 191MBmy/ubuntu v2 3042e8d9219a 23 minutes ago 137MBhttpd latest 5eace252f2f2 15 hours ago 132MBcentos 6.7 9f1de3c6ad53 12 days ago 191MBhello-world latest fce289e99eb9 2 months ago 1.84kBubuntu 15.10 9b9cb95443b5 2 years ago 137MB[root@localhost ~]# docker tag f7fc7dac3d4b test/centos:dev[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest/centos 6.7 f7fc7dac3d4b 3 minutes ago 191MBtest/centos dev f7fc7dac3d4b 3 minutes ago 191MBmy/ubuntu v2 3042e8d9219a 23 minutes ago 137MBhttpd latest 5eace252f2f2 15 hours ago 132MBcentos 6.7 9f1de3c6ad53 12 days ago 191MBhello-world latest fce289e99eb9 2 months ago 1.84kBubuntu 15.10 9b9cb95443b5 2 years ago 137MB[root@localhost ~]# 可以看到，ID为f7fc7dac3d4b的镜像多一个标签。]]></content>
      <categories>
        <category>linux</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-docker-02 docker安装与部署]]></title>
    <url>%2Fdocker-02%2F</url>
    <content type="text"><![CDATA[linux-docker-02 docker安装与部署实验准备准备一台干净的虚拟机 前提条件Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。 Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。 实验步骤通过 uname -r 命令查看你当前的内核版本，如下，可以看到我的当前内核版本是支持安装docker的。 123[root@localhost ~]# uname -r3.10.0-862.el7.x86_64[root@localhost ~]# 安装 Docker1.安装一些必要的系统工具 1[root@localhost ~]# yum install -y yum-utils device-mapper-persistent-data lvm2 添加软件源信息 1[root@localhost ~]# yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 3.更新 yum 缓存 1[root@localhost ~]# yum makecache fast 4.安装 Docker-ce 1[root@localhost ~]# yum -y install docker-ce 5.启动 Docker 后台服务 12[root@localhost ~]# systemctl restart docker[root@localhost ~]# systemctl enable docker 6.测试运行 hello-world 由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行。 1[root@localhost ~]# docker run hello-world 注意：若运行docker run hello-world时镜像拉取超时导致报错（如下图），先配置好下面的镜像加速，然后再尝试运行docker run hello-world即可。 镜像加速 鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，新版的 Docker 使用 /etc/docker/daemon.json（Linux）来配置 Daemon，这里我们选用daocloud的镜像源，是我目前所知中速度最快的。 123456789[root@localhost ~]# vim /etc/docker/daemon.json[root@localhost ~]# cat /etc/docker/daemon.json&#123; &quot;registry-mirrors&quot;: [&quot;http://141e5461.m.daocloud.io&quot;]&#125;[root@localhost ~]# [root@localhost ~]# systemctl daemon-reload[root@localhost ~]# systemctl restart docker[root@localhost ~]# 以下是国内加速地址Docker中国区官方镜像(http://www.docker-cn.com/registry-mirror)https://registry.docker-cn.com 网易http://hub-mirror.c.163.com ustchttps://docker.mirrors.ustc.edu.cn docker CE 与 docker EE2017年的3月1号之后，Docker的版本命名开始发生变化，同时将CE版本和EE版本进行分开。 Docker社区版（CE）：为了开发人员或小团队创建基于容器的应用,与团队成员分享和自动化的开发管道。docker-ce提供了简单的安装和快速的安装，以便可以立即开始开发。docker-ce集成和优化，基础设施。（免费） Docker企业版（EE）：专为企业的发展和IT团队建立谁。docker-ee为企业提供最安全的容器平台，以应用为中心的平台。（付费）]]></content>
      <categories>
        <category>linux</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-docker-01 docker基础学习]]></title>
    <url>%2Fdocker-01%2F</url>
    <content type="text"><![CDATA[linux-docker-01 docker基础学习概念解析容器技术 容器技术虚拟化技术已经成为一种被大家广泛认可的容器技术服务器资源共享方式，容器技术可以在按需构建容器技术操作系统实例的过程当中为系统管理员提供极大的灵活性。由于hypervisor虚拟化技术仍然存在一些性能和资源使用效率方面的问题，因此出现了一种称为容器技术（Container）的新型虚拟化技术来帮助解决这些问题。 容器和虚拟机的区别容器：操作系统层面的虚拟化 虚拟机：硬件层的虚拟化（hypervisor） 区别： 把一个公寓套间比作虚拟机，那么容器就是合租的模式，每一个容器就是公寓里的一个卧室，大家共享客厅和厨房，但是隔壁同学大声放音乐可能会吵到隔壁同学，并且从锁门保护隐私来看也不是这么的安全。 传统虚拟化方式 vs Docker 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程。而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 容器的三个特点1、容器具有不可变的特性 在it运维过程中，环境变化是导致运维故障的主要原因，例如本地安装的python3，上架到服务器上调试时发现服务器原有环境是Python2，这就会导致问题出现。或者开发工作结束后，到服务器上测试会由于环境不同而出现很多问题。然而docker技术解决了问题，只要定义了docker file的环境，则有了一次构建，到处执行的特性。 2、容器都非常轻量 VM虚拟化程度更高，可以在物理机或者虚拟机创建多个容器 3、容器的创建速度更快 秒级启动、创建、销毁 Docker Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 Docker参考资料官方网站：https://www.docker.com/ 官方文档：https://docs.docker.com/ Docker 发展历史 Docker最初是dotCloud公司创始人Solomon Hykes。 üDocker使用Google公司推出的Go语言进行开发实现。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。 Docker 的优点1、简化程序 Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的任务，在Docker容器的处理下，只需要数秒就能完成，容器使软件具备了超强的可移植能力。 2、避免选择恐惧症 如果你有选择恐惧症，还是资深患者。Docker 帮你 打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。 3、节省开支 一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。 4、总结： 更高效的利用系统资源、更快速的启动时间、一致的运行环境、持续交付和部署、更轻松的迁移、更轻松的维护和扩展。 docker等于容器container 吗？实则不然docker是一种以容器技术为核心的一套应用的构建、分发、执行的体系和生态 docker体系docker engine ：docker 引擎，控制容器创建、销毁、管理 docker hub：docker 仓库，用来存放docker镜像，docker镜像仓库：hub.docker.com docker machine：让容器能快速封发到主机上执行，包括私有云公有云和物理机，比作将集装箱运往船上的吊车，而私有云公有云和物理机就是船，容器就是集装箱 docker compose：Compose是Docker的服务编排工具，主要用来构建基于Docker的复杂应用，Compose 通过一个配置文件来管理多个Docker容器，非常适合组合使用多个容器进行开发的场景。 docker S：吊车将集装箱运往船上时，需要通过一套完整的自动化体系去编排各种步骤的顺序，docker S是一种编排体系。 docker解决的问题1.程序在我这里跑的好好的，怎么到你那里就不行了？ 2.系统好卡，是哪个进程把CPU给吃光了？ 3.这套系统我已经搭建好了，要不你再重新搭建一遍？ 4.如今的IT架构已经变得非常复杂，开发人员通常需要多种服务构建和组装应用。而且应用可能部署到不同的环境上（虚拟服务器，公有云，私有云）。 5.一个应用包含多种服务，这些服务都有不同的依赖库和软件包。多种部署环境，如果需要动态迁移的时候，如何保证应用正常运行？这会大大消耗开发人员和运维人员的时间和精力，开发人员编写代码时需要考虑到不同的运行环境；运维人员，则需要为不同的服务和平台配置环境。 搭建一套系统是非常繁琐的过程，至少需要十天半个月。然而用docker构建环境是非常快速的、自动化的。docker解决了环境变化带来的问题，解决了进程和进程之间资源的隔，通过linux内核本身特性，实现资源的隔离。 解决方法： Docker 将集装箱思想运用到软件打包上，为代码提供了一个基于容器的标准化运输系统。Docker 可以将任何应用及其依赖打包成一个轻量级、可移植、自包含的容器。 Docker的优势对于开发人员——Build Once, Run Anywhere 容器意味着环境隔离和可重复性。开发人员只需为应用创建一次运行环境，然后打包成容器便可在其他机器上运行。另外，容器环境与所在的 Host 环境是隔离的，就像虚拟机一样，但更快更简单。 对于运维人员——Configure Once, Run Anything 只需要配置好标准的 runtime 环境，服务器就可以运行任何容器。这使得运维人员的工作变得更高效，一致和可重复。容器消除了开发、测试、生产环境的不一致性。 从全球航运视角认识docker 没有集装箱就没有全球化，集装箱改变世界，docker也在改变世界。集装箱是二十世纪最伟大的发明之一，不同尺寸的货物在全世界如何通过一种低沉本、快速的方式去运输？ docker类比于传统航运体系 建立”航运“技术标准的挑战有集装箱尺寸形状、装卸流程、吊车尺寸、通关流程等，docker自然也面临这些挑战。 集装箱：变革了人类整个生产流程体系，让地球变平了 docker：变革IT领域的软件交付方式，让IT之间的鸿沟消失 Docker的应用场景 Web 应用的自动化打包和发布。 自动化测试和持续集成、发布。 在服务型环境中部署和调整数据库或其他的后台应用。 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。 企业在哪些场景会用到docker1.构建devops流程，实现运维自动化 2.企业私有的PAAS平台，降低开发成本，提升效率 3.企业级AppStore，统一的后端系统分发平台，让所有后端系统标准化系统化地进行管理和分发 4.间歇式计算任务，让其非常轻量级，可以秒级创建。启动、销毁 5.构建微服务架构 docker使用实践经验1、3C原则（一个容器只运行一个应用），一个集装箱一个目的地，方便调配和管理 使用镜像来交付应用程序，不要直接部署，很多人习惯创建一个容器，然后在容器里安装一个系统，然后登录到系统里直接安装部署，其实这是非常不好的，正确的方式是通过docker file定义整个环境然后biuld成镜像，然后通过镜像去分发、执行。 2、分层构建镜像 不要将所有东西所有打包成一个镜像，例如县构建一个基础的ubantu的镜像，然后在其他镜像里面去引用它，一般把系统基础镜像划分为一个层次，environment环境划分为一个层次，最后将应用镜像划分为一个层次。后面形成镜像叠加 3、不要把本地运行的容器转成镜像 很多人习惯将容器当成虚拟机来使用，安装好所有东西后push到仓库，这样是非常不好的，我们应道使用镜像来交付应用，而不是直接部署 4、不要将数据存储在容器中，因为容器一旦销毁就没了 可以将一些不变的数据存储到专门存储数据的镜像，或者把一些外部设备映射到镜像里面 docker核心概念 概念 解析 镜像(Images) Docker 镜像是用于创建 Docker 容器的只读模板，包含一个最小 root文件系统。 容器(Container) 容器是独立运行的一个或一组应用。 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker API (https://docs.docker.com/reference/api/docker_remote_api) 与 Docker 的守护进程通信。 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 仓库(Registry) Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。 Machine Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 Docker镜像 Docker 镜像（Image）是一个只读模版，包含一个最小 root文件系统。Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 Docker容器 Docker 容器就是 Docker 镜像的运行实例，用户可以通过 CLI（docker）或是 API 启动、停止、移动或删除容器。对于应用软件，镜像是软件生命周期的构建和打包阶段，而容器则是启动和运行阶段。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。 Docker仓库Registry 是存放 Docker 镜像的仓库进行集中存储和分发。Registry 分私有和公有两种：公共仓库：Docker Hub私有仓库：用户自己创建的仓库 Docker组件协同工作流程①Docker客户端执行docker run 命令②Docker daemon发现本地没有httpd镜像③Dameon从Docker Hub 下载镜像④下载完成，镜像被保存到本地⑤Docker daemon启动容器 Docker 架构 Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器，Docker 容器通过 Docker 镜像来创建，容器与镜像的关系类似于面向对象编程中的对象与类。 Docker 采用的是 Client/Server 架构，客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个 Host 上，客户端也可以通过 socket 或REST API 与远程的服务器通信。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-git-05 搭建Git服务器]]></title>
    <url>%2Fgit-05%2F</url>
    <content type="text"><![CDATA[linux-git-05 搭建Git服务器GitLab GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务，安装方法可以参考GitLab在GitHub上的Wiki页面。 实验准备一台干净的虚拟机的内存给4G以上，建议使用方案2，这里也用方案2来演示。 方案1： 12345678910[root@node2 ~]# yum install git -y[root@node2 ~]# adduser git[root@node2 git]# mkdir .ssh/放入公钥并初始化：[root@node2 git]# vim .ssh/authorized_keys[root@node2 git]# cd /srv/[root@node2 srv]# git init --bare sample.git[root@node2 srv]# chown -R git:git sample.git/克隆仓库：[root@node1 ~]# git clone git@node2:/srv/sample.git 方案2： GitLab安装 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849环境准备：[root@localhost ~]# yum install -y curl policycoreutils-python openssh-server[root@localhost ~]# systemctl enable sshd[root@localhost ~]# systemctl start sshd[root@localhost ~]# firewall-cmd --add-port=&#123;8090,80&#125;/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# 邮箱服务：[root@localhost ~]# yum install postfix -y[root@localhost ~]# systemctl enable postfix[root@localhost ~]# systemctl start postfix[root@localhost ~]# 配置YUM源：[root@localhost ~]# vim /etc/yum.repos.d/gitlab_ce.repo[root@localhost ~]# cat /etc/yum.repos.d/gitlab_ce.repo[gitlab-ce]name=Gitlab CE Repositorybaseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/gpgcheck=0enabled=1[root@localhost ~]# yum makecache[root@localhost ~]# yum install gitlab-ce -y[root@localhost ~]# sed -i &quot;s/^external_url.*/external_url &apos;http:\/\/192.168.141.132:8090&apos;/g&quot; /etc/gitlab/gitlab.rb[root@localhost ~]#注意：192.168.141.132是虚拟机ip注意：\/\/是//的转义注意：s/^external_url.*/external_url中的s表示替换注意：gitlab本身采用80端口，如安装前服务器有启用80，安装完访问会报错，需更改gitlab的默认端口。注意：unicorn本身采用8080端口，如安装前服务器有启用8080，安装完访问会报错，需更改unicorn的默认端口。每次更改后使配置生效：[root@localhost ~]# gitlab-ctl reconfiguregitlab 日常管理命令： gitlab-ctl start gitlab-ctl stop gitlab-ctl status gitlab-ctl restart gitlab-ctl reconfigure最后通过浏览器：http://$Host_IP:8090默认root用户，并且重置密码 注意， gitlab-ctl reconfigure敲完之后，需要等待较久的时间，如下图，我等了3分13秒。然后，登完之后在开始打开浏览器进行验证，才能看到效果。 验证 如下图，gitlab功能和git是基本一样的，搭建在公司内部服务器上，就成为了一个私有的开源git平台。刚开始，需要你设置root管理员的密码，密码长度至少8个字符。 设置好密码后，现在就可以用root用户名和你刚刚设置好的密码登录了。 如下图，登录上来是这个样子的，也github大差不差，功能齐全，操作简单，剩下的这里不再赘述，其中妙处需要自己体验。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-git-04 git分支管理]]></title>
    <url>%2Fgit-04%2F</url>
    <content type="text"><![CDATA[linux-git-04 git分支管理 问题：假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 分支的作用：创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 我们依然用本地仓库：firstgit来演示，首先看看里面的已有文件内容 123456789[root@localhost firstgit]# ls1.txt readme.txt[root@localhost firstgit]# cat readme.txt hello readme[root@localhost firstgit]# cat 1cat: 1: 没有那个文件或目录[root@localhost firstgit]# cat 1.txt i am first[root@localhost firstgit]# 快速合并 12345678910111213141516171819202122232425262728293031323334353637383940创建分支“dev”，合并分支[root@localhost firstgit]# git checkout -b devM readme.txt切换到一个新分支 &apos;dev&apos;[root@localhost firstgit]# git branch* dev master[root@localhost firstgit]# cat 1.txt i am first[root@localhost firstgit]# echo &quot;This is dev operation&quot; &gt; 1.txt [root@localhost firstgit]# git add 1.txt[root@localhost firstgit]# git commit -m &quot;modify 1.txt&quot;[dev a0d7502] modify 1.txt 1 file changed, 1 insertion(+), 1 deletion(-)[root@localhost firstgit]# git checkout masterM readme.txt切换到分支 &apos;master&apos;[root@localhost firstgit]# cat 1.txt i am first[root@localhost firstgit]# git merge dev更新 6f7081e..a0d7502Fast-forward 1.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)[root@localhost firstgit]# cat 1.txt This is dev operation[root@localhost firstgit]# git branch -d dev已删除分支 dev（曾为 a0d7502）。[root@localhost firstgit]# cat 1.txt This is dev operation[root@localhost firstgit]# 命令解释：查看分支：git branch创建分支：git branch &lt;name&gt;切换分支：git checkout &lt;name&gt;创建+切换分支：git checkout -b &lt;name&gt;合并某分支到当前分支：git merge &lt;name&gt;删除分支：git branch -d &lt;name&gt; 在上面这个例子中，主分支没有修改1.txt，只有dev分支修改了1.txt，那么主分支与dev分支合并的时候就不会产生冲突。与其说是合并，倒不如理解成没有主见的主分支采取了dev分支的意见，可以完成快速合并。 那么，如果除了dev分支，还有主分支对1.txt也进行了修改，导致二者之间各抒己见，就会产生冲突，这时候就没有办法快速合并了，你得手动解决二者之间的冲突之后，才能完成合并，下面我们新建一个test分支来测试一下如何进行冲突合并。 冲突合并 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495[root@localhost firstgit]# git checkout -b testM readme.txt切换到一个新分支 &apos;test&apos;[root@localhost firstgit]# cat 1.txt This is dev operation[root@localhost firstgit]# echo &quot;test1&quot; &gt;&gt; 1.txt [root@localhost firstgit]# cat 1.txt This is dev operationtest1[root@localhost firstgit]# git add 1.txt[root@localhost firstgit]# git commit -m &quot;add test1&quot; [test 11e4e6b] add test1 1 file changed, 1 insertion(+)[root@localhost firstgit]# git checkout master M readme.txt切换到分支 &apos;master&apos;您的分支领先 &apos;origin/master&apos; 共 1 个提交。 （使用 &quot;git push&quot; 来发布您的本地提交）[root@localhost firstgit]# echo &quot;test2&quot; &gt;&gt; 1.txt [root@localhost firstgit]# cat 1.txt This is dev operationtest2[root@localhost firstgit]# git add 1.txt[root@localhost firstgit]# git commit -m &quot;add test2&quot; [master bbf9686] add test2 1 file changed, 1 insertion(+)[root@localhost firstgit]# git merge test自动合并 1.txt冲突（内容）：合并冲突于 1.txt自动合并失败，修正冲突然后提交修正的结果。[root@localhost firstgit]# 合并失败：因为现在test分支和master分支同级，而且二者之间产生了冲突！解决办法：[root@localhost firstgit]# git status# 位于分支 master# 您的分支领先 &apos;origin/master&apos; 共 2 个提交。# （使用 &quot;git push&quot; 来发布您的本地提交）## 您有尚未合并的路径。# （解决冲突并运行 &quot;git commit&quot;）## 未合并的路径：# （使用 &quot;git add &lt;file&gt;...&quot; 标记解决方案）## 双方修改： 1.txt## 尚未暂存以备提交的变更：# （使用 &quot;git add &lt;file&gt;...&quot; 更新要提交的内容）# （使用 &quot;git checkout -- &lt;file&gt;...&quot; 丢弃工作区的改动）## 修改： readme.txt#修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）[root@localhost firstgit]# [root@localhost firstgit]# cat 1.txt This is dev operation&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADtest2=======test1&gt;&gt;&gt;&gt;&gt;&gt;&gt; test[root@localhost firstgit]# 上面这个echo显示出来的结果表示，主分支写的是test2但是test分支写的是test1，那么二者之间就产生了冲突。这里需要我们手动修改1.txt冲突的内容，然后再次添加和提交[root@localhost firstgit]# vim 1.txt [root@localhost firstgit]# cat 1.txt This is dev operationtest12[root@localhost firstgit]# [root@localhost firstgit]# git add 1.txt[root@localhost firstgit]# git commit -m &quot;test12&quot;[master 6caac74] test12[root@localhost firstgit]# cat 1.txt This is dev operationtest12[root@localhost firstgit]# 上面重新对1.txt进行了修改和提交之后，冲突得到了解决，那么合并过程到此彻底完成。查看分支合并情况：[root@localhost firstgit]# git log --graph --pretty=oneline --abbrev-commit* 6caac74 test12|\ | * 11e4e6b add test1* | bbf9686 add test2|/ * a0d7502 modify 1.txt* 6f7081e add 1.txt* 01633f9 change messages* c391307 write something[root@localhost firstgit]# Bug分支 环境：当我们正在dev开发新功能的时候，突然有个紧急bug111需要修复，这是我们就需要将当前dev分支通过git stash命令打快照，然后假设去修改master分支上的bug，然后就需要先切换到master分支，然后再创建并切换到issue-111分支，进行修复，修复后将issue-111分支合并到master分支即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081在test分支，修改1.txt文件，然后stash将现场快照[root@localhost firstgit]# git checkout testM readme.txt切换到分支 &apos;test&apos;[root@localhost firstgit]# cat 1.txt This is dev operationtest1[root@localhost firstgit]# echo &quot;111&quot; &gt; 1.txt[root@localhost firstgit]# cat 1.txt 111[root@localhost firstgit]# git stash # 打快照Saved working directory and index state WIP on test: 11e4e6b add test1HEAD 现在位于 11e4e6b add test1[root@localhost firstgit]#创建issue-111分支，修复bug（修改1.txt）的内容，然后add，commit[root@localhost firstgit]# git checkout -b issue-111切换到一个新分支 &apos;issue-111&apos;[root@localhost firstgit]# echo &quot;11111&quot; &gt; 1.txt [root@localhost firstgit]# git add 1.txt [root@localhost firstgit]# git commit -m &quot;change 11111&quot;[issue-111 93d8aa1] change 111 1 file changed, 1 insertion(+) create mode 100644 money.txt[root@localhost firstgit]# git status# 位于分支 issue-111无文件要提交，干净的工作区[root@localhost firstgit]# 将issue-111分支合并到master分支[root@localhost firstgit]# git checkout master 切换到分支 &apos;master&apos;您的分支领先 &apos;origin/master&apos; 共 6 个提交。 （使用 &quot;git push&quot; 来发布您的本地提交）[root@localhost firstgit]# git merge issue-111自动合并 1.txt冲突（内容）：合并冲突于 1.txt自动合并失败，修正冲突然后提交修正的结果。[root@localhost firstgit]# vim 1.txt [root@localhost firstgit]# cat 1.txt This is dev operationtest1211111[root@localhost firstgit]# [root@localhost firstgit]# git add 1.txt[root@localhost firstgit]# git commit -m &quot;11111&quot;[master bfd7bf0] 11111[root@localhost firstgit]# git checkout test切换到分支 &apos;test&apos;[root@localhost firstgit]# git status# 位于分支 test无文件要提交，干净的工作区[root@localhost firstgit]# git stash liststash@&#123;0&#125;: WIP on test: 11e4e6b add test1[root@localhost firstgit]# git stash pop # 恢复快照# 位于分支 test# 尚未暂存以备提交的变更：# （使用 &quot;git add &lt;file&gt;...&quot; 更新要提交的内容）# （使用 &quot;git checkout -- &lt;file&gt;...&quot; 丢弃工作区的改动）## 修改： 1.txt# 修改： readme.txt#修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）丢弃了 refs/stash@&#123;0&#125; (0fe7895c82dba8d77ed308963093c362ce5edfe6)[root@localhost firstgit]# [root@node1 Shell]# cat 1.txt 111然后继续在test分支上进行工作。删除分支命令：git branch -d (branchname)若要删除一个还未合并的feature分支，可以通过git branch -D &lt;name&gt;强行删除！ 多人协作 查看远程库信息，使用git remote -v 本地新建的分支如果不推送到远程，对其他人就是不可见的 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 rebase作用 rebase操作可以把本地未push的分叉提交历史整理成直线 rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比 标签管理创建标签 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a -m “blablabla…”可以指定标签信息； 命令git tag可以查看所有标签。 管理标签 命令git push origin 可以推送一个本地标签； 命令git push origin –tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-git-03 git远程仓库]]></title>
    <url>%2Fgit-03%2F</url>
    <content type="text"><![CDATA[linux-git-03 git远程仓库添加远程仓库 Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。有一台机器有一个原始版本库，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 步骤12341.注册Github账号2.创建SSH Key$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;3.登陆Github将id_rsa.pub文件的内容添加到SHH Key页面中 GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 添加远程仓库1.注册Github账号，官网：https://github.com 2.打开一台centos7的虚拟机，创建SSH Key，下面youremail@example.com这里可以填的你邮箱，然后直接敲三个回车即可，存放密钥用的是默认的文件夹，而且没有为密钥设置密码。 1234567891011ssh-keygen -t rsa -C &quot;youremail@example.com&quot;[root@localhost ~]# ls /root/.ssh/id_rsa id_rsa.pub[root@localhost ~]# cat /root/.ssh/id_rsa.pub 这里会显示公钥内容，把公钥复制下来[root@localhost ~]# 3.登录github，如下图，将上面复制好的ssh key公钥添加到你的github中。 复制上去后，给密钥起个名字，如下图我的是“myfirstkey”，然后点击Add SSH Key即可。 添加完成 仓库的创建1.先远程再本地（建议使用） 最佳选择是先创建远程库然后克隆到本地，但是创建远程库的时候选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。 创建远程仓库：testgit 复制仓库链接：https://github.com/ZhongEagles/testgit.git 123456789101112[root@localhost ~]# git clone 你刚刚复制的仓库链接正克隆到 &apos;testgit&apos;...remote: Enumerating objects: 3, done.remote: Counting objects: 100% (3/3), done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.[root@localhost ~]# lsanaconda-ks.cfg firstgit testgit[root@localhost ~]# cd testgit/[root@localhost testgit]# lsREADME.md[root@localhost testgit]# 然后你就可以在你的本地仓库进行开发了，例如我们写一个a.txt，然后同步到远程仓库。 123456789101112[root@localhost testgit]# vim a.txt[root@localhost testgit]# cat a.txt hello my testgit![root@localhost testgit]# [root@localhost testgit]# git add a.txt[root@localhost testgit]# git commit -m &quot;write a.txt&quot;[master 4e2168d] write a.txt 1 file changed, 1 insertion(+) create mode 100644 a.txt[root@localhost testgit]# git push -u origin master -u是update的意思，master是主分支的意思，这里需要你输入github账户名密码。 到网页上刷新一下，可以看到你推送上来的a.txt已经在这个远程仓库里面了。 2.先本地再远程（不建议使用）继续我们上一篇文章中用到的本地仓库firstgit。 12345[root@localhost testgit]# cd ..[root@localhost ~]# cd firstgit/[root@localhost firstgit]# ls1.txt readme.txt[root@localhost firstgit]# 在远程也创建一个仓库：firstgit 现在我们需要把这个仓库与远程仓库进行关联，复制仓库链接 1234[root@localhost firstgit]# git remote add origin https://github.com/ZhongEagles/firstgit.git[root@localhost firstgit]# git push -u origin master 输入账号密码 刷新一下网页，可以看到推送上去的俩文件。 总结 根据提示信息： 在命令行中创建新的仓库并关联 在命令行中关联已经存在的仓库 git push命令：把当前分支master推送到远程 从远程库克隆 最佳选择是先创建远程库然后克隆到本地，但是创建远程库的时候选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。 其他 github的pull requests是指在本地修改了别人的代码之后，请求别人的同意，别人同意就能同步，不同意就被驳回。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-git-02 git版本控制系统]]></title>
    <url>%2Fgit-02%2F</url>
    <content type="text"><![CDATA[linux-git-02 git版本控制系统集中式vs分布式 集中式CVS、SVN 速度慢，必须联网，开源精神不符 版本库集中放在中央服务器，工作时，获取最新版本，工作完成后，再推送给中央服务器！ 分布式 无中央服务器，每个人的电脑都是一个完整的版本库 安全性能更高 通常有一台充当“中央服务器”的电脑，仅仅作为方便“交换”大家的修改 安装使用Yum安装： 1[root@localhost ~]# yum install git -y 为node1上所有的git仓库设置用户名和Email 12[root@node1 ~]# git config --global user.name &quot;Your Name&quot;[root@node1 ~]# git config --global user.email &quot;email@example.com&quot; 创建并初始化版本库 12345678910[root@localhost ~]# mkdir firstgit[root@localhost ~]# cd firstgit/[root@localhost firstgit]# git init初始化空的 Git 版本库于 /root/firstgit/.git/[root@localhost firstgit]# ls[root@localhost firstgit]# ls -ah. .. .git.git目录作用：跟踪管理版本库 所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 常规操作1.把文件添加到仓库中 123456[root@localhost firstgit]# echo &quot;hello world&quot; &gt; readme.txt[root@localhost firstgit]# git add readme.txt [root@localhost firstgit]# git commit -m &quot;write something&quot; [master（根提交） c391307] write something 1 file changed, 1 insertion(+) create mode 100644 readme.txt 2.修改文件内容，查询内容和状态并提交 1234567891011121314151617181920212223242526272829303132333435363738394041[root@localhost firstgit]# echo &quot;hello eagleslab&quot; &gt; readme.txt[root@localhost firstgit]# git status# 位于分支 master# 尚未暂存以备提交的变更：# （使用 &quot;git add &lt;file&gt;...&quot; 更新要提交的内容）# （使用 &quot;git checkout -- &lt;file&gt;...&quot; 丢弃工作区的改动）## 修改： readme.txt#修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）[root@localhost firstgit]# git diff readme.txt diff --git a/readme.txt b/readme.txtindex 3b18e51..8d0e700 100644--- a/readme.txt+++ b/readme.txt@@ -1 +1 @@-hello world+hello eagleslab[root@localhost firstgit]# git add readme.txt [root@localhost firstgit]# git status# 位于分支 master# 要提交的变更：# （使用 &quot;git reset HEAD &lt;file&gt;...&quot; 撤出暂存区）## 修改： readme.txt#[root@localhost firstgit]# git commit -m &quot;change messages&quot;[master 01633f9] change messages 1 file changed, 1 insertion(+), 1 deletion(-)[root@localhost firstgit]# git status# 位于分支 master无文件要提交，干净的工作区[root@localhost firstgit]# [root@localhost firstgit]# lsreadme.txt其中git status # 查询当前git仓库状态 git diff readme.txt # 查询发生变化的内容 -hello world 表示删减了hello world+hello eagleslab 表示增加了hello eagleslab 3.查询历史记录并版本退回 123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@node1 firstgit]# git logcommit 3efa7f0fc058f00b0a98171fb77b44ab31481c87 # 版本IDAuthor: Cokeku &lt;1154283293@qq.com&gt;Date: Mon Mar 18 22:42:38 2019 -0400 add zjcommit 7b92afbb9f118f7ae10c49abc3114e4ee91ed26aAuthor: Cokeku &lt;1154283293@qq.com&gt;Date: Mon Mar 18 22:37:05 2019 -0400 change messagescommit e380d2cc936e01e17065408000c42c21f114321aAuthor: Cokeku &lt;1154283293@qq.com&gt;Date: Mon Mar 18 22:31:25 2019 -0400 write a readme.txt file[root@node1 firstgit]# git reset --hard e380d2cc936e01e17065408000c42c21f114321a HEAD is now at e380d2c write a readme.txt file[root@node1 firstgit]# cat readme.txt hello world[root@node1 firstgit]# git reset --hard 3efa7f0fc058f00b0a98171fb77b44ab31481c87HEAD is now at 3efa7f0 add zj[root@node1 firstgit]# cat readme.txt hello eagleslab zhengjiang![root@localhost firstgit]# git logcommit 01633f92603eea86884e9ba4cc181fee859016adAuthor: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 15:07:06 2019 +0800 change messagescommit c3913073a08501d652624c2a0ccbe32e2aa70014Author: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 15:05:58 2019 +0800 write something[root@localhost firstgit]# cat readme.txt hello eagleslab[root@localhost firstgit]# git reset --hard c3913073a08501d652624c2a0ccbe32e2aa70014HEAD 现在位于 c391307 write something[root@localhost firstgit]# cat readme.txt hello world[root@localhost firstgit]# 其中git reset --hard 版本ID # 退回指定版本 4.回滚失误怎么办？记录每一次的命令： 123456789[root@localhost firstgit]# git reflogc391307 HEAD@&#123;0&#125;: reset: moving to c3913073a08501d652624c2a0ccbe32e2aa7001401633f9 HEAD@&#123;1&#125;: commit: change messagesc391307 HEAD@&#123;2&#125;: commit (initial): write something[root@localhost firstgit]# git reset --hard 01633f9HEAD 现在位于 01633f9 change messages[root@localhost firstgit]# cat readme.txt hello eagleslab[root@localhost firstgit]# 控制版本历史记录：因为git内部有个Head指针指向当前的版本，如果需要退回版本，只需要将Head指针指向相对应的版本号id，并且更新工作区文件。版本号不用写全，如图复制粘贴即可。 工作区和暂存区 工作区：当前所在的firstgit目录就是一个工作区 .git不算工作区，只是Git的版本库 版本库中有暂存区和自动创建的master分支及指向master的一个指针HEAD git add将文件放到缓存区（暂存区）中，git commit将缓存区内的文件提交到仓库中，提交到仓库中之后我们用git status才能看到working directory clean工作区域变空，我们的仓库的内容才是最新的，所以每次工作对仓库内容进行更改之后，要git add并且git commit。 git add：将修改后文件添加到暂存区 git commit：将暂存区的所有文件提交到master分支上 git跟踪的是每次修改而不是文件，如果不将修改添加到暂存区是无法加入commit中的 撤销修改 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset –hard 版本id，就回到了场景1，第二步按场景1操作 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，版本退回即可，不过前提是没有推送到远程库 删除文件 123456[root@localhost firstgit]# git status# On branch master# Changes not staged for commit:# (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) # 先删除再提交# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) # 将版本库中的最新内容同步到工作区# deleted: readme.tx 实例测试12345678910[root@localhost firstgit]# echo &quot;i am first&quot; &gt; 1.txt[root@localhost firstgit]# git add 1.txt [root@localhost firstgit]# git commit -m &quot;add 1.txt&quot;[master 6f7081e] add 1.txt 1 file changed, 1 insertion(+) create mode 100644 1.txt[root@localhost firstgit]# git status# 位于分支 master无文件要提交，干净的工作区[root@localhost firstgit]# 场景1：当你改乱了1.txt的内容，想直接丢弃工作区的修改时，用命令git checkout – file 123456789[root@localhost firstgit]# vim 1.txt [root@localhost firstgit]# cat 1.txt i am firstasdiausdaushduahsdiuhiuasjdoaishd[root@localhost firstgit]# git checkout 1.txt [root@localhost firstgit]# cat 1.txt i am first[root@localhost firstgit]# 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset –hard 版本id ，就回到了场景1；第二步按场景1操作。 123456789101112131415161718192021222324252627282930313233[root@localhost firstgit]# vim 1.txt [root@localhost firstgit]# cat 1.txt i am firstiauhdiusa&apos;asdhausddoaushdiau[root@localhost firstgit]# git add 1.txt [root@localhost firstgit]# git logcommit 6f7081e1b06730504533015604d51e55e21c175aAuthor: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 15:52:47 2019 +0800 add 1.txtcommit 01633f92603eea86884e9ba4cc181fee859016adAuthor: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 15:07:06 2019 +0800 change messagescommit c3913073a08501d652624c2a0ccbe32e2aa70014Author: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 15:05:58 2019 +0800 write something[root@localhost firstgit]# git reset --hard 6f7081e1b06730504533015604d51e55e21c175aHEAD 现在位于 6f7081e add 1.txt[root@localhost firstgit]# git checkout 1.txt [root@localhost firstgit]# cat 1.txt i am first[root@localhost firstgit]# git status# 位于分支 master无文件要提交，干净的工作区[root@localhost firstgit]# 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，版本退回即可，不过前提是没有推送到远程库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[root@localhost firstgit]# vim 1.txt [root@localhost firstgit]# cat 1.txt i am firstduasgiu\aasdasdasdasdasd[root@localhost firstgit]# git add 1.txt [root@localhost firstgit]# git commit -m &quot;add trash 1.txt&quot;[master ec3d8c4] add trash 1.txt 1 file changed, 7 insertions(+)[root@localhost firstgit]# git status# 位于分支 master无文件要提交，干净的工作区[root@localhost firstgit]# git logcommit ec3d8c40f68aa9928d7294c61866be82a2b8f81dAuthor: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 16:03:03 2019 +0800 add trash 1.txtcommit 6f7081e1b06730504533015604d51e55e21c175aAuthor: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 15:52:47 2019 +0800 add 1.txtcommit 01633f92603eea86884e9ba4cc181fee859016adAuthor: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 15:07:06 2019 +0800 change messagescommit c3913073a08501d652624c2a0ccbe32e2aa70014Author: feng &lt;yfengzone@outlook.com&gt;Date: Sun Mar 24 15:05:58 2019 +0800 write something[root@localhost firstgit]# git reset --hard 6f7081e1b06730504533015604d51e55e21c175aHEAD 现在位于 6f7081e add 1.txt[root@localhost firstgit]# cat 1.txt i am first[root@localhost firstgit]# git status# 位于分支 master无文件要提交，干净的工作区[root@localhost firstgit]# 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-git-01 git基础学习]]></title>
    <url>%2Fgit-01%2F</url>
    <content type="text"><![CDATA[linux-git-01 git基础学习概念引入在一个游戏公司里面有若干个部门，游戏中增加了一个新英雄，正常的开发流程是： 当前版本1.0的游戏–&gt;设计人物模型–&gt;设计技能模型–&gt;代码开发–&gt;测试–&gt;运维部署–&gt;版本升级为2.0 但是，不用部门开发效率不同，例如游戏人物模型设计好了但是技能模型没写完，二技能三技能都有了但是大招还没设计好，这时后面的所有部门就需要等待，等技能模型全部设计完成之后才能发布到第二版开发环境，测试时发现bug，等的时间就浪费了。 于是这里就有了持续集成： 不同部门开发出某一技能或某一皮肤模型就提交到第一版集成环境测试，看看会不会出错，不用等到第二版再测试；代码开发好之后，交付测试人员，持续交付；测试人员测试好之后给部署人员，持续部署。 这样做的好处就是，例如开发出一个二技能，就先测试这个二技能，在测试部门测试这个二技能的同时，技能设计部门还可以继续设计三技能，这样测试部门无需等到设计部门把新英雄的所有技能都设计出来就可以开始测试，所以称之为持续交付测试。同样的道理，测试人员测试某一技能没有问题的话，先把这个技能给运维部门先部署好，不用等到所有的技能都测好才进行部署，这样运维部门也能同时运作起来而不是傻傻地等。 总之，一个串行的开发流程，变成了半串行半并行的开发流程，如下图： 由上图可得，无论从时间还是效率上来看，都是持续交付的模式更优。那么，如何做到高效的版本管理呢？答案呼之欲出：git 概念解析GIT （分布式版本控制系统） Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 是用于 Linux内核开发的版本控制工具。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持（wingeddevil注：这得分是用什么样的服务端，使用http协议或者git协议等不太一样。并且在push和pull的时候和服务器端还是有交互的。），使源代码的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux kernel 这样的大项目来说自然很重要。 Git 最为出色的是它的合并跟踪（merge tracing）能力。 gitHub gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。 gitHub于2008年4月10日正式上线，除了git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。 GitHub可以托管各种git库，并提供一个web界面，但它与外国的SourceForge、Google Code或中国的coding的服务不同，GitHub的独特卖点在于从另外一个项目进行分支的简易性。为一个项目贡献代码非常简单：首先点击项目站点的“fork”的按钮，然后将代码检出并将修改加入到刚才分出的代码库中，最后通过内建的“pull request”机制向项目负责人申请代码合并。已经有人将GitHub称为代码玩家的MySpace。 GitLab GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务，安装方法可以参考GitLab在GitHub上的Wiki页面。 举例分析 例如，我在github上放了一个公开项目abc，初始版本是abc1.0，那么其他所有人都可以看到我的这个abc项目，并且可以对它进行下载或者克隆等。现在有甲乙丙丁四个人，甲看到我的项目还不错，但是有些地方需要修改完善一下，于是他下载了一份abc1.0到他们自己的电脑上对之进行修改。甲修改了abc1.0里面一张叫做a.jpg的图片，然后提交给我，请求采用他修改后的项目，我看到甲的确把a.jpg修改得更漂亮了，那么我就采用了甲修改后的项目，并将版本更新为abc2.0。 过了几天，乙和丙下载了我的项目abc2.0， 乙修改了abc2.0里面的b.jpg和c.jpg，丙修改了abc2.0里面的c.jpg和d.jpg，然后，两人都请求我采用他修改后的项目。这样一来，乙丙二人的修改之间就产生了冲突，这就是两个不同的项目分支。这时候我就需要做分支合并了，我会对两人的项目进行对比，发现二人之间冲突的是图片c.jpg，那么我会选择其中一个人修改后的c.jpg到新版项目里。另外，乙改好的b.jpg和丙改好的d.jpg也会被加到新版项目里。最终，分支合并完成，项目升级到了abc3.0。 后来又过了几天，丁下载了abc3.0，觉得其实可以省略所有图片，于是删除了a.jpg、b.jpg、c.jpg、d.jpg，然后请求我采用他修改后的项目。我觉得他的想法不错，就采用了其项目，于是就有了abc4.0。 这样的话，如果公司要赶项目，可以在最基础的1.0版本的项目上，多人同时开发，每做出一步改动就可以先同步到仓库中，不断地分之与合并，可以高效快速地吸取所有人的优秀改动到项目中。即使后面发现有些改动并不合适，也可以进行版本回滚，相当于对于每一次改动都做了备份，不会出现辛辛苦苦几十年，一夜回到解放前的尴尬状况。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-ansible-06 ansible-playbook部署LNMP]]></title>
    <url>%2Fansible-06%2F</url>
    <content type="text"><![CDATA[linux-ansible-06 ansible-playbook部署LNMP实验准备实验涉及到了unarchive模块，这个模块之前没有学到，这里加以补充。 ansible unarchive模块unarchive模块：http://docs.ansible.com/ansible/unarchive_module.html 功能：解压缩 用法： 1、将ansible主机上的压缩包在本地解压缩后传到远程主机上，这种情况下，copy=yes. 本地解压缩,解压缩位置不是默认的目录,没找到或传完删了 后传到远程主机 2、将远程主机上的某个压缩包解压缩到指定路径下。这种情况下，需要设置copy=no 远程主机上面的操作,不涉及ansible服务端 参数： copy：默认为yes，当copy=yes，那么拷贝的文件是从ansible主机复制到远程主机上的，如果设置为copy=no，那么会在远程主机上寻找src源文件 src：源路径，可以是ansible主机上的路径，也可以是远程主机上的路径，如果是远程主机上的路径，则需要设置copy=no dest：远程主机上的目标路径 mode：设置解压缩后的文件权限 实验环境准备两台干净的虚拟机 node1（ansible管理机）：192.168.141.53 node2（客户端）：192.168.141.69 配置准备node1安装ansible 12[root@node1 ~]# yum install epel-release -y[root@node1 ~]# yum install ansible -y 服务端修改主机清单配置文件host 123456[root@node1 ~]# vim /etc/ansible/hosts#在文档末尾加上一下这几行[node]node2 服务端修改host文件 12345[root@node1 ~]# vim /etc/hosts#在文档中加入下列一行192.168.141.69 node2 实现管理机对所有客户端的免密钥登录—ssh-key在node1生成密钥#提示生成的密钥放在/root/.ssh/id_dsa #提示是否给生成的密钥再加密一次，回车即可 #让你再确认一次，回车即可。 1234567891011121314151617181920212223242526272829[root@node1 ~]# ssh-keygen -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): #直接回车Created directory &apos;/root/.ssh&apos;.Enter passphrase (empty for no passphrase): #直接回车Enter same passphrase again: #直接回车Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:ekKryIWOOpY+BnW5QhineRozN2nLqYz1EEwM8fa1BoE root@node1The key&apos;s randomart image is:+---[RSA 2048]----+|o+ .. ||..E . || Oo.... ||B.@.oo . || % *..+ S ||o B..o o ||+oo+. + . ||+X o.. o ||Bo= . |+----[SHA256]-----+[root@node1 ~]# ll /root/.ssh/总用量 8-rw-------. 1 root root 1675 4月 11 11:30 id_rsa #生成后的私钥文件-rw-r--r--. 1 root root 392 4月 11 11:30 id_rsa.pub #公钥文件[root@node1 ~]# 把公钥发送到客户端机器上，第一次连接要输入yes，记录主机名跟IP，然后输出对方的密码即可 1[root@node1 ~]# ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.141.69 #公钥发送过去之后，登录对方的机器不用密码了。 1234567[root@node1 ~]# ssh 192.168.141.69Last login: Thu Apr 11 11:24:30 2019 from 192.168.141.1[root@node2 ~]# [root@node2 ~]# exit登出Connection to 192.168.141.69 closed.[root@node1 ~]# ansible测试第一次执行ansible的命令需要加yes回车，但是之后就可以直接执行了。 12345678910111213[root@node1 ~]# ansible node2 -m command -a &quot;echo hello&quot;The authenticity of host &apos;node2 (192.168.141.69)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:cFZVkPh6j57TyfDgnCxFrAXPxeifK3T2cUCZGde78uE.ECDSA key fingerprint is MD5:74:27:63:2b:dd:8e:28:b5:a0:fa:01:5d:75:5d:8e:b1.Are you sure you want to continue connecting (yes/no)? yesnode2 | CHANGED | rc=0 &gt;&gt;hello[root@node1 ~]# ansible node2 -m command -a &quot;echo hello&quot;node2 | CHANGED | rc=0 &gt;&gt;hello[root@node1 ~]# 实验步骤node1上roles文件夹里定义文件结构tree 123456789101112131415161718192021222324252627282930313233343536[root@node1 ~]# yum install tree -y[root@node1 ~]# mkdir -pv /etc/ansible/roles/&#123;mysql,php,web&#125;/&#123;files,templates,tasks,handlers,vars,meta,default&#125;[root@node1 ~]# cd /etc/ansible/roles/[root@node1 roles]# lsmysql php web[root@node1 roles]# tree.├── mysql│ ├── default│ ├── files│ ├── handlers│ ├── meta│ ├── tasks│ ├── templates│ └── vars├── php│ ├── default│ ├── files│ ├── handlers│ ├── meta│ ├── tasks│ ├── templates│ └── vars└── web ├── default ├── files ├── handlers ├── meta ├── tasks ├── templates └── vars24 directories, 0 files[root@node1 roles]# 可以看到roles文件夹下主要有三个文件夹：web、php、mysql。 web在files文件夹准备好wordpress的安装包，准备好web.conf作为配置文件 1234567891011121314151617181920212223242526272829303132333435363738[root@node1 roles]# cd web/[root@node1 web]# lsdefault files handlers meta tasks templates vars[root@node1 web]# cd files[root@node1 files]# wget http://wordpress.org/latest.tar.gz[root@node1 files]# vim web.conf[root@node1 files]# cat web.conf worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; server &#123; listen 80; server_name www.static.com; location / &#123; root html; index index.php index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; location ~ \.php$ &#123; root /usr/share/nginx/html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; &#125;&#125;[root@node1 files]# lslatest.tar.gz web.conf[root@node1 files]# 在tasks、handlers文件夹下创建编辑main.yml 12345678910111213141516171819202122232425262728293031323334353637[root@node1 files]# cd ..[root@node1 web]# lsdefault files handlers meta tasks templates vars[root@node1 web]# cd tasks[root@node1 tasks]# vim main.yml[root@node1 tasks]# cat main.yml - name: add user nginx user: name=nginx group=root uid=666- name: install epel-release yum: name=epel-release state=latest- name: disable selinux selinux: state=disabled- name: firewalld enabled ports firewalld: port=80/tcp state=enabled permanent=yes- name: firewalld reload command: firewall-cmd --reload- name: install nginx yum: name=nginx state=latest notify: restart nginx- name: install conf copy: src=web.conf dest=/etc/nginx/nginx.conf tags: conf- name: copy and unzip blog unarchive: src=latest.tar.gz dest=/usr/share/nginx/html/- name: set mode file: name=/usr/share/nginx/html/wordpress recurse=yes owner=nginx group=nginx- name: start nginx service: name=nginx state=started enabled=yes[root@node1 tasks]# cd ..[root@node1 web]# cd handlers/[root@node1 handlers]# vim main.yml[root@node1 handlers]# cat main.yml - name: restart nginx service: name=nginx state=restarted[root@node1 handlers]# cd ..[root@node1 web]# cd ..[root@node1 roles]# php在tasks文件夹下创建编辑main.yml 12345678910111213141516171819202122232425[root@node1 roles]# cd php/tasks/[root@node1 tasks]# vim main.yml[root@node1 tasks]# cat main.yml - name: install php yum: name=&#123;&#123; item &#125;&#125; state=present with_items: - php-mysql - php-fpm- name: start php-fpm service: name=php-fpm state=started enabled=yes[root@node1 tasks]# cd ..[root@node1 php]# tree.├── default├── files├── handlers├── meta├── tasks│ └── main.yml├── templates└── vars7 directories, 1 file[root@node1 php]# cd ..[root@node1 roles]# mysql在tasks文件夹下创建编辑main.yml，在files文件夹下创建编辑my.cnf。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[root@node1 roles]# cd mysql[root@node1 mysql]# vim tasks/main.yml[root@node1 mysql]# cat tasks/main.yml - name: install mariadb yum: name=&#123;&#123; item &#125;&#125; state=present with_items: - mariadb - mariadb-server- name: install conf copy: src=my.cnf dest=/etc/my.cnf- name: start mariadb service: name=mariadb state=started enabled=yes- name: mysql command: mysql -e &quot;create database wordpress;grant all on wordpress.* to wordpress@&apos;192.168.141.69&apos; identified by &apos;123456&apos;;&quot;- name: command command: mysql -e &quot;grant replication slave,replication client on *.* to &apos;backuper&apos;@&apos;192.168.141.69&apos; identified by &apos;backuper&apos;;&quot;[root@node1 mysql]# [root@node1 mysql]# vim files/my.cnf[root@node1 mysql]# cat files/my.cnf [mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.socksymbolic-links=0log_bin=master_binserver_id=1innodb_file_per_table=ONskip_name-resolve=ON[mysqld_safe]log-error=/var/log/mariadb/mariadb.logpid-file=/var/run/mariadb/mariadb.pid[root@node1 mysql]# tree.├── default├── files│ └── my.cnf├── handlers├── meta├── tasks│ └── main.yml├── templates└── vars7 directories, 2 files[root@node1 mysql]# cd ..[root@node1 roles]# roles在roles文件夹创建编辑调用role的文件lnmp.yml。 123456789[root@node1 roles]# vim lnmp.yml[root@node1 roles]# cat lnmp.yml - hosts: node2 remote_user: root roles: - php - web - mysql[root@node1 roles]# 部署 1[root@node1 roles]# ansible-playbook lnmp.yml 结果如下图，警告不用管，没有报错，执行完毕。 接下来我们到node2上验证一下防火墙和selinux状态 12345[root@node2 ~]# firewall-cmd --list-ports80/tcp[root@node2 ~]# getenforce Permissive[root@node2 ~]# 接下来验证lnmp架构的可用性 浏览器打开http://192.168.141.69/wordpress ，即可看到wordpress的安装界面了，其中192.168.141.69是node2的ip地址。 至于后面在这个网页端安装wordpress就省略了，本次验证已经完毕，结果是我们通过ansible的playbook成功部署出了一个采用LNMP架构的网站。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-ansible-05 ansible-playbook-roles]]></title>
    <url>%2Fansible-05%2F</url>
    <content type="text"><![CDATA[linux-ansible-05 ansible-playbook-roles通过playbook角色目录（roles）安装apache 前面写过了ansible常用的模块介绍，熟悉这些模块是基础，接下来我们通过一个实例来介绍playbook，playbook通过灵活的组装这些基础模块组件，可以适应各种复杂的业务操作场景。 在上一篇文章中，我们给出了角色目录文件结构tree的官方案例，现在我们将它实现出来自己做一个案例，具体如下： 12345678910111213141516171819202122[root@test ~]# cd /etc/ansible/[root@test ansible]# [root@test ansible]# yum install tree -y[root@test ansible]# tree roles/roles/├── httpd│ ├── defaults│ ├── files│ │ └── index.html│ ├── handlers│ │ └── main.yaml│ ├── metas│ ├── tasks│ │ └── main.yaml│ ├── templates│ │ └── vhost1.conf.j2│ └── vars│ └── main.yaml└── httpd.yaml8 directories, 6 files[root@test ansible]# 在roles文件夹里，创建httpd文件夹以及httpd.yaml，编辑httpd.yaml内容如下 1234567891011121314[root@test ~]# cd /etc/ansible/roles[root@test roles]# [root@test roles]# ls[root@test roles]# mkdir httpd[root@test roles]# vim httpd.yaml[root@test roles]# cat httpd.yaml - hosts: node3 remote_user: root roles: - httpd[root@test roles]# lshttpd httpd.yaml[root@test roles]# 在httpd目录下创建所需要的所有目录 12345678910111213[root@test roles]# cd httpd[root@test httpd]# ls[root@test httpd]# mkdir &#123;defaults,tasks,vars,templates,handlers,files,metas&#125; -pvmkdir: created directory ‘defaults’mkdir: created directory ‘tasks’mkdir: created directory ‘vars’mkdir: created directory ‘templates’mkdir: created directory ‘handlers’mkdir: created directory ‘files’mkdir: created directory ‘metas’[root@test httpd]# lsdefaults files handlers metas tasks templates vars[root@test httpd]# 在files目录下创建默认页面，里面随便写一句话就好，我写的是hello ansible ! 123456[root@test httpd]# cd files/[root@test files]# vim index.html[root@test files]# cat index.html hello ansible ![root@test files]# cd ..[root@test httpd]# 在handlers目录下创建并且编辑main.yaml，如下 12345678[root@test httpd]# cd handlers/[root@test handlers]# ls[root@test handlers]# vim main.yaml[root@test handlers]# cat main.yaml - name: reload httpd service: name=httpd state=reloaded[root@test handlers]# cd ..[root@test httpd]# 在tasks目录下创建并且编辑main.yaml，如下 1234567891011121314151617181920212223242526[root@test httpd]# cd tasks/[root@test tasks]# ls[root@test tasks]# vim main.yaml[root@test tasks]# cat main.yaml - name: config hostname command: hostnamectl set-hostname &#123;&#123; hostname &#125;&#125;- name: config resolv file copy: src=/etc/resolv.conf dest=/etc/resolv.conf- name: install service httpd yum: name=httpd state=latest- name: config httpdconf template: src: vhost1.conf.j2 dest: /etc/httpd/conf.d/vhost1.conf notify: - reload httpd- name: disable selinux selinux: state=disabled- name: config vhost1 index.html copy: src=index.html dest=/var/www/- name: firewalld ports command: firewall-cmd --add-port=&#123;&#123; port &#125;&#125;/tcp - name: start httpd service: name=httpd state=started enabled=yes[root@test tasks]# cd ..[root@test httpd]# 在templates目录下创建并且编辑vhost1.conf.j2，如下 1234567891011[root@test httpd]# cd templates/[root@test templates]# ls[root@test templates]# vim vhost1.conf.j2[root@test templates]# cat vhost1.conf.j2 Listen &#123;&#123; port &#125;&#125;&lt;VirtualHost *:&#123;&#123; port &#125;&#125;&gt; Servername &#123;&#123; hostname &#125;&#125; DocumentRoot &quot;/var/www/&quot;&lt;/VirtualHost&gt;[root@test templates]# cd ..[root@test httpd]# 在vars目录下创建并且编辑main.yaml，如下 123456789[root@test httpd]# cd vars/[root@test vars]# ls[root@test vars]# vim main.yaml[root@test vars]# cat main.yaml port: 8080hostname: node3[root@test vars]# cd ..[root@test httpd]# 回到roles目录下，执行httpd.yaml，可以看到执行成功 123456789101112131415161718192021222324252627282930313233343536373839404142[root@test httpd]# cd ..[root@test roles]# lshttpd httpd.yaml[root@test roles]# ansible-playbook httpd.yaml [WARNING]: Found variable using reserved name: portPLAY [node3] *********************************************************************************************************TASK [Gathering Facts] ***********************************************************************************************ok: [node3]TASK [httpd : config hostname] ***************************************************************************************changed: [node3]TASK [httpd : config resolv file] ************************************************************************************ok: [node3]TASK [httpd : install service httpd] *********************************************************************************ok: [node3]TASK [httpd : config httpdconf] **************************************************************************************ok: [node3]TASK [httpd : disable selinux] *************************************************************************************** [WARNING]: SELinux state change will take effect next rebootok: [node3]TASK [httpd : config vhost1 index.html] ******************************************************************************ok: [node3]TASK [httpd : firewalld ports] ***************************************************************************************changed: [node3]TASK [httpd : start httpd] *******************************************************************************************ok: [node3]PLAY RECAP ***********************************************************************************************************node3 : ok=9 changed=2 unreachable=0 failed=0 [root@test roles]# 注意：2.4版本的ansible的task/main.yaml的notify配置时，因为dict不可哈希，所以采用 12notify:- name: restart apache 时会报错： ERROR! Unexpected Exception, this is probably a bug: unhashable type: ‘dict’如何遇到此类问题，是因为dict不可哈希，所以notify在配置下，使用可哈希数据类型即可 12notify:- restart apache 上面的配置使用的是不报错的- restart apache，能够一次性执行成功！如下图： 测试给node3安装apache后的结果，浏览器访问node3的主页，可以看到我们之前给node3的index.html内写入的hello ansible ！ 1http://192.168.141.69:8080/ 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-ansible-04 ansible-playbook]]></title>
    <url>%2Fansible-04%2F</url>
    <content type="text"><![CDATA[linux-ansible-04 ansible-playbook概念解析playbook Playbooks俗称”剧本“，是一种高效运用Ansible的方式，也是系统ansible命令的集合。playbook利用yaml语言编写，其命令根据自上而下的顺序依次执行。 简单来说，Playbooks 是一种简单的配置管理系统与多机器部署系统的基础。与现有的其他系统有不同之处，且非常适合于复杂应用的部署。 同时，Playbooks开创了很多特性，它可以允许你传输某个命令的状态到后面的指令，如你可以从一台机器的文件中抓取内容并附为变量，然后在另一台机器中使用，这使得你可以实现一些复杂的部署机制，这是ansible命令无法实现的。 Playbooks可用于声明配置，更强大的地方在于，在Playbooks中可以编排有序的执行过程，甚至于做到在多组机器间，来回有序的执行特别指定的步骤。并且可以同步或异步的发起任务。 我们完成一个任务，例如安装部署一个httpd服务，我们需要多个模块（一个模块也可以称之为task）提供功能来完成。而playbook就是组织多个task的容器，他的实质就是一个文件，有着特定的组织格式，它采用的语法格式是YAML（Yet Another Markup Language）。YAML语法能够简单的表示散列表，字典等数据结构，详情可参考：YAML详细语法 。 YAML YAML是“YAML不是一种标记语言”的外语缩写，又被称为“另外一种标记语言”，但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名。它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。 playbook基础组件Hosts：运行执行任务（task）的目标主机 remote_user：在远程主机上执行任务的用户 tasks：任务列表，由模块定义的操作列表 handlers：任务，和nogity结合使用，为条件触发操作，满足条件方才执行，否则不执行；与tasks不同的是只有在接受到通知时才会被触发。 templates：使用模板语言的文本文件，使用jinja2语法。 variables：变量，变量替换{{ variable_name }}，内置变量或自定义变量在playbook中调用 roles: 角色 整个playbook是以task为中心，表明要执行的任务；hosts和remote_user表明在哪些远程主机以何种身份执行；其他组件让其能够更加灵活。 官方实例12345678910111213141516171819202122232425- hosts: webservers vars: http_port: 80 max_clients: 200 remote_user: root tasks: - name: ensure apache is at the latest version yum: name: httpd state: latest - name: write the apache config file template: #作用：将变量在远程主机上变成指定的值，应用变量传参 src: /srv/httpd.j2 #源文件必须以j2结尾 dest: /etc/httpd.conf notify: - restart apache - name: ensure apache is running service: name: httpd state: started handlers: - name: restart apache service: name: httpd state: restarted 1234567运行： -t Tag 指定运行特定的任务 --skip-tags=SKIP_TAGS 跳过指定的标签 --start-at-task=START_AT 从哪个任务后执行 使用 -e选项传入参数，例如： ansible-playbook 192.168.200.136 -e &quot;httpd_port=808&quot; httpd04.yml 实例解析webservers是官方对其管理机所管理服务器的统称，我们这里用的是node。 vars: #在playbook中定义变量 http_port: 80 max_clients: 200 变量的引用： 变量变量的来源： ansible setup facts远程主机的所有变量都可以用 自定义变量 优先级： 通过命令行指定变量，优先级最高 在/etc/ansible/hosts 定义变量，在主机组中的主机单独定义 在/etc/ansible/hosts 定义变量，针对主机组中的所有主机集中定义变量 在Playbook中定义变量（建议使用这种方法） 模版 使用模板语言的文本文件内部嵌套有模板语言脚本（使用模板语言编写） Jinja2 是由python编写的。在我们打算使用基于文本的模板语言时，jinja2是很好的解决方案。yaml是写playbook，jinja2是写配置文件模板的。 功能：将模板的文件的变量值转换成对应的本地主机的确定值。例如：ansible端写一个内建变量，当这个文件被复制到对应主机时会自动生成对应主机 cpu的颗数的结果替换之。 templates文件必须存放在templates目录下 yaml文件需要和templates目录平级 template只能在palybook中使用。 Jinja2语法 123456789101112字面量： 字符串：使用单引号或双引号； 数字：整数、浮点数； 列表：[item1, item2, ...] 元组：(item1, item2, ...) 字典：&#123;key1:value1, key2:value2, ...&#125; 布尔型：true/false算术运算： +, -, *, /, //, %, **比较操作： ==, !=, &gt;, &lt;, &gt;=, &lt;=逻辑运算：and, or, not 实例123456789101112131415161718192021[root@node1 templates]# cat nginxconf.j2.bak &#123;% for vhost in nginx_vhosts %&#125;server &#123; listen &#123;&#123; vhost &#125;&#125;# listen &#123;&#123; vhost.listen &#125;&#125;&#125;&#123;% endfor %&#125;worker_processes &#123;&#123; ansible_processor_vcpus &#125;&#125;;[root@node1 tmp]# cat nginxtemp.yam- hosts: mageduweb remote_user: root vars: nginx_vhosts: - web1 - web2 - web3# nginx_vhosts:# - listen: 8080 tasks: - name: template config to remote hosts template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf 条件判断一般通过when或者迭代循环 123- name: restart Nginx service: name=nginx state=restarted when: ansible_distribution_major_version == &quot;6&quot; 循环迭代迭代列表或者键值对 12345678910111213141516171819#基于字符串列表 tasks: - name: create rsyncd file copy: src=&#123;&#123; item &#125;&#125; dest=/tmp/&#123;&#123; item &#125;&#125; with_items: - a - b - c - d*with_itmes 嵌套子变量*#基于字典列表- hosts: eagleslab remote_user: root tasks: - name: add several users user: name=&#123;&#123; item.name &#125;&#125; state=present groups=&#123;&#123; item.groups &#125;&#125; with_items: - &#123; name: &apos;testuser1&apos; , groups: &apos;wheel&apos;&#125; - &#123; name: &apos;testuser2&apos; , groups: &apos;root&apos; &#125; 角色roles12345678910[root@node1 ~]# tree /etc/ansible/roles//etc/ansible/roles/└── http ├── defaults ├── files ├── headlers ├── meta ├── tasks ├── template └── varsfiles/：存储由copy或script等模块调用的文件； tasks/：此目录中至少应该有一个名为main.yml的文件，用于定义各task；其它的文件需要由main.yml进行“包含”调用； handlers/：此目录中至少应该有一个名为main.yml的文件，用于定义各handler；其它的文件需要由main.yml进行“包含”调用； vars/：此目录中至少应该有一个名为main.yml的文件，用于定义各variable；其它的文件需要由main.yml进行“包含”调用； templates/：存储由template模块调用的模板文本； meta/：此目录中至少应该有一个名为main.yml的文件，定义当前角色的特殊设定及其依赖关系；其它的文件需要由main.yml进行“包含”调用； default/：此目录中至少应该有一个名为main.yml的文件，用于设定默认变量； files目录：存放由copy或script等模块调用的文件； 调用roles12345[root@node1 ~]# cat /etc/ansible/roles/site.yml- hosts: abc remote_user: root roles: - httpd 实例分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677[root@node1 ansible]# tree roles/roles/├── http│ ├── defaults│ │ └── main.yaml│ ├── files│ │ └── index.html│ ├── headlers│ │ └── main.yaml│ ├── meta│ │ └── main.yaml│ ├── tasks│ │ └── main.yaml│ ├── templates│ │ └── httpd.conf.j2│ └── vars│ └── main.yaml└── site.yaml[root@node1 roles]# cat site.yaml - hosts: node2 remote_user: root# vars:# httpd_ports: 8080 roles: - http[root@node1 http]# cat files/index.html hello eagleslab![root@node1 http]# cat tasks/main.yaml - name: installed httpd service yum: name=httpd state=latest when: ansible_os_family == &quot;RedHat&quot;- name: start httpd server service: name=httpd state=restarted - name: write httpd config template: src=httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf notify: - restart httpd- name: config httpd index copy: src=index.html dest=/var/www/html/index.html[root@node1 http]# cat templates/httpd.conf.j2 | grep -Ev &quot;^[[:space:]]|^#&quot;ServerRoot &quot;/etc/httpd&quot;Listen &#123;&#123; httpd_ports &#125;&#125;Include conf.modules.d/*.confUser apacheGroup apacheServerAdmin root@localhost&lt;Directory /&gt;&lt;/Directory&gt;DocumentRoot &quot;/var/www/html&quot;&lt;Directory &quot;/var/www&quot;&gt;&lt;/Directory&gt;&lt;Directory &quot;/var/www/html&quot;&gt;&lt;/Directory&gt;&lt;IfModule dir_module&gt;&lt;/IfModule&gt;&lt;Files &quot;.ht*&quot;&gt;&lt;/Files&gt;ErrorLog &quot;logs/error_log&quot;LogLevel warn&lt;IfModule log_config_module&gt;&lt;/IfModule&gt;&lt;IfModule alias_module&gt;&lt;/IfModule&gt;&lt;Directory &quot;/var/www/cgi-bin&quot;&gt;&lt;/Directory&gt;&lt;IfModule mime_module&gt;&lt;/IfModule&gt;AddDefaultCharset UTF-8&lt;IfModule mime_magic_module&gt;&lt;/IfModule&gt;EnableSendfile onIncludeOptional conf.d/*.conf[root@node1 http]# cat headlers/main.yaml - name: restart httpd service: name=httpd state=restarted[root@node1 http]# cat vars/main.yaml httpd_ports: 8000 任务tasks执行的模块命令 12345678910111213格式： action：模块参数（此种方式只在较新的版本中出现） module：参数(已键值对的形式出现)每一个task都有一个名称，用于标记此任务。任务示例： name: install httpd yum: name=httpd state=present注意：shell和command没有参数，可在后面直接跟命令 shell: ss -tnl | grep :80（1）某任务的运行状态为changed后，可通过相应的notify通知相应的handlers（2）任务可以通过tags打标签，然后通过palybook命令-t选项调用. playbook调用方式1234567891011用法：ansible-playbook &lt;filename.yml&gt; ... [options] &lt;filename.yml&gt;:yaml格式的playbook文件路径，必须指明 [options]: 选项 -C, --check：并不在远程主机上执行，只是测试。 -i PATH, --inventory=PATH：资产的文件路径 --flush-cache：清楚fact缓存 --list-hosts：列出匹配的远程主机，并不执行任何动作 -t, TAGS, --tags=TAGS：运行指定的标签任务 --skip-tags:跳过指定的notify，后面详细介绍。 palybook实验实验准备下述实验环境和之前的一样，无需改动即可。 在服务端安装ansible 12[root@localhost ~]# yum install epel-release -y[root@localhost ~]# yum install ansible -y 服务端修改主机清单配置文件host 1234567[root@localhost ~]# vim /etc/ansible/hosts#在文档末尾加上一下这几行[node]node2node3 服务端修改host文件 123456[root@localhost ~]# vim /etc/hosts#在文档中加入下列两行192.168.141.53 node2192.168.141.69 node3 通过playbook添加用户示例（1）给远程主机node3添加用户test 12345678910111213141516171819202122232425[root@test ~]# vim user.yml[root@test ~]# cat user.yml - hosts: node3 remote_user: root gather_facts: False vars: - user: test tasks: - name: create user user: name=&#123;&#123; user &#125;&#125;[root@test ~]# ansible-playbook user.ymlPLAY [node3] *********************************************************************************************************TASK [create user] ***************************************************************************************************changed: [node3]PLAY RECAP ***********************************************************************************************************node3 : ok=1 changed=1 unreachable=0 failed=0 [root@test ~]# ansible node3 -a &quot;id test&quot;node3 | CHANGED | rc=0 &gt;&gt;uid=1000(test) gid=1000(test) groups=1000(test)[root@test ~]# 上面的playbook 实现的功能是新增一个用户： 123456name：对该playbook实现的功能做一个概述，后面执行过程中，会打印name变量的值hosts：指定了对哪些主机进行参作remote_user：指定了使用什么用户登录远程主机操作gather_facts：指定了在以下任务部分执行前，是否先执行setup模块获取主机相关信息，这在后面的task会使用到setup获取的信息时用到vars：指定了变量，这里指定了一个user变量，其值为test，需要注意的是，变量值一定要用引号引起来tasks：指定了一个任务，其下面的name参数同样是对任务的描述，在执行过程中会打印出来。user提定了调用user模块，name是user模块里的一个参数，而增加的用户名字调用了上面user变量的值 （2）删除远程主机test的账号只需改一行： user: name=”“ state=absent remove=yes 1234567891011121314151617181920212223242526272829[root@test ~]# vim user.yml[root@test ~]# cat user.yml - hosts: node3 remote_user: root gather_facts: False vars: - user: test tasks: - name: create user user: name=&#123;&#123; user &#125;&#125; state=absent remove=yes[root@test ~]# ansible node3 -a &quot;id test&quot;node3 | CHANGED | rc=0 &gt;&gt;uid=1000(test) gid=1000(test) groups=1000(test)[root@test ~]# ansible-playbook user.ymlPLAY [node3] *********************************************************************************************************TASK [create user] ***************************************************************************************************changed: [node3]PLAY RECAP ***********************************************************************************************************node3 : ok=1 changed=1 unreachable=0 failed=0 [root@test ~]# ansible node3 -a &quot;id test&quot;node3 | FAILED | rc=1 &gt;&gt;id: test: no such usernon-zero return code[root@test ~]# 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-ansible-03 ansible常用模块命令实例]]></title>
    <url>%2Fansible-03%2F</url>
    <content type="text"><![CDATA[linux-ansible-03 ansible常用模块命令实例user模块创建一个用户：feng1[root@test ~]# ansible node2 -m user -a &quot;name=feng uid=1024 password=000000 shell=/bin/bash group=root&quot; 可以到node2上查看这个用户的uid，如下，uid确实是1024 12[root@node2 ~]# id fenguid=1024(feng) gid=0(root) 组=0(root) 删除用户123456789[root@test ~]# ansible node2 -m user -a &quot;name=feng state=absent force=yes&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;force&quot;: true, &quot;name&quot;: &quot;feng&quot;, &quot;remove&quot;: false, &quot;state&quot;: &quot;absent&quot;&#125;[root@test ~]# group模块给node2创建一个组fenggroup 123456789[root@test ~]# ansible node2 -m group -a &quot;gid=1024 name=fenggroup system=yes&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;gid&quot;: 1024, &quot;name&quot;: &quot;fenggroup&quot;, &quot;state&quot;: &quot;present&quot;, &quot;system&quot;: true&#125;[root@test ~]# 给node2创建一个用户feng，其主组root，加入到fenggroup附属组 12345678910111213141516171819202122232425[root@test ~]# ansible node2 -m user -a &quot;name=feng uid=1024 password=000000 shell=/bin/bash group=root groups=fenggroup&quot; [WARNING]: The input password appears not to have been hashed. The &apos;password&apos; argument must be encrypted for thismodule to work properly.node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;comment&quot;: &quot;&quot;, &quot;create_home&quot;: true, &quot;group&quot;: 0, &quot;groups&quot;: &quot;fenggroup&quot;, &quot;home&quot;: &quot;/home/feng&quot;, &quot;name&quot;: &quot;feng&quot;, &quot;password&quot;: &quot;NOT_LOGGING_PASSWORD&quot;, &quot;shell&quot;: &quot;/bin/bash&quot;, &quot;state&quot;: &quot;present&quot;, &quot;stderr&quot;: &quot;useradd: warning: the home directory already exists.\nNot copying any file from skel directory into it.\nCreating mailbox file: File exists\n&quot;, &quot;stderr_lines&quot;: [ &quot;useradd: warning: the home directory already exists.&quot;, &quot;Not copying any file from skel directory into it.&quot;, &quot;Creating mailbox file: File exists&quot; ], &quot;system&quot;: false, &quot;uid&quot;: 1024&#125;[root@test ~]# 到node2上查看这个用户的信息，可以看到一切无误 12[root@node2 ~]# id fenguid=1024(feng) gid=0(root) 组=0(root),1024(fenggroup) 删除fenggroup组 1234567[root@test ~]# ansible node2 -m group -a &quot;name=fenggroup state=absent&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;name&quot;: &quot;fenggroup&quot;, &quot;state&quot;: &quot;absent&quot;&#125;[root@test ~]# 此时再到node2上查看这个用户的信息，可以看到它不再从属于fenggroup组了，因为fenggroup组已被删除 12[root@node2 ~]# id fenguid=1024(feng) gid=0(root) 组=0(root) selinux模块首先到node2上查看node2的selinux状态 12[root@node2 ~]# getenforce Enforcing 在test上将node2的selinux关闭掉 12345678910111213[root@test ~]# ansible node2 -m selinux -a &quot;state=disabled&quot; [WARNING]: SELinux state temporarily changed from &apos;enforcing&apos; to &apos;permissive&apos;. State change will take effect nextreboot.node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;configfile&quot;: &quot;/etc/selinux/config&quot;, &quot;msg&quot;: &quot;Config SELinux state changed from &apos;enforcing&apos; to &apos;disabled&apos;&quot;, &quot;policy&quot;: &quot;targeted&quot;, &quot;reboot_required&quot;: true, &quot;state&quot;: &quot;disabled&quot;&#125;[root@test ~]# 再到node2上查看node2的selinux状态，可以看到关闭成功 123456789101112131415161718[root@node2 ~]# getenforce Permissive[root@node2 ~]# cat /etc/selinux/config # This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=disabled# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection.SELINUXTYPE=targeted [root@node2 ~]# firewalld模块放行node2的8080端口，并在node2上进行验证。 12345678910111213141516[root@node1 roles]# ansible node2 -m firewalld -a &quot;port=8080/tcp state=enabled permanent=yes&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;msg&quot;: &quot;Permanent operation, Changed port 8080/tcp to enabled&quot;&#125;[root@node1 roles]#[root@node1 roles]# ansible node2 -m command -a &quot;firewall-cmd --reload&quot;node2 | CHANGED | rc=0 &gt;&gt;success[root@node1 roles]# [root@node2 ~]# firewall-cmd --list-ports8080/tcp[root@node2 ~]# copy模块先在test上创建一个文件user.txt 1[root@test ~]# touch user.txt 将这个文件传送给node2的/tmp目录下 1234567891011121314151617181920212223242526[root@test ~]# ansible node2 -m copy -a &quot;src=/root/user.txt dest=/tmp&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;checksum&quot;: &quot;da39a3ee5e6b4b0d3255bfef95601890afd80709&quot;, &quot;dest&quot;: &quot;/tmp/user.txt&quot;, &quot;gid&quot;: 0, &quot;group&quot;: &quot;root&quot;, &quot;md5sum&quot;: &quot;d41d8cd98f00b204e9800998ecf8427e&quot;, &quot;mode&quot;: &quot;0644&quot;, &quot;owner&quot;: &quot;root&quot;, &quot;secontext&quot;: &quot;unconfined_u:object_r:admin_home_t:s0&quot;, &quot;size&quot;: 0, &quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1553334220.5-91381585251620/source&quot;, &quot;state&quot;: &quot;file&quot;, &quot;uid&quot;: 0&#125;[root@test ~]# ansible node2 -a &quot;ls /tmp&quot;node2 | CHANGED | rc=0 &gt;&gt;ansible_command_payload_ZUXpXhks-script-NiyyISsystemd-private-60d307935d5b4b589a7ba7fb1e063954-chronyd.service-kxndmtuser.txtvmware-rootyum.log[root@test ~]# 往node2的/tmp目录下的user.txt里写入：”hello“ 123456789101112131415161718192021[root@test ~]# ansible node2 -m copy -a &quot;dest=/tmp/user.txt content=hello&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;checksum&quot;: &quot;aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d&quot;, &quot;dest&quot;: &quot;/tmp/user.txt&quot;, &quot;gid&quot;: 0, &quot;group&quot;: &quot;root&quot;, &quot;md5sum&quot;: &quot;5d41402abc4b2a76b9719d911017c592&quot;, &quot;mode&quot;: &quot;0644&quot;, &quot;owner&quot;: &quot;root&quot;, &quot;secontext&quot;: &quot;unconfined_u:object_r:admin_home_t:s0&quot;, &quot;size&quot;: 5, &quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1553334393.04-135202047372696/source&quot;, &quot;state&quot;: &quot;file&quot;, &quot;uid&quot;: 0&#125;[root@test ~]# ansible node2 -a &quot;cat /tmp/user.txt&quot;node2 | CHANGED | rc=0 &gt;&gt;hello[root@test ~]# file模块给node2的/tmp目录下创建一个名为user.test的文件 123456789101112131415161718192021222324252627[root@test ~]# ansible node2 -m file -a &quot;path=/tmp/user.test state=touch owner=root group=root mode=777&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;dest&quot;: &quot;/tmp/user.test&quot;, &quot;gid&quot;: 0, &quot;group&quot;: &quot;root&quot;, &quot;mode&quot;: &quot;0777&quot;, &quot;owner&quot;: &quot;root&quot;, &quot;size&quot;: 0, &quot;state&quot;: &quot;file&quot;, &quot;uid&quot;: 0&#125;[root@test ~]# ansible node2 -a &quot;ls /tmp&quot;node2 | CHANGED | rc=0 &gt;&gt;ansible_command_payload_7oz5ZRks-script-NiyyISsystemd-private-521b915097e843e2a1cd732f94d50984-chronyd.service-sTxtbhuser.testuser.txtvmware-rootyum.log[root@test ~]# ansible node2 -a &quot;ls -l /tmp/user.test&quot;node2 | CHANGED | rc=0 &gt;&gt;-rwxrwxrwx 1 root root 0 Mar 23 21:23 /tmp/user.test[root@test ~]# 给node2的/tmp目录下创建一个名为test的文件夹 1234567891011121314151617181920212223242526272829[root@test ~]# ansible node2 -m file -a &quot;path=/tmp/test state=directory owner=root group=root mode=644&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;gid&quot;: 0, &quot;group&quot;: &quot;root&quot;, &quot;mode&quot;: &quot;0644&quot;, &quot;owner&quot;: &quot;root&quot;, &quot;path&quot;: &quot;/tmp/test&quot;, &quot;size&quot;: 6, &quot;state&quot;: &quot;directory&quot;, &quot;uid&quot;: 0&#125;[root@test ~]# ansible node2 -a &quot;ls -l /tmp/test&quot;node2 | CHANGED | rc=0 &gt;&gt;total 0[root@test ~]# ansible node2 -a &quot;ls -l /tmp&quot;node2 | CHANGED | rc=0 &gt;&gt;total 8drwx------ 2 root root 80 Mar 23 21:30 ansible_command_payload_dUhGn0-rwx------. 1 root root 836 Mar 16 22:08 ks-script-NiyyISdrwx------ 3 root root 17 Mar 23 21:16 systemd-private-521b915097e843e2a1cd732f94d50984-chronyd.service-sTxtbhdrw-r--r-- 2 root root 6 Mar 23 21:29 test-rwxrwxrwx 1 root root 0 Mar 23 21:23 user.test-rw-r--r--. 1 root root 5 Mar 23 17:46 user.txtdrwx------. 2 root root 6 Mar 16 22:18 vmware-root-rw-------. 1 root root 0 Mar 16 22:01 yum.log[root@test ~]# 删除/tmp目录下一个名为user.test的文件 12345678910111213141516171819202122232425262728[root@test ~]# ansible node2 -a &quot;ls /tmp&quot;node2 | CHANGED | rc=0 &gt;&gt;ansible_command_payload_cRmbqnks-script-NiyyISsystemd-private-521b915097e843e2a1cd732f94d50984-chronyd.service-sTxtbhtestuser.testuser.txtvmware-rootyum.log[root@test ~]# ansible node2 -m file -a &quot;path=/tmp/user.test state=absent&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;path&quot;: &quot;/tmp/user.test&quot;, &quot;state&quot;: &quot;absent&quot;&#125;[root@test ~]# ansible node2 -a &quot;ls /tmp&quot;node2 | CHANGED | rc=0 &gt;&gt;ansible_command_payload_SabNhtks-script-NiyyISsystemd-private-521b915097e843e2a1cd732f94d50984-chronyd.service-sTxtbhtestuser.txtvmware-rootyum.log[root@test ~]# cron(计划任务)模块给node2指定一个计划任务，*/1表示每一分钟，date显示日期时间 123456789[root@test ~]# ansible node2 -m cron -a &quot;name=showdate minute=*/1 job=date state=present&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;envs&quot;: [], &quot;jobs&quot;: [ &quot;showdate&quot; ]&#125;[root@test ~]# 删除上面指定的计划任务 1234567[root@test ~]# ansible node2 -m cron -a &quot;name=showdate state=absent&quot;node2 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;envs&quot;: [], &quot;jobs&quot;: []&#125;[root@test ~]# setup模块查看node2的系统信息（该系统信息篇幅很长） 1[root@test ~]# ansible node2 -m setup | less yum模块 给node2安装和卸载lrzsz，其中state为install、present表示安装，为latest表示安装到最新版，为absent、removed表示卸载。 1[root@test ~]# ansible node2 -m yum -a &quot;name=lrzsz state=latest&quot; 1[root@test ~]# ansible node2 -m yum -a &quot;name=lrzsz state=removed&quot; 如果yum报错的话：可以尝试以下命令： 1ansible node2 -m copy -a &quot;src=/etc/resolv.conf dest=/etc/resolv.conf force=yes&quot; service模块先给node2安装httpd 1[root@test ~]# ansible node2 -m yum -a &quot;name=httpd state=latest&quot; 给node2重启httpd服务，设置其开机自启 1[root@test ~]# ansible node2 -m service -a &quot;name=httpd state=restarted enabled=yes&quot; 给node2停止httpd服务 1[root@test ~]# ansible node2 -m service -a &quot;name=httpd state=stopped&quot; 查看node2的httpd状态，可以看到是关闭的 1[root@test ~]# ansible node2 -m command -a &quot;systemctl status httpd&quot; command不支持管道，变量及重定向等，如果是带有管道，变量及重定向符号，请用shell模块 12345678[root@test ~]# ansible node2 -m shell -a &quot;cat /etc/httpd/conf/httpd.conf | grep Listen&quot;node2 | CHANGED | rc=0 &gt;&gt;# Listen: Allows you to bind Apache to specific IP addresses and/or# Change this to Listen on specific IP addresses as shown below to #Listen 12.34.56.78:80Listen 80[root@test ~]# 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-ansible-02 ansible常用模块]]></title>
    <url>%2Fansible-02%2F</url>
    <content type="text"><![CDATA[linux-ansible-02 ansible常用模块参数解析ansible命令常用参数：-a指定模块参数-m指定模块名称-M指定模块路径–list-hosts：列出主机清单–f FORKS：指定进程并发量，默认为5 其中，常用-a与-m配合完成一条ansible命令 默认使用的模块是command，也就是说，你不指定模块是，默认使用的是command模块 举例分析在上一篇文章中，我们改了主机名，命令如下 12345678910111213141516171819[root@localhost ~]# ansible node2 -m command -a &quot;hostnamectl set-hostname node2&quot;node2 | CHANGED | rc=0 &gt;&gt;[root@localhost ~]# ansible node3 -m command -a &quot;hostnamectl set-hostname node3&quot;node3 | CHANGED | rc=0 &gt;&gt;[root@localhost ~]# ssh 192.168.141.53Last login: Sat Mar 23 16:01:20 2019 from 192.168.141.12[root@node2 ~]# exitlogoutConnection to 192.168.141.53 closed.[root@localhost ~]# ssh 192.168.141.69Last login: Sat Mar 23 16:01:28 2019 from 192.168.141.12[root@node3 ~]# exitlogoutConnection to 192.168.141.69 closed.[root@localhost ~]# 其中，-m command表示指定使用command模块，-a “hostnamectl set-hostname node3”表示指定的模块参数是”hostnamectl set-hostname node3”，整个命令连起来就是用command模块将node3更改主机名称为node3的意思。 ansible的执行状态绿色：执行成功并且不需要做改变的操作黄色：执行成功并且对目标主机做变更红色：执行失败 常用模块在介绍常用模块之前，必须要掌握的命令是ansible-doc命令。 ansible-doc -l 查看当前支持的所有模块ansible-doc -s 模块名 查看当前指定模块使用方法ansible-doc -h 该命令使用方法ansible-doc -M 指定模块路径 例如，查看command模块如何使用 1ansible-doc -s command ansible-doc -s 模块名之后如何退出： 如下图，此时按q即可退出。 ping如下，可以看到 1234567[root@test ~]# ansible-doc -s ping- name: Try to connect to host, verify a usable python and return `pong&apos; on success ping: data: # Data to return for the `ping&apos; return value. If this parameter is set to `crash&apos;, the module will cause an exception.[root@test ~]# user123456789101112131415161718[root@test ~]# ansible-doc -s user- name: Manage user accounts user: comment: # 用户的描述信息 create_home: # 是否创建家目录 force: # 在使用`state=absent&apos;时, 行为与`userdel --force&apos;一致 group: # 指定基本组（主组） groups: # 指定附加组，如果指定为(&apos;groups=&apos;)表示删除所有附加组 home: # 指定用户家目录 name: # 指定用户名 password: # 指定用户密码 password_lock: # 是否锁定用户的密码 remove: # 在使用 `state=absent&apos;时, 行为与 `userdel --remove&apos;一致. shell: # 指定默认shell state: # 设置帐号状态，不指定为创建，指定值为absent表示删除 system: # 当创建一个用户，设置这个用户是系统用户。这个设置不能更改现有用户。 uid: # 指定用户的uid update_password: # `always&apos; will update passwords if they differ. `on_create&apos; will only set the password group12345678[root@test ~]# ansible-doc -s group- name: Add or remove groups group: gid: # Optional `GID&apos; to set for the group. name: # (required) Name of the group to manage. state: # 指定组状态，默认为创建，设置值为absent为删除 system: # If `yes&apos;, indicates that the group created is a system group. command1.command是默认使用的模块 2.不支持管道，变量及重定向等，如果是带有管道，变量及重定向符号，请用shell模块 123456789101112131415[root@test ~]# ansible-doc -s command- name: Executes a command on a remote node command: argv: # Allows the user to provide the command as a list vs. a string. Only the string or the list form can be provided, not both. One or the other must be provided. chdir: # Change into this directory before running the command. creates: # A filename or (since 2.0) glob pattern. If it already exists, this step *won&apos;t* be run. free_form: # (required) The command module takes a free form command to run. There is no parameter actually named &apos;free form&apos;. See the examples! removes: # A filename or (since 2.0) glob pattern. If it already exists, this step *will* be run. stdin: # Set the stdin of the command directly to the specified value. warn: # If command_warnings are on in ansible.cfg, do not warn about this particular line if set to `no&apos;. shell1.调用bash执行命令 2.但是某些复杂的操作即使使用shell也可能会失败 解决方法：将操作写到脚本中，通过script模块 3.command不支持管道，变量及重定向等，如果是带有管道，变量及重定向符号，请用shell模块 12345678910111213141516[root@test ~]# ansible-doc -s shell- name: Execute commands in nodes. shell: chdir: # cd into this directory before running the command creates: # a filename, when it already exists, this step will *not* be run. executable: # change the shell used to execute the command. Should be an absolute path to the executable. free_form: # (required) The shell module takes a free form command to run, as a string. There&apos;s not an actual option named &quot;free form&quot;. See the examples! removes: # a filename, when it does not exist, this step will *not* be run. stdin: # Set the stdin of the command directly to the specified value. warn: # if command warnings are on in ansible.cfg, do not warn about this particular line if set to no/false.[root@test ~]# script123456789101112[root@test ~]# ansible-doc -s script- name: Runs a local script on a remote node after transferring it script: chdir: # Change into this directory on the remote node before running the script. creates: # A filename on the remote node, when it already exists, this step will *not* be run. decrypt: # This option controls the autodecryption of source files using vault. executable: # Name or path of a executable to invoke the script with. free_form: # (required) Path to the local script file followed by optional arguments. There is no parameter actually named &apos;free form&apos;, see the examples! removes: # A filename on the remote node, when it does not exist, this step will *not* be run.[root@test ~]# copy1234567891011[root@test ~]# ansible-doc -s copy- name: Copies files to remote locations copy: backup: # 在覆盖之前，将源文件备份，备份文件包含时间信息。 content: # 用于替代“src”，可以直接设定指定文件的值 dest: # 必选项。要将源文件复制到的远程主机的绝对路径 directory_mode: # 递归设定目录的权限，默认为系统默认权限 force: # 强制覆盖目的文件内容，默认为yes others: # 所有的file模块里的选项都可以在这里使用 src: #被复制到远程主机的本地文件，可以是绝对路径，也可以是相对路径。如果路径是一个目录，它将递归复制。 file12345678910111213141516171819[root@test ~]# ansible-doc -s file- name: Sets attributes of files file: force: # 需要在两种情况下强制创建软链接，一种是源文件不存在，但之后会建立的情况下；另一种是目标软链接已存在，需要先取消之前的软链，然后创建新的软链，有两个选项：yes|no group: # 定义文件/目录的所属组 mode: # 定义文件/目录的权限 owner: # 定义文件/目录的所属用户 path: # 必选项，定义文件/目录的路径 recurse: # 递归设置文件的属性，只对目录有效 src: # 被链接的源文件路径，只应用于state=link的情况 dest: # 被链接到的路径，只应用于state=link的情况 state： directory：如果目录不存在，就创建目录 file：即使文件不存在，也不会被创建 link：创建软链接 hard：创建硬链接 touch：如果文件不存在，则会创建一个新的文件，如果文件或目录已存在，则更新其最后修改时间 absent：删除目录、文件或者取消链接文件 cron1234567891011121314151617181920212223242526272829303132333435363738394041424344[root@test ~]# ansible-doc -s cron- name: Manage cron.d and crontab entries cron: backup: # If set, create a backup of the crontab before it is modified. The location of the backup is returned in the `backup_file&apos; variable by this module. cron_file: # If specified, uses this file instead of an individual user&apos;s crontab. If this is a relative path, it is interpreted with respect to /etc/cron.d. (If it is absolute, it will typically be /etc/crontab). Many linux distros expect (and some require) the filename portion to consist solely of upper- and lower-case letters, digits, underscores, and hyphens. To use the `cron_file&apos; parameter you must specify the `user&apos; as well. day: # Day of the month the job should run ( 1-31, *, */2, etc ) disabled: # If the job should be disabled (commented out) in the crontab. Only has effect if `state=present&apos;. env: # If set, manages a crontab&apos;s environment variable. New variables are added on top of crontab. &quot;name&quot; and &quot;value&quot; parameters are the name and the value of environment variable. hour: # Hour when the job should run ( 0-23, *, */2, etc ) insertafter: # Used with `state=present&apos; and `env&apos;. If specified, the environment variable will be inserted after the declaration of specified environment variable. insertbefore: # Used with `state=present&apos; and `env&apos;. If specified, the environment variable will be inserted before the declaration of specified environment variable. job: # The command to execute or, if env is set, the value of environment variable. The command should not contain line breaks. Required if state=present. minute: # Minute when the job should run ( 0-59, *, */2, etc ) month: # Month of the year the job should run ( 1-12, *, */2, etc ) name: # Description of a crontab entry or, if env is set, the name of environment variable. Required if state=absent. Note that if name is not set and state=present, then a new crontab entry will always be created, regardless of existing ones. reboot: # If the job should be run at reboot. This option is deprecated. Users should use special_time. special_time: # Special time specification nickname. state: # Whether to ensure the job or environment variable is present or absent. user: # The specific user whose crontab should be modified. weekday: # Day of the week that the job should run ( 0-6 for Sunday-Saturday, *, etc )(END) yum1234567891011[root@test ~]# ansible-doc -s yum- name: Manages packages with the `yum&apos; package manager yum: conf_file: # 定远程yum安装时所依赖的配置文件。如配置文件没有在默认的位置。 disable_gpg_check: # 是否禁止GPG checking，只用于`present&apos; or `latest&apos;。 disablerepo: # 临时禁止使用yum库。 只用于安装或更新时。 enablerepo: # 临时使用的yum库。只用于安装或更新时。 name: # 所安装的包的名称 state: # present安装， latest安装最新的, absent 卸载软件。 update_cache: # 强制更新yum的缓存。 service12345678910[root@test ~]# ansible-doc -s service- name: Manage services service: arguments: # 命令行提供额外的参数 enabled: # 设置开机启动。 name: # 服务名称 runlevel: # 开机启动的级别，一般不用指定。 sleep: # 在重启服务的过程中，是否等待。如在服务关闭以后等待2秒再启动。 state: # started启动服务， stopped停止服务， restarted重启服务， reloaded重载配置 setup12345678910111213141516171819202122232425[root@test ~]# ansible-doc -s setup- name: Gathers facts about remote hosts setup: fact_path: # path used for local ansible facts (`*.fact&apos;) - files in this dir will be run (if executable) and their results be added to `ansible_local&apos; facts if a file is not executable it is read. Check notes for Windows options. (from 2.1 on) File/results format can be json or ini-format filter: # if supplied, only return facts that match this shell-style (fnmatch) wildcard. gather_subset: # if supplied, restrict the additional facts collected to the given subset. Possible values: `all&apos;, `min&apos;, `hardware&apos;, `network&apos;, `virtual&apos;, `ohai&apos;, and `facter&apos;. Can specify a list of values to specify a larger subset. Values can also be used with an initial `!&apos; to specify that that specific subset should not be collected. For instance: `!hardware,!network,!virtual,!ohai,!facter&apos;. If `!all&apos; is specified then only the min subset is collected. To avoid collecting even the min subset, specify `!all,!min&apos;. To collect only specific facts, use `!all,!min&apos;, and specify the particular fact subsets. Use the filter parameter if you do not want to display some collected facts. gather_timeout: # Set the default timeout in seconds for individual fact gathering[root@test ~]# selinux123456789[root@test ~]# ansible-doc -s selinux- name: Change policy and state of SELinux selinux: conf: # path to the SELinux configuration file, if non-standard policy: # name of the SELinux policy to use (example: `targeted&apos;) will be required if state is not `disabled&apos; state: # (required) The SELinux mode[root@test ~]# firewalld12345678910111213141516171819202122232425262728[root@test ~]# ansible-doc -s firewalld- name: Manage arbitrary ports/services with firewalld firewalld: immediate: # Should this configuration be applied immediately, if set as permanent interface: # The interface you would like to add/remove to/from a zone in firewalld masquerade: # The masquerade setting you would like to enable/disable to/from zones within firewalld permanent: # Should this configuration be in the running firewalld configuration or persist across reboots. As of Ansible version 2.3, permanent operations can operate on firewalld configs when it&apos;s not running (requires firewalld &gt;= 3.0.9). (NOTE: If this is false, immediate is assumed true.) port: # Name of a port or port range to add/remove to/from firewalld. Must be in the form PORT/PROTOCOL or PORT-PORT/PROTOCOL for port ranges. rich_rule: # Rich rule to add/remove to/from firewalld. service: # Name of a service to add/remove to/from firewalld - service must be listed in output of firewall-cmd --get-services. source: # The source/network you would like to add/remove to/from firewalld state: # (required) Enable or disable a setting. For ports: Should this port accept(enabled) or reject(disabled) connections. The states &quot;present&quot; and &quot;absent&quot; can only be used in zone level operations (i.e. when no other parameters but zone and state are set). timeout: # The amount of time the rule should be in effect for when non-permanent. zone: # The firewalld zone to add/remove to/from (NOTE: default zone can be configured per system but &quot;public&quot; is default from upstream. Available choices can be extended based on per-system configs, listed here are &quot;out of the box&quot; defaults).[root@test ~]# setup123456789101112131415161718192021222324[root@test ~]# ansible-doc -s setup- name: Gathers facts about remote hosts setup: fact_path: # path used for local ansible facts (`*.fact&apos;) - files in this dir will be run (if executable) and their results be added to `ansible_local&apos; facts if a file is not executable it is read. Check notes for Windows options. (from 2.1 on) File/results format can be json or ini-format filter: # if supplied, only return facts that match this shell-style (fnmatch) wildcard. gather_subset: # if supplied, restrict the additional facts collected to the given subset. Possible values: `all&apos;, `min&apos;, `hardware&apos;, `network&apos;, `virtual&apos;, `ohai&apos;, and `facter&apos;. Can specify a list of values to specify a larger subset. Values can also be used with an initial `!&apos; to specify that that specific subset should not be collected. For instance: `!hardware,!network,!virtual,!ohai,!facter&apos;. If `!all&apos; is specified then only the min subset is collected. To avoid collecting even the min subset, specify `!all,!min&apos;. To collect only specific facts, use `!all,!min&apos;, and specify the particular fact subsets. Use the filter parameter if you do not want to display some collected facts. gather_timeout: # Set the default timeout in seconds for individual fact gathering[root@test ~]#]]></content>
      <categories>
        <category>linux</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-ansible-01 ansible基础学习]]></title>
    <url>%2Fansible-01%2F</url>
    <content type="text"><![CDATA[linux-ansible-01 ansible基础学习概念引入假如我们要管理几十台刚买来的服务器，步骤如下：1.给每一台服务器装系统，可采用PXE+kickstart无人值守安装，亦或是云端镜像服务。2.给每一台服务器配置网络。3.给每一台服务器安装服务所需软件包 。4.给每一台服务器修改配置文件5.给每一台服务器启动服务6.其他… 那么，如果上述步骤，我们全部手动操作，一台一台服务器去弄，效率必然很低。我们嫌弃效率太慢，那么可以写脚本，一个脚本下去一步到位。但是，每一台服务器都要去手动执行一次这个脚本，是很麻烦的，如果后面有了新的服务需要部署，那么你既要写新的脚本，又要到每台服务器上手动执行一次新脚本，不胜其烦。所以，我们需要额外搭建一台服务器，在上面弄个任务清单，让其他服务器照着这个任务清单完成任务即可。当我们想要对服务器群做其他新的配置或搭建新的服务时，只需要在控制机上再写一个任务清单，让其他服务器照做即可，这就需要引入自动化运维的概念了。 概念解析自动化运维 随着信息时代的持续发展，IT运维已经成为IT服务内涵中重要的组成部分。面对越来越复杂的业务，面对越来越多样化的用户需求，不断扩展的IT应用需要越来越合理的模式来保障IT服务能灵活便捷、安全稳定地持续保障，这种模式中的保障因素就是IT运维（其他因素是更加优越的IT架构等）。从初期的几台服务器发展到庞大的数据中心，单靠人工已经无法满足在技术、业务、管理等方面的要求，那么标准化、自动化、架构优化、过程优化等降低IT服务成本的因素越来越被人们所重视。其中，自动化最开始作为代替人工操作为出发点的诉求被广泛研究和应用。 IT运维从诞生发展至今，自动化作为其重要属性之一已经不仅仅只是代替人工操作，更重要的是深层探知和全局分析，关注的是在当前条件下如何实现性能与服务最优化，同时保障投资收益最大化。自动化对IT运维的影响，已经不仅仅是人与设备之间的关系，已经发展到了面向客户服务驱动IT运维决策的层面，IT运维团队的构成，也从各级技术人员占大多数发展到业务人员甚至用户占大多数的局面。 因此，IT运维自动化是一组将静态的设备结构转化为根据IT服务需求动态弹性响应的策略，目的就是实现IT运维的质量，降低成本。可以说自动化一定是IT运维最高层面的重要属性之一，但不是全部。 ansible ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。ansible是基于模块工作的，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。 ansible框架1、连接插件connection plugins：负责和被监控端实现通信；2、host inventory：指定操作的主机，是一个配置文件里面定义监控的主机；3、各种模块核心模块、command模块、自定义模块；4、借助于插件完成记录日志邮件等功能；5、playbook：剧本执行多个任务时，非必需可以让节点一次性运行多个任务。 ansible核心组件 Ansible：核心程序 Modules：包括Ansible自带的核心模块及自定义模块 Plugins：完成模块功能的补充，包括连接插件、邮箱插件 Playbooks：剧本；定义Ansible多任务配置文件，由Ansible自动执行 Inventory：定义Ansible管理主机的清单 Connection Plugins：负责和被监控端实现通信 ansible特性1、no agents：不需要在被管控主机上安装任何客户端；2、no server：无服务器端，使用时直接运行命令即可；3、modules in any languages：基于模块工作，可使用任意语言开发模块；4、yaml，not code：使用yaml语言定制剧本playbook；5、ssh by default：基于SSH工作；6、strong multi-tier solution：可实现多级指挥。 ansible优点1、轻量级，无需在客户端安装agent，更新时，只需在操作机上进行一次更新即可；2、批量任务执行可以写成脚本，而且不用分发到远程就可以执行；3、使用python编写，维护更简单4、支持sudo。 ansible命令执行过程 加载自己的配置文件 默认/etc/ansible/ansible.cfg 加载自己对应的模块文件，如command 通过ansible将模块或命令生成对应的临时py文件，并将该文件传输至远程服务器的 对应执行用户的家目录的.ansible/tmp/XXX/XXX.PY文件。 给文件+x执行 执行并返回结果 删除临时py文件，sleep 0 退出 ansible安装部署 pip安装 二进制 yum安装 ansible程序文件/etc/ansible/roles：角色目录 /etc/ansible/ansible.cfg：主配置文件 /etc/ansible/hosts：主机清单配置文件 基本配置1、密钥登录 2、定义主机清单 实验准备三台虚拟机 服务端Test（管理机）：192.168.141.12 客户端node2：192.168.141.53 客户端node3：192.168.141.69 ansible安装与配置在服务端安装ansible 12[root@localhost ~]# yum install epel-release -y[root@localhost ~]# yum install ansible -y 服务端修改主机清单配置文件host 1234567[root@localhost ~]# vim /etc/ansible/hosts#在文档末尾加上一下这几行[node]node2node3 服务端修改host文件 123456[root@localhost ~]# vim /etc/hosts#在文档中加入下列两行192.168.141.53 node2192.168.141.69 node3 实现管理机对所有客户端的免密钥登录—ssh-key1ssh-keygen -t rsa #提示生成的密钥放在/root/.ssh/id_dsa #提示是否给生成的密钥再加密一次，回车即可 #让你再确认一次，回车即可。 123456[root@localhost ~]# ll /root/.ssh/total 12-rw-------. 1 root root 1679 Mar 23 02:50 id_rsa #生成后的私钥文件-rw-r--r--. 1 root root 408 Mar 23 02:50 id_rsa.pub #公钥文件 -rw-r--r--. 1 root root 519 Mar 23 03:13 known_hosts[root@localhost ~]# 把公钥发送到客户端机器上，第一次连接要输入yes，记录主机名跟IP，然后输出对方的密码即可 12[root@localhost ~]# ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.141.69[root@localhost ~]# ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.141.53 #公钥发送过去之后，登录对方的机器不用密码了。 1234567891011[root@localhost ~]# ssh 192.168.141.69Last login: Sat Mar 23 15:47:08 2019 from 192.168.141.1[root@localhost ~]# exitlogoutConnection to 192.168.141.69 closed.[root@localhost ~]# ssh 192.168.141.53Last login: Sat Mar 23 15:46:03 2019 from 192.168.141.1[root@localhost ~]# exitlogoutConnection to 192.168.141.53 closed.[root@localhost ~]# ansible测试我们先改好三台虚拟机的主机名 1234567891011121314151617181920[root@localhost ~]# hostnamectl set-hostname Test[root@localhost ~]# ansible node2 -m command -a &quot;hostnamectl set-hostname node2&quot;node2 | CHANGED | rc=0 &gt;&gt;[root@localhost ~]# ansible node3 -m command -a &quot;hostnamectl set-hostname node3&quot;node3 | CHANGED | rc=0 &gt;&gt;[root@localhost ~]# ssh 192.168.141.53Last login: Sat Mar 23 16:01:20 2019 from 192.168.141.12[root@node2 ~]# exitlogoutConnection to 192.168.141.53 closed.[root@localhost ~]# ssh 192.168.141.69Last login: Sat Mar 23 16:01:28 2019 from 192.168.141.12[root@node3 ~]# exitlogoutConnection to 192.168.141.69 closed.[root@localhost ~]# 可以看到上面三台虚拟机的主机名都已经改好，当然，Test的主机名你需要再次登录才能看到，如下 123456789101112131415161718[root@localhost ~]# exitlogoutConnection closing...Socket close.Connection closed by foreign host.Disconnected from remote host(Test) at 16:03:19.Type `help&apos; to learn how to use Xshell prompt.[C:\~]$ Connecting to 192.168.141.12:22...Connection established.To escape to local shell, press &apos;Ctrl+Alt+]&apos;.WARNING! The remote SSH server rejected X11 forwarding request.Last login: Sat Mar 23 02:44:34 2019 from 192.168.141.1[root@test ~]# 查看ansible帮助 12[root@test ~]# ansible --helpUsage: ansible &lt;host-pattern&gt; [options] 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rhce-10]]></title>
    <url>%2Frhce-10%2F</url>
    <content type="text"><![CDATA[重启开不了机的解决办法 RHCE做完所有题目之后，必须重启虚拟机进行检查，如果遇到重启失败的情况，很可能是/etc/fstab文件写错了，这个时候可以进入救援模式修改这个文件。 按照RHCSA进入救援模式的方法，进行如下操作 12345switch_root:/# mount -o remount,rw /sysrootswitch_root:/# chroot /sysrootsh-4.2# vim /etc/fstab#将里面所有自己添加的内容注释掉，不要误将系统本有的挂载注释sh-4.2# cat /etc/fstab 注释掉自己添加的那部分内容后，就可以正常启动了，之后将该文件内容改对就行了。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-rhce</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rhce-09 第21-22题]]></title>
    <url>%2Frhce-09%2F</url>
    <content type="text"><![CDATA[rhce-09 第21-22题题目列表21.配置一个数据库 22.数据库查询 21.配置一个数据库在server0上部署MariaDB。要求如下： 1）仅允许从system1系统上使用登陆到数据库。 2）登陆数据库所用的账号为root,密码为redhat。 3）从http://content.example.com/courses/rhce/rhel7.0/materials/mariadb/mariadb.dump上下载文件，并将其恢复为legacy库。 4）为此数据库创建一个名为bob的用户，并要求这个用户对数据库legacy有选择操作权限。 注意事项 本题需要注意做题步骤，如果在root文件夹下先下载了mariadb.dump文件的话，就会无法安装mariadb这时只能删掉mariadb.dump，yum install mariadb才能成功！同理，要yum remove mariadb的话，也要先删掉mariadb.dump才能成功！ 安装mariadb 123[root@localhost ~]# yum install mariadb* -y[root@localhost ~]# systemctl restart mariadb[root@localhost ~]# systemctl enable mariadb 初始化 1234567891011121314151617181920212223[root@localhost ~]# mysql_secure_installation /usr/bin/mysql_secure_installation: line 379: find_mysql_client: command not foundNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&apos;ll need the currentpassword for the root user. If you&apos;ve just installed MariaDB, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none): #初始密码为空，因此这里直接回车OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] y #输入y回车，设置root密码New password: [redhat]Re-enter new password: [redhat]Password updated successfully!#之后的选项一律回车即可。 导入数据、建立用户 12[root@localhost ~]# wget http://content.example.com/courses/rhce/rhel7.0/materials/mariadb/mariadb.dump[root@localhost ~]# ls 12345678910[root@localhost ~]# mysql -u root -predhatMariaDB [(none)]&gt; create database legacy;MariaDB [(none)]&gt; use legacy;MariaDB [legacy]&gt; source /root/mariadb.dumpMariaDB [legacy]&gt; grant select on legacy.* to bob@localhost identified by &apos;redhat&apos;;MariaDB [legacy]&gt; quitBye[root@localhost ~]# [root@localhost ~]# firewall-cmd --add-service=mysql --permanent[root@localhost ~]# firewall-cmd --reload 22.数据库查询数据查询填空 在system1上登陆数据库，查看legacy库进行查询，并将结果填入相应的框格中。 查询类别为Servers的产品的数量____。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#首先查看数据库legacy中所有数据表[root@localhost ~]# mysql -u root -predhatMariaDB [(none)]&gt; use legacy;MariaDB [legacy]&gt; show tables;+------------------+| Tables_in_legacy |+------------------+| category || manufacturer || product |+------------------+3 rows in set (0.02 sec)MariaDB [legacy]&gt; #查看每个表MariaDB [legacy]&gt; select * from category;+----+------------+| id | name |+----+------------+| 1 | Networking || 2 | Servers || 3 | Ssd |+----+------------+3 rows in set (0.00 sec)MariaDB [legacy]&gt; select * from manufacturer;+----+----------+----------------+-------------------+| id | name | seller | phone_number |+----+----------+----------------+-------------------+| 1 | SanDisk | John Miller | +1 (941) 329-8855 || 2 | Kingston | Mike Taylor | +1 (341) 375-9999 || 3 | Asus | Wilson Jackson | +1 (432) 367-8899 || 4 | Sony | Allen Scott | +1 (876) 213-4439 |+----+----------+----------------+-------------------+4 rows in set (0.00 sec)MariaDB [legacy]&gt; select * from product;+----+-------------------+---------+-------+-------------+-----------------+| id | name | price | stock | id_category | id_manufacturer |+----+-------------------+---------+-------+-------------+-----------------+| 1 | ThinkServer TS140 | 539.88 | 20 | 2 | 4 || 2 | ThinkServer RD630 | 2379.14 | 20 | 2 | 4 || 3 | RT-AC68U | 219.99 | 10 | 1 | 3 || 4 | X110 64GB | 73.84 | 100 | 3 | 1 |+----+-------------------+---------+-------+-------------+-----------------+#用合适的sql语句查询出结果MariaDB [legacy]&gt; select sum(stock) from product,category where category.id=product.id_category and category.name=&quot;Servers&quot;;+------------+| sum(stock) |+------------+| 40 |+------------+1 row in set (0.01 sec)MariaDB [legacy]&gt; MariaDB [legacy]&gt; quitBye[root@localhost ~]# #将答案40在网页上填好，提交即可 注意事项 数据库的题每次都会不同，要求考生熟练掌握sql语句。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-rhce</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rhce-08 第19-20题]]></title>
    <url>%2Frhce-08%2F</url>
    <content type="text"><![CDATA[rhce-08 第19-20题题目列表19.配置 iscsI 服务端 20.配置 iscsI 的客户端 19.配置 iscsI 服务端配置system1提供一个iSCSI服务磁盘名为iqn.2017-02.com.example:system1,并符合下列要求: 1）服务端口为3260。 2）使用iscsi_store作为其后端卷，其大小为3G。 3）此服务只能被system2访问。 安装工具，防火墙放行相应端口，查看空闲磁盘。 123456[root@localhost ~]# yum install targetcli -y[root@localhost ~]# systemctl restart target[root@localhost ~]# systemctl enable target[root@localhost ~]# firewall-cmd --permanent --add-port=3260/tcp[root@localhost ~]# firewall-cmd --reload [root@localhost ~]# fdisk -l 如上图，sdb空闲，可以讲iscsi服务搭在这个磁盘。 新建磁盘分区 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061[root@localhost ~]# fdisk /dev/sdbWelcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Device does not contain a recognized partition tableBuilding a new DOS disklabel with disk identifier 0x85651593.Command (m for help): nPartition type: p primary (0 primary, 0 extended, 4 free) e extendedSelect (default p): pPartition number (1-4, default 1): #直接回车First sector (2048-20971519, default 2048): #直接回车Using default value 2048Last sector, +sectors or +size&#123;K,M,G&#125; (2048-20971519, default 20971519): +3100M #这里写3100M而不是3G，因为必须多出来一些空间以作他用Partition 1 of type Linux and of size 3 GiB is setCommand (m for help): t #指定类型typeSelected partition 1Hex code (type L to list all codes): L #用L表示list列出所有类型，下面8e就是LVM类型 0 Empty 24 NEC DOS 81 Minix / old Lin bf Solaris 1 FAT12 27 Hidden NTFS Win 82 Linux swap / So c1 DRDOS/sec (FAT- 2 XENIX root 39 Plan 9 83 Linux c4 DRDOS/sec (FAT- 3 XENIX usr 3c PartitionMagic 84 OS/2 hidden C: c6 DRDOS/sec (FAT- 4 FAT16 &lt;32M 40 Venix 80286 85 Linux extended c7 Syrinx 5 Extended 41 PPC PReP Boot 86 NTFS volume set da Non-FS data 6 FAT16 42 SFS 87 NTFS volume set db CP/M / CTOS / . 7 HPFS/NTFS/exFAT 4d QNX4.x 88 Linux plaintext de Dell Utility 8 AIX 4e QNX4.x 2nd part 8e Linux LVM df BootIt 9 AIX bootable 4f QNX4.x 3rd part 93 Amoeba e1 DOS access a OS/2 Boot Manag 50 OnTrack DM 94 Amoeba BBT e3 DOS R/O b W95 FAT32 51 OnTrack DM6 Aux 9f BSD/OS e4 SpeedStor c W95 FAT32 (LBA) 52 CP/M a0 IBM Thinkpad hi eb BeOS fs e W95 FAT16 (LBA) 53 OnTrack DM6 Aux a5 FreeBSD ee GPT f W95 Ext&apos;d (LBA) 54 OnTrackDM6 a6 OpenBSD ef EFI (FAT-12/16/10 OPUS 55 EZ-Drive a7 NeXTSTEP f0 Linux/PA-RISC b11 Hidden FAT12 56 Golden Bow a8 Darwin UFS f1 SpeedStor 12 Compaq diagnost 5c Priam Edisk a9 NetBSD f4 SpeedStor 14 Hidden FAT16 &lt;3 61 SpeedStor ab Darwin boot f2 DOS secondary 16 Hidden FAT16 63 GNU HURD or Sys af HFS / HFS+ fb VMware VMFS 17 Hidden HPFS/NTF 64 Novell Netware b7 BSDI fs fc VMware VMKCORE 18 AST SmartSleep 65 Novell Netware b8 BSDI swap fd Linux raid auto1b Hidden W95 FAT3 70 DiskSecure Mult bb Boot Wizard hid fe LANstep 1c Hidden W95 FAT3 75 PC/IX be Solaris boot ff BBT 1e Hidden W95 FAT1 80 Old Minix Hex code (type L to list all codes): 8e #选择8e即可Changed type of partition &apos;Linux&apos; to &apos;Linux LVM&apos;Command (m for help): w #write写入保存The partition table has been altered!Calling ioctl() to re-read partition table.Syncing disks.[root@localhost ~]# [root@localhost ~]# partprobe [root@localhost ~]# fdisk -l 如下图，多出来一个sdb1分区。 创建逻辑卷iscsi_store作为后端存储 1234567[root@localhost ~]# pvcreate /dev/sdb1 Physical volume &quot;/dev/sdb1&quot; successfully created[root@localhost ~]# vgcreate myvg /dev/sdb1 Volume group &quot;myvg&quot; successfully created[root@localhost ~]# lvcreate -n iscsi_store -L +3G myvg Logical volume &quot;iscsi_store&quot; created[root@localhost ~]# 接下来到system2上，cat出iscsi的iqn，下面要用 123456[root@localhost ~]# cat /etc/iscsi/initiatorname.iscsi InitiatorName=iqn.1994-05.com.redhat:9e96ff23da37[root@localhost ~]# #复制上述iqn：iqn.1994-05.com.redhat:9e96ff23da37 回到system1，开始配置iscsi服务端： 123456789101112131415161718[root@localhost ~]# targetcli/&gt; lso- / ..................................................................... [...] o- backstores .......................................................... [...] | o- block .............................................. [Storage Objects: 0] | o- fileio ............................................. [Storage Objects: 0] | o- pscsi .............................................. [Storage Objects: 0] | o- ramdisk ............................................ [Storage Objects: 0] o- iscsi ........................................................ [Targets: 0] o- loopback ..................................................... [Targets: 0]/&gt; /backstores/block create iscsi_store /dev/myvg/iscsi_store /&gt; /iscsi create iqn.2017-02.com.example:system1 #这是题目里面要求配置的iqn/&gt; /iscsi/iqn.2017-02.com.example:system1/tpg1/luns create /backstores/block/iscsi_store /&gt; iscsi/iqn.2017-02.com.example:system1/tpg1/portals delete ip_address=0.0.0.0 ip_port=3260 #这个命令会报错是正常的，它只是为了确保3260端口不被占用/&gt; /iscsi/iqn.2017-02.com.example:system1/tpg1/portals create 172.25.0.11/&gt; /iscsi/iqn.2017-02.com.example:system1/tpg1/acls create iqn.1994-05.com.redhat:9e96ff23da37 #这个iqn就是上面特意到system2上cat出来的iqn。/&gt; exit[root@localhost ~]# systemctl restart target 实际配置时，有字体颜色区别，如下图： 20.配置 iscsI 的客户端配置system2使其能连接在system1上提供的iqn.2017-02.com.example:system1并符合以下要求： 1）iSCSI设备在系统启动的时候自动加载。 2）块设备iSCSI上包含一个大小为2100 MiB的分区，并格式化为xfs。 3）此分区挂载在/mnt/data上同时在系统启动的期间自动挂载。 在system2上完成以下配置： 1234567891011121314[root@localhost ~]# yum install iscsi-initiator-utils -y[root@localhost ~]# systemctl enable iscsi iscsid[root@localhost ~]# systemctl restart iscsi iscsid[root@localhost ~]# iscsiadm -m discovery -t st -p 172.25.0.11172.25.0.11:3260,1 iqn.2017-02.com.example:system1[root@localhost ~]# iscsiadm -m node -l[root@localhost ~]# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 10G 0 disk └─sda1 8:1 0 10G 0 part /sdb 8:16 0 10G 0 disk sdc 8:32 0 3G 0 disk sr0 11:0 1 1024M 0 rom [root@localhost ~]# 如下图， system2上多出来一个大小为3G的磁盘sdc，就说明登录成功了 对sdc磁盘分区 1234567891011121314151617181920[root@desktop0 ~]# fdisk /dev/sdcCommand (m for help): nPartition type: p primary (0 primary, 0 extended, 4 free) e extendedSelect (default p): pPartition number (1-4, default 1): #直接回车First sector (8192-6291455, default 8192): #直接回车Using default value 8192Last sector, +sectors or +size&#123;K,M,G&#125; (8192-6291455, default 6291455): +2100MPartition 1 of type Linux and of size 2.1 GiB is setCommand (m for help): wThe partition table has been altered!Calling ioctl() to re-read partition table.Syncing disks.[root@desktop0 ~]# partprobe [root@desktop0 ~]# fdisk -l 将分区sdc1格式化为xfs 1234567891011[root@desktop0 ~]# mkfs.xfs /dev/sdc1meta-data=/dev/sdc1 isize=256 agcount=8, agsize=67200 blks = sectsz=512 attr=2, projid32bit=1 = crc=0data = bsize=4096 blocks=537600, imaxpct=25 = sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=0log =internal log bsize=4096 blocks=2560, version=2 = sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0[root@desktop0 ~]# 配置开机自动挂载 1234567891011[root@desktop0 ~]# mkdir /mnt/data[root@desktop0 ~]# blkid /dev/sdc1/dev/sdc1: UUID=&quot;ace30a49-85ef-4e65-86ac-9a8e96665d95&quot; TYPE=&quot;xfs&quot; #将此UUID复制下来，添加到/etc/fstab文件里面[root@desktop0 ~]# vim /etc/fstab [root@desktop0 ~]# cat /etc/fstab | tail -n 2UUID=&quot;ace30a49-85ef-4e65-86ac-9a8e96665d95&quot; /mnt/data xfs defaults,_netdev 0 0[root@desktop0 ~]# 挂载，查看结果 12[root@desktop0 ~]# mount -a[root@desktop0 ~]# df -hT 如下图，可以看到挂载成功。 扩展知识123456lvextend和lvcreate的参数：-l|--extents LogicalExtentsNumber[%&#123;VG|FREE|ORIGIN&#125;] -L|--size LogicalVolumeSize[bBsSkKmMgGtTpPeE]&#125;l：指定物理扩展单元数量（无单位）L：指定逻辑卷大小（有单位M）]]></content>
      <categories>
        <category>linux</category>
        <category>linux-rhce</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rhce-07 第17-18题]]></title>
    <url>%2Frhce-07%2F</url>
    <content type="text"><![CDATA[rhce-07 第17-18题题目列表 17.创建一个脚本 18.创建一个添加用户的脚本 17.创建一个脚本在system1上创建一个名为/root/foo.sh的脚本，让其提供下列特性： 1）当运行/root/foo.sh redhat，输出fedora。 2）当运行/root/foo.sh fedora，输出redhat。 3）当没有任何参数或者参数不是redhat或者fedora时，其错误输出产生以下的信息： /root/foo.sh redhat|fedora system1： 12345678910111213141516171819202122[root@localhost ~]# vim /root/foo.sh[root@localhost ~]# chmod +x foo.sh [root@localhost ~]# cat foo.sh #!/bin/bashcase $1 in redhat) echo &quot;fedora&quot; ;; fedora) echo &quot;redhat&quot; ;; *) echo &quot;/root/foo.sh redhat|fedora&quot; ;;esac[root@localhost ~]# ./foo.sh /root/foo.sh redhat|fedora[root@localhost ~]# ./foo.sh redhatfedora[root@localhost ~]# ./foo.sh fedoraredhat[root@localhost ~]# 18.创建一个添加用户的脚本 在system1上创建一个名为/root/batchusers,此脚本能够实现为系统system1创建本地用户，并且这些用户的用户名来自一个包含用户名列表的文件，同时满足下列要求: 1）此脚本要求提供一个参数，此参数就是包含用户名列表的文件。 2）如果没有提供参数，此脚本应该给出下面的提示信息Usage: /root/batusers userfile ,并且退出返回相应的值。 3）如果提供一个不存在的文件名，此脚本应该给出下面的提示信息Input file not found然后退出并返回相应的值。 4）创建的用户不可登录交互式shell。 5）此脚本不需要为用户设置密码。 6）您可以从下面的URL获取用户列表作为测试用： http://classroom.example.com/materials/userlist system1： 1234567891011121314151617181920212223[root@localhost ~]# vim /root/batchusers[root@localhost ~]# chmod +x batchusers [root@localhost ~]# cat batchusers #!/bin/bashif [ $# == 1 ];then if [ -f $1 ];then while read username;do useradd -s /bin/false $username &amp;&gt;/dev/null done&lt;$1 else echo &quot;Input file not found&quot; fielse echo &quot;Usage: /root/batusers userfile&quot;fi[root@localhost ~]# ./batchusers Usage: /root/batusers userfile[root@localhost ~]# ./batchusers 123Input file not found[root@localhost ~]# wget http://classroom.example.com/materials/userlist[root@localhost ~]# ./batchusers userlist [root@localhost ~]# cat /etc/passwd[root@localhost ~]# curl http://classroom.example.com/materials/userlist 验证： 命令解析bash的单引号’’，双引号””和反引号的区别。 单引号’ ‘ 和双引号” “，这两者都是解决变量中间有空格的问题。在bash中，空格是一种很特殊的字符，比如在bash中这样定义string=hello world，这样就会报错，为了避免出错就得使用单引号’ ‘和双引号” “。 单引号’’，双引号””的区别１）单引号’ ‘剥夺了所有字符的特殊含义，单引号’ ‘内就变成了单纯的字符。 ２）双引号” “则对于双引号” “内的参数替换($)和命令替换。 123456789[root@localhost ~]# bash[root@localhost ~]# n=100[root@localhost ~]# echo &apos;$n&apos;$n[root@localhost ~]# echo &quot;$n&quot;100[root@localhost ~]# echo $n100[root@localhost ~]# 反引号 反引号是命令替换，命令替换是指Shell可以先执行中的命令，将输出结果暂时保存，在适当的地方输出。下面的例子中，将命令执行结果保存在变量中： 1234567891011121314151617181920[root@localhost ~]# bash[root@localhost ~]# mydate=date[root@localhost ~]# echo &quot;mydate&quot;mydate[root@localhost ~]# echo &quot;$mydate&quot;date[root@localhost ~]# [root@localhost ~]# [root@localhost ~]# [root@localhost ~]# mydate=&apos;date&apos;[root@localhost ~]# echo &quot;$mydate&quot;date[root@localhost ~]# [root@localhost ~]# [root@localhost ~]# [root@localhost ~]# [root@localhost ~]# mydate=`date`[root@localhost ~]# echo &quot;$mydate&quot;2019年 08月 08日 星期四 16:46:04 CST[root@localhost ~]# 由上面的三个例子可以看出，无论用单引号还是不加符号，都只能将字符串date赋值给mydate变量，导致后面输出这个变量的时候仅仅是输出字符串date。 而用单引号的时候，可以看到将date命令执行结果赋值给了mydate变量，所以后面输出这个变量的时候得以输出date命令的执行结果。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-rhce</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rhce-06 第12-16题]]></title>
    <url>%2Frhce-06%2F</url>
    <content type="text"><![CDATA[rhce-06 第12-16题题目列表12.实现一个 web 服务器 13.配置安全 web 服务 14.配置虚拟主机 15.配置 web 内容的访问 16.实现动态 web 内容 12.实现一个 web 服务器在system1上配置一个站点http://server0.example.com，然后执行以下步骤： 1）从http://classroom.example.com/materials/station.html下载文件，并且将文件重命名为index.html,绝对不能修改此文件的内容。 2）将index.html拷贝到你的web服务器的DocumentRoot目录下。 3）来自example.com(172.25.0.0/24)域的客户端可以访问此web服务。 4）来自my133t.org(172.17.10.0/24)域的客户端拒绝访问此web服务。 system1： 12345678[root@localhost ~]# yum install httpd -y[root@localhost ~]# wget http://classroom.example.com/materials/station.html -O /var/www/html/index.html[root@localhost ~]# systemctl restart httpd[root@localhost ~]# systemctl enable httpd[root@localhost ~]# firewall-cmd --permanent --add-service=http[root@localhost ~]# firewall-cmd --permanent --add-rich-rule &apos;rule family=ipv4 source address=172.17.10.0/24 service name=http reject&apos;[root@localhost ~]# firewall-cmd --reload [root@localhost ~]# system2验证： 1[root@localhost ~]# curl http://server0.example.com 13.配置安全 web 服务为站点http://server0.example.com配置TLS加密。 1）一个已经签名证书从http://classroom.example.com/pub/tls/certs/server0.crt获取。 2）此证书的密钥从http://classroom.example.com/pub/tls/private/server0.key获取。 3）此证书的授权信息从http://classroom.example.com/pub/example-ca.crt获取。 system1： 1234567891011121314151617[root@localhost ~]# yum install mod_ssl -y[root@localhost ~]# cd /etc/httpd[root@localhost httpd]# wget http://classroom.example.com/pub/tls/certs/server0.crt[root@localhost httpd]# wget http://classroom.example.com/pub/tls/private/server0.key[root@localhost httpd]# wget http://classroom.example.com/pub/example-ca.crt[root@localhost httpd]# cd[root@localhost ~]# [root@localhost ~]# vim /etc/httpd/conf.d/ssl.conf 100 SSLCertificateFile /etc/httpd/server0.crt107 SSLCertificateKeyFile /etc/httpd/server0.key122 SSLCACertificateFile /etc/httpd/example-ca.crt[root@localhost ~]# systemctl restart httpd[root@localhost ~]# firewall-cmd --permanent --add-service=https[root@localhost ~]# firewall-cmd --reload[root@localhost ~]# system2验证： 12下面接一个参数k是因为跳过浏览器提示此网站证书不安全的提示，如下图，若不加k参数则会报错。[root@localhost ~]# curl -k https://server0.example.com 如果不想用命令行验证，也可以打开虚拟机桌面的火狐浏览器输入网址进行验证。 14.配置虚拟主机 在system1上扩展你的web服务器，为站点http://www0.example.com创建一个虚拟主机，然后执行以下步骤： 1）设置DocumentRoot为/var/www/virtual。 2）从http://classroom.example.com/materials/www.html下载文件并重命名为index.html，不要对文件index.html内容做任何修改。 3）将index.htm文件放到虚拟主机的DocumentRoot目录下。 4）确保floyd用户能够在/var/www/virtual目录下创建文件。 注意：原始站点http://system1.example.com必须仍然能够访问。站点的所用的域名网络中已有DNS服务器解析服务。 1234567891011121314151617[root@localhost ~]# mkdir /var/www/virtual[root@localhost ~]# wget http://classroom.example.com/materials/www.html -O /var/www/index.html[root@localhost ~]# useradd floyd[root@localhost ~]# setfacl -m u:floyd:rwx /var/www/virtual/[root@localhost ~]# [root@localhost ~]# vim /etc/httpd/conf.d/vhost.conf&lt;VirtualHost _default_:80&gt;DocumentRoot /var/www/htmlServerName server0.example.com&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt;DocumentRoot /var/www/virtualServerName www0.example.com&lt;/VirtualHost&gt;[root@localhost ~]# systemctl restart httpd system2验证： 123[root@localhost ~]# curl http://server0.example.com[root@localhost ~]# curl -k https://server0.example.com[root@localhost ~]# curl http://www0.example.com 15.配置 web 内容的访问在你的system1上的web服务器的DocumentRoot目录下创建一个名为private的目录，要求如下： 1）从http://classroom.example.com/materials/private.html下载一个文件副本到这个目录，并且重命名为index.html，不要对这个文件的内容作任何修改。 2）从system1上，任何人都可以浏览private的内容，但是从其他系统就不能访问这个目录的内容。 1234567891011121314151617181920212223[root@localhost ~]# mkdir /var/www/html/private[root@localhost ~]# cd /var/www/html/private/[root@localhost private]# wget http://classroom.example.com/materials/private.html -O index.html[root@localhost private]# lsindex.html[root@localhost private]# cd[root@localhost ~]# [root@localhost ~]# vim /etc/httpd/conf.d/vhost.conf[root@localhost ~]# systemctl restart httpd[root@localhost ~]# cat /etc/httpd/conf.d/vhost.conf&lt;VirtualHost _default_:80&gt;DocumentRoot /var/www/htmlServerName server0.example.com&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt;DocumentRoot /var/www/virtualServerName www0.example.com&lt;/VirtualHost&gt;&lt;Directory &quot;/var/www/html/private&quot;&gt;Require local&lt;/Directory&gt;[root@localhost ~]# system1验证： 1[root@localhost ~]# curl http://server0.example.com/private system2验证： 1[root@localhost ~]# curl http://server0.example.com/private 可以看到，system1上可以访问，而system2上则是包403拒绝访问。 16.实现动态 web 内容在system1上配置提供动态web内容，要求如下： 1）动态内容由名为webapp0.example.com的虚拟主机提供。 2）虚拟主机监听在端口8908。 3）从http://classroom.example.com/materials/webinfo.wsgi下载一个脚本，然后放在适当的位置，无论如何不要修改此文件的内容。 4）客户端访问http://webapp0.example.com:8908时应该接收到动态生成的web页面。 5）此站点http://webapp0.example.com:8908必须能够被example.com域内的所有系统访问。 123456789101112131415161718192021222324252627282930[root@localhost ~]# yum install mod_wsgi -y[root@localhost ~]# cd /var/www/cgi-bin/[root@localhost cgi-bin]# wget http://classroom.example.com/materials/webinfo.wsgi[root@localhost cgi-bin]# lswebinfo.wsgi[root@localhost cgi-bin]# cd[root@localhost ~]# semanage port -a -t http_port_t -p tcp 8908[root@localhost ~]# vim /etc/httpd/conf.d/vhost.conf [root@localhost ~]# systemctl restart httpd[root@localhost ~]# cat /etc/httpd/conf.d/vhost.conf Listen 8908&lt;VirtualHost _default_:80&gt;DocumentRoot /var/www/htmlServerName server0.example.com&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt;DocumentRoot /var/www/virtualServerName www0.example.com&lt;/VirtualHost&gt;&lt;Directory &quot;/var/www/html/private&quot;&gt;Require local&lt;/Directory&gt;&lt;VirtualHost *:8908&gt;ServerName webapp0.example.comWSGIScriptAlias / /var/www/cgi-bin/webinfo.wsgi&lt;/VirtualHost&gt;[root@localhost ~]# [root@localhost ~]# [root@localhost ~]# firewall-cmd --permanent --add-port=8908/tcp[root@localhost ~]# firewall-cmd --reload system2验证： 1[root@localhost ~]# curl http://webapp0.example.com:8908]]></content>
      <categories>
        <category>linux</category>
        <category>linux-rhce</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rhce-05 第10-11题]]></title>
    <url>%2Frhce-05%2F</url>
    <content type="text"><![CDATA[rhce-05 第10-11题题目列表10.配置 NFS 服务 11.挂载一个 NFS 共享 10.配置 NFS 服务在system1配置NFS服务，要求如下： 1）以只读的形式共享目录/public同时只能被example.com域中的系统访问。 2）以读写的形式共享目录/protected同时只能被example.com域中的系统访问。 3）访问/protected需要通过Kerberos安全加密，您可以使用下面提供的密钥： http://classroom.example.com/pub/keytabs/server0.keytab 4）目录/protected应该包含名为project拥有人为ldapuser0的子目录。 5）用户ldapuser0能以读写形式访问/protected/project。 system1： 1234567891011121314151617181920[root@localhost ~]# yum install nfs-utils -y[root@localhost ~]# firewall-cmd --permanent --add-service=nfs[root@localhost ~]# firewall-cmd --permanent --add-service=rpc-bind[root@localhost ~]# firewall-cmd --permanent --add-service=mountd[root@localhost ~]# firewall-cmd --reload [root@localhost ~]# [root@localhost ~]# mkdir -p /public /protected/project[root@localhost ~]# chown ldapuser0 /protected/project[root@localhost ~]# chown nfsnobody /public[root@localhost ~]# setfacl -m u:ldapuser0:rwx /protected/project/[root@localhost ~]# #设置selinux安全上下文[root@localhost ~]# semanage fcontext -a -t &apos;public_content_t&apos; &apos;/protected(/.*)?&apos;[root@localhost ~]# semanage fcontext -a -t &apos;public_content_rw_t&apos; &apos;/protected/project(/.*)?&apos;[root@localhost ~]# restorecon -Rv /protected/ 12345678910111213141516171819[root@localhost ~]# wget http://classroom.example.com/pub/keytabs/server0.keytab -O /etc/krb5.keytab#编辑 nfs 资源导出配置文件，注意不要有多余空格[root@system1 ~]# vim /etc/exports/public 172.25.0.0/24(ro,sync)/protected 172.25.0.0/24(rw,sync,sec=krb5p)#设置nfs版本[root@localhost ~]# vim /etc/sysconfig/nfsRPCNFSDARGS=&quot;-V 4.2&quot;#重启服务[root@localhost ~]# systemctl enable nfs-server nfs-secure-server[root@localhost ~]# systemctl restart nfs-server nfs-secure-server[root@localhost ~]# #刷新并验证导出资源[root@localhost ~]# exportfs -ra[root@localhost ~]# exportfs 11.挂载一个 NFS 共享在system2上挂载一个来自system1上的NFS共享，并符合下列要求： 1）/pulbic共享挂载到本地的/mnt/nfsmount。 2）/protected挂载到本地的/mnt/nfssecure,并使用安全的方式，密钥下载地址： http://classroom.example.com/pub/keytabs/desktop0.keytab 3）用户ldapuser0能够在/mnt/nfssecure/project上创建文件。 4）这些文件系统在系统启动时自动挂载。 system2： 12#首先要明确，ldapuser0是系统预设的早已经存在的用户，不需要自己手动去添加。[root@localhost ~]# id ldapuser0 下面是操作步骤 123456789101112131415[root@localhost ~]# wget http://classroom.example.com/pub/keytabs/desktop0.keytab -O /etc/krb5.keytab[root@localhost ~]# systemctl enable nfs-secure[root@localhost ~]# systemctl restart nfs-secure[root@localhost ~]# [root@localhost ~]# mkdir /mnt/nfssecure /mnt/nfsmount[root@localhost ~]# vim /etc/fstab server0.example.com:/public /mnt/nfsmount nfs defaults 0 0server0.example.com:/protected /mnt/nfssecure nfs defaults,sec=krb5p,v4.2 0 0 [root@localhost ~]# mount -a [root@localhost ~]# df -Th#如下图挂载成功，这题基本就可以满分了 最后，验证用户ldapuser0能够在/mnt/nfssecure/project上创建文件 123456[root@localhost ~]# su - ldapuser0Last login: Thu Aug 8 14:03:33 CST 2019 on pts/0[ldapuser0@localhost ~]$ kinitPassword for ldapuser0@EXAMPLE.COM: [kerberos][ldapuser0@localhost ~]$ cd /mnt/nfssecure/project/[ldapuser0@localhost project]$ touch test.txt]]></content>
      <categories>
        <category>linux</category>
        <category>linux-rhce</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rhce-04 第8-9题]]></title>
    <url>%2Frhce-04%2F</url>
    <content type="text"><![CDATA[rhce-04 第8-9题题目列表8.通过 SMB 共享目录 9.配置多用户 SMB 挂载 8.通过 SMB 共享目录在 system1上配置 SMB 服务 1）您的 SMB 服务器必须是 STAFF 工作组的一个成员 2）共享/common目录，共享名必须为common。 3）只有 example.com 域内的客户端可以访问 common 共享 4）common 必须是可以浏览的 5）该目录可以被用户harry以只读的方式访问，如需设置密码，请使用redhat。 1234567[root@localhost ~]# yum install samba samba-client.x86_64 -y#设置selinux安全上下文[root@localhost ~]# mkdir /common[root@localhost ~]# chcon -t samba_share_t /common[root@localhost ~]# setsebool -P samba_export_all_ro on[root@localhost ~]# 123456789101112131415161718192021#注意，下面修改配置文件之前先备份[root@localhost ~]# cp /etc/samba/smb.conf&#123;,.bak&#125;[root@localhost ~]# vim /etc/samba/smb.conf 89 workgroup = STAFF 95 hosts allow = 127. 172.25.0. 321 [common] 322 path = /common 323 browseable = yes[root@localhost ~]# systemctl restart smb nmb[root@localhost ~]# systemctl enable smb nmb[root@localhost ~]# useradd harry[root@localhost ~]# smbpasswd -a harryNew SMB password: [redhat]Retype new SMB password: [redhat]Added user harry.[root@localhost ~]# [root@localhost ~]# setfacl -m u:harry:rx /common/[root@localhost ~]# getfacl /common/ 123456789101112131415161718192021#若使用firewalld，添加策略[root@localhost ~]# firewall-cmd --add-service=samba --permanent [root@localhost ~]# firewall-cmd --reload [root@localhost ~]# #测试[root@localhost ~]# cd /common/[root@localhost common]# touch 1.txt[root@localhost common]# ls1.txt[root@localhost common]#cd[root@localhost ~]# smbclient //server0.example.com/common -U harryEnter harry&apos;s password: [redhat]smb: \&gt; ls . D 0 Thu Aug 8 10:35:55 2019 .. D 0 Thu Aug 8 10:14:36 2019 1.txt N 0 Thu Aug 8 10:35:55 2019 40913 blocks of size 262144. 27984 blocks availablesmb: \&gt; exit[root@localhost ~]# 如下图，注意设置harry对common目录权限的时候是rx而不是r，否则会不可读。 接下来在system2上也测试一下 12345678910111213#cifs协议是SMB协议增强版[root@localhost ~]# yum install samba-client.x86_64 cifs-utils.x86_64 -y[root@localhost ~]# smbclient //server0.example.com/common -U harryEnter harry&apos;s password: Domain=[STAFF] OS=[Unix] Server=[Samba 4.1.1]smb: \&gt; ls . D 0 Thu Aug 8 10:35:55 2019 .. D 0 Thu Aug 8 10:14:36 2019 1.txt N 0 Thu Aug 8 10:35:55 2019 40913 blocks of size 262144. 27984 blocks availablesmb: \&gt; exit[root@localhost ~]# 9.配置多用户 SMB 挂载在system1通过SMB服务共享目录/devops，并满足以下要求： 1）共享名为devops。 2）共享目录devops只能被example.com域中的客户端使用。 3）共享目录devops必须可以被浏览。 4）该目录可以被用户harry以只读的方式访问，如需设置密码，请使用redhat。 5）该目录可以被用户natasha以读写的方式访问，如需设置密码，请使用redhat。 6）此共享目录永久挂载在system2上的/mnt/multi目录，并使用用户harry作为认证用户验证登录，并且可以通过用户natasha来临时获取写权限。 system1： 1234567891011121314151617181920212223242526272829#设置selinux安全上下文#rw读写，因为题目中涉及到了写权限，所以配置rw[root@localhost ~]# mkdir /devops[root@localhost ~]# chcon -t samba_share_t /devops[root@localhost ~]# setsebool -P samba_export_all_rw on[root@localhost ~]# [root@localhost ~]# vim /etc/samba/smb.conf 325 [devops] 326 path = /devops 327 browseable = yes 328 write list = natasha[root@localhost ~]# useradd natasha[root@localhost ~]# smbpasswd -a natashaNew SMB password: [redhat]Retype new SMB password: [redhat]Added user natasha.[root@localhost ~]# [root@localhost ~]# setfacl -m u:harry:rx /devops/[root@localhost ~]# setfacl -m u:natasha:rwx /devops/[root@localhost ~]# getfacl /devops[root@localhost ~]# #nmb是smb的网络连接服务域名解析用的[root@localhost ~]# systemctl restart smb nmb[root@localhost ~]# system2： 12345678910111213141516171819[root@localhost ~]# mkdir /mnt/multi[root@localhost ~]# vim /etc/fstab #文档尾部追加这一行//172.25.0.11/devops /mnt/multi cifs defaults,multiuser,username=harry,password=redhat,sec=ntlmssp 0 0[root@localhost ~]# mount -a[root@localhost ~]# #测试客户端[root@localhost ~]# useradd natasha[root@localhost ~]# su - natasha[natasha@localhost ~]$ cifscreds add 172.25.0.11 -u natashaPassword: [redhat][natasha@localhost ~]$ cd /mnt/multi[natasha@localhost multi]$ touch a.txt[natasha@localhost multi]$ exitlogout[root@localhost ~]# ls /mnt/multia.txt[root@localhost ~]# 接下来可以到system1上验证： system1： 123[root@localhost ~]# ls /devopsa.txt[root@localhost ~]#]]></content>
      <categories>
        <category>linux</category>
        <category>linux-rhce</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rhce-03 第5-7题]]></title>
    <url>%2Frhce-03%2F</url>
    <content type="text"><![CDATA[rhce-03 第5-7题题目列表5.配置链路聚合 6.配置 IPv6 地址 7.配置本地邮件服务 5.配置链路聚合在 server0.example.com 和 desktop0.example.com 之间按以下要求配置一个链接 1）此链路使用接口 eth1 和 eth2 2）此链路在一个接口失效时仍然能工作 3）此链路 server0 使用地址：172.16.1.65/255.255.255.0 4）此链路 desktop0 使用地址：172.16.1.75/255.255.255.0 5）此链路在系统重启之后依然保持正常状态 首先，到server0桌面目录下创建一个文本文件，用于我们打草稿。 查看命令模板 1[root@server0 ~]# man nmcli-examples 回车后进入到这个界面，输入 1/example 7 回车后就到了模板7这里，复制前三条命令道文门之前创建好的a.txt草稿文档里面 然后按照本题要求，修改这三条命令 12345678910改之前：$ nmcli con add type team con-name Team1 ifname Team1 config team1-master-json.conf$ nmcli con add type team-slave con-name Team1-slave1 ifname em1 master Team1$ nmcli con add type team-slave con-name Team1-slave2 ifname em2 master Team1改之后：nmcli con add type team con-name Team1 ifname Team1 config &apos;&#123;&quot;runner&quot;:&#123;&quot;name&quot;:&quot;activebackup&quot;&#125;&#125;&apos;nmcli con add type team-slave con-name Team1-slave1 ifname eth1 master Team1nmcli con add type team-slave con-name Team1-slave2 ifname eth2 master Team1 改完之后粘贴进终端即可 接下来修改Team1的ip地址 1234[root@server0 ~]# nmcli connection modify Team1 ipv4.addresses 172.16.1.65/24 ipv4.method manual[root@server0 ~]# nmcli connection up Team1[root@server0 ~]# teamdctl Team1 state[root@server0 ~]# ifconfig Team1 查看Team1的ip 注意这题要做在两台虚拟机上，desktop0的配置同理。两台虚拟机均配置完成后，二者的Team1的ip地址可以相互ping通。（练习环境可能ping不通） 6.配置 IPv6 地址在您的考试系统上配置接口 eth0使用下列 IPv6 地址 1）server0 上的地址应该是 2014:ac18::10a/64 2）desktop0 上的地址应该是 2014:ac18::11b/64 3）两个系统必须能与网络 2014:ac18/64 内的系统通信 4）地址必须在重启后依旧生效 5）两个系统必须保持当前的 IPv4 地址并能通信 1234567891011121314[server0]nmcli connection modify eth0 ipv6.addresses 2014:ac18::10a/64 ipv6.method manual connect.autoconnect yesnmcli con reloadnmcli con down eth0nmcli con up eth0ip add[desktop0]nmcli con modify eth0 ipv6.addresses 2014:ac18::11b/64 ipv6.method manual connection.autoconnect yesnmcli con reloadnmcli con down eth0nmcli con up eth0ip add 在server0上验证 12ping 172.25.0.10ping6 2014:ac18::11b ipv6解析 1234567ipv6地址长度：128 bits /64表示64位掩码，掩了128位的一半位数了都ipv4地址长度：32 bits /16表示16位掩码，也是掩了32位的一半了，写作255.255.0.0ipv6表示方法：X:X:X:X:X:X:X:X，其中每个X占16位例如2014:ac18::a就是2014:ac18:0:0:0:0:0:000a，其中2014的每个数字各占4位，用16进制表示为什么不是2014:ac18:0:0:0:0:0:a000呢？因为就跟在192.168.1.1中指的是192.168.001.001一样。 nmcli命令不能自动补全的解决办法 1yum install bash-completion -y 然后重启虚拟机即可 7.配置本地邮件服务在系统 server0 和 desktop0 上配置邮件服务，满足以下要求 1）这些系统不接收外部发送来的邮件 2）在这些系统上发送的任何邮件都会自动路由到 classroom.example.com 3）从这些系统上发送的邮件显示来自于 example.com 备注： 您可以通过发送邮件到本地用户’hal’来测试您的配置，系统 classroom.example.com 已经配置把此用户的邮件转到下列 URL http://classroom.example.com/cgi-bin/recevied_mail 查看题目要求，一个是做邮件转发，另外一个做邮件别名 首先，这题建议直接死记硬背需要修改的配置文件的行号：75 83 99 164 316 其次，修改配置文件不要忘了去掉备注符号#号。 在server0上： 123456789[root@server0 ~]# cd /etc/postfix/[root@server0 postfix]# cp -a main.cf main.cf.source[root@server0 ~]# vim /etc/postfix/main.cf #修改这个配置文件，修改以下几行75 myhostname = server0.example.com83 mydomain = example.com99 myorigin = $mydomain164 mydestination = &quot;&quot;316 relayhost = [classroom.example.com][root@server0 ~]# systemctl restart postfix.service 在desktop0上： 123456789[root@server0 ~]# cd /etc/postfix/[root@server0 postfix]# cp -a main.cf main.cf.source[root@desktop0 ~]# vim /etc/postfix/main.cf #修改这个配置文件，修改以下几行75 myhostname = desktop0.example.com83 mydomain = example.com99 myorigin = $mydomain164 mydestination = &quot;&quot;316 relayhost = [classroom.example.com][root@desktop0 ~]# systemctl restart postfix.service 验证，通过题目连接检查是否收到邮件。（练习环境可能收不到邮件） 1mailq 知识扩展 vim翻页快捷键，命令模式下： 1）向上翻页：Ctrl + f 或者PageUp键 2）向下翻页 : Ctrl + b 或者PageDown键]]></content>
      <categories>
        <category>linux</category>
        <category>linux-rhce</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rhce-02 第1-4题]]></title>
    <url>%2Frhce-02%2F</url>
    <content type="text"><![CDATA[rhce-02 第1-4题题目列表1.配置 SELinux 2.配置 SSH 访问 3.自定义用环境 4.配置端口转发 1.配置 SELinuxSELinux 必须在两个系统 server0 和 desktop0 中运行 Enforcing 模式 123456789[root@server0 ~]# vim /etc/selinux/config 设置为：SELINUX=enforcing[root@server0 ~]# cat /etc/selinux/config [root@server0 ~]# setenforce 1[root@server0 ~]# sestatus 注意两台虚拟机均要配置，看到如下图即可 2.配置 SSH 访问按以下要求配置 SSH 访问 1）用户能够从域 example.com 内的客户端通过 SSH 远程访问您的两个虚拟机系统 2）在域 my133t.org 内的客户端不能访问您的两个虚拟机 12345678[root@server0 ~]# firewall-cmd --permanent --add-service=sshsuccess[root@server0 ~]# firewall-cmd --permanent --add-rich-rule &apos;rule family=ipv4 source address=172.25.1.0/24 service name=ssh reject&apos;success[root@server0 ~]# firewall-cmd --reload success[root@server0 ~]# firewall-cmd --list-all[root@server0 ~]# ssh root@172.25.0.10 注意两台虚拟机均要进行配置，验证的时候先查看防火墙规则列表，然后互相ssh测试一下即可。 3.自定义用环境1）在系统 server0 和 desktop0 上创建自定义命令为 qstat 2）此定义命令将执行以下 命令： /bin/ps -Ao pid,tt,user,fname,rsz 3）此命令对系统中所有用户有效。 注意：以下命令中使用的是双箭头&gt;&gt;符号，不要敲错为单箭头。双箭头表示追加，单箭头表示覆盖，无论是单箭头还是双箭头，如果文件不存在，就创建文件。 123456[root@server0 ~]# echo &quot;alias qstat=&apos;/bin/ps -Ao pid,tt,user,fname,rsz&apos;&quot; &gt;&gt; /etc/bashrc[root@server0 ~]# bash[root@server0 ~]# which qstatalias qstat=&apos;/bin/ps -Ao pid,tt,user,fname,rsz&apos; /bin/ps[root@server0 ~]# 注意两台虚拟机均要进行配置，验证结果如下图： 4.配置端口转发在系统 server0 配置端口转发，要求如下 1）在 172.25.0.0/24 网络中的系统，访问 server0 的本地端口 5423 将被转发到 80 2）此设置必须永久有效 12345[root@server0 ~]# firewall-cmd --add-rich-rule &apos;rule family=ipv4 source address=172.25.0.0/24 forward-port port=5423 protocol=tcp to-port=80&apos; --permanentsuccess[root@server0 ~]# firewall-cmd --reloadsuccess[root@server0 ~]# firewall-cmd --list-all]]></content>
      <categories>
        <category>linux</category>
        <category>linux-rhce</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rhce-01 RHCE 考试注意事项]]></title>
    <url>%2Frhce-01%2F</url>
    <content type="text"><![CDATA[rhce-01 RHCE 考试注意事项注意事项 RHCE（红帽认证系统工程师）考试时间为下午，时长3小时，和RHCSA一样，总分300，达到210分即为合格。与上午考的RHCSA不同的是，下午考试需要配置的有二个虚拟机，一台作服务器、一台做客户端，千万不能配置反了！ 上午考的RHCSA偏基础，因此要求你修改主机名和root密码。而下午的RHCE考试中，root密码是在试题说明中已经给出了的，不需要你去修改密码，按照给出的root密码直接登录系统即可。另外，上午考的RHCSA需要你去手动修改主机名，而下午RHCE考试中一般已经设好主机名不再需要修改了，但是为了保险的话，建议再修改一下主机名。 上午的RHCSA考试中要求考生配置ip地址、网关、dns等信息，而下午考试中监考考官在考试开始前就已经给每台电脑都已经配置好了ip，但是却是DHCP方式获取的ip地址。考官会提醒你：“不建议手动修改ip地址，如果自己修改ip除了问题自己负责！”，因此，个人以为，保险起见还是不要去动ip了。当然也有人觉得将DHCP改为静态ip更好，只要改动时不出错，这样也是可以的。 yum源需要你手动配置，但不是正式题目，属于答题前的准备工作。 不同于RHCSA，下午考的RHCE难度较大，比较容易出错或者漏敲命令等，因此，做完所有题目之后一定要重启检查，如果时间充足，建议多重启几次，检查挂载项是否正常，检查Apache服务的网站是否能正常打开，如果上面两个部分检查没有问题，基本上就是稳过了。如果时间还有富余，那么可以将每道题都检查一遍。 下午的RHCE考试中，测试ssh远程连接的时候，ip一定不要敲错，因为尝试连接他人主机会被判0分。无理论是上午的RHCSA还是下午的RHCE考试，所有主机都在网络监控当中，任何作弊或者疑似作弊的流量都可能导致你被判0分。 按照考生亲身经历，考场中确实发生过考生网线接触不良的情况，所以考试时尽量不要抖腿或者跷二郎腿等，如果考试中发现自己无法访问教师机（classroom.example.com），可以请监考老师帮忙检查网线连通性。除了网线，还有电源线也是同理，同样也有考生考到一半电脑提示电量不足，这才发现自己的电源线是坏的，马上让监考老师帮忙换了一根。 另外要提醒的是，无论RHCSA还是RHCE考试，都允许上厕所，但是各只有一次机会。 考试环境1.物理机桌面系统(已经预装 Red Hat Enterprise Linux7.2 操作系统，但是你没有root权限) 请注意，因为考试系统是虚拟机，所以你需要使用桌面上的 VM Control Console 图标来访问虚拟机。您也可以通过 SSH 从桌面系统来访问虚拟机，但是在您还没有完成相关考试要求之前，是不能通过 SSH 访问虚拟机 2.虚拟机RHEL7两台： （1）server0.example.com：服务端，172.25.0.11/24 （2）desktop0.example.com：客户端，172.25.0.10/24 root密码均为：redhat ，系统ip地址均由DHCP提供。 您的系统是 DNS 域 example.com 的成员。所有在 DNS 域 example.com 中的系统都在172.25.0.0/24中，同样在这个子网中的系统都在 example.com DNS 域中。除非特别指明，所有要求配置的网络服务都必须能被 example.com 域中的系统访问。 classroom.example.com 提供了集中认证的服务域 EXAMPLE.COM。两个系统 server0 和 desktop0 已经预先配置成此域的客户端。两个系统防火墙默认都是打开的。在你认为适当的时侯可以关闭。 集中认证服务器classroom.example.com提供了yum软件仓库：http://classroom.example.com/content/rhel7.0/x86_64/dvd/ 不可信网络：my133.org(172.25.1.0/24)，有部分题目会有一些要求明确不允许服务被域 my133t.org 访问。 准备工作 正式答题前需要做一些准备工作，给server0和desktop0两台虚拟机配置好YUM仓库配置文件即可。注意是两台虚拟机都要配置。 123456789[root@server0 ~]# vim /etc/yum.repos.d/base.repo [root@server0 ~]# cat /etc/yum.repos.d/base.repo [rhce] name = EX300 gpgcheck = 0 baseurl = http://classroom.example.com/content/rhel7.0/x86_64/dvd/ [root@server0 ~]# yum makecache#请在 desktop 上做同样的操作！！！ 如下图，yum makecache未出错即表示配置成功。 另外，练习环境中需要设置一下默认开机启动进入图形化界面。 12systemctl set-default graphical.targetstartx 附录 题目总纲（共22题）1.配置 SELinux 2.配置 SSH 访问 3.自定义用环境 4.配置端口转发 5.配置链路聚合 6.配置 IPv6 地址 7.配置本地邮件服务 8.通过 SMB 共享目录 9.配置多用户 SMB 挂载 10.配置 NFS 服务 11.挂载一个 NFS 共享 12.实现一个 web 服务器 13.配置安全 web 服务 14.配置虚拟主机 15.配置 web 内容的访问 16.实现动态 web 内容 17.创建一个脚本 18.创建一个添加用户的脚本 19.配置 iscsI 服务端 20.配置 iscsI 的客户端 21.配置一个数据库 22.数据库查询 注意事项：虽然练习环境下题目是有22题，但是真实考试时，12~16是五选四，而17~18是二选一，所以考试时只有20道题。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-rhce</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rhcsa-06 附加练习题]]></title>
    <url>%2Frhcsa-06%2F</url>
    <content type="text"><![CDATA[rhcsa-06 附加练习题题目列表附加练习一：调整逻辑卷容量 附加练习二：调整逻辑卷容量 附加练习一：调整逻辑卷容量请按照以下要求调整本地逻辑卷home的容量： 1）调整后的逻辑卷及文件系统大小为1000MiB 2）调整后确保文件系统中已存在的内容不能被破坏 3）调整后的容量可能出现误差，只要在950MiB - 1050MiB之间都是允许的 4）调整后，保证其挂载目录不改变，文件系统完成 首先查看本地逻辑卷home的容量，确定是要扩容还是裁剪。 可以看到逻辑卷home的容量为445M，小于1000M，因此要扩容。格式为ext4格式，因此要使用resize2fs命令（如果是xfs文件系统，需要用xfs_growfs 替换resize2fs ）。 123456[root@system1 ~]# lvextend -L 1000M /dev/exam/home [root@system1 ~]# resize2fs /dev/exam/home 验证配置结果：[root@system1 ~]# lvs [root@system1 ~]# df -hT 附加练习二：调整逻辑卷容量请按照以下要求调整本地逻辑卷srv的容量： 1）调整后的逻辑卷及文件系统大小为400MiB 2）调整后确保文件系统中已存在的内容不能被破坏 3）调整后的容量可能出现误差，只要在350MiB - 440MiB之间都是允许的 4）调整后，保证其挂载目录不改变，文件系统完成 首先查看本地逻辑卷srv的容量，确定是要扩容还是裁剪。 由上图可以看到，当前逻辑卷srv的大小976M大于400M，因此要裁剪逻辑卷。由于其格式为ext4，因此使用的命令是resize2fs（如果是xfs文件系统，需要用xfs_growfs 替换resize2fs ）。 1234567[root@system1 ~]# umount /dev/exam/srv [root@system1 ~]# e2fsck -f /dev/exam/srv [root@system1 ~]# resize2fs /dev/exam/srv 400M[root@system1 ~]# resize2fs -f /dev/exam/srv 400M[root@system1 ~]# lvreduce -L 400M /dev/exam/srv Do you really want to reduce srv? [y/n]: y[root@system1 ~]# 将刚刚卸载掉的逻辑卷重新挂载上，挂载验证配置结果： 123[root@system1 ~]# mount -a[root@system1 ~]# lvs [root@system1 ~]# df -hT]]></content>
      <categories>
        <category>linux</category>
        <category>linux-rhcsa</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rhcsa-05 第12-17题]]></title>
    <url>%2Frhcsa-05%2F</url>
    <content type="text"><![CDATA[rhcsa-05 第12-17题题目列表12.创建一个归档 13.配置一个用户账户 14.添加一个swap分区 15.查找文件 16.查找一个字符串 17.创建一个逻辑卷 12.创建一个归档 打包文件，请对/etc/sysconfig目录进行打包并用bzip2压缩，生成的文件保存为/root/sysconfig.tar.bz2 12[root@server0 ~]# tar -jcf /root/sysconfig.tar.bz2 /etc/sysconfig[root@server0 ~]# file sysconfig.tar.bz2 扩展 123456考试可能要求gziptar -zcf /root/sysconfig.tar.gz /etc/sysconfig/file sysconfig.tar.gz帮助命令：man tar 13.配置一个用户账户请创建一个名为alex的用户，并满足以下要求： 1）用户id为3456 2）密码为glegunge 1234567[root@server0 ~]# useradd -u 3456 alex[root@server0 ~]# echo glegunge | passwd --stdin alex验证：[root@server0 ~]# id alexuid=3456(alex) gid=3456(alex) groups=3456(alex)[root@server0 ~]# 14.添加一个swap分区为系统新增加一个swap分区： 1）新建的swap分区容量为512MiB 2）重启系统后，新建的swap分区会自动激活 3）不能删除或者修改原有的swap分区 按下图进行配置 注意mkswap格式化/dev/sda5时别忘了玩了复制下UUID，如上图粘贴进/etc/fstab里面： 15.查找文件请把系统上拥有者为ira用户的所有文件，并将其拷贝到/root/findfiles目录中 123mkdir /root/findfilesfind / -user ira -exec cp -a &#123;&#125; /root/findfiles/ \;ls /root/findfiles/ 16.查找一个字符串 把/usr/share/dict/words文件中所有包含seismic字符串的行找到，并将这些行按照原始文件中的顺序存放到/root/wordlist中，/root/wordlist文件不能包含空行。 1grep seismic /usr/share/dict/words | grep -v ^$ &gt; /root/wordlist 17.创建一个逻辑卷请按下列要求创建一个新的逻辑卷： 1）创建一个名为datastore的卷组，卷组的PE尺寸为16MiB 2）逻辑卷的名字为database，所属卷组为datastore，该逻辑卷由50个PE组成 3）将新建的逻辑卷格式化为xfs文件系统，要求系统启动时，该逻辑卷能被自动挂载到/mnt/database目录。 参考下图进行配置：]]></content>
      <categories>
        <category>linux</category>
        <category>linux-rhcsa</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rhcsa-04 第6-11题]]></title>
    <url>%2Frhcsa-04%2F</url>
    <content type="text"><![CDATA[rhcsa-04 第6-11题题目列表6.配置一个cron计划任务 7.创建一个共享目录 8.安装内核的升级 9.绑定外部验证服务 10.配置autofs 11.配置NTP 6.配置一个cron计划任务对natasha用户建立计划任务，要求在本地时间的每天14：23执行以下命令：/bin/echo “rhcsa” 123crontab -e -u natashacrontab -l -u natasha23 14 * * * /bin/echo &quot;rhcsa&quot; 参考配置解析 12345678# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed 由于考试可能变体，因此注意不要只记住小时和分钟，还有后面的天（几号）、月（几月）、周（星期几）。例如 “23 14 12 5 *” 就是5月12日14:23的意思。 7.创建一个共享目录在/home目录下创建名为admins的子目录，并按以下要求设置权限： 1）/home/admins的所属组为adminuser 2）该目录对adminuser组的成员可读可执行可写，但对其他用户没有任何权限，但root不受限制 3）在/home/admins目录下所创建的文件的所属组自动被设置为adminuser 123456mkdir /home/adminschgrp adminuser /home/adminschmod g=rwx,o=--- /home/adminschmod g+s /home/adminsls -ld /home/admins 8.安装内核的升级请按下列要求更新系统的内核： 1）新内核的RPM包位于http://content.example.com/rhel7.0/x86_64/errata/Packages 2）系统重启后，默认以新内核启动系统，原始的内核将继续可用 首先在考试系统自带的浏览器打开上述链接，找到该内核，右键复制链接地址 安装内核，下面这个链接就是上面复制下来的内核链接 1yum install -y http://content.example.com/rhel7.0/x86_64/errata/Packages/kernel-3.10.0-123.1.2.el7.x86_64.rpm 验证： 1grub2-editenv list 也可以重启系统验证 9.绑定到外部验证服务 配置LDAP客户端，在classroom.example.com上已经部署了一台LDAP认证服务器，按以下要求将你的系统加入到该LDAP服务中，并使用Kerberos认证用户密码： 1）该LDAP认证服务的Base DN为：dc=example,dc=com 2）该LDAP认证服务的LDAP Server为：classroom.example.com 3）密码认证服务的Kerberos Realm为：EXAMPLE.COM 4）密码认证服务的Kerberos KDC为：classroom.example.com 5）密码认证服务的Kerberos Admin Server为：classroom.example.com 6）认证的会话连接需要使用TLS加密，加密所用证书请在此下载http://classroom.example.com/pub/example-ca.crt 1234yum -y install authconfig-gtk sssdauthconfig-gtk按下图配置 注意：做完这一题后，一定要先做第11题：配置NTP，然后再做第10题配置autofs。 10.配置autofs（请先完成第11题再回来做本题）按照下述要求配置autofs用来自动挂载LDAP用户的主目录： 1）classroom.example.com(172.25.254.254)通过NFS输出了/home/guests目录到您的系统。这个文件系统包括了用户ldapuser0的主目录，并且已经预先配置好了 2）ldapuser用户的主目录是classroom.example.com:/home/guests/ldapuser0 3）ldapuser0用户的主目录必须挂载到本地的/home/guests/ldapuser0目录下 4）用户对其主目录必须可写 5）NFS挂载它是要使用的NFS版本3 6）ldapiser0的用户密码是kerberos 首先，为了确认ntp配置正确且不存在其他异常情况，可以看看能否正常重启sssd服务，如果可以正常启动，则可以开始完成autofs的配置，否则先保证sssd服务可以正常启动。 1[root@server0 ~]# systemctl restart sssd 开始配置autofs 123456[root@server0 ~]# yum -y install autofs[root@server0 ~]# systemctl enable autofs[root@server0 ~]# vim /etc/auto.master将原来的那一行修改为：/home/guests /etc/auto.ldap 1234567891011[root@server0 ~]# cp -a /etc/auto.misc /etc/auto.ldap[root@server0 ~]# vim /etc/auto.ldap 将原来的内容修改为这一行：ldapuser0 -fstype=nfs,v3,rw classroom.example.com:/home/guests/ldapuser0#注意上面的nfs,v3,rw顺序不要更改，否则会出错！[root@server0 ~]# cat /etc/auto.ldap [root@server0 ~]# systemctl restart autofs[root@server0 ~]# 验证结果 12345[root@server0 ~]# su - ldapuser0[ldapuser0@server0 ~]$ pwd[ldapuser0@server0 ~]$ nfsstat -m[ldapuser0@server0 ~]$ exit[root@server0 ~]# 11.配置NTP配置您的系统时间与服务器classroom.example.com同步，要求系统重启后依然生效 12345678910vim /etc/chrony.conf将原本的server开头的四行注释掉，加入下面这一行server classroom.example.com iburstsystemctl enable chronydsystemctl restart chronydchronyc waitsync 看到返回值正确即可 exit]]></content>
      <categories>
        <category>linux</category>
        <category>linux-rhcsa</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rhcsa-03 第1-5题]]></title>
    <url>%2Frhcsa-03%2F</url>
    <content type="text"><![CDATA[rhcsa-03 第1-5题题目列表1.配置SElinux 2.配置yum软件仓库 3.调整逻辑卷大小 4.创建用户和用户组 5.配置文件/var/tmp/fstab的权限 1.配置SElinux请按下列要求设定系统： 1）SeLinux的工作模式为enforcing 2）要求系统重启后依然生效 1234[root@server0 ~]# vim /etc/selinux/config [root@server0 ~]# cat /etc/selinux/config [root@server0 ~]# setenforce 1[root@server0 ~]# sestatus 2.配置yum软件仓库配置你的本地默认YUM软件仓库，仓库地址为http://classroom.example.com/content/rhel7.0/x86_64/dvd 方法1（建议采用）： 12345678[root@server0 ~]# vim /etc/yum.repos.d/base.repo [root@server0 ~]# cat /etc/yum.repos.d/base.repo [rhcsa]name=EX200gpgcheck=0baseurl=http://classroom.example.com/content/rhel7.0/x86_64/dvd[root@server0 ~]# yum makecache [root@server0 ~]# 方法2： 1234yum-config-manager --add-repo=&quot;http://classroom.example.com/content/rhel7.0/x86_64/dvd&quot;cat /etc/yum.repos.d/base.repoyum repolistrpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release 3.调整逻辑卷大小请按照以下要求调整本地逻辑卷lvm1的容量： 1）调整后的逻辑卷及文件系统大小为770MiB 2）调整后确保文件系统中已存在的内容不能被破坏 3）调整后的容量可能出现误差，只要在730MiB - 805MiB之间都是允许的 4）调整后，保证其挂载目录不改变，文件系统完成 首先，要先看lvm1的格式、大小，判断是该裁剪还是该扩容。 1[root@server0 ~]# df -hT 如上图所示，lvm1文件系统的格式为xfs，大小为253M，需要扩容为770M。 1234[root@server0 ~]# lvextend -L 770M /dev/vg1/lvm1 [root@server0 ~]# xfs_growfs /dev/vg1/lvm1 注意：如果这里lvm1的文件系统的格式为xfs，那么使用的是xfs_growfs；如果格式为ext4，那么需要用resize2fs 验证配置结果 1234[root@server0 ~]# lvs[root@server0 ~]# df -hT如下图，逻辑卷大小和文件系统大小均已调整正确 考试时可能遇到需要裁剪逻辑卷的情况，可以参考附加题。 参考命令解析 12345678910lvs:查看lv（逻辑卷）信息vgs:查看vg（卷组）信息pvs:查看pv（物理卷）信息lvextend指令用于在线扩展逻辑卷的空间大小，而不中断应用程序对逻辑卷的访问。 -L 指定逻辑卷的大小，单位为“kKmMgGtT”字节 -l 指定逻辑卷的大小（LE数）resize2fs：调整ext2\ext3\ext4文件系统的大小xfs_growfs :调整xfs文件系统的大小 4.创建用户和用户组请按照以下要求创建用户、用户组： 1）新建一个名为adminuser的组，组id为40000 2）新建一个名为natasha的用户，并将adminuser作为其附属组 3）新建一个名为harry的用户，并将adminuser作为其附属组 4）新建一个名为sarah的用户，其不属于adminuser组，并将其shell设置为不可登陆shell 5）natasha、harry和sarah三个用户的密码均设置为glegunge 1234567groupadd -g 40000 adminuseruseradd -G adminuser natashauseradd -G adminuser harryuseradd -s /sbin/nologin sarahecho glegunge | passwd --stdin natashaecho glegunge | passwd --stdin harryecho glegunge | passwd --stdin sarah 参考命令解析 123456标准输入（STDIN）标准输出（STDOUT）标准错误输出（STDERR）敲错了如何删除用户：userdel -r xxx 5.配置文件/var/tmp/fstab的权限复制文件/etc/fstab到/var/tmp目录下，并按照以下要求配置/var/tmp/fstab文件的权限: 1）该文件的所属人为root 2）该文件的所属组为root 3）该文件对任何人均没有执行权限 4）用户natasha对该文件有读和写的权限 5）用户harry对该文件既不能读也不能写 6）所有其他用户（包括当前已有用户及未来创建的用户）对该文件都有读的权限 12345cp /etc/fstab /var/tmp/fstabchown root:root /var/tmp/fstabchmod a-x /var/tmp/fstabsetfacl -m u:natasha:rw,u:harry:---,o::r /var/tmp/fstabgetfacl /var/tmp/fstab 参考命令解析 12345678910111213setfacl命令可以用来细分linux下的文件权限。setfacl -help查看帮助，其参数-m指的是modifygetfacl获取文件访问控制列表chmod命令可以把文件权限分为u,g,o三个组，而setfacl可以对每一个文件或目录设置更精确的文件权限。chmod u代表用户 g代表组 o代表其他 a代表上述所有 setfacl -m, --modify-acl 更改文件的访问控制列表]]></content>
      <categories>
        <category>linux</category>
        <category>linux-rhcsa</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rhcsa-02 RHCSA-练习环境准备]]></title>
    <url>%2Frhcsa-02%2F</url>
    <content type="text"><![CDATA[RHCSA-练习环境准备说明考试时间2.5小时，请首先按一下要求配置考试系统： 123456重置密码为：redhat主机名设为：server0.example.comip地址设为：172.25.0.11掩码设置为：255.255.255.0网关设置为：172.25.254.254DNS设置为：172.25.254.254 这里域指的是：example.com 在这个域里面，有一台classroom.example.com是专门给考生下载资源的服务器。考生用的虚拟机主机名要求改为server0.example.com。 操作步骤1.重置密码此处省略，可以参考：https://zhongeagles.github.io/linux-02/ 命令行如下： 12345678mount -o remount,rw /sysrootchroot /sysrootpasswd rootredhatredhattouch /.autorelabelexitexit 2.设置主机名12hostnamectl set-hostname server0.example.com bash 3.修改网络配置 12[root@server0 ~]# nmcli connection modify eth0 ipv4.addresses &quot;172.25.0.11/24 172.25.254.254&quot; ipv4.method manual connection.autoconnect yes[root@server0 ~]# nmcli connection up eth0 验证配置 12[root@server0 ~]# ip add[root@server0 ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 参考命令 123456789101112查看eth0网卡设备nmcli device查看所有连接nmcli connection show启用和关闭连接nmcli connection up eth0nmcli connection down eth0查看网卡连接配置信息cat /etc/sysconfig/network-scripts/ifcfg-eth0 3.图形化界面： 123456789设置开机默认进入图形化界面[root@server0 ~]# systemctl set-default graphical.target 重启系统：init 6 由命令行界面进入到图形化界面init 5startx 附录 题目总纲（共17题）1.配置SElinux 2.配置yum软件仓库 3.调整逻辑卷大小 4.创建用户和用户组 5.配置文件/var/tmp/fstab的权限 6.配置一个cron计划任务 7.创建一个共享目录 8.安装内核的升级 9.绑定外部验证服务 10.配置autofs 11.配置NTP 12.创建一个归档 13.配置一个用户账户 14.添加一个swap分区 15.查找文件 16.查找一个字符串 17.创建一个逻辑卷 附加练习一：调整逻辑卷容量 附加练习二：调整逻辑卷容量 备注：附加练习题只在练习环境中有，考试时不会有附加题。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-rhcsa</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rhcsa-01 红帽认证]]></title>
    <url>%2Frhcsa-01%2F</url>
    <content type="text"><![CDATA[rhcsa-01 红帽认证概念解析 红帽认证是由红帽linux公司推出的，主要包括红帽认证系统管理员（RHCSA），红帽认证工程师（RHCE）和红帽认证架构师（RHCA）。是以实际操作能力为基础的测试项目，主要考察考生在实际操作系统中的实践能力。红帽培训和测试非常注重培养实际的动手实战能力！ RHCE认证 RHCSA是Red Hat Certified System Administrator 的简称，RHCE是Red Hat Certified Engineer的简称。RHCE认证展示了高级系统管理员应掌握的技能。一名红帽认证工程师除了要掌握红帽认证技师具备的 所有技能，还应具有配置网络服务和安全的能力，他/她应该可以决定公司网络上应该部署哪种服务以及 具体的部署方式。RHCE认证包括DNS、NFS、Samba、Sendmail、Postfix、Apache和关键安全功能的详细内容。始于1999年3月。红帽认证工程师（RHCE）和红帽认证系统管理员（RHCSA）是以实际操作能力为基础的测试项目，主要考察考生在现场系统中的实际能力。 总之，红帽考试认证是由红帽linux公司推出的，包括红帽管理员，红帽系统工程师和红帽资深架构师。红帽考试认证以实际上机操作为基础的测试考试项目，考察学生在实际电脑操作系统中的实践知识运用能力。红帽考试认证全是上机操作，所以有些公司招聘相对比较认可。 考试介绍红帽RHCE考试分上下午，考试没有笔试题，全部是上机实验。 上午考RHCSA（红帽认证系统管理员），主要考察考生对Linux系统命令的掌握情况； 下午考RHCE（红帽认证系统工程师），要求考生完成指定网络服务的搭建并确保服务的安全。 上午考试时间为2.5小时； 下午考试3小时。 两个考试各均满分300分，210分及格。一般考试后3个工作日左右会收到美国官网发来的成绩单邮件。（考试邮件域名请提前添加白名单，收到邮件后，如果通过会给一个唯一的红帽9位的号码，格式为180-xxx-xxx，以后如果有其他考试，请考前添加此号码，以便关联相关的认证，例如RHCA认证需要 RHCSA+RHCE 以及其他五门认证才可以颁发RHCA认证） 注意事项 考试完成尽量要把电脑重新启动一次，因为考官是在你做完之后，把所有的电脑重启一遍，来远程执行判分程序的。如果电脑重启开不了，网址配置错误的话，基本上考试也是过不了的。 下午的rhce考试题量较多，相对难度也大，题目之前的相关性也多，一道题也另一道相关联， 前面做不出来，后面没有办法向下进行。所以在平常的时间，一定多练习练习，将每一个命令都敲上10遍以上，总会熟悉的。同时也需要跟朋友或者同学好好交流，尽可能大家所遇到过的问题都解决掉。 （1）下午有二个虚拟机，一台作服务器、一台做客户端，千万不能配置反了！ （2）服务器的ip，dns，gateway还有yum源等必须设置正确，题意必须看清楚，就叫是配置一台，还是二台都需要配置 （3）对于每道题目都要有清析的思路，清楚linux重要的权限：文件系统，服务权限，防火墙，selinux等，以及出现权限报错后的处理方法。 （4）学会多利用各种帮助如man命令手册等去查看案例，这样能大大提高你的效率。 （5）最重要的还有时间，下午时间非常紧，不能太过犹豫不决浪费时间，主要是平时练习的时候要足够努力，要对命令行有足够的熟悉程度。 （6）考试期间可以上厕所，有需要的话千万不要憋着 （7）考试时尽量不要抖腿，脚放端正不要跷二郎腿等，因为万一踢掉了电源线或者网线，那是没地方哭的。 （8）考完尽量不要提前走 （9）记住要将更改过后的服务程序加入到开机启动项中，保证下一次启动的时候仍然会为用户提供服务。命令是systemctl enable 服务名称 （10）如何复制文本到虚拟机？ 考试的时候，在物理机上打开一个终端，然后利用ssh的方式连接虚拟机，这样就可以把物理机上的文本复制到虚拟机了，节约了大量考试时间。需要注意的是，此时的终端一般是不能打开图形化界面的，需要打开图形化界面请到虚拟机里面去。 （11）操作终端突然变大，不方便操作。 这种情况一般是不小心按到了F11键，再按一下F11键就终端就会还原到原来的大小。 （12）重启虚拟机卡死怎么办？ 通过管理机强制重启，还是不行就进入紧急救援模式，输入reboot -f 强制重启。 （13）root密码不能随便设置，要根据题目要求设置 （14）主机名每个人都是不同的，所以rhcsa域配置的时候，大家的域可能都不尽相同。考场的每个座位都有一个编号，编号跟IP和主机名相对，例如在6号座位，那么你的域可能就是group6.example.com，虚拟机主机名例如system1.group6.example.com，另外，不要忘了配置主机名！ （15）试的时候会发草稿纸，要带笔，可以记下一些东西，如密码、网段和域名等，免得多次翻看。（16）web页面上有倒数的时钟，系统的时钟也是准确的，考官会在最有15分钟、5分钟和1分钟时提醒你。 考试成绩 考试完后，考官会要求大家重启机器，离开考场，然后他会运行脚本进行评分；考完后一般在当天晚上会收到成绩，最晚三天之内收到成绩。你会收到来自redhat的两封email，一封是RedHat Certification Central发的，内容参考前面部分，如果通过，附件会有pdf版本的证书；另外一封是appsaba@redhat.com发的，感谢你参与了考试。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-rhcsa</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computer-07 C盘空间不足解决办法]]></title>
    <url>%2Fcomputer-07%2F</url>
    <content type="text"><![CDATA[computer-07 C盘空间不足解决办法C盘装满的原因：1、硬盘本身容量过小 2、装系统时给C盘分配容量太小导致 3、C盘作为系统盘，在使用电脑过程中会产生大量的系统缓存和垃圾文件，时间久了会把C盘填满。 为C盘瘦身方法：1、 使用系统自带磁盘管理扩大C盘容量（适用装系统时给C盘分配容量太小的情况） 这种方法很方便，但是有个要求，就是C盘和D盘物理上必须是同一块磁盘才可以，不然就无法增加C盘的容量，是在一块磁盘上的分区。比如C盘是120GB 的固态硬盘，而D盘则是1TB机械硬盘，所以C盘最大也只有120GB，不能借用D盘的空间来增大磁盘。 解决办法：通过windows自带的磁盘管理工具就可以解决 操作步骤： 鼠标右键开始菜单，选择磁盘管理 右键C盘，点击”压缩卷“，弹出窗口选择压缩卷，输入相应的容量，然后就会多出一个未分配的分区。 然后再右键点击C盘，选择扩展卷，输入未分配的分区容量，即可免格式化增加C盘容量。 （一次压缩卷，一次扩展卷） 1、 清理系统垃圾释放磁盘空间 安全卫士什么都存在一定的风险可能会导致系统崩溃，所以最好自己手动来清理这些缓存垃圾等等 （1）开始-&gt;程序-&gt;附件-&gt;系统工具-&gt;磁盘清理，选择C盘，确认后，选中所有的“口”再确认。 （2）系统工具-&gt;磁盘碎片整理程序（时间长，固态硬盘不需要进行磁盘碎片清理） （3）多次安装和反安装后，系统保留了很多无用的DLL 文件，应将其删除 （4）开始-&gt;运行-&gt;输入regedit，即打开注册表编辑器窗口 （5）打开这个LOCAL 的分支，在对话框右侧，其键值数据后面的括号中都有一个数字，如果数字为0，表示此DLL为垃圾文件，将其删除。 （6）将不要的程序卸载时，控制面板à添加/删除程序，选择确定删除，这个才是彻底的删除方法。 （碎片整理时，不要运行任何程序，最好也关闭一些自动运行的程序，不然整理起来会很缓慢，并且如果分区中有GHOST 的系统备份文件，千万不要对此盘进行整理，会使系统恢复出错） 3、 删除windows.old文件 低版本升级而来的高版本系统，或者执行自定义安装来安装系统的，没有在安装过程中格式化分区，以前的版本的windows中使用的文件存储在windows.old文件夹中，这个文件夹的文件是取决于自己的电脑的。新系统用一段时间，一两周，确定文件和设置都已经返回原位置，可以通过磁盘清理，删除这个Old文件了，这样可以安全的回收磁盘空间啦。 C盘-&gt;属性-&gt;磁盘清理-&gt;清理系统文件-&gt;勾选“以前的windows安装” 清理成功 这个操作不可撤销 4.关闭虚拟内存 5.调整为最佳设置 本篇到此结束]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>computer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computer-06 其它]]></title>
    <url>%2Fcomputer-06%2F</url>
    <content type="text"><![CDATA[computer-06 其它主板1.尺寸（长X宽，单位毫米）1)EATX加强型 305X330 拓展性最强 2)ATX标准型 305X244 3)M-ATX紧凑型 224X244 4)MINI-ITX迷你型 170X170 尺寸越大拓展性越好 2.芯片组1)分类 —AMD —INTER 2)芯片组决定了主板能够搭载的CPU主频 电池1.续航能力 2.充电速度 装系统 装系统时，有时候电脑明明装了两个硬盘，但是选择系统盘的时候却只显示了一个硬盘，可以在开机时进入到BIOS的SATA那里改为ACHI，然后重启电脑，再次装系统选择系统盘时，就可以看到电脑上所有硬盘了，想装在哪里就装在哪里。 注意事项1.家庭版的系统不适合我们学IT的，很鸡肋，建议买装好了专业版系统的电脑。 2.实体店坑太多防不胜防，而且百分百被宰或者被转型，建议在可以7天无理由退换的网上购买，如京东等。 3.京东被很多人称为“二手东”，究其原因，不乏有一些居心不良的顾客不停地买电脑用4天左右退换，稍微有瑕疵就重复退换，造成我们很有可能入手一个二手货。 —解决办法：跟客服沟通，先说明白自己绝对不会用二手货，电脑到货后一定会仔细检查外观并且用鲁大师等硬件检测工具对硬盘使用时间进行检测，若发现是二手货一概退换，直到入手的为新货为止。 4.查询出厂日期：win+r输入cmd，然后敲命令systeminfo查看系统信息 ，注意里面的BIOS Version参数 ，查看一下新买的电脑的BIOS版本是否为最近时间的，版本太老太旧的估计就是很旧的电脑改装的。 5.查询保修截止期：官网用S/N号（主机编号）查询，S/Y号一般在笔记本电脑的底部，下面以联想电脑查询保修截止期为例： 1.进入联想官网，选择”服务“选项 2.下拉，找到保修查询 3.输入主机编号即可查看保修截止期 本篇到此结束]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>computer</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computer-05 硬盘]]></title>
    <url>%2Fcomputer-05%2F</url>
    <content type="text"><![CDATA[computer-05 硬盘概念解析 硬盘是电脑主要的存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成。碟片外覆盖有铁磁性材料。 硬盘分类 硬盘有固态硬盘（SSD 盘，新式硬盘内有sata固态、m.2固态、pci-e固态，而m.2固态又有nvme的m.2和sata的m.2）、机械硬盘（HDD 传统硬盘内有3.5寸、2.5寸的，还有5400转和7200转）、混合硬盘（HHD 一块基于传统机械硬盘诞生出来的新硬盘）。SSD采用闪存颗粒来存储，HDD采用磁性碟片来存储，混合硬盘(HHD: Hybrid Hard Disk)是把磁性硬盘和闪存集成到一起的一种硬盘。绝大多数硬盘都是固定硬盘，被永久性地密封固定在硬盘驱动器中。 参数解析1.电脑处理信息的机制（如下图） —键盘鼠标输入信息到CPU —CPU处理成电脑明白的语言，告诉内存我需要XX —内存告诉硬盘我需要XX —硬盘将XX给内存，内存将XX给CPU —CPU将XX换成人类能识别的信息显示出来 2.硬盘分类 —机械硬盘 写速度70-100 —混合硬盘 读写速度100-150 (商家搞噱头的，不建议购买) —固态硬盘 读写速度500-3000 3.性能参数 1)读写速度对应开机速度: —100 MB/S 开机50秒 —150 MB/S 开机40秒 —500 MB/S 开机5秒 2)硬盘大小容量 3)接口 —SATA3 串口接口的读写速度理论极限750MB/S —PCIE3.0X4J接口的读写速度理论极限4GB/S 4)不同硬盘特点 —机械硬盘里面装着磁盘和磁头，工作噪音较大 —固态硬盘里面只有芯片组 —混合硬盘虽然比固态便宜，比机械快一丁点，但是还是太慢，购买混合硬盘是非常吃亏的 5)建议用固态硬盘做系统盘，机械硬盘储存文件以及做各个软件、游戏的安装路径。 实例解析 我们平时用电脑，所有的文件都存在硬盘里，需要的时候再从硬盘里拿出来用。其中，传统的机械硬盘长这样： 个人推荐固态硬盘（SSD），采用闪存作为存储介质，读取速度相对机械硬盘更快，而且有低功耗、无噪音、抗震动、低热量、体积小、工作温度范围大等优点。不过，SSD固态硬盘一般都比机械硬盘贵，所以小伙伴们还是要按需选购为妙。如果你的目标是一台轻巧便携、开机速度又快的超极本，建议选择固态硬盘版本。 本篇到此结束]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>computer</tag>
        <tag>硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computer-04 内存]]></title>
    <url>%2Fcomputer-04%2F</url>
    <content type="text"><![CDATA[computer-04 内存概念解析 内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。内存(Memory)也被称为内存储器，其作用是用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。只要计算机在运行中，CPU就会把需要运算的数据调到内存中进行运算，当运算完成后CPU再将结果传送出来，内存的运行也决定了计算机的稳定运行。 参数分析1）内存种类建议淘汰： DDR1 DDR2 建议使用（主流）： DDR3 DDR4 2)内存容量8G适中 两条4G内存条比一条8G好 3)内存频率（数值越高性能越强）1600mhz 2400mhz 3000mhz 不必过分追求这个数值 4)内存选购DDR3 1600 1866 DDR4 2133 2400 5)内存与主板的兼容—DDR4兼容主板： H170/270 B150/250 Z170/270 C232/236 X99 —其他都是插DDR3内存的 实例解析 内存是是与CPU进行沟通的桥梁，所有的程序软件都是在内存里运行的，所以内存的性能对电脑的效率影响非常大。 举个栗子 图中的内存条是台式机16G内存DDR4 2400MHz，其中我们要关注三个据：“16G”、“DDR4”和“2400MHz”。 “16G”代表容量，作为与CPU沟通的桥梁，当然是越宽越好，所以容量越大越好。 “DDR4”代表这是第4代产品，比第3代更好，另外“2400Mhz”代表主频率，频率越高越好。 本篇到此结束]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>computer</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computer-03 显存]]></title>
    <url>%2Fcomputer-03%2F</url>
    <content type="text"><![CDATA[computer-03 显存概念解析 显存，也被叫做帧缓存，它的作用是用来存储显卡芯片处理过或者即将提取的渲染数据。如同计算机的内存一样，显存是用来存储要处理的图形信息的部件。 显存，全称“显存内存”与运行内存类似，有大有小，大家都知道，显卡是负责繁重的图形渲染工作的，那么渲染完呢，你根本不知道它渲染了小哥哥还是小姐姐，还是要送到显示器才能观看啊，因此可以理解为显存是另一辆车（显存）把图像“运送”到显示器。在其他条件不变的情况下，显存越大，一次“运送”的图像越多，游戏性能（主要体现在帧数上）也就相对高一些。 查看显存1.打开任务管理器，切换到详细信息界面 2.点击左上角的“性能”选项卡，下拉，找到并点击GPU0或者GPU1，此时右上角可以看到我们的显卡型号。 GPU：图形处理器（英语：Graphics Processing Unit，缩写：GPU） 3.点击GPU1，对NVDIA的那个GPU进行查看，如下图，我的显存容量为2GB。 实例解析 一个1060 3GB和一个1060 6GB显卡，虽然显示核心基本相同，但是显存相差一倍，多了这3GB显存吃鸡可以特效全开60帧哦~所以，大家在选购电脑时可以留意下显存大小哦。 本篇到此结束]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>computer</tag>
        <tag>显存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computer-02 显卡]]></title>
    <url>%2Fcomputer-02%2F</url>
    <content type="text"><![CDATA[computer-02 显卡 显卡（英语：Video card、Display card、Graphics card、Video adapter），是个人计算机最基本组成部分之一，用途是将计算机系统所需要的显示信息进行转换驱动显示器，并向显示器提供逐行或隔行扫描信号，控制显示器的正确显示，是连接显示器和个人计算机主板的重要组件，是“人机对话”的重要设备之一。 基础概念1) 常识—全称：显示适配器/显示接口卡 —功能：进行数模信号转换，输出显示图形 —显卡决定了玩游戏的画质和流畅度 2)分类—集成显卡 十几年前的技术 只能显示最基本的图像 —核心显卡 把显示核心做进CPU的技术 适合魂斗罗等小游戏 —独立显卡 单独出来、自成一体，好的独显能玩大游戏 3)参数LOGO PCB 外形 尺寸 风扇个数 默认频率 接口 电容 信仰 4)公版与非公版—公版 原汁原味百分百原装 —非公版 在公版基础上改装，性能比公版好10% ##### 2.显示核心部分1)显卡频率—显示核心工作的速度 2)流处理器—类似CPU核心数 3.显存 （显示频率）1)显卡显存处理速度可以超频但意义不是很大 2)显存类型 GDDR5 HBM2 3)显存容量 越高的分辨率需要越高的显存容量 4)显存位宽&amp;显存带宽 小位宽：magnet:?xt=1 大位宽：magnet:?xt=123456789 显存带宽：显存与显示核心之间通道的宽度 5)补充： —光栅单元 光影效果 —纹理单元 条纹细节清晰度 显卡知识集显、核显、独显、双显有什么区别？ 显卡负责显示器画面显示，电脑没有显卡，就不会有画面显示。显卡，又叫做显示接口卡或显示适配器，是计算机最基本、最重要、也是必备的配件之一。 集显（部分老式主板才有，如今已经淘汰）位置：集成在主板上的显卡， 优点：价格低，兼容性好和升级成本低 缺点：没有独立的显存，要占用系统内存，使CPU可用的物理内存减少，在与系统交互的过程中总是占用总线周期和CPU 周期，所以会在某些方面影响电脑性能。 升级：必须更新主板BIOS 核显（核心显卡）位置：集成在CPU当中，CPU自带，其实目前的智能手机也都是CPU内置GPU，也就是核心显卡方案 优点：性能好，选择一款内置好一些的核心显卡即可满足不少网络游戏需求，无需搭配独立显卡即可满足不少网络游戏需求。 ​ 低能耗，价格相对便宜 独立显卡位置：需要插在主板的PCI 显卡插槽 优点：高性价比，配备单独的散热风扇，所以性能要比集显和核显出众 ​ 本身带有独立显存，不会占用系统内存 ​ 独显可在电脑内部组成多显卡，拥有强大的图像处理能力。 缺点：贵 升级：一般都是购买显存更大的显卡，升级方便但成本高，更适合主流游戏用户推荐。 双显卡一台电脑上包含2块显卡 比如：CPU 既内置了核心显卡，用户又单独购买了独立显卡，这样的电脑就配置了双显卡，目前大多数独显电脑其实都配置了双显卡，电脑会根据需求，智能进行切换使用。 双独显（双卡交火） 核显，独显（混合交火） 显卡选购建议：多数用户的电脑都是配置了 核显+独显双显卡 实例解析 显卡这里我们主要说 NVIDIA（俗称 N 卡），以NVIDIA GTX 1080Ti 11G举例。GTX代表它是“发烧级”，此外还有GT“入门级”。最重要的数据是最后的“11G”，它代表显卡的显存，显存越大，显卡性能越好。 本篇到此结束]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>computer</tag>
        <tag>显卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computer-01 CPU]]></title>
    <url>%2Fcomputer-01%2F</url>
    <content type="text"><![CDATA[computer-01 CPU初识CPU 对于需要购买笔记本电脑的朋友们来说，不同的用途，对电脑CPU的要求也是不一样的。需要玩吃鸡等大型游戏、视频处理剪辑、大数据分析的同学适合选择标压处理器。对性能要求不高，但是经常需要经常出差，背着笔记本到处跑，想要长时间续航，你就需要低压CPU产品。 CPU又叫中央处理器，相当于我们的大脑，是计算机的运算核心。如今的CPU两大阵营，也就是Intel和AMD，几乎垄断了CPU市场。其中以Intel更为主流，现在我们来了解一下笔记本上的Intel处理器。 举个栗子： 如上图，分析如下： 品牌标识符：i7代表高端，i3代表入门，i5代表主流 代际：6920中的“6”代表着第6代，这个数字当然是越大越好，“9”代表它的市场定位，同样是越大越好，后面两位数字往往表示同型号处理器的不同的升级版本。 字母后缀： U——低电压 省电 M——移动版，笔记本专用 H——不能拆卸 产品线后缀： Q——四核 K——无锁，可以倍频超频，玩大型游戏 X——极致性能 CPU具体参数以下排序越靠前越优先考虑：1)主频—主频越高，单位时间内处理数据越多。（主频单位：Ghz） —主频越高，发热越大。主频越大越好，但需要强大的散热功能与之对应。 —主频超过临界值后卡顿感才会消失。（临界值指玩某游戏需要的最大主频） —睿频，英特尔酷睿i5/i7处理器独有技术，（频率大小根据任务多少变化）。 2)核心—核心数越多，能同时处理的任务数就越多。 —核心数越多，发热越大。 —对于渲染建模（3D建造虚拟模型），核心多有优势。 —核心与线程，例如4C8T指4核8线程，模拟了比4C4T多一倍的核心数。 （线程是核心的2倍指超线程或线程分裂，性能提升一倍） 3)针脚—针脚传输性能要跟上 —可以由针脚看出它是哪个时代的CPU 4)架构—越新的架构带着越新的技术，旧架构相当于小水管，新架构即相当于大铁管。 5)缓存—缓存位于CPU内部，其读写速度是内存的不知道多少倍。 —CPU要处理的数据来自内存，如果CPU内没有缓存，那么CPU就不得不一直 等内存将数据发过来，导致电脑间歇性卡死。 —分级有：1级越快，2级次之，3级最慢。 6)制程—制程（目前均限制在14NM纳米数下）越小越好，耗电越少发热越小，体积越小。 举例：1.英特尔的I7-9980K—I7 厂商分级，I7为高端，可参考CPU天梯图 —第一个9 第九代 产品 —第二个9 性能排名 表示它在其性能梯队中最强 —50 区分用途 商业、民用、定制等 — K 特殊能力 K代表可以超频（相对的，U代表低电压，Y代表超低电压 ​ M代表移动版，X代表它是旗舰CPU也能超频，但一般不买） ​ 总之，K是最好的。 2.AMD的R7-1800XAMD全系列CPU都能超频，都能睿频 —R7 厂商分级 —1 —8 性能排名 —00 区分用途 —X 说明带满血XFR技术，只要散热到位，即可额外自动超频 CPU天梯图（2019年2月份） 实例参考1、型号中带Y的处理器 这个系列是性能较弱的，也就是名字中含有Y的处理器，这一系列采用的是超低电压的设计，使用场景一般为平板电脑，如i7-7Y75，虽然这是一款带有i7头衔的处理器，但是性能却比普通的i7弱很多，但是低电压带来性能低的同时，也带来了低功耗，满足了平板电脑所需较长的续航。 2、带有字母U 这个系列也是低电压系列，但是应用场景一般为超薄本，笔记本的运算需求较高一些，但是也要满足续航，因此这是较为折中的处理器系列，如I5-8250U，处于第8代I5处理器，性能比超低压CPU强上一大截，但是玩大型游戏仍然不是他们的强项，日常办公还是足够的。 3、带有字母H 这一系列CPU属于高性能的标压CPU，通常应用在游戏本上，如I5-8300H,I7-8750H等，图中就是拥有6核心12线程的强大的I7-8750H处理器。 4、带有字母Q 同样情况下末尾带有Q的则为4核处理器，Q一般和H同时出现，如7700HQ，7300HQ。 5、带有字母M 当然标压笔记本CPU也是有可拆卸的版本，一般字母代号为M，如3230M，3630QM等，是支持拆机更换处理器的。 6、带有字母K的处理器 带K的含义是不锁倍频，意思就是CPU可以超速“行驶”，这一类处理器一般为台式机或者顶级游戏本使用，追求高性能的同时发热量也是很高的。 本篇到此结束]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>computer</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-14 互联网信息服务IIS]]></title>
    <url>%2Fwindows-14%2F</url>
    <content type="text"><![CDATA[windows-运维-14 互联网信息服务IIS安装IIS IIS8.0是windows Server2012自带的服务器管理系统，和以往不同，IIS8.0安装和操作都比较简单，界面很简洁，安装也很迅速。 1、打开虚拟机桌面左下角的“服务器管理器”。在Windows 2012系统上，这个按钮一般位于左下角的第一个位置。我这边演示用的是Windows 2012 R2版，这套系统新增了白色的开始图标，因此“服务器管理器”按钮移到了第二个位置。 2、点击“添加角色和功能”，在弹出的安装对话框中，再点击两次“下一步”。 3、进入服务器角色安装对话框，勾选“Web服务器(IIS)”这项，会弹出提示询问你是否添加功能，我们点击“添加功能”按钮表示同意添加。然后点击三次“下一步”。直接点击“下一步”表示我们将采用系统提供的默认安装方式，有兴趣的朋友也可以仔细看一下这些默认步骤上的说明文字，以更一步增进对IIS系统的了解。 4、接下来，为Web服务器(IIS)选择要安装的角色服务。这里咱们由于后面要搭建wordpress网站和discuz论坛，所以咱们要选三样东西打钩，另外建议您展开第5项“应用程序开发”，安装常用的应用程序工具，如ASP/ASP.NET 3.5/ASP.NET 4.5等。在勾选的时候，系统会询问您是否安装所需的功能，我们一律点击“添加功能”。选择完毕后的示意图如下： 5、最后一步，我们选择“自动重新启动目标服务器”，然后点击“安装”按钮，等待系统完成安装。 注意，不同于IIS 6.0以前的版本，从IIS 7.0开始，安装Windows组件不再通过光盘或i386文件，而是直接从网络上下载。所以安装前请确保已经设置好了网络，并且可以正常浏览网页。 IIS8.0的Web Server 设置 ASP程序解析 （1）我们打算将ASP 应用程序拷贝到C 盘，当然，其他也可。所以要新建一个目录作为安装解析目录:c:\netexam （2）桌面左下角windows—〉往下翻一页—〉计算机管理—〉“服务和应用程序”，可以看 到 “Internet 信息服务” ，双击； （3）网站上右键—“添加网站” （4）按图中的内容填写吧，其中IP 地址，也可以填写你自己机器的真实的 IP 地址：127.0.0.1 确定后，会自动退出此窗口。 （5）选择，刚才建立的网站 netexam 显示： 双击 ASP 显示：将启用“父路径”右边的FALSE 改为True：如果你的网站程序使用了父路径，如../conn/db.asp这样的，..表示上层目录，就一定要开启父路径，否则系统不能正常识别..父路径，网页就无法正常显示。最后别忘了保存设置应用。 （6）点击：“默认文档” 查看可用的网页默认文档，例如：index.asp 也可以是default.aspx 或者等等 -————————————————————————————————- 编辑权限 （1）选择右上角的“编辑权限” 打开安全选项卡，选择【编辑】 选择【添加】 选 择【高级】 选择【立即查找】 找到 以 IIS_IUSERS 开头的名称；并选择它，一路确定从而退出刚刚打开的这些窗口。 赋予相应的权限： 点击确定即可 重新启动网站 可以看到安装解析目录:c:\netexam下多了一个配置文件 浏览器打开127.0.0.1访问本地网站，如下图是默认浏览页面。 我们到iis服务网站根目录下C:\inetpub\wwwroot，添加一个文件index.txt，用记事本在里面写上helloworld，然后将index.txt改为index.html，再次重启网站。 浏览器打开127.0.0.1访问本地网站，如下图是我们刚刚设置好的index.html里面的内容helloworld。 关机，保存快照。后面原计划是要在IIS服务的基础上配置mysql+php环境、搭建discuz论坛和wordpress博客的，但是由于网上下载winserver 2012 r2镜像装的虚拟机，总要安装许多补丁，而且在安装php的过程中容易出错，vc扩展也直接报错而安装不了，所以这里后续文章就不在虚拟机里面搭建discuz论坛和wordpress博客了，后面直接搭在腾讯云服务器即可。购买服务器装好windows server 2012 R2系统后，可以采用宝塔控制面板一键部署好环境，快速搭建discuz论坛和wordpress博客等，非常方便。如果不想一键部署，而是想要自己一步一步配置环境部署网站的话，可以参考腾讯云上的动态网站搭建教程，网址如下： https://cloud.tencent.com/developer/edu/learn-1064/1241 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-13 windows使用linux命令]]></title>
    <url>%2Fwindows-13%2F</url>
    <content type="text"><![CDATA[windows-运维-13 windows使用linux命令 Windows、Linux看似死敌一对，但其实微软对于开源实业还是相当支持的，Windows 10系统内就首次内置了一个Linux子系统(Windows Subsystem for Linux/WSL)，允许开发者模拟Linux环境，而且有需要的可以直接从Windows应用商店下载SUSE、Ubuntu。 如果你安装了Build 16237或者更新预览版的Windows Server 2016，就可以打开windows server通往Linux的大门了，本质上就是个Linux虚拟机，可以执行一般任务，比如SSHD、MySQL等等，但不能持续运行Linux后台服务。 注意：要在windows上用linux命令，用cmd不行，要用powershell。当然，在cmd里面敲powershell命令切换到powershell命令行模式后也是可以的。 现在在物理机上做实验，windows10操作系统中，打开控制面板，找到程序和功能 点击启用或关闭windows功能 勾选上适用于linux的windows子系统，确定 重启电脑，然后就可以使用linux命令了。 结果验证，如下图： 用cmd测试一下： 在cmd敲linux命令会报错，但是敲完powershell切换成powershell命令行模式后就不会报错了。 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-12 Windows 防火墙]]></title>
    <url>%2Fwindows-12%2F</url>
    <content type="text"><![CDATA[windows-运维-12 Windows 防火墙概念解析​ 防火墙(英文：firewall)是一项协助确保信息安全的设备或者软件，会依照特定的规则，允许或是限制传 输的数据通过。防火墙可以是一台专属的硬件也可以是架设在一般硬件上的一套软件。Windows防火墙 顾名思义就是在Windows操作系统中系统自带的软件防火墙。 ​ Windows防火墙是一个基于主机的准状态防火墙，防火墙安装在被保护的主机 上。它用来保护Windows Server单台服务器,而不是保护网络中其它的主机或者 设备。状态防火墙和传统的包过滤防火墙有明显的区别，使用状态防火墙的一个 典型特征是：被保护的计算机可以主动访问其它计算机，而如果没有例外，其它 计算机无法访问被保护的计算机。 常规防火墙的作用1、过滤进出网络的数据包 2、管理进出网络的访问行为 3、封堵某些禁止访问的行为 4、记录通过防火墙的信息内容和活动 5、对网络攻击进行检测和报警 6、过滤大部分的危险端口 7、设置严格的外向内的状态过滤规则 8、抵挡大部分的拒绝服务攻击 9、加强访问控制能力 防火墙的分类1、按照用户终端：分为企业防火墙和个人防火墙 2、按照实现方法：分为软件防火墙和硬件防火墙 3、检测技术——包过滤、状态检测防火墙 4、固定防火墙和移动防火墙 5、按照部署方式，分为单机防火墙和网络防火墙 防火墙配置 Windows防火墙这个在个人PC上的鸡肋，在服务器安全方面却能起到很大的作用。 以下介绍如何在 Windows Server 2008 R2 中开启防火墙，建立白名单，并允许回显 请求（不禁用Ping）。 1、打开虚拟机，开启Windows防火墙 1）打开 【控制面板】 2）依次进入 【系统和安全】 - 【Windows 防火墙】 3）左侧，点击进入 【打开或关闭 Windows 防火墙】 4）在专用网络、公用网络里 都 点选【启用 Windows 防火墙】 2、添加一个端口的白名单 开启防火墙后，除了系统默认开启的端口，其余端口均被拦截了，如果需要对外开放，就需要添加端口白名单。 1）在控制面板的【Windows 防火墙】项下，进入【高级设置】 2）【入站规则】 右侧 【新建规则】 3）点选【端口】 下一步 4）点选 TCP ，这里以 MySQL 添加远程端口白名单为例 ，端口为 3306 5）接下来为默认的下一步、下一步，名称 我这里填写testmysql 6）完成。 3、设置“开启Ping响应（回显请求）” 开启防火墙后，系统默认会禁止Ping响应，Ping服务器会返回“请求超时”，让我 们无法判断服务器的网络状态。 所以大多数情况下，我们都需要开启Ping响应。 在开启ping响应前，我们先用物理机ping一下服务器： 服务器ip：192.168.141.74 物理机ping服务器结果： 接下来开启Ping响应 【入站规则】 中 找到 “文件和打印机共享(回显请求 - ICMPv4-In)”，我用的 IPv4，故配置此项，如果您用的IPv6，配置“文件和打印机共享(回显请求 - ICMPv6-In)” 双击规则进入编辑状态勾选【已启用】 确定退出 测试完毕，Ping 之后能收到回显请求了。 4、添加一个程序的白名单 有些程序使用的端口不固定，我们无法通过设置端口白名单来放行，这个时候就可 以使用程序白名单来解决问题。 以使用程序白名单来解决问题： 1）【入站规则】 右侧 【新建规则】 2）点选【程序】 下一步 3）指定 程序路径，这里以微软FTP 添加白名单为例，路径为 %SystemRoot% \System32\inetsrv\InetMgr.exe 4）接下来为默认的下一步、下一步，名称 我这里填写testftp 5）完成。 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-11 windows小技巧]]></title>
    <url>%2Fwindows-11%2F</url>
    <content type="text"><![CDATA[windows-运维-11 windows小技巧cmd用不了ping命令在cmd中用PING命令时,出现’Ping’ 不是内部或外部命令，也不是可运行的程序或批处理文件。 先了解一下内容： 1、可执行文件、命令文件和批处理文件 以.exe或者.com或者.bat为扩展名的文件分别被称为可执行文件、命令文件和批处理文件。 2、外部命令和内部命令 DOS命令可以分为外部命令和内部命令，内部命令包含在一个名为command.com的文件，在系统启动时候驻留在内存中。外部命令是保存在c:\windows\system32中的一些可以直接有效的文件的文件，包括.exe文件，.com文件，.bat文件。 系统变量中path的作用是引导系统从path中设置的根目录开始，查找匹配的路径，并组成新的路径，从而执行文件。如果path变量设置不当就会使得系统无法查找到相关文件从而出错。系统默认的系统变量path的值是c:\windows\system32。也就是说用户在命令提示符后输入文件名后，系统会自动到c:\windows\system32的目录下去寻找文件，而不管用户在哪个命令提示符后输入。如果path的值中不包含c:\windows\system32,那么用户只能在命令提示符为c:\windows\system32后输入ping，才能执行ping文件。而你在任意一个命令提示符，比如在我的电脑上，在c:\Documents and Settings\lsr后输入ping，这是系统会认为ping这个文件位于c:\Documents and Settings\lsr目录下的。但是ping文件其实是位于c:\windows\system32目录下，这时候就出现找不到文件的错误。 解决方法： 右键单击我的电脑-&gt;属性-&gt;高级-&gt;环境变量-&gt;在系统变量中选中名字为path或者是PATH-&gt;编辑-&gt;在变量值中添加上c:\windows\system32 接下来就可以用ping命令了 powershell无法与cmd互相切换在系统变量里添加这两个路径后，就可以让powershell无法与cmd互相切换了 12C:\Windows\system32\C:\Windows\System32\WindowsPowerShell\v1.0\ 接下来就可以在powershell下输入cmd回车切换到cmd 也可以在cmd下输入powershell回车切换到powershell windows经常开启共享的话，可以用nsa免疫工具检查电脑防黑 进入本地组策略编辑器的方法win+r输入如下 1Gpedit.msc 连接到虚拟机的C盘的方法win+r输入如下，其中是虚拟机的ip 1\\192.168.16.30\c$ 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-10 文件和存储服务]]></title>
    <url>%2Fwindows-10%2F</url>
    <content type="text"><![CDATA[windows-运维-10 文件和存储服务​ Windows Server 2012中对于文件和存储的服务有了很大的改进，其中引入了SMB 2.2、存储池、重复数据删除、iSCSI Target等技术，使得Windows Server 2012能够提供更好的文件存储服务。使得Windows Server 2012 不仅可以作为文件共享服务器，还可以作为NFS存储和IP-SAN存储。 windows存储池这台服务器上总共安装了2块磁盘，一块磁盘是系统盘，另外一块磁盘作为数据盘（此磁盘没有经过初始化）。 打开虚拟机，右键开始菜单-&gt;磁盘管理，可以看到我们新增的磁盘未分配，所以在文件资源管理器里面也仅仅只有C盘而没有D盘。 添加文件和存储服务，如下图，之后正常安装即可 进入文件和存储服务 选择存储池-&gt;任务-&gt;重新扫描存储，然后新的磁盘就会显示出来了 新建存储池 起个名字，一直下一步即可。我这里新建了一个叫feng的存储池 新建虚拟磁盘 给虚拟磁盘起个名字叫vdisk1 对应关系 simple：普通的磁盘 mirrors：RAID-1 parity：RAID-5 我们这里选择simple就好 容量设置成5G，点击下一步，创建，即可完成。 虚拟磁盘创建完成，关闭新建虚拟磁盘向导后，自动弹出新建卷向导，或者你也可以右键vdisk1新建卷，接下来使用虚拟磁盘的空间新建卷。 新建一个3G的卷 选择文件系统设置 启用重复数据删除 确认没有问题之后点创建 最后在卷里面看见我们创建的卷 ISCSI前言：此为搭建共享磁盘的一种方式，并非唯一 目的：为IIS准备共享磁盘 操作系统：Windows Server 2012 R2、Windows10 准备： 准备两台服务器，能够通过网络ping通 一台用作磁盘服务器(安装Windows Server 2012，提供iSCSI磁盘服务) 一台用作客户机(安装Windows10，用于访问磁盘服务器提供的iSCSI磁盘服务）可以用咱们的物理机作为客户机 客户机可以使用多台，当设置多台客户机时，需要在磁盘服务器上增加多个访问服务器 相关知识： iSCSI，SCSI 术语： 访问服务器，访问目标，iSCSI目标，客户机，四个词为同一概念，即客户机 一、磁盘服务器上操作 1.安装iSCSI服务 1.1.打开服务器管理器&gt;&gt;添加角色和功能 1.2.基于角色或基于功能的安装 1.3.选择安装iSCSI服务的服务器，默认选择本机 1.4.选择iSCSI开头的两个选项和文件服务器 1.5.按需要选择功能，或者直接下一步 1.6.确认后安装 1.7.安装成功 2.创建iSCSI虚拟磁盘 2.1.打开服务器管理器&gt;&gt;文件和存储服务&gt;&gt;iSCSI&gt;&gt;任务&gt;&gt;新建iSCSI虚拟磁盘 2.2.选择服务器(默认本机），键入自定义路径（用于存放虚拟磁盘文件），也可以使用按卷选择 在C盘新建一个文件夹，自定义路径就写这个文件夹 2.3.填写虚拟磁盘名称，路径中可以看到是作为虚拟磁盘文件名的 2.4.设置磁盘大小及类型 2.5.新建iSCSI目标 2.6.填写目标名称 2.7.访问服务&gt;&gt;添加，访问服务器即客户机 这里使用ip的方式设置客户机，其他几种方式可以自己尝试一下，可以设置多个访问服务器 首先用cmd查看物理机ip，命令：ipconfig，选择和虚拟机同一网段那个ip，作为添加程序发起id。 2.8.启用身份验证，也可以不启用，直接下一步 确认后创建虚拟磁盘即可创建成功 二、在客户机上的操作打开iscsi发起程序 查看虚拟机ip： 将虚拟机ip作为目标，快速连接，然后会出来如下图的目标已连接。 右键开始菜单，打开磁盘管理，会自动跳出来一个窗口，让你初始化磁盘，这个Cinderella磁盘就是来自于虚拟机那边的共享磁盘。 现在可以看到，多出一块新的未分配的磁盘，大小2G正是我们之前创建的共享磁盘大小。 打开文件资源管理器，本来我电脑里只有这俩磁盘。 现在咱们把那块2G的新磁盘分配一下，右键新建简单卷，一直点击下一步即可 建好了就变成了新加卷 现在再次打开咱们的文件资源管理器 可以看到多了一个可以使用的新加卷。 到iscsi发起程序里，把之前连接好的断开连接 可以看到新加卷变成灰色，不可用了 然后，过了一会儿，那个新加卷就消失了，一切恢复原状。 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-09 更改计算机状态]]></title>
    <url>%2Fwindows-09%2F</url>
    <content type="text"><![CDATA[windows-运维-09 更改计算机状态更改计算机状态 若要在 Windows PowerShell 中重置计算机，请使用标准命令行工具或 WMI 类。 尽管你使用 Windows PowerShell 仅仅是为了运行该工具，但了解如何在 Windows PowerShell 中更改计算机的电源状态将阐明有关在 Windows PowerShell 中使用外部工具的一些重要详细信息。 锁定计算机使用标准可用工具直接锁定计算机的唯一方法是调用 user32.dll 中的 LockWorkstation() 函数： 1rundll32.exe user32.dll,LockWorkStation 此命令将立即锁定工作站。 它使用 rundll32.exe，后者运行 Windows DLL（并保存其库以便重复使用）以运行 user32.dll（Windows 管理函数的库）。 如果在启用了“快速用户切换”时锁定工作站（例如在 Windows XP 中），则计算机将显示用户登录屏幕，而不会启动当前用户的屏幕保护程序。 若要关闭终端服务器上的特定会话，请使用 tsshutdn.exe 命令行工具。 注销当前会话 可以使用多种不同的方法来注销本地系统上的会话。 最简单的方法是使用远程桌面/终端服务命令行工具 logoff.exe（若要了解有关详细信息，请在 Windows PowerShell 提示符处键入 logoff /?）。 若要注销当前活动会话，请键入 logoff 而不带参数。 你还可以使用具 shutdown.exe 工具及其 logoff 选项： 1shutdown.exe -l 第三个选项是使用 WMI。 Win32_OperatingSystem 类具有 Win32Shutdown 方法。 调用具有 0 标志的方法将启动注销： 1(Get-WmiObject -Class Win32_OperatingSystem -ComputerName .).Win32Shutdown(0) 若要了解有关详细信息和 Win32Shutdown 方法的其他功能，请参阅 MSDN 中的“Win32_OperatingSystem 类的 Win32Shutdown 方法”。 关闭或重启计算机 关闭和重启计算机通常是相同类型的任务。 关闭计算机的工具通常也可以重启计算机，反之亦然。 从 Windows PowerShell 重启计算机有两个直接的选项。 使用 Tsshutdn.exe 或 Shutdown.exe 及其相应参数。 你可以从 tsshutdn.exe /? 或 shutdown.exe /? 获取详细的使用情况信息。 也可以直接从 Windows PowerShell 执行关闭或重启操作。 若要关闭计算机，请使用 stop-computer 命令 1stop-computer 若要重启操作系统，请使用 restart-computer 命令 1restart-computer 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-08 执行文件和脚本]]></title>
    <url>%2Fwindows-08%2F</url>
    <content type="text"><![CDATA[windows-运维-08 执行文件和脚本执行文件和脚本 像运行可执行文件一样，Powershell运行文件和脚本，也必须使用绝对路径或者相对路径，或者要运行的文件必须定义在可受信任的环境变量中。 关于脚本脚本和批处理都属于伪可执行文件，它们只是包含了若干命令行解释器能够解释和执行的命令行代码。 执行批处理文件 批处理是扩展名为”.bat”的文本文件，它可以包含任何cmd控制台能够处理的命令。当批处理文件被打开，Cmd控制台会逐行执行每条命令。那Powershell能够直接执行批处理吗？将下列命令保存为ping.bat 1234@echo offecho batch File TestpauseDir %windir%/system 然后执行ping屏幕会打印ping命令帮助，说明调用的ping cmd 而不是ping.bat。改为： 1234567891011121314151617181920212223242526272829303132PS C:\PS&gt; ./pingbatch File TestPress any key to continue . . . Volume in drive C has no label. Volume Serial Number is 4E9B-D846 Directory of C:Windowssystem2009/06/11 05:21 69,584 avicap.dll2009/06/11 05:21 109,456 avifile.dll2009/07/14 05:41 32,816 COMMDLG.DLL2009/07/14 05:41 2,000 keyboard.drv2009/06/11 05:42 9,936 lzexpand.dll2009/06/11 05:21 73,376 mciavi.drv2009/06/11 05:21 25,264 mciseq.drv2009/06/11 05:21 28,160 mciwave.drv2009/07/14 05:41 68,992 MMSYSTEM.DLL2009/07/14 05:41 1,152 mmtask.tsk2009/07/14 05:41 2,032 mouse.drv2009/06/11 05:21 126,912 msvideo.dll2009/06/11 05:42 82,944 olecli.dll2009/07/14 05:41 24,064 OLESVR.DLL2009/07/14 05:41 5,120 SHELL.DLL2009/07/14 05:41 1,744 sound.drv2009/06/11 05:25 5,532 stdole.tlb2009/07/14 05:41 3,360 system.drv2009/07/14 05:41 4,048 TIMER.DRV2009/06/11 05:42 9,008 ver.dll2009/07/14 05:41 2,176 vga.drv2009/07/14 05:41 12,704 WFWNET.DRV 22 File(s) 700,380 bytes 2 Dir(s) 75,927,420,928 bytes free 通过cmd进入cmd控制台输入ping发现执行的不是ping命令，而是直接运行ping.bat ，也就是说可以通过.bat 覆盖cmd命令。这种机制很危险，如果有人侵入电脑，并将系统内部命令篡改成自己批处理，那就太悲剧了。 这种命令与脚本的混淆不会发生在powershell中，因为powershell有更安全的机制。 执行VB脚本文件12345Set wmi = GetObject(&quot;winmgmts:&quot;)Set collection = wmi.ExecQuery(&quot;select * from Win32_Process&quot;)For Each process in collectionWScript.Echo process.getObjectText_Next 执行 .\test.vbs 会遍历当前Win32进程，并把每个进程的详细信息通过窗口显示出来。怎样让VB脚本的通过控制台输出呢？Wscript //H:CScript怎样还原VB脚本通过窗口输出呢？WScript //H:WScript 在powershell中执行VB脚本123456789101112131415161718PS C:\PS&gt; cscript.exe .test.vbsMicrosoft (R) Windows Script Host Version 5.8Copyright (C) Microsoft Corporation. All rights reserved.instance of Win32_Process&#123; Caption = &quot;System Idle Process&quot;; CreationClassName = &quot;Win32_Process&quot;; CSCreationClassName = &quot;Win32_ComputerSystem&quot;; CSName = &quot;test-me-01&quot;; Description = &quot;System Idle Process&quot;; Handle = &quot;0&quot;; HandleCount = 0; KernelModeTime = &quot;484113379271&quot;; Name = &quot;System Idle Process&quot;; OSCreationClassName = &quot;Win32_OperatingSystem&quot;; OSName = &quot;Microsoft Windows 7 Enterprise ……………………………………以下省略很多进程信息 执行powershell脚本Powershell拥有自己的脚本，扩展名为“.ps1” 1234PS C:\PS&gt; echo &quot;dir;Get-PSProvider;help dir&quot; &gt;test.ps1PS C:\PS&gt; Get-Content ./test.ps1dir;Get-PSProvider;help dirPS C:\PS&gt; ./test.ps1 初次执行脚本时，可能会碰到一个异常： 12345File ” C:\PS\test.ps1″ cannot be loaded because theexecution of scripts is disabled on this system. Please see“get-help about_signing” for more details.At line:1 char:10\+ .test.ps1 &lt;&lt;&lt;&lt; 这是powershell的默认安全设置禁用了执行脚本，要启用这个功能需要拥有管理员的权限。]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-07 数组和哈希表]]></title>
    <url>%2Fwindows-07%2F</url>
    <content type="text"><![CDATA[windows-运维-07 数组和哈希表命令返回数组当我们把一个命令的执行结果保存到一个变量中，可能会认为变量存放的是纯文本。 但是，事实上Powershell会把文本按每一行作为元素存为数组。如果一个命令的返回值不止一个结果时，Powershell也会自动把结果存储为数组。 1234567891011121314151617181920212223PS C:Powershell&gt; $IPcfg=ipconfigPS C:Powershell&gt; $IPcfgWindows IP ConfigurationEthernet adapter Local Area Connection:Connection-specific DNS Suffix . : *** Link-local IPv6 Address . . . . . : *** IPv4 Address. . . . . . . . . . . : 192.168.140.128 Subnet Mask . . . . . . . . . . . : 255.255.252.0 Default Gateway . . . . . . . . . : 192.168.140.1Tunnel adapter isatap.eagleslab.com: Connection-specific DNS Suffix . : *** Link-local IPv6 Address . . . . . : *** Default Gateway . . . . . . . . . :***Tunnel adapter Teredo Tunneling Pseudo-Interface: Media State . . . . . . . . . . . : Media disconnected Connection-specific DNS Suffix . :PS C:Powershell&gt; $IPcfg.Count22 使用数组存储结果判断一个变量是否为数组 12345678PS C:Powershell&gt; $ip=ipconfigPS C:Powershell&gt; $ip -is [array]TruePS C:Powershell&gt; &quot;abac&quot; -is [array]FalsePS C:Powershell&gt; $str=&quot;字符串&quot;PS C:Powershell&gt; $str.ToCharArray() -is [array]True 查看数组的元素个数用$array.Count属性。访问第x个元素，使用$array[x-1]，因为数组是以0开始索引的。 123456PS C:Powershell&gt; ipconfig | Select-String &quot;IP&quot;Windows IP Configuration Link-local IPv6 Address . . . . . : *** IPv4 Address. . . . . . . . . . . : *** Link-local IPv6 Address . . . . . : *** 使用真实的对象操作 为什么不愿把IPconfig返回的结果称为对象，因为它不是真正Cmdlet命令，真正的Powershell命令返回的数组元素可不止一个字符串，它是一个内容丰富的对象。 12345678910111213141516171819202122232425262728PS C:Powershell&gt; ls Directory: C:PowershellMode LastWriteTime Length Name---- ------------- ------ ----d---- 2011/11/23 17:25 ABCd---- 2011/11/29 18:21 myscript-a--- 2011/11/24 18:30 67580 a.html-a--- 2011/11/24 20:04 26384 a.txt-a--- 2011/11/24 20:26 12060 alias-a--- 2011/11/24 20:27 12060 alias.ps1-a--- 2011/11/23 17:25 0 b.txt-a--- 2011/11/23 17:25 0 c.txt-a--- 2011/11/23 17:25 0 d.txt-a--- 2011/11/25 11:20 556 employee.xml-a--- 2011/11/29 19:23 21466 function.ps1-a--- 2011/11/28 11:12 186 LogoTestConfig.xml-a--- 2011/11/24 17:37 7420 name.html-a--- 2011/11/28 15:30 63 ping.bat-a--- 2011/11/24 17:44 735892 Powershell_Cmdlets.html-a--- 2011/11/30 16:04 2556 psdrive.html-a--- 2011/12/2 18:47 140 test.ps1-a--- 2011/11/23 17:37 242 test.txt-a--- 2011/11/28 16:42 170 test.vbsPS C:Powershell&gt; $result=lsPS C:Powershell&gt; $result.Count20 数组的每一个元素存放的是一个System.IO.DirectoryInfo对象。当我们输出这些对象时，Powershell会自动帮我们把它转换成友好的文本格式。 1234567PS C:Powershell&gt; $result[0].gettype().fullnameSystem.IO.DirectoryInfoPS C:Powershell&gt; $result[0] Directory: C:PowershellMode LastWriteTime Length Name---- ------------- ------ ----d---- 2011/11/23 17:25 ABC 对于任何一个对象都可以使用Format-List * 查看它所有的属性和方法。 1234567891011121314151617181920212223PS C:Powershell&gt; $result[0] | fl *PSPath : Microsoft.PowerShell.CoreFileSystem::C:PowershellABCPSParentPath : Microsoft.PowerShell.CoreFileSystem::C:PowershellPSChildName : ABCPSDrive : CPSProvider : Microsoft.PowerShell.CoreFileSystemPSIsContainer : TrueBaseName : ABCMode : d----Name : ABCParent : PowershellExists : TrueRoot : C:FullName : C:PowershellABCExtension :CreationTime : 2011/11/23 17:25:53CreationTimeUtc : 2011/11/23 9:25:53LastAccessTime : 2011/11/23 17:25:53LastAccessTimeUtc : 2011/11/23 9:25:53LastWriteTime : 2011/11/23 17:25:53LastWriteTimeUtc : 2011/11/23 9:25:53Attributes : Directory 创建数组在Powershell中创建数组可以使用逗号。 123456PS C:Powershell&gt; $nums=2,0,1,2PS C:Powershell&gt; $nums2012 对于连续的数字数组可以使用一个更快捷的方法 1234567PS C:Powershell&gt; $nums=1..5PS C:Powershell&gt; $nums12345 数组的多态像变量一样如果数组中元素的类型为弱类型，默认可以存储不同类型的值 123456789101112131415161718192021222324PS C:Powershell&gt; $array=1,&quot;2012世界末日&quot;,([System.Guid]::NewGuid()),(get-date)PS C:Powershell&gt; $array12012世界末日Guid----06a88783-a181-4511-9e41-2780ecbd7924DisplayHint : DateTimeDate : 2011/12/9 0:00:00Day : 9DayOfWeek : FridayDayOfYear : 343Hour : 14Kind : LocalMillisecond : 910Minute : 15Month : 12Second : 45Ticks : 634590369459101334TimeOfDay : 14:15:45.9101334Year : 2011DateTime : 2011年12月9日 14:15:45 空数组和单元素数组空数组 12345PS C:Powershell&gt; $a=@()PS C:Powershell&gt; $a -is [array]TruePS C:Powershell&gt; $a.Count0 1个元素的数组 12345PS C:Powershell&gt; $a=,&quot;moss&quot;PS C:Powershell&gt; $a -is [array]TruePS C:Powershell&gt; $a.Count1 访问数组 数组的元素可以使用索引寻址，第一个元素的索引为0，第i个元素的索引为i-1，最后一个元素的索引为Count-1，但是Powershell为了使用方便，直接可以将 -1 作为最后的一个元素的索引。 123456789PS C:Powershell&gt; $books=&quot;元素1&quot;,&quot;元素2&quot;,&quot;元素3&quot;PS C:Powershell&gt; $books[0]元素1PS C:Powershell&gt; $books[1]元素2PS C:Powershell&gt; $books[($book.Count-1)]元素3PS C:Powershell&gt; $books[-1]元素3 从数组中选择多个元素12345678910PS C:Powershell&gt; $result=lsPS C:Powershell&gt; $result[0,3,5,12] Directory: C:PowershellMode LastWriteTime Length Name---- ------------- ------ ----d---- 2011/11/23 17:25 ABC-a--- 2011/11/24 20:04 26384 a.txt-a--- 2011/11/24 20:27 12060 alias.ps1-a--- 2011/11/24 17:37 7420 name.html 将数组逆序输出 12345PS C:Powershell&gt; $books=&quot;元素1&quot;,&quot;元素2&quot;,&quot;元素3&quot;PS C:Powershell&gt; $books[($books.Count)..0]元素3元素2元素1 给数组添加和删除元素 因为Powershell数组在内存中是顺序存储的，所以数组的大小必须是确定的，这样才方便分配存储空间，所以给数组增加元素其实相当于创建一个新的数组，只不过之后会把原来的副本删除。在当前数组追加元素可以使用“+=”操作符。 1234567PS C:Powershell&gt; $books=&quot;元素1&quot;,&quot;元素2&quot;,&quot;元素3&quot;PS C:Powershell&gt; $books+=&quot;元素4&quot;PS C:Powershell&gt; $books元素1元素2元素3元素4 要删除第三个元素可以使用以下命令： 1234567891011PS C:Powershell&gt; $num=1..4PS C:Powershell&gt; $num1234PS C:Powershell&gt; $num=$num[0..1]+$num[3]PS C:Powershell&gt; $num124 复制数组 数组属于引用类型，使用默认的的赋值运算符在两个变量之间赋值只是复制了一个引用，两个变量共享同一份数据。这样的模式有一个弊病如果其中一个改变也会株连到另外一个。所以复制数组最好使用Clone()方法，除非有特殊需求。 1234567891011121314151617PS C:Powershell&gt; $chs=@(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)PS C:Powershell&gt; $chsBak=$chsPS C:Powershell&gt; $chsBak[1]=&quot;H&quot;PS C:Powershell&gt; $chsAHCPS C:Powershell&gt; $chs.Equals($chsBak)TruePS C:Powershell&gt; $chsNew=$chs.Clone()PS C:Powershell&gt; $chsNew[1]=&quot;Good&quot;PS C:Powershell&gt; $chs.Equals($chsNew)FalsePS C:Powershell&gt; $chsAHC 强类型数组 Powershell数组一般具有多态性，如果你不指定元素的具体类型，解释器会自动选择合适的类型存储每个元素。如果要统一限制所有元素的类型，可是使用类型名和一对方括号作为数组变量的类型。这样每当赋值时，会自动类型检查。如果目标数据类型不能转换成功，就会抛出一个异常。 12345678910PS C:Powershell&gt; [int[]] $nums=@()PS C:Powershell&gt; $nums+=2012PS C:Powershell&gt; $nums+=12.3PS C:Powershell&gt; $nums+=&quot;999&quot;PS C:Powershell&gt; $nums+=&quot;can not convert&quot;Cannot convert value &quot;can not convert&quot; to type &quot;System.Int32&quot;. Error: &quot;Input string was not in a correct format.&quot;At line:1 char:6+ $nums &lt;&lt;&lt;&lt; +=&quot;can not convert&quot; + CategoryInfo : MetadataError: (:) [], ArgumentTransformationMetadataException + FullyQualifiedErrorId : RuntimeException 使用哈希表 哈希表存放的是对，在哈希表中不再仅仅限制使用数字寻址，可以使用任意类型的数据类型寻址。创建哈希表 之前使用@()创建数组，现在使用@{}创建哈希表，使用哈希表的键访问对应的值。 1234567891011121314151617181920212223PS C:Powershell&gt; $stu=@&#123; Name = &quot;小明&quot;;Age=&quot;12&quot;;sex=&quot;男&quot; &#125;PS C:Powershell&gt; $stuName Value---- -----Name 小明Age 12sex 男PS C:Powershell&gt; $stu[&quot;Name&quot;]小明PS C:Powershell&gt; $stu[&quot;age&quot;]12PS C:Powershell&gt; $stu.Count3PS C:Powershell&gt; $stu.KeysNameAgesexPS C:Powershell&gt; $stu.Values小明12男 在哈希表中存储数组可以在创建哈希表时就使用数组，因为创建数组和哈希表的的元素关键字不冲突。一个是逗号，一个是分号。 123456789PS C:Powershell&gt; $stu=@&#123; Name = &quot;小明&quot;;Age=&quot;12&quot;;sex=&quot;男&quot;;Books=&quot;三国演义&quot;,&quot;围城&quot;,&quot;哈姆雷特&quot; &#125;PS C:Powershell&gt; $stuName Value---- -----Books &#123;三国演义, 围城, 哈姆雷特&#125;Name 小明Age 12sex 男 在哈希表中插入新的键值在哈希表中插入新的键值很方便，象定义变量一样，可以直接拿来使用 123456789PS C:Powershell&gt; $Student=@&#123;&#125;PS C:Powershell&gt; $Student.Name=&quot;令狐冲&quot;PS C:Powershell&gt; $Student.School=&quot;华山派&quot;PS C:Powershell&gt; $Student Name Value---- -----Name 令狐冲 School 华山派 哈希表值的更新和删除如果要更新键的值，可以直接重写。如果要删除这个键值对，可以使用Remove方法，参数为Key 1234567891011121314151617181920PS C:Powershell&gt; $stuName Value---- -----Books &#123;三国演义, 围城, 哈姆雷特&#125;Name 小明Age 12sex 男PS C:Powershell&gt; $stu.Name=&quot;赵强&quot;PS C:Powershell&gt; $stu.Name赵强PS C:Powershell&gt; $stu.Remove(&quot;Name&quot;)PS C:Powershell&gt; $stuName Value---- -----Books &#123;三国演义, 围城, 哈姆雷特&#125;Age 12sex 男 使用哈希表格式化输出 在Powershell中哈希表的一个有趣的应用可以用来格式化文本输出。Powershell许多命令的输出结果都是以表格的形式，当然可以使用Format-Table自定义表格格式，例如： 12345678910111213141516PS C:Powershell&gt; Dir | Format-Table Directory: C:PowershellMode LastWriteTime Length Name---- ------------- ------ ----d---- 2011/11/23 17:25 ABCd---- 2011/11/29 18:21 myscriptPS C:Powershell&gt; Dir | Format-Table FullName,ModeFullName Mode-------- ----C:PowershellABC d----C:Powershellmyscript d----C:Powershella.html 上述的命令只能限制表格输出那些列，隐藏那些列。但是对于列的宽度，列标题无能为力，但是有了哈希表就可以实现更多自定义了。 表格的每一个列包含四个属性：Expression:绑定的表达式Width:列宽度Label:列标题Alignment:列的对齐方式 123456789PS C:Powershell&gt; $column1 = @&#123;expression=&quot;Name&quot;; width=30;label=&quot;filename&quot;; alignment=&quot;left&quot;&#125;PS C:Powershell&gt; $column2 = @&#123;expression=&quot;LastWriteTime&quot;; width=40;label=&quot;last modification&quot;; alignment=&quot;right&quot;&#125;PS C:Powershell&gt; ls | Format-Table $column1, $column2filename last modification-------- -----------------ABC 2011/11/23 17:25:53myscript 2011/11/29 18:21:28a.html 2011/11/24 18:30:13]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-06 PowerShell别名]]></title>
    <url>%2Fwindows-06%2F</url>
    <content type="text"><![CDATA[windows-运维-06 PowerShell别名PowerShell别名 cmdlet 的名称由一个动词和一个名词组成，其功能对用户来讲一目了然。但是对于一个经常使用powershell命令的人每天敲那么多命令也很麻烦啊。能不能把命令缩短一点呢？于是“别名”就应运而生了。Powershell内部也实现了很多常用命令的别名。例如Get-ChildItem，列出当前的子文件或目录。它有两个别名：ls 和 dir，这两个别名来源于unix 的shell和windows的cmd。因此别名有两个作用： 继承：继承unix-shell和windows-cmd。 方便：方便用户使用。 处理别名：查询别名所指的真实cmdlet命令。 12345678910111213141516171819202122PS C:\&gt; Get-Alias -name dir CommandType Name Version Source ----------- ---- ------- ------ Alias dir -&gt; Get-ChildItem PS C:\&gt; Get-Alias -name ls CommandType Name Version Source ----------- ---- ------- ------ Alias ls -&gt; Get-ChildItem PS C:\&gt; Get-Alias -name ft CommandType Name Version Source ----------- ---- ------- ------ Alias ft -&gt; Format-Table PS C:\&gt; 查看可用的别名查看可用的别名，可以通过” ls alias:” 或者 ”Get-Alias“如何查看所有以Remove打头的cmdlet的命令的别名呢？ 12345678910111213141516171819PS C:\PS&gt; dir alias: | where &#123;$_.Definition.Startswith(&quot;Remove&quot;)&#125;CommandType Name Definition----------- ---- ----------Alias del Remove-ItemAlias erase Remove-ItemAlias rbp Remove-PSBreakpointAlias rd Remove-ItemAlias rdr Remove-PSDriveAlias ri Remove-ItemAlias rjb Remove-JobAlias rm Remove-ItemAlias rmdir Remove-ItemAlias rmo Remove-ModuleAlias rp Remove-ItemPropertyAlias rsn Remove-PSSessionAlias rsnp Remove-PSSnapinAlias rv Remove-VariableAlias rwmi Remove-WMIObject 说明：dir alias:获取的是别名的数组，通过where对数组元素进行遍历，$_代表当前元素，alias的Definition为String类型，因为powershell支持.net，.net中的string类有一个方法Startswith。通过where过滤集合在powershell中使用非常广泛。 有的cmdlet命令可能有2-3个别名，我们可以通过下面的命令查看所有别名和指向cmdlet的别名的个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111PS C:\PS&gt; ls alias: | Group-Object definition | sort -Descending CountCount Name Group----- ---- ----- 6 Remove-Item &#123;del, erase, rd, ri...&#125; 3 Set-Location &#123;cd, chdir, sl&#125; 3 Get-History &#123;ghy, h, history&#125; 3 Get-ChildItem &#123;dir, gci, ls&#125; 3 Get-Content &#123;cat, gc, type&#125; 3 Move-Item &#123;mi, move, mv&#125; 3 Copy-Item &#123;copy, cp, cpi&#125; 2 Start-Process &#123;saps, start&#125; 2 Set-Variable &#123;set, sv&#125; 2 Write-Output &#123;echo, write&#125; 2 Get-Process &#123;gps, ps&#125; 2 Invoke-History &#123;ihy, r&#125; 2 New-PSDrive &#123;mount, ndr&#125; 2 Stop-Process &#123;kill, spps&#125; 2 Rename-Item &#123;ren, rni&#125; 2 Get-Location &#123;gl, pwd&#125; 2 Compare-Object &#123;compare, diff&#125; 2 Where-Object &#123;?, where&#125; 2 ForEach-Object &#123;%, foreach&#125; 2 Clear-Host &#123;clear, cls&#125; 1 Out-Host &#123;oh&#125; 1 New-PSSession &#123;nsn&#125; 1 New-Variable &#123;nv&#125; 1 Out-GridView &#123;ogv&#125; 1 Pop-Location &#123;popd&#125; 1 Tee-Object &#123;tee&#125; 1 Remove-PSBreakpoint &#123;rbp&#125; 1 Receive-Job &#123;rcjb&#125; 1 Push-Location &#123;pushd&#125; 1 mkdir &#123;md&#125; 1 Measure-Object &#123;measure&#125; 1 help &#123;man&#125; 1 Remove-PSSnapin &#123;rsnp&#125; 1 Out-Printer &#123;lp&#125; 1 New-Item &#123;ni&#125; 1 New-Module &#123;nmo&#125; 1 New-Alias &#123;nal&#125; 1 Move-ItemProperty &#123;mp&#125; 1 Wait-Job &#123;wjb&#125; 1 Remove-PSDrive &#123;rdr&#125; 1 Start-Service &#123;sasv&#125; 1 Set-PSBreakpoint &#123;sbp&#125; 1 Set-ItemProperty &#123;sp&#125; 1 Start-Job &#123;sajb&#125; 1 Set-Alias &#123;sal&#125; 1 Start-Sleep &#123;sleep&#125; 1 Set-Item &#123;si&#125; 1 Select-Object &#123;select&#125; 1 Set-Content &#123;sc&#125; 1 Sort-Object &#123;sort&#125; 1 Remove-WMIObject &#123;rwmi&#125; 1 Remove-Module &#123;rmo&#125; 1 Rename-ItemProperty &#123;rnp&#125; 1 Stop-Service &#123;spsv&#125; 1 Set-WMIInstance &#123;swmi&#125; 1 Remove-Job &#123;rjb&#125; 1 Remove-Variable &#123;rv&#125; 1 Resolve-Path &#123;rvpa&#125; 1 Stop-Job &#123;spjb&#125; 1 Remove-ItemProperty &#123;rp&#125; 1 Remove-PSSession &#123;rsn&#125; 1 Exit-PSSession &#123;exsn&#125; 1 Format-Custom &#123;fc&#125; 1 Enter-PSSession &#123;etsn&#125; 1 Export-Csv &#123;epcsv&#125; 1 Export-PSSession &#123;epsn&#125; 1 Format-List &#123;fl&#125; 1 Get-PSBreakpoint &#123;gbp&#125; 1 Get-Command &#123;gcm&#125; 1 Get-Alias &#123;gal&#125; 1 Format-Table &#123;ft&#125; 1 Format-Wide &#123;fw&#125; 1 Export-Alias &#123;epal&#125; 1 Clear-History &#123;clhy&#125; 1 Clear-Item &#123;cli&#125; 1 Clear-Content &#123;clc&#125; 1 Add-Content &#123;ac&#125; 1 Add-PSSnapIn &#123;asnp&#125; 1 Clear-ItemProperty &#123;clp&#125; 1 Disable-PSBreakpoint &#123;dbp&#125; 1 Enable-PSBreakpoint &#123;ebp&#125; 1 Convert-Path &#123;cvpa&#125; 1 Clear-Variable &#123;clv&#125; 1 Copy-ItemProperty &#123;cpp&#125; 1 Invoke-Expression &#123;iex&#125; 1 Invoke-Item &#123;ii&#125; 1 Invoke-Command &#123;icm&#125; 1 Get-Variable &#123;gv&#125; 1 Get-WmiObject &#123;gwmi&#125; 1 Import-Alias &#123;ipal&#125; 1 powershell_ise.exe &#123;ise&#125; 1 Invoke-WMIMethod &#123;iwmi&#125; 1 Import-PSSession &#123;ipsn&#125; 1 Import-Csv &#123;ipcsv&#125; 1 Import-Module &#123;ipmo&#125; 1 Get-Unique &#123;gu&#125; 1 Get-Job &#123;gjb&#125; 1 Get-Member &#123;gm&#125; 1 Get-Item &#123;gi&#125; 1 Get-PSCallStack &#123;gcs&#125; 1 Get-PSDrive &#123;gdr&#125; 1 Get-Module &#123;gmo&#125; 1 Get-PSSnapIn &#123;gsnp&#125; 1 Get-Service &#123;gsv&#125; 1 Get-PSSession &#123;gsn&#125; 1 Get-ItemProperty &#123;gp&#125; 1 Group-Object &#123;group&#125; 创建自己的别名给记事本创建一个别名，并查看该别名； 1234PS C:\PS&gt; Set-Alias -Name Edit -Value notepadPS C:\PS&gt; EditPS C:\PS&gt; $alias:Editnotepad 删除自己的别名 别名不用删除，自定义的别名在powershell退出时会自动清除。但是请放心，powershell内置别名（诸如ls,dir,fl等）不会清除。如果你非得手工删除别名。请使用 1PS C:\PS&gt; del alias:Edit 保存自己的别名 可以使用Export-Alias将别名导出到文件，需要时再通过Import-Alias导入。但是导入时可能会有异常，提示别名已经存在无法导入： 12345678PS C:\PS&gt; Import-Alias alias.ps1Import-Alias : Alias not allowed because an alias with the name &apos;ac&apos; already exists.At line:1 char:13+ Import-Alias &lt;&lt;&lt;&lt; alias.ps1 + CategoryInfo : ResourceExists: (ac:String) [Import-Alias], SessionStateException + FullyQualifiedErrorId : AliasAlreadyExists,Microsoft.PowerShell.Commands.ImportAliasCommand 这时可以使用Force强制导入。 12PS C:\PS&gt; Export-Alias alias.ps1PS C:\PS&gt; Import-Alias -Force alias.ps1 通过函数扩展别名 在Powershell中设置别名的确方便快捷，但是在设置别名的过程中并设置参数的相关信息。尽管别名会自动识别参数，但是如何把经常使用的参数默认设定在别名里面呢？例如Test-Connection -Count 2 -ComputerName，让-“-Count 2” 固化在别名中。 这时简单的别名无法完成上述需求，可以通过函数来完成它，并且一旦把函数拉过来，定义别名会变得更加灵活。 12345678PS C:\PS&gt; function test-conn &#123; Test-Connection -Count 2 -ComputerName $args&#125;PS C:\PS&gt; Set-Alias tc test-connPS C:\PS&gt; tc localhostSource Destination IPV4Address IPV6Address Bytes Time(ms)------ ----------- ----------- ----------- ----- --------test-me-01 localhost 127.0.0.1 ::1 32 0test-me-01 localhost 127.0.0.1 ::1 32 0 有了函数牵线，别名可以完成更高级更强大的功能，其中$args为参数的占位符。 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-05 初识PowerShell]]></title>
    <url>%2Fwindows-05%2F</url>
    <content type="text"><![CDATA[windows-运维-05 初识PowerShell什么是PowerShell Powershell 是运行在windows机器上实现系统和应用程序管理自动化的命令行脚本环境。你可以把它看成是命令行提示符cmd.exe的扩充，不对，应当是颠覆。 powershell需要.NET环境的支持，同时支持.NET对象。微软之所以将Powershell 定位为Power，并不是夸大其词，因为它完全支持对象。其可读性，易用性，可以位居当前所有shell之首。 当前powershell有四版本，分别为1.0，2.0，3.0 ,4.0 如果您的系统是window7或者Windows Server 2008，那么PowerShell 2.0已经内置了，可以升级为3.0，4.0。 如果您的系统是Windows 8 或者Windows server 2012，那么PowerShell 3.0已经内置了，可以升级为4.0。 如果您的系统为Windows 8.1或者Windows server 2012 R2，那默认已经是4.0了。 Powershell 自定义控制台 打开虚拟机或者物理机，打开你powershell，右击powershell的标题栏选择”属性”弹出powershell控制台对话框。在这里有四个选项卡：选项、字体、布局和颜色。 Powershell 编辑模式powershell控制台有两种模式，一个是快速编辑模式，一个是标准模式。快速编辑模式和标准模式的切换可以通过控制台标题栏-&gt;鼠标右击-&gt;属性-&gt;选项-&gt;编辑选项 。 Powershell标准模式鼠标右击选择标记后才能实现复制和粘切功能。 Powershell快速编辑模式可以通过鼠标左键选择任意矩形区域内的文本，并且鼠标右击实现复制功能。 Powershell的快捷键 ALT+F7 清除命令的历史记录 PgUp PgDn 显示当前会话的第一个命令和最后一个命令 Enter 执行当前命令 End 将光标移至当前命令的末尾 Del 从右开始删除输入的命令字符 Esc 清空当前命令行 F2 自动补充历史命令至指定字符 (例如历史记录中存在Get-Process，按F2，提示”Enter char to copy up to”，键入‘s’，自动补齐命令:Get-Proce) F4 删除命令行至光标右边指定字符处 F7 对话框显示命令行历史记录 F8 检索包含指定字符的命令行历史记录 F9 根据命令行的历史记录编号选择命令，历史记录编号可以通过F7查看 左/右方向键 左右移动光标 上/下方向键 切换命令行的历史记录 Home 光标移至命令行最左端 Backspace 从右删除命令行字符 Ctrl+C 取消正在执行的命令 Ctrl+左/右方向键 在单词之间移动光标 Ctrl+Home 删除光标最左端的所有字符 Tab 自动补齐命令或者文件名 Powershell交互式Powershell 进行数学运算 我们可以把powershell当成一个计算器。象键入命令行那样输入数学表达式，回车，powershell会自动计算并把结果输出。常用的加减乘除模（+,-,*,/,%）运算和小括号表达式都支持。 12345678PS C:\pstest&gt; 1+2+36PS C:\pstest&gt; 0xABCD43981PS C:\pstest&gt; 3.14*10*10314PS C:\pstest&gt; 1+3-(2.4-5)*(7.899-4.444)12.983 PowerShell也能自动识别计算机容量单位,包括KB，MB，GB，TB，PB 12345678PS C:\pstest&gt; 1pb/1tb1024PS C:\pstest&gt; 1tb/1gb1024PS C:\pstest&gt; 1gb/1kb1048576PS C:\pstest&gt; 1gb/20mb*10kb524288 假如一个网站每个页面大小为80kb，统计显示每天的PV操作为800，1个月下来占用的带宽： 12PS C:\pstest&gt; 80kb*800*30/1gb1.8310546875 假如一个网站的每天人均PV操作为5，页面大小为80Kb，主机提供商限制的总流量为10G，那平均每天的最大访客数 为： 12PS C:pstest&gt; 10GB/(80KB*5)/30873.813333333333 Powershell变量定义变量变量可以临时保存数据，因此可以把数据保存在变量中，以便进一步操作。 12345678910#定义变量$a=10$b=4#计算变量$result=$a*$b$msg=&quot;保存文本&quot;#输出变量$result$msg powershell 不需要显示地去声明，可以自动创建变量，只须记住变量的前缀为$. 创建好了变量后，可以通过变量名输出变量，也可以把变量名存在字符串中。但是有个例外单引号中的字符串不会识别和处理变量名。 选择变量名 在powershell中变量名均是以美元符”$”开始，剩余字符可以是数字、字母、下划线的任意字符，并且powershell变量名大小写不敏感（$a和$A 是同一个变量)。 某些特殊的字符在powershell中有特殊的用途，一般不推荐使用这些字符作为变量名。当然你硬要使用，请把整个变量名后缀用花括号括起来。 123PS C:\test&gt; $&#123;&quot;I&quot;like $&#125;=&quot;mossfly&quot;PS C:\test&gt; $&#123;&quot;I&quot;like $&#125;mossfly 赋值和返回值 赋值操作符为“=”，几乎可以把任何数据赋值给一个变量，甚至一条cmdlet命令，为什么，因为Powershell支持对象，对象可以包罗万象。 1234567891011121314151617181920212223242526PS C:\test&gt; $item=Get-ChildItem .PS C:\test&gt; $item Directory: C:\testMode LastWriteTime Length Name---- ------------- ------ ----d---- 2011/11/23 17:25 ABC-a--- 2011/11/24 18:30 67580 a.html-a--- 2011/11/24 20:04 26384 a.txt-a--- 2011/11/24 20:26 12060 alias-a--- 2011/11/24 20:27 12060 alias.ps1-a--- 2011/11/23 17:25 0 b.txt-a--- 2011/11/23 17:25 0 c.txt-a--- 2011/11/23 17:25 0 d.txt-a--- 2011/11/25 11:20 556 employee.xml-a--- 2011/11/24 17:37 7420 name.html-a--- 2011/11/28 15:30 63 ping.bat-a--- 2011/11/24 17:44 735892 Powershell_Cmdlets.html-a--- 2011/11/28 17:03 60 test.ps1-a--- 2011/11/23 17:37 242 test.txt-a--- 2011/11/28 16:42 170 test.vbsPS C:\test&gt; $result=3000*(1/12+0.0075)PS C:\test&gt; $result272.5 给多个变量同时赋值赋值操作符不仅能给一个变量赋值，还可以同时给多个变量赋相同的值。 1234567PS C:\test&gt; $a=$b=$c=123PS C:\test&gt; $a123PS C:\test&gt; $b123PS C:\test&gt; $c123 交换变量的值要交换两个变量的值，传统的程序语言至少需要三步，并且还需定义一个中间临时变量。 12345$Value1 = 10$Value2 = 20$Temp = $Value1$Value1 = $Value2$Value2 = $Temp 在powershell中，交换两个变量的值，这个功能变得非常简单。 1234567PS C:\test&gt; $value1=10PS C:\test&gt; $value2=20PS C:\test&gt; $value1,$value2=$value2,$value1PS C:\test&gt; $value120PS C:\test&gt; $value210 查看正在使用的变量 Powershell将变量的相关信息的记录存放在名为variable:的驱动中。如果要查看所有定义的变量，可以直接遍历variable: 123456789101112131415161718PS C:\test&gt; ls variable:Name Value---- -----&quot;I&quot;like $ mossfly$ cls? True^ cls_1 1a 123args &#123;&#125;b 123c 123ConfirmPreference HighConsoleFileNameDebugPreference SilentlyContinue。。。 查找变量因为有虚拟驱动variable:的存在，可以象查找文件那样使用通配符查找变量。例如要查询以value打头的变量名。 123456PS C:\test&gt; ls variable:value*Name Value---- -----value1 20value2 10 验证变量是否存在 验证一个变量是否存在，仍然可以象验证文件系统那样，使用cmdlet Test-Path。为什么？因为变量存在变量驱动器中。 123456PS C:\test&gt; Test-Path variable:value1TruePS C:\test&gt; Test-Path variable:value2TruePS C:\test&gt; Test-Path variable:valueUnkonwFalse 删除变量 因为变量会在powershell退出或关闭时，自动清除。一般没必要删除，但是你非得删除，也可以象删除文件那样删除它 12345PS C:\test&gt; Test-Path variable:value1TruePS C:\test&gt; del variable:value1PS C:\test&gt; Test-Path variable:value1False 使用专用的变量命令 为了管理变量，powershell提供了五个专门管理变量的命令Clear-Variable，Get-Variable，New-Variable，Remove-Variable，Set-Variable。因为虚拟驱动器variable:的存在，clear，remove，set打头的命令可以被代替。但是Get-Variable，New-Variable。却非常有用new-variable可以在定义变量时，指定变量的一些其它属性，比如访问权限。同样Get-Variable也可以获取这些附加信息。 变量写保护(创建常量)可以使用New-Variable 的option选项 在创建变量时，给变量加上只读属性，这样就不能给变量重新赋值了。 1234567891011PS C:\test&gt; New-Variable num -Value 100 -Force -Option readonlyPS C:\test&gt; $num=101Cannot overwrite variable num because it is read-only or constant.At line:1 char:5+ $num &lt;&lt;&lt;&lt; =101 + CategoryInfo : WriteError: (num:String) [], SessionStateUnauthorizedAccessException + FullyQualifiedErrorId : VariableNotWritable PS C:\test&gt; del Variable:numRemove-Item : Cannot remove variable num because it is constant or read-only. If the variable is read-only,ration again specifying the Force option.At line:1 char:4+ del &lt;&lt;&lt;&lt; Variable:num + CategoryInfo : WriteError: (num:String) [Remove-Item], SessionStateUnauthorizedAccessExcepti + FullyQualifiedErrorId : VariableNotRemovable,Microsoft.PowerShell.Commands.RemoveItemCommand 但是可以通过删除变量，再重新创建变量更新变量内容。 1234PS C:\test&gt; del Variable:num -ForcePS C:\test&gt; $num=101PS C:\test&gt; $num101 有没有权限更高的变量，有，那就是：选项Constant，常量一旦声明，不可修改 123456789101112PS C:\test&gt; new-variable num -Value &quot;strong&quot; -Option constantPS C:\test&gt; $num=&quot;why? can not delete it.&quot;Cannot overwrite variable num because it is read-only or constant.At line:1 char:5+ $num &lt;&lt;&lt;&lt; =&quot;why? can not delete it.&quot; + CategoryInfo : WriteError: (num:String) [], SessionStateUnauthorizedAccessException + FullyQualifiedErrorId : VariableNotWritable PS C:\test&gt; del Variable:num -ForceRemove-Item : Cannot remove variable num because it is constant or read-only. If the variable is read-only,ration again specifying the Force option.At line:1 char:4+ del &lt;&lt;&lt;&lt; Variable:num -Force + CategoryInfo : WriteError: (num:String) [Remove-Item], SessionStateUnauthorizedAccessExcepti + FullyQualifiedErrorId : VariableNotRemovable,Microsoft.PowerShell.Commands.RemoveItemCommand 变量描述 在New-Variable 可以通过-description 添加变量描述，但是变量描述默认不会显示，可以通过Format-List 查看。 123456789101112131415PS C:\test&gt; new-variable name -Value &quot;me&quot; -Description &quot;This is my name&quot;PS C:\test&gt; ls Variable:name | fl *PSPath : Microsoft.PowerShell.CoreVariable::namePSDrive : VariablePSProvider : Microsoft.PowerShell.CoreVariablePSIsContainer : FalseName : nameDescription : This is my nameValue : meVisibility : PublicModule :ModuleName :Options : NoneAttributes : &#123;&#125; 执行外部命令 Powershell能像cmd一样执行外部命令 通过netstat查看网络端口状态12345678PS C:\PS&gt; netstatActive Connections Proto Local Address Foreign Address State TCP 192.168.0.100:3049 192.168.0.88:7575 ESTABLISHED TCP 192.168.0.100:3052 192.168.0.88:7575 ESTABLISHED TCP 192.168.0.100:3061 192.168.0.88:7575 ESTABLISHED route print 查看本机路由信息1234567891011121314151617181920212223242526272829303132333435PS C:\PS&gt; route printIPv4 Route Table===========================================================================Active Routes:Network Destination Netmask Gateway Interface Metric 0.0.0.0 0.0.0.0 192.168.140.1 192.168.140.100 20 192.0.0.0 255.0.0.0 On-link 192.0.0.1 306 192.0.0.1 255.255.255.255 On-link 192.0.0.1 306 192.255.255.255 255.255.255.255 On-link 192.0.0.1 306 192.168.140.0 255.255.252.0 On-link 192.168.140.100 276 192.168.140.100 255.255.255.255 On-link 192.168.140.100 276 192.168.143.255 255.255.255.255 On-link 192.168.140.100 276 224.0.0.0 240.0.0.0 On-link 192.0.0.1 306 224.0.0.0 240.0.0.0 On-link 192.168.140.100 276 255.255.255.255 255.255.255.255 On-link 192.0.0.1 306 255.255.255.255 255.255.255.255 On-link 192.168.140.100 276===========================================================================Persistent Routes: NoneIPv6 Route Table===========================================================================Active Routes: If Metric Network Destination Gateway 1 306 ::1/128 On-link 10 276 fe80::/64 On-link 11 281 fe80::5efe:192.168.140.100/128 On-link 10 276 fe80::b965:91f3:33a0:7285/128 On-link 1 306 ff00::/8 On-link 10 276 ff00::/8 On-link===========================================================================Persistent Routes: None 启动CMD控制台启动CMD控制台键入cmd或者cmd.exe,退出cmd可以通过命令exit。 123456PS C:\PS&gt; cmdMicrosoft Windows [Version 6.1.7601]Copyright (c) 2009 Microsoft Corporation. All rights reserved.C:\PS&gt;exitPS C:\PS&gt; 查找可用的Cmd控制台命令 Cmd.exe 通过 /c 来接收命令参数，在Cmd中help可以查看可用的命令，所以可以通过Cmd /c help 查找可用的Cmd控制台命令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091PS C:\PS&gt; cmd /c help有关某个命令的详细信息，请键入 HELP 命令名ASSOC 显示或修改文件扩展名关联。ATTRIB 显示或更改文件属性。BREAK 设置或清除扩展式 CTRL+C 检查。BCDEDIT 设置启动数据库中的属性以控制启动加载。CACLS 显示或修改文件的访问控制列表(ACL)。CALL 从另一个批处理程序调用这一个。CD 显示当前目录的名称或将其更改。CHCP 显示或设置活动代码页数。CHDIR 显示当前目录的名称或将其更改。CHKDSK 检查磁盘并显示状态报告。CHKNTFS 显示或修改启动时间磁盘检查。CLS 清除屏幕。CMD 打开另一个 Windows 命令解释程序窗口。COLOR 设置默认控制台前景和背景颜色。COMP 比较两个或两套文件的内容。COMPACT 显示或更改 NTFS 分区上文件的压缩。CONVERT 将 FAT 卷转换成 NTFS。您不能转换 当前驱动器。COPY 将至少一个文件复制到另一个位置。DATE 显示或设置日期。DEL 删除至少一个文件。DIR 显示一个目录中的文件和子目录。DISKCOMP 比较两个软盘的内容。DISKCOPY 将一个软盘的内容复制到另一个软盘。DISKPART 显示或配置磁盘分区属性。DOSKEY 编辑命令行、调用 Windows 命令并创建宏。DRIVERQUERY 显示当前设备驱动程序状态和属性。ECHO 显示消息，或将命令回显打开或关上。ENDLOCAL 结束批文件中环境更改的本地化。ERASE 删除一个或多个文件。EXIT 退出 CMD.EXE 程序(命令解释程序)。FC 比较两个文件或两个文件集并显示它们之间的不同。FIND 在一个或多个文件中搜索一个文本字符串。FINDSTR 在多个文件中搜索字符串。FOR 为一套文件中的每个文件运行一个指定的命令。FORMAT 格式化磁盘，以便跟 Windows 使用。FSUTIL 显示或配置文件系统的属性。FTYPE 显示或修改用在文件扩展名关联的文件类型。GOTO 将 Windows 命令解释程序指向批处理程序 中某个带标签的行。GPRESULT 显示机器或用户的组策略信息。GRAFTABL 启用 Windows 在图形模式显示扩展字符集。HELP 提供 Windows 命令的帮助信息。ICACLS 显示、修改、备份或还原文件和 目录的 ACL。IF 在批处理程序中执行有条件的处理过程。LABEL 创建、更改或删除磁盘的卷标。MD 创建一个目录。MKDIR 创建一个目录。MKLINK 创建符号链接和硬链接MODE 配置系统设备。MORE 逐屏显示输出。MOVE 将一个或多个文件从一个目录移动到另一个目录。OPENFILES 显示远程用户为了文件共享而打开的文件。PATH 为可执行文件显示或设置搜索路径。PAUSE 停止批处理文件的处理并显示信息。POPD 还原由 PUSHD 保存的当前目录上一次的值。PRINT 打印一个文本文件。PROMPT 改变 Windows 命令提示。PUSHD 保存当前目录，然后对其进行更改。RD 删除目录。RECOVER 从损坏的磁盘中恢复可读取的信息。REM 记录批处理文件或 CONFIG.SYS 中的注释。REN 重新命名文件。RENAME 重新命名文件。REPLACE 替换文件。RMDIR 删除目录。ROBOCOPY 复制文件和目录树的高级实用程序SET 显示、设置或删除 Windows 环境变量。SETLOCAL 开始用批文件改变环境的本地化。SC 显示或配置服务(后台处理)。SCHTASKS 安排命令和程序在一部计算机上按计划运行。SHIFT 调整批处理文件中可替换参数的位置。SHUTDOWN 让机器在本地或远程正确关闭。SORT 将输入排序。START 打开单独视窗运行指定程序或命令。SUBST 将驱动器号与路径关联。SYSTEMINFO 显示机器的具体的属性和配置。TASKLIST 显示包括服务的所有当前运行的任务。TASKKILL 终止正在运行的进程或应用程序。TIME 显示或设置系统时间。TITLE 设置 CMD.EXE 会话的窗口标题。TREE 以图形显示启动器或路径的目录结构。TYPE 显示文本文件的内容。VER 显示 Windows 的版本。VERIFY 告诉 Windows 验证文件是否正确写入磁盘。VOL 显示磁盘卷标和序列号。XCOPY 复制文件和目录树。WMIC 在交互命令外壳里显示 WMI 信息。 命令集 cmdletscmdlets是Powershell的内部命令，cmdlet的类型名为System.Management.Automation.CmdletInfo，包含下列属性和方法： Name MemberType Definition Equals Method bool Equals(System.Object obj) GetHashCode Method int GetHashCode() GetType Method type GetType() ToString Method string ToString() CommandType Property System.Management.Automation.CommandTypes CommandType {get;} DefaultParameterSet Property System.String DefaultParameterSet {get;} Definition Property System.String Definition {get;} HelpFile Property System.String HelpFile {get;} ImplementingType Property System.Type ImplementingType {get;} Module Property System.Management.Automation.PSModuleInfo Module {get;} ModuleName Property System.String ModuleName {get;} Name Property System.String Name {get;} Noun Property System.String Noun {get;} OutputType Property System.Collections.ObjectModel.ReadOnlyCollection`1[[System.Management.Automation.PSTypeName, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]] OutputType {get;} Parameters Property System.Collections.Generic.Dictionary`2[[System.String, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.Management.Automation.ParameterMetadata, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]] Parameters {get;} ParameterSets Property System.Collections.ObjectModel.ReadOnlyCollection`1[[System.Management.Automation.CommandParameterSetInfo, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]] ParameterSets {get;} PSSnapIn Property System.Management.Automation.PSSnapInInfo PSSnapIn {get;} Verb Property System.String Verb {get;} Visibility Property System.Management.Automation.SessionStateEntryVisibility Visibility {get;set;} DLL ScriptProperty System.Object DLL {get=$this.ImplementingType.Assembly.Location;} HelpUri ScriptProperty System.Object HelpUri {get=try { # ok to cast CommandTypes enum to HelpCategory because string/indentifier for # cmdlet,function,filter,alias,externalscript is identical. # it is ok to fail for other enum values (i.e. for Application) $helpObject = get-help -Name ($this.Name) -Category (string) -ErrorAction SilentlyContinue# return first non-null uri (and try not to hit any strict mode things) if ($helpObject -eq $null) { return $null } if ($helpObject.psobject.properties[‘relatedLinks’] -eq $null) { return $null } if ($helpObject.relatedLinks.psobject.properties[‘navigationLink’] -eq $null) { return $null } $helpUri = [string]$( $helpObject.relatedLinks.navigationLink \ %{ if ($.psobject.properties[‘uri’] -ne $null) { $.uri } } \ ?{ $_ } \ select -first 1 ) return $helpUri } catch {};} 下面是全部的Cmdlets命令 每个命令有一个动词和名词组成，命令的作用一目了然。 Name ModuleName Help Add-Computer Microsoft.PowerShell.Management help Add-Content Microsoft.PowerShell.Management help Add-History Microsoft.PowerShell.Core help Add-Member Microsoft.PowerShell.Utility help Add-PSSnapin Microsoft.PowerShell.Core help Add-Type Microsoft.PowerShell.Utility help Checkpoint-Computer Microsoft.PowerShell.Management help Clear-Content Microsoft.PowerShell.Management help Clear-EventLog Microsoft.PowerShell.Management help Clear-History Microsoft.PowerShell.Core help Clear-Item Microsoft.PowerShell.Management help Clear-ItemProperty Microsoft.PowerShell.Management help Clear-Variable Microsoft.PowerShell.Utility help Compare-Object Microsoft.PowerShell.Utility help Complete-Transaction Microsoft.PowerShell.Management help Connect-WSMan Microsoft.WSMan.Management help ConvertFrom-Csv Microsoft.PowerShell.Utility help ConvertFrom-SecureString Microsoft.PowerShell.Security help ConvertFrom-StringData Microsoft.PowerShell.Utility help Convert-Path Microsoft.PowerShell.Management help ConvertTo-Csv Microsoft.PowerShell.Utility help ConvertTo-Html Microsoft.PowerShell.Utility help ConvertTo-SecureString Microsoft.PowerShell.Security help ConvertTo-Xml Microsoft.PowerShell.Utility help Copy-Item Microsoft.PowerShell.Management help Copy-ItemProperty Microsoft.PowerShell.Management help Debug-Process Microsoft.PowerShell.Management help Disable-ComputerRestore Microsoft.PowerShell.Management help Disable-PSBreakpoint Microsoft.PowerShell.Utility help Disable-PSSessionConfiguration Microsoft.PowerShell.Core help Disable-WSManCredSSP Microsoft.WSMan.Management help Disconnect-WSMan Microsoft.WSMan.Management help Enable-ComputerRestore Microsoft.PowerShell.Management help Enable-PSBreakpoint Microsoft.PowerShell.Utility help Enable-PSRemoting Microsoft.PowerShell.Core help Enable-PSSessionConfiguration Microsoft.PowerShell.Core help Enable-WSManCredSSP Microsoft.WSMan.Management help Enter-PSSession Microsoft.PowerShell.Core help Exit-PSSession Microsoft.PowerShell.Core help Export-Alias Microsoft.PowerShell.Utility help Export-Clixml Microsoft.PowerShell.Utility help Export-Console Microsoft.PowerShell.Core help Export-Counter Microsoft.PowerShell.Diagnostics help Export-Csv Microsoft.PowerShell.Utility help Export-FormatData Microsoft.PowerShell.Utility help Export-ModuleMember Microsoft.PowerShell.Core help Export-PSSession Microsoft.PowerShell.Utility help ForEach-Object Microsoft.PowerShell.Core help Format-Custom Microsoft.PowerShell.Utility help Format-List Microsoft.PowerShell.Utility help Format-Table Microsoft.PowerShell.Utility help Format-Wide Microsoft.PowerShell.Utility help Get-Acl Microsoft.PowerShell.Security help Get-Alias Microsoft.PowerShell.Utility help Get-AuthenticodeSignature Microsoft.PowerShell.Security help Get-ChildItem Microsoft.PowerShell.Management help Get-Command Microsoft.PowerShell.Core help Get-ComputerRestorePoint Microsoft.PowerShell.Management help Get-Content Microsoft.PowerShell.Management help Get-Counter Microsoft.PowerShell.Diagnostics help Get-Credential Microsoft.PowerShell.Security help Get-Culture Microsoft.PowerShell.Utility help Get-Date Microsoft.PowerShell.Utility help Get-Event Microsoft.PowerShell.Utility help Get-EventLog Microsoft.PowerShell.Management help Get-EventSubscriber Microsoft.PowerShell.Utility help Get-ExecutionPolicy Microsoft.PowerShell.Security help Get-FormatData Microsoft.PowerShell.Utility help Get-Help Microsoft.PowerShell.Core help Get-History Microsoft.PowerShell.Core help Get-Host Microsoft.PowerShell.Utility help Get-HotFix Microsoft.PowerShell.Management help Get-Item Microsoft.PowerShell.Management help Get-ItemProperty Microsoft.PowerShell.Management help Get-Job Microsoft.PowerShell.Core help Get-Location Microsoft.PowerShell.Management help Get-Member Microsoft.PowerShell.Utility help Get-Module Microsoft.PowerShell.Core help Get-PfxCertificate Microsoft.PowerShell.Security help Get-Process Microsoft.PowerShell.Management help Get-PSBreakpoint Microsoft.PowerShell.Utility help Get-PSCallStack Microsoft.PowerShell.Utility help Get-PSDrive Microsoft.PowerShell.Management help Get-PSProvider Microsoft.PowerShell.Management help Get-PSSession Microsoft.PowerShell.Core help Get-PSSessionConfiguration Microsoft.PowerShell.Core help Get-PSSnapin Microsoft.PowerShell.Core help Get-Random Microsoft.PowerShell.Utility help Get-Service Microsoft.PowerShell.Management help Get-TraceSource Microsoft.PowerShell.Utility help Get-Transaction Microsoft.PowerShell.Management help Get-UICulture Microsoft.PowerShell.Utility help Get-Unique Microsoft.PowerShell.Utility help Get-Variable Microsoft.PowerShell.Utility help Get-WinEvent Microsoft.PowerShell.Diagnostics help Get-WmiObject Microsoft.PowerShell.Management help Get-WSManCredSSP Microsoft.WSMan.Management help Get-WSManInstance Microsoft.WSMan.Management help Group-Object Microsoft.PowerShell.Utility help Import-Alias Microsoft.PowerShell.Utility help Import-Clixml Microsoft.PowerShell.Utility help Import-Counter Microsoft.PowerShell.Diagnostics help Import-Csv Microsoft.PowerShell.Utility help Import-LocalizedData Microsoft.PowerShell.Utility help Import-Module Microsoft.PowerShell.Core help Import-PSSession Microsoft.PowerShell.Utility help Invoke-Command Microsoft.PowerShell.Core help Invoke-Expression Microsoft.PowerShell.Utility help Invoke-History Microsoft.PowerShell.Core help Invoke-Item Microsoft.PowerShell.Management help Invoke-WmiMethod Microsoft.PowerShell.Management help Invoke-WSManAction Microsoft.WSMan.Management help Join-Path Microsoft.PowerShell.Management help Limit-EventLog Microsoft.PowerShell.Management help Measure-Command Microsoft.PowerShell.Utility help Measure-Object Microsoft.PowerShell.Utility help Move-Item Microsoft.PowerShell.Management help Move-ItemProperty Microsoft.PowerShell.Management help New-Alias Microsoft.PowerShell.Utility help New-Event Microsoft.PowerShell.Utility help New-EventLog Microsoft.PowerShell.Management help New-Item Microsoft.PowerShell.Management help New-ItemProperty Microsoft.PowerShell.Management help New-Module Microsoft.PowerShell.Core help New-ModuleManifest Microsoft.PowerShell.Core help New-Object Microsoft.PowerShell.Utility help New-PSDrive Microsoft.PowerShell.Management help New-PSSession Microsoft.PowerShell.Core help New-PSSessionOption Microsoft.PowerShell.Core help New-Service Microsoft.PowerShell.Management help New-TimeSpan Microsoft.PowerShell.Utility help New-Variable Microsoft.PowerShell.Utility help New-WebServiceProxy Microsoft.PowerShell.Management help New-WSManInstance Microsoft.WSMan.Management help New-WSManSessionOption Microsoft.WSMan.Management help Out-Default Microsoft.PowerShell.Utility help Out-File Microsoft.PowerShell.Utility help Out-GridView Microsoft.PowerShell.Utility help Out-Host Microsoft.PowerShell.Utility help Out-Null Microsoft.PowerShell.Utility help Out-Printer Microsoft.PowerShell.Utility help Out-String Microsoft.PowerShell.Utility help Pop-Location Microsoft.PowerShell.Management help Push-Location Microsoft.PowerShell.Management help Read-Host Microsoft.PowerShell.Utility help Receive-Job Microsoft.PowerShell.Core help Register-EngineEvent Microsoft.PowerShell.Utility help Register-ObjectEvent Microsoft.PowerShell.Utility help Register-PSSessionConfiguration Microsoft.PowerShell.Core help Register-WmiEvent Microsoft.PowerShell.Management help Remove-Computer Microsoft.PowerShell.Management help Remove-Event Microsoft.PowerShell.Utility help Remove-EventLog Microsoft.PowerShell.Management help Remove-Item Microsoft.PowerShell.Management help Remove-ItemProperty Microsoft.PowerShell.Management help Remove-Job Microsoft.PowerShell.Core help Remove-Module Microsoft.PowerShell.Core help Remove-PSBreakpoint Microsoft.PowerShell.Utility help Remove-PSDrive Microsoft.PowerShell.Management help Remove-PSSession Microsoft.PowerShell.Core help Remove-PSSnapin Microsoft.PowerShell.Core help Remove-Variable Microsoft.PowerShell.Utility help Remove-WmiObject Microsoft.PowerShell.Management help Remove-WSManInstance Microsoft.WSMan.Management help Rename-Item Microsoft.PowerShell.Management help Rename-ItemProperty Microsoft.PowerShell.Management help Reset-ComputerMachinePassword Microsoft.PowerShell.Management help Resolve-Path Microsoft.PowerShell.Management help Restart-Computer Microsoft.PowerShell.Management help Restart-Service Microsoft.PowerShell.Management help Restore-Computer Microsoft.PowerShell.Management help Resume-Service Microsoft.PowerShell.Management help Select-Object Microsoft.PowerShell.Utility help Select-String Microsoft.PowerShell.Utility help Select-Xml Microsoft.PowerShell.Utility help Send-MailMessage Microsoft.PowerShell.Utility help Set-Acl Microsoft.PowerShell.Security help Set-Alias Microsoft.PowerShell.Utility help Set-AuthenticodeSignature Microsoft.PowerShell.Security help Set-Content Microsoft.PowerShell.Management help Set-Date Microsoft.PowerShell.Utility help Set-ExecutionPolicy Microsoft.PowerShell.Security help Set-Item Microsoft.PowerShell.Management help Set-ItemProperty Microsoft.PowerShell.Management help Set-Location Microsoft.PowerShell.Management help Set-PSBreakpoint Microsoft.PowerShell.Utility help Set-PSDebug Microsoft.PowerShell.Core help Set-PSSessionConfiguration Microsoft.PowerShell.Core help Set-Service Microsoft.PowerShell.Management help Set-StrictMode Microsoft.PowerShell.Core help Set-TraceSource Microsoft.PowerShell.Utility help Set-Variable Microsoft.PowerShell.Utility help Set-WmiInstance Microsoft.PowerShell.Management help Set-WSManInstance Microsoft.WSMan.Management help Set-WSManQuickConfig Microsoft.WSMan.Management help Show-EventLog Microsoft.PowerShell.Management help Sort-Object Microsoft.PowerShell.Utility help Split-Path Microsoft.PowerShell.Management help Start-Job Microsoft.PowerShell.Core help Start-Process Microsoft.PowerShell.Management help Start-Service Microsoft.PowerShell.Management help Start-Sleep Microsoft.PowerShell.Utility help Start-Transaction Microsoft.PowerShell.Management help Start-Transcript Microsoft.PowerShell.Host help Stop-Computer Microsoft.PowerShell.Management help Stop-Job Microsoft.PowerShell.Core help Stop-Process Microsoft.PowerShell.Management help Stop-Service Microsoft.PowerShell.Management help Stop-Transcript Microsoft.PowerShell.Host help Suspend-Service Microsoft.PowerShell.Management help Tee-Object Microsoft.PowerShell.Utility help Test-ComputerSecureChannel Microsoft.PowerShell.Management help Test-Connection Microsoft.PowerShell.Management help Test-ModuleManifest Microsoft.PowerShell.Core help Test-Path Microsoft.PowerShell.Management help Test-WSMan Microsoft.WSMan.Management help Trace-Command Microsoft.PowerShell.Utility help Undo-Transaction Microsoft.PowerShell.Management help Unregister-Event Microsoft.PowerShell.Utility help Unregister-PSSessionConfiguration Microsoft.PowerShell.Core help Update-FormatData Microsoft.PowerShell.Utility help Update-List Microsoft.PowerShell.Utility help Update-TypeData Microsoft.PowerShell.Utility help Use-Transaction Microsoft.PowerShell.Management help Wait-Event Microsoft.PowerShell.Utility help Wait-Job Microsoft.PowerShell.Core help Wait-Process Microsoft.PowerShell.Management help Where-Object Microsoft.PowerShell.Core help Write-Debug Microsoft.PowerShell.Utility help Write-Error Microsoft.PowerShell.Utility help Write-EventLog Microsoft.PowerShell.Management help Write-Host Microsoft.PowerShell.Utility help Write-Output Microsoft.PowerShell.Utility help Write-Progress Microsoft.PowerShell.Utility help Write-Verbose Microsoft.PowerShell.Utility help Write-Warning Microsoft.PowerShell.Utility help 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-04 日志服务]]></title>
    <url>%2Fwindows-04%2F</url>
    <content type="text"><![CDATA[windows-运维-04 日志服务 打开物理机，右键单击“此电脑”，选择“管理”，点进去 出现“计算机管理”对话框，在左侧“计算机管理（本地local）”—“系统工具”—“事件查看 找到“Windows日志”，双击，观察右侧展开区域的变化 找到右侧区域中的“应用程序”，双击打开 看到非常详细的应用程序信息，其中包括应用程序被打开、修改、权限过户、权限登记、关闭以及重要的出错或者兼容性信息，都一一被记录在内，可以根据关键字、时间排序来搜索定位。 右键单击其中任意一条信息，选择“事件属性Event”，可以看到详细的属性。 右键单击其中任意一条应用程序信息，选择“保存选择的事件”，可以将其详细信息保存在计算机中或者自定义的网络位置。 双击左侧的“安全”，可以将具体的电脑记录的设计安全性的事件信息全都枚举于此，我们普通用户也可以对其进行具体查看和保存、附加程序等。其中带钥匙图案的表示审核通过的事件 双击左侧的“设置”，在右侧就会展开系统设置详细内容，再点击“XML样式”切换到XML样式，其中系统自动生成完整的网页信息，如果想要把这些信息嵌入到你的网页中，那么只需声明正确的CSS样式，就可以完成嵌入。但是最好不要擅自修改这些代码，因为格式的不兼容会导致编译过程中程序出现不可逆的乱码。 双击左侧的“系统”，就可以看到Windows操作系统运行时内核以及上层软硬件之间的运行记录，这里面会记录大量的错误信息，是黑客们分析目标计算机漏洞时最常用到的信息库，如果有时间精力的话最好熟悉错误码，这样的话可以提高分析效率。 本篇到此结束]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-03 活动目录]]></title>
    <url>%2Fwindows-03%2F</url>
    <content type="text"><![CDATA[windows-运维-03 活动目录概述 Active Directory（活动目录）是Windows Server 2003域环境中提供目录服务的组件。目录服务在微软平台上从Windows Server 2000开始引入，所以我们可以理解为活动目录是目录服务在微软平台的一种实现方式。当然目录服务在非微软平台上都有相应的实现。 Windows Server 2012 R2有两种网络环境：工作组和域，默认是工作组网络环境，工作组网络也称为“对等式”的网络，因为网络中每台计算机的地位都是平等的。如下图： 相关概念1.命名空间 命名空间是一个界定好的区域，比如我们把电话簿看成一个“命名空间”，那么我们就可以通过电话簿这个界定好的区域里面的某个人名，找到与这个人名相关的电话、地址以及公司名称等信息。而Windows Server的活动目录就一个命名空间，我们通过活动目录里的对象的名称就可以找到与这个对象相关的信息。活动目录的“命名空间”采用DNS的架构，所以活动目录的域名采用DNS的格式来命名。我们可以把域名命名为feng.com、abc.com等。 2.域、域树、林和组织单元 活动目录的逻辑结构包裹：域（Domain）、域树(Domain Tree)、林（Forest）和组织单元（Organization Unit）。如下图： 域是一种逻辑分组，准确的说是一种环境，域是安全的最小边界。域环境能对网络中的资源集中统一的管理，要想实现域环境，你必须要计算机中安装活动目录。 域树是由一组具有连续命名空间的域组成的。如下图： 其中最上层的域名为feng.com，这个域是这棵域树的根域(root domain)，此根域下面有2个子域,分别是www.feng.com和file.feng.com。从图中我们可以看出他们的命名空间具有连续性。例如，域www.feng.com的后缀名包含着上一层父域的域名feng.com。其实子域www.feng.com和file.feng.com还都可以有自己的子域，图中没有给出而已。 ​ 域树内的所有域共享一个Active Directory(活动目录)，这个活动目录内的数据分散地存储在各个域内，且每一个域只存储该域内的数据，如该域内的用户账户，计算机账户等，Windows Server将存储在各个域内的对象总称为Active Directory。 ​ 林（Forest）是由一棵或多棵域树组成的，每棵域树独享连续的命名空间，不同域树之间没有命名空间的连续性。林中第一棵域树的根域也整个林的根域，同时也是林的名称。 组织单元（OU）是一种容器，它里面可以包含对象（用户账户，计算机账户等），也可以包含其他的组织单元（OU）。 3. 域控制器和站点活动目录的物理结构由域控制器和站点组成。 ​ 域控制器（Domain Controller）是活动目录的存储地方，也就是说活动目录存储在域控制器内。安装了活动目录的计算机就称为域控制器，其实在你第一次安装活动目录的时候，你安装活动目录的那台计算机就成为了域控制器。一个域可以有一台或多台域控制器。最经典的做法是做一个主辅域控。呵呵，这些概念听起来有些咬嘴。 域是逻辑组织形式，它能够对网络中的资源进行统一管理，就像工作组环境对网络进行分散管理一样，要想实现域，必须在一台计算机上安装活动目录才能实现，而安装了活动目录的计算机就称为域控制器（DC）。 当一台域控制器的活动目录数据库发生改动时，这些改动的数据将会复制到其他域控制器的活动目录数据库内。 站点（Site）一般与地理位置相对应。它由一个或几个物理子网组成。创建站点的目的是为了优化DC之间的复制。活动目录允许一个站点可以有多个域，一个域也是可以属于多个站点。 活动目录的优势 Active Directory服务提供了单一登入的能力和一个所有基础设施相关信息的集中储存机制，大幅度的简化了使用者和计算机的管理，同时提供优越的网络资源存取能力。 微软在Windows Server 2000中首次引入了AD技术，经过几年的发展，AD技术已经成为了微软网络架构的核心，几乎所有的产品和技术都是围绕这AD这个核心运转的。可以这么说，在网络中不实现AD，就无法基于微软产品和技术实现基本的网络管理，也无法适应将来的技术发展! 那么到底安装活动目录有什么意义呢?这是所有初学Windows Server的人首要要问的一个问题。因为活动目录并不是Windows系统必需安装的一种服务，要全面理解它又是非常的不容易，那么安装活动目录的意义在哪里呢?它主要体现在以下几个方面： 1、信息的安全性大大增强 2、引入基于策略的管理，使系统的管理更加明朗 3、具有很强的可扩展性 4、具有很强的可伸缩性 5、智能的信息复制能力 6、与 DNS 集成紧密 7、与其他目录服务具有互连性 8、具有灵活的查询 本篇到此结束。]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-02 工作组和域]]></title>
    <url>%2Fwindows-02%2F</url>
    <content type="text"><![CDATA[windows-运维-02 工作组和域什么是工作组？ 工作组（Work Group）是局域网中的一个概念。它是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。 在一个网络内，可能有成百上千台电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。为了解决这一问题，早在Windows 9x/NT/2008就引用了“工作组”这个概念，将不同的电脑一般按功能分别列入不同的组中，如财务部的电脑都列入“财务部”工作组中，人事部的电脑都列入“人事部”工作组中。你要访问某个部门的资源，就在“网上邻居”里找到那个部门的工作组名，双击就可以看到那个部门的电脑了。 那么怎么加入工作组呢？其实很简单，你只需要右击你的Windows桌面上的“网上邻居”，在弹出的菜单出选择“属性”，点击“标识”，在“计算机名”一栏中添入你想好的名字，在“工作组”一栏中添入你想加入的工作组名称。 如果你输入的工作组名称以前没有，那么相当于新建一个工作组，当然只有你的电脑在里面。计算机名和工作组的长度不能超过15个英文字符，可以输入汉字，但是不能超过7个。“计算机说明”是附加信息，不填也可以，但是最好填上一些这台电脑主人的信息，如“技术部主管”等。单击[确定]按钮后，Windows 提示需要重新启动，按要求重新启动之后，再进入“网上邻居”，就可以看到你所在工作组的成员了。 一般来说，同一个工作组内部成员相互交换信息的频率最高，所以你一进入“网上邻居”，首先看到的是你所在工作组的成员。如果要访问其他工作组的成员，需要双击“整个网络”，就会看到网络上所有的工作组，双击工作组名称，就会看到里面的成员。 你也可以退出某个工作组，只要将工作组名称改动即可。不过这样在网上别人照样可以访问你的共享资源，只不过换了一个工作组而已。你可以随便加入同一网络上的任何工作组，也可以离开一个工作组。“工作组”就像一个自由加入和退出的俱乐部一样，它本身的作用仅仅是提供一个“房间”，以方便网上计算机共享资源的浏览。 工作组回忆在说域这个概念之前,我们先来回忆一下工作组. 每一台计算机都独立维护自己的资源,不能集中管理所有网络资源. 每一台计算机都在本地存储用户的帐户 一个账户只能登陆到一台计算机 工作组中计算机都是平等的,对于其他计算机来说即是服务器,也是客户机. 工作组的网络规模一般少于10台计算机. 案例 行业某个哥们小张(某企业网络管理员),刚开始全单位8台计算机,他用的是工作组管理模式。网络配置很轻松,几乎不用管理.哪台机器有问题 就去哪来机器上解决.工作强度也不是很大。不到3个月时间.随着企业信息化的需要,公司的计算机台数增加到了50台.小张采用同样的管理方式。每天都很忙碌,从早上到公司到晚上离开,一直在解决网络中用户的计算机故障问题,病毒\IE首页篡改\甚至出现了公司内部恶意攻击的事件,经常晚上加班,通宵达旦的工作.但问题总是解决不了。一个月后,他被辞退了。为什么会这样呢?有没有更简单方便的管理方式呢? 下面我们来看这么个例子: 如果我们把工作组看成是原始社会,各服务器(人)各自为政，再想想刚刚的例子,小张公司的8台电脑最开始都是各自为政的，所以就不存在管理的概念，小张只能充当一个哪里出问题就去哪解决的故障排除机器般的被动角色。那么在网络日益应用广泛，结构越来越复杂的今天,我们可不可以，让我们的计算机网络世界也进化一下呢？比如在计算机中通过网络成立一个国家,在公司的一定范围内实现集中管理,中央集权！一个国家可以管理的范围只在一个国家内，想做更复杂范围更广阔的管理,需要什么样的体制呢？ 感谢地球,因为我们有联合国、欧盟。实现多个基本管理范围(国家，域)的联合管理，减少这些基本管理范围内的重复管理工作，方便相互之间资源调用。 那么我们继续刚刚的例子，来看看活动目录域的定义 首先谁能加入联合国(活动目录中能放哪些对象) ；其次共同遵守的设定和规则(通用性设定) ；第三不干涉别国内政(各域数据原则上由该数据所在的域进行管理) 。我们何以把活动目录当作一个联合国,其中包括了所有的成员国信息，大家遵守统一的规则,每个成员国各自管理自己的国家。 那么每个成员国以及每个国家中的人(域和域中的计算机)如何去其他国家呢？走什么样的路线呢？国家与国家之间又怎样联系彼此呢？ DNS这个具有全球定位系统服务的管理机构,也就是我们的联合国管理委员会,帮助我们解决了这个问题，准确的定位各个国家的位置，并为各个国民提供了方便的查询服务。 我们想要去某个国家,想在某个国家内享受一个国民的基本权利,比如取得这个国家提供的最低生活保证金(访问域中的网络资源：如共享文件、打印)，就连想要加入某个国家国籍(加入域)都必须通过DNS这个机构为我们指引。 结构关系：域林和树，可以看成联合国和成员国(国家内的省，省内的县市，县市内的村子) 这种管理结构关系 称呼名词。而子域这个名称是相对的，可以看作一个相对某个成员国中的某一个省或者相对某个省的某一个县。 这里有牵扯到一个名词：DC(域控制器，Domain Controller，简写为DC) 。可以把它看成一个国家的首都(也就是一台物理服务器上安装了AD活动目录)。 所有的国民的户籍信息都存储在这里。]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-运维-01 Windows安装以及初始化]]></title>
    <url>%2Fwindows-01%2F</url>
    <content type="text"><![CDATA[windows-运维-01 Windows安装以及初始化概念解析 Windows Server是微软在2003年4月24日推出的Windows 的服务器操作系统，其核心是Microsoft Windows Server System（WSS），每个Windows Server都与其家用（工作站）版对应（2003 R2除外）。 （1）Windows7的服务器版是Windows server 2008 r2 （2）Windows xp的服务器版是Windows server 2003 （3）Windows xp sp的服务器版是Windows server 2003 r2 (稳定性提高，功能拓展) （4）Windows10的服务器版是Windows server 2012 r2 Windows Server 2012（开发代号：Windows Server 8）是微软的一个服务器系统。 这是Windows 8的服务器版本，并且是Windows Server 2008 R2的继任者。该操作系统已经在2012年8月1日 完成编译RTM版，并且在2012年9月4日正式发售。 Windows Server 2012 号称是一款“云操作系统”，它从管理硬件和应用程序扩展到管理服务和技术，让最 终用户、开发人员和IT人员都能享受到云计算的优势。Windows Server 2012 提供了超过300项的新功能， 并包含新一代的Hyper-V 3.0虚拟化技术，同时也是微软首款支持云环境的Server操作系统。Windows Server 2012有句宣传语是“建立在云上”， 是为云而生的 Cloud OS，因此不难理解着奥操作系 统的意图。那么，什么是云技术呢？简而言之，就是利用远程网络服务器（而不是本地服务器）网络来存 储、管理和处理数据。 从运算层、储存层到网络层都可与云端嫁接，Windows Server 2012 完全为云端运算的资源集中、灵活 度、自助服务和使用调配等特性而设计，并可支持各种云端服务，并能够直接连接 Windows Azure 公有云 作业环境，让企业的云端架设方案更有弹性。Windows Server 2012 R2版本将这些技术扩展到企业，并以同样的方式应用于这些企业的员工。所有企业 数据都可现场或远程通过虚拟机或个人工作站直接备份到云中。在当下和未来，云技术都是世界商业发展 的驱动力。 Windows Server 2012 R2新增的功能 · 用户界面的重大变化 · 新增的Action Directory功能，增强了部署和可管理性 · 添加了Hyper-V的新技术 · 对Windows组网技术的增强，使之更快速、更安全 · 新增的管理工具 · IIS 8.0 的重要特性 Windows Server安装在“msdn，我告诉你”网站上可以下载实验所需的Windows Server 2012 R2，网址： https://msdn.itellyou.cn/ 如图，下载cn_windows_server_2012_r2_x64_dvd_2707961版本的即可。 接下来安装虚拟机，安装过程很简单，下面几个选项注意一下即可： 1.选Windows server 2012 2.安装一个名称为WinNew的虚拟机，位置自选，但是路径中不要有中文目录。 3.选择BIOS 4.用我们刚刚下载下来的那个cn_windows_server_2012_r2_x64_dvd_2707961镜像 5.内存和CPU可以稍微给大点，给物理机的一般内核、内存就好。开启此虚拟机，即可开始安装。 6.这里要输入密钥，还只能手动输入，只能慢慢敲了： 1NB4WH-BBBYV-3MPPC-9RCMV-46XCB 7.选择带有GUI的服务器的那个 8.选自定义 9.然后点下一步即可开始安装了，安装好后好设置用户名密码，登录即可使用Windows Server了。如下图，作为一台服务器，显然不适合设置太过简单的密码。最好包括数字大小写字母加符号就很好。 10.关机保存快照，以后玩坏了还可以恢复快照，不用重装。 11.关于虚拟机屏幕解锁，如下图，是需要按Ctrl+Alt+Delete的，然而一旦按了连咱们的物理机都会受到牵连。然后就会看到如下图的提示： 原来，如果不想让物理机也受到牵连的话，可以用Ctrl+Alt+Insert来解锁。 Windows Server安装后的初始化1.桌面右键，调整屏幕分辨率 调整为1680X1050比较合适，当然，主要看个人喜好。 2.关闭windows防火墙进入控制面板，进入防火墙功能，关闭防火墙 3.开启远程桌面 5.查看windows server的ip用win+r输入cmd，然后用ipconfig命令查看windows server的ip：192.168.141.74 6.物理机远程连接到服务器 任何服务器的日常管理都极少在服务器本身上进行，相反，管理员通常都是远程连接到服务器对服务 器进行日常管理。 远程桌面协议（RDP, Remote Desktop Protocol）是一个多通道（multi-channel）的协议，让用户 （客户端或称“本地电脑”）连上提供微软终端机服务的电脑（服务器端或称“远程电脑”）。大部 分的Windows都有客户端所需软件。其他操作系统也有这些客户端软件，例如 Linux、FreeBSD、Mac OS X。服务端电脑方面，则听取送到TCP3389端口的数据。 3389 UDP 网络环境差针对UDP的优化，默认用tcp传输，网络环境差，改为使用udp协议。Remote Desktop for Administration 是远程桌面服务（Remote Desktop Service，RDS）在 Windows Server 2012 R2服务器上的默认实现。在这种模式中，同时最多只有两名管理员可以远程登录服务器进行远程管理。 命令：mstsc（Microsoft terminal services client） win+r，然后输入mstsc回车如下图： 输入windows server的ip，用户名Administrator，如下图： 然后输入windows server的登录密码即可连接成功 我们关掉这次远程连接，再来一次，将它另存为一个文件，就叫WinNew吧！ 以后我们想要远程连接虚拟机WinNew，可以直接双击这个rdp文件即可，很方便。 设置固定ip 检测网络连通性 关闭IESec安全组件 为方便实用IE浏览器，建议关闭IESec组件（生产环境中不建议这么做，生产环境比如你在腾讯云买了一台服务器，服务器装的是这个系统，或者你工作时公司的服务器，关了就不安全了） 开启隐藏文件可见和显示文件后缀名为安全和方便实用开启这两项功能 修改计算机名称就修改为WinNew吧，计算机描述也修改为WinNew。 另外，远程桌面靠复制粘贴共享文件，你的物理机里的文件复制下来，可以粘贴到虚拟机里面。但是直接用鼠标拖拽拖不进去。 好了，基本设置都已经完成了，关机保存快照。 本篇到此结束。]]></content>
      <categories>
        <category>windows</category>
        <category>windows-系统运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-32 Zabbix部署]]></title>
    <url>%2Flinux-32%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-32 Zabbix部署概念解析 zabbix是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。zabbix由2部分构成，zabbix server与可选组件zabbix agent。zabbix server可以通过SNMP，zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux，Solaris，HP-UX，AIX，Free BSD，Open BSD，OS X等平台上。 其他开源监控软件：zabbix、cacti、nagios被称为三大监控软件，俗称监控三剑客但它们都是英文界面，而owl是国产监控软件，有时间的话这些监控软件都应该去了解一下。 另外，想从事系统运维方面工作的，可以多在开源中国社区学一下zabbix的使用，以及如何处理各种问题等，下面就先了解一下zabbix最基础的部分吧！ 环境部署安装lanmp或者lnmp框架 为运行zabbix提供环境，此处以安装lamp为例 1[root@localhost ~]# yum install mariadb mariadb-server httpd php php-mysql -y 初始化mariadb数据库服务 123456789101112[root@localhost ~]# setenforce 0[root@localhost ~]# systemctl restart httpd[root@localhost ~]# systemctl enable httpd[root@localhost ~]# systemctl restart mariadb[root@localhost ~]# systemctl enable mariadbCreated symlink from /etc/systemd/system/multi-user.target.wants/mariadb.service to /usr/lib/systemd/system/mariadb.service.[root@localhost ~]# firewall-cmd --add-port=3306/tcp --permanent success[root@localhost ~]# firewall-cmd --add-port=80/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --reloadsuccess 初始化数据库 设置root管理员在数据库中的密码值（注意，该密码并非root管理员在系统中的密码，这里的密码值默认应该为空，可直接按回车键）。 设置root管理员在数据库中的专有密码。 随后删除匿名账户，并使用root管理员从远程登录数据库，以确保数据库上运行的业务的安全性。 删除默认的测试数据库，取消测试数据库的一系列访问权限。 刷新授权列表，让初始化的设定立即生效。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263[root@localhost ~]# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&apos;ll need the currentpassword for the root user. If you&apos;ve just installed MariaDB, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] yNew password: Re-enter new password: Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from &apos;localhost&apos;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] y ... Success!By default, MariaDB comes with a database named &apos;test&apos; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you&apos;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB![root@localhost ~]# 安装zabbix导入zabbix源1[root@localhost ~]# rpm -ivh http://repo.zabbix.com/zabbix/3.2/rhel/7/x86_64/zabbix-release-3.2-1.el7.noarch.rpm 安装zabbix包1[root@localhost ~]# yum -y install zabbix-server-mysql zabbix-web-mysql 配置数据库12345678910111213141516171819[root@localhost ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 10Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; create database zabbix character set utf8 collate utf8_bin;Query OK, 1 row affected (0.00 sec)MariaDB [(none)]&gt; grant all privileges on zabbix.* to zabbix@localhost identified by &apos;zabbix&apos;;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; quitBye[root@localhost ~]# 导入数据12345[root@localhost ~]# cd /usr/share/doc/zabbix-server-mysql-3.2.11/[root@localhost zabbix-server-mysql-3.2.11]# zcat create.sql.gz | mysql -uroot -p zabbixEnter password: [root@localhost zabbix-server-mysql-3.2.11]# cd[root@localhost ~]# 修改zabbix配置文件12345[root@localhost ~]# vim /etc/zabbix/zabbix_server.conf 81 DBHost=localhost91 DBName=zabbix107 DBUser=zabbix115 DBPassword=zabbix 编辑zabbix前端的PHP配合配置12[root@localhost ~]# vim /etc/httpd/conf.d/zabbix.conf19 php_value date.timezone Asia/Shanghai 调整时间同步安装 ntpdate，使用ntpdate同步时间 12[root@localhost ~]# yum install ntpdate -y[root@localhost ~]# ntpdate cn.pool.ntp.org 启动zabbix和apache服务1234[root@localhost ~]# systemctl restart zabbix-server[root@localhost ~]# systemctl enable zabbix-server[root@localhost ~]# systemctl restart httpd[root@localhost ~]# systemctl enable httpd 登录zabbix先查到自己zabbix服务器也就是你的虚拟机的ip 浏览器打开： 1234http://IP/zabbix/http://IP/zabbix/setup.php默认用户名/密码：Admin/zabbix 安装过程 这里连接数据库要填密码，填咱们之前设好的“zabbix”即可。 然后随便想一个主机名 默认用户名/密码：Admin/zabbix 登录上去后是这个样子的 将语言设置为中文 监控zabbix服务器自己本身监控zabbix服务器自己本身默认是停用的，我们可以点击“停用的”那里对它进行启用 启用之后，可以看到“可用性”那里全是灰色的，可用性指的是使用什么插件或者协议去监控，这里说明这些协议都未生效 为了让其中的ZBX生效，我们需要安装并且重启zabbix-agent 12[root@localhost ~]# yum install zabbix-agent -y[root@localhost ~]# systemctl restart zabbix-agent 安装好之后，查看主机状态是否已启用，可用性是否亮绿灯，网上说红灯绿灯都是正常的，我的是红灯说明状态已经正常，但是连接是失败的。 我们把鼠标悬停在红色的ZBX标志那里，可以发现是端口111未被防火墙放行 我们回到zabbix服务器，放行相关端口。另外，zabbix和zabbix-agent的端口分别是10050和10051，顺带也放行了 123456789[root@localhost ~]# firewall-cmd --add-port=111/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --add-port=10050/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --add-port=10051/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# systemctl restart zabbix-agent 放行这些端口之后，回到浏览器，要稍等一会儿，才能看到ZBX标志变成绿色了。这表示已经正常监控了zabbix服务器了 可以切换到图形监控界面，如下图，可以很直观看到zabbix服务器的cpu相关运行参数变化情况 监控Linux主机给Linux客户端安装上代理程序随便开启一台赶紧的centos虚拟机作为客户端，这里我开启的虚拟机ip是192.168.141.53 导入zabbix源1[root@localhost ~]# rpm -ivh http://repo.zabbix.com/zabbix/3.2/rhel/7/x86_64/zabbix-release-3.2-1.el7.noarch.rpm 安装zabbix代理程序下面两个ip填你的zabbix服务器ip即可。 12345[root@localhost ~]# yum -y install zabbix-agent[root@server zabbix-server-mysql-3.2.11]# vim /etc/zabbix/zabbix_agentd.conf 95 Server=192.168.141.12136 ServerActive=192.168.141.12[root@server zabbix-server-mysql-3.2.11]# systemctl restart zabbix-agent.service 回到浏览器，添加对客户机的监控 先选择模板，记住要选择后要添加到“链接的模板”的那个框里面，最后在点击更新 添加主机，填上客户机的ip 添加完成后可以看到 客户端放行相关端口，重启zabbix代理服务 123456789[root@localhost ~]# firewall-cmd --add-port=111/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --add-port=10050/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --add-port=10051/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# systemctl restart zabbix-agent 然后可以看到该客户端的ZBX标志变绿了，说明可用了 可以看到其运行数据，不过本来也没有监控几分钟，所以只能看到这么点儿 监控windows我们的物理机电脑也可以被zabbix服务器所监控，但是需要下载代理组件 可以到zabbix官网：https://www.zabbix.com/自己找 也可以按照下面这个链接下载windows agent https://www.zabbix.com/downloads/3.2.0/zabbix_agents_3.2.0.win.zip 关闭windows防火墙（本次实验完再打开） 解压zabbix_agents_3.2.0.win.zip压缩包 在windows系统中c盘根目录下新建一个目录，将解压后的zabbix_agents_3.2.0.win中bin\win64（看系统具体32位或者64位来选）下的文件和conf下的配置文件，放到新建的zabbix目录下 修改C:\zabbix\zabbix_agentd.win.conf文件（建议用notepad++） 123462 EnableRemoteCommands=171 LogRemoteCommands=184 Server=192.168.141.12136 Hostname=wintest01 windows下按win+x，点击Windows PowerShell(管理员)(A)，然后进行以下操作运行zabbix agent服务 123456789PS C:\WINDOWS\system32&gt; cmdC:\WINDOWS\system32&gt;cd C:\zabbixC:\zabbix&gt;zabbix_agentd.exe -i -c zabbix_agentd.win.confzabbix_agentd.exe [4964]: service [Zabbix Agent] installed successfullyzabbix_agentd.exe [4964]: event source [Zabbix Agent] installed successfullyC:\zabbix&gt;zabbix_agentd.exe -s -c zabbix_agentd.win.confzabbix_agentd.exe [6328]: service [Zabbix Agent] started successfully 回到浏览器，创建windows主机群组 创建windows主机，名称叫做wintest01 先用cmd查看你电脑ip，记住要看哪个和zabbix服务器在同一个网段的那个ip 1ipconfig 可以看到我的ip是192.168.141.1 创建完成，单击wintest01主机 给它配置模板 回到主机那里，点击将它停用，然后再点击一次将它启用，可以看到ZBX从灰色变为红色 等40秒就好了，就变绿色了 和之前一样，可以看看监控图形 实验做完了，别忘了以管理员模式打开powershell再卸载掉zabbix 1234567891011PS C:\WINDOWS\system32&gt; cmdMicrosoft Windows [版本 10.0.17763.195](c) 2018 Microsoft Corporation。保留所有权利。C:\WINDOWS\system32&gt;cd C:\zabbixC:\zabbix&gt;zabbix_agentd.exe -d -c zabbix_agentd.win.confzabbix_agentd.exe [17148]: service [Zabbix Agent] uninstalled successfullyzabbix_agentd.exe [17148]: event source [Zabbix Agent] uninstalled successfullyC:\zabbix&gt; 实验做完了，别忘了你自己电脑的防火墙可以开回去了。 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-31 OpenSSL实现CA证书]]></title>
    <url>%2Flinux-31%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-31 OpenSSL实现CA证书OpenSSL实现CA证书什么是CA CA,Catificate Authority,通俗的理解就是一种认证机制。它的作用就是提供证书（也就是服务端证书，由域名，公司信息，序列号，签名信息等等组成）来加强客户端与服务器端访问信息的安全性，同时提供证书的发放等相关工作。国内的大部分互联网公司都在国际CA机构申请了CA证书，并且在用户进行访问的时候，对用户的信息加密，保障了用户的信息安全。理论上来说，任何组织或者个人都可以扮演CA的角色，只不过，难以得到客户端的信任，不能推而广之，最典型应用莫过于12306网站，这个网站就是自己给自己颁发的根证书。 目前能够让浏览器默认支持的CA大厂有很多，Windows 操作系统在安装之初，也默认安装了很多受信任的根证书。可以通过控制面板–Internet选项来进行查看。 另外，可以将证书理解为带有额外信息的公钥。 SSL/TLS SSL/TLS是网络通信过程中非常重要的两个协议。互联网的通信安全就建立在SSL/TLS协议基础之上。他们通过一系列的加密行为保障了通信的安全，是如今互联网通信最主要的应用之一。 SSL/TLS是一个很大的互联网应用，关于他们的介绍互联网上有很多，我们暂时不做详细的介绍。关于SSL/TLS通信的过程大致可以用下面的这张图来进行描述。 十六字真诀公钥加密，私钥解密私钥签章，公钥验签 实验准备CA服务器：192.168.141.132 客户机：192.168.141.69 物理机（就是你的电脑） OpenSSL OpenSSL是一套开源软件，在Linux中可以很容易的安装。它能够很容易的完成密钥生成以及证书管理。我们接下来就利用OpenSSL搭建CA证书，并实现证书的申请与分发。 1[root@localhost ~]# yum install openssl –y CA配置 要手动创建CA证书，就必须首先了解，OpenSSL中关于CA的配置，配置文件位于下面的/etc/pki/tls/openssl.cnf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[root@localhost ~]# cat /etc/pki/tls/openssl.cnf####################################################################[ ca ]default_ca= CA_default #默认CA####################################################################[ CA_default ]dir=/etc/pki/CA # CA的工作目录这里其实是定义了一个变量certs= $dir/certs # 证书存储路径crl_dir= $dir/crl # 证书吊销列表database= $dir/index.txt # 证书数据库列表new_certs_dir= $dir/newcerts #新的证书路径certificate = $dir/cacert.pem # CA自己的证书serial= $dir/serial #下一个证书的编号，十六进制，默认00crlnumber= $dir/crlnumber #下一个要被吊销的证书编号，十六进制，默认00crl = $dir/crl.pem # The current CRLprivate_key = $dir/private/cakey.pem # CA 的私钥RANDFILE= $dir/private/.rand # private random number filex509_extensions = usr_cert # The extentions to add to the cert# Comment out the following two lines for the &quot;traditional&quot;# (and highly broken) format.name_opt = ca_default # 命名方式cert_opt = ca_default # CA的选项default_days= 365 # 默认证书的有效期限default_crl_days= 30 # how long before next CRLdefault_md= default # use public key default MDpreserve= no # keep passed DN orderingpolicy= policy_match #策略 #这里记录的是 将来CA在搭建的时候，以及客户端申请证书的时候， 需要提交的信息的匹配程度。[ policy_match ] # match意味着CA以及子CA必须一致countryName = match # 国家stateOrProvinceName= match # 州或者省organizationName= match #组织公司organizationalUnitName = optionalcommonName= suppliedemailAddress= optional[ policy_anything ] #可以对外提供证书申请，这时，证书的匹配就可以不用那么严格countryName = optionalstateOrProvinceName = optionallocalityName= optionalorganizationName= optionalorganizationalUnitName = optionalcommonName = suppliedemailAddress= optional 找到配置文件中指定的路径 12[root@localhost ~]# cat /etc/pki/tls/openssl.cnf | grep dirdir = /etc/pki/CA # Where everything is kept 可以看到路径 /etc/pki/CA 创建所需要的文件 这里有一点需要注意，我们的实验环境中包含了一个主机，如果不提前创建这两个文件，那么在生成证书的过程中会出现错误。 我们将文件创建在配置文件中指定的路径下面。 12345生成证书索引数据库文件 [root@localhost ~]# touch /etc/pki/CA/index.txt指定第一个颁发证书的序列号 [root@localhost ~]# echo 01 &gt; /etc/pki/CA/serial CA 自签名证书(构造根CA)首先构造根CA的证书。因为没有任何机构能够给根CA颁发证书，所以只能根CA自己给自己颁发证书。 首先生成私钥文件cakey.pem1234567[root@localhost ~]# openssl genrsa -out /etc/pki/CA/private/cakey.pem -des3 2048Generating RSA private key, 2048 bit long modulus...............+++.......................................+++e is 65537 (0x10001)Enter pass phrase for /etc/pki/CA/private/cakey.pem: #这里需要输入密码（ pass phrase ）Verifying - Enter pass phrase for /etc/pki/CA/private/cakey.pem: #这里确认密码 更具私钥文件cakey.pem生成自签名证书cacert.pem1234567891011121314151617[root@localhost ~]# openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -days 7300 -out /etc/pki/CA/cacert.pemEnter pass phrase for /etc/pki/CA/private/cakey.pem:You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [XX]:CN #中国State or Province Name (full name) []:js #江苏Locality Name (eg, city) [Default City]:zj #镇江Organization Name (eg, company) [Default Company Ltd]:fengOrganizational Unit Name (eg, section) []:caCommon Name (eg, your name or your server&apos;s hostname) []:ca.feng.comEmail Address []:admin@feng.com[root@localhost ~]# 查看生成的证书cacert.pem1234[root@localhost ~]# cd /etc/pki/CA/[root@localhost CA]# lscacert.pem certs crl index.txt newcerts private serial[root@localhost CA]# cat cacert.pem 关闭selinux123[root@localhost CA]# cd[root@localhost ~]# setenforce 0[root@localhost ~]# 颁发证书（客户端申请证书）为客户端颁发ssl证书 客户端首先产生一个私钥以及证书请求的公钥 客户端将公钥发给CA服务器 CA服务器为客户端颁发数字签名再传回客户机 我们再开一台虚拟机作为客户端，由于它不是CA服务器，所以就不在/etc/pki/CA/目录下生成私钥和证书等文件了，咱们另外建一个目录来搞。 客户端首先在/root/key/目录下生成一个私钥https.key1234567[root@localhost ~]# yum install openssl -y #客户端也要装ssl套件[root@localhost ~]# mkdir key[root@localhost ~]# openssl genrsa -out /root/key/https.key 2048Generating RSA private key, 2048 bit long modulus............................+++.................+++e is 65537 (0x10001) 客户端再用私钥https.key生成证书请求https.csr123456789101112131415161718192021[root@localhost ~]# openssl req -new -key /root/key/https.key -out /root/key/https.csr -days 365You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [XX]:CNState or Province Name (full name) []:jsLocality Name (eg, city) [Default City]:zjOrganization Name (eg, company) [Default Company Ltd]:fengOrganizational Unit Name (eg, section) []:techCommon Name (eg, your name or your server&apos;s hostname) []:192.168.141.69Email Address []:admin@feng.comPlease enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []:123456An optional company name []:feng[root@localhost ~]# 客户端将证书请求文件https.csr传到CA服务器的/etc/pki/CA目录下123456789101112[root@localhost ~]# cd key[root@localhost key]# lshttps.csr https.key[root@localhost key]# scp https.csr 192.168.141.132:/etc/pki/CAThe authenticity of host &apos;192.168.141.132 (192.168.141.132)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:mJVa6J0b/NaWyJ+cbVho0hHnUDY9utS7iWUGq91HvpM.ECDSA key fingerprint is MD5:d3:6c:dc:1c:76:df:3a:d1:b9:ef:6c:17:82:64:76:6e.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.141.132&apos; (ECDSA) to the list of known hosts.root@192.168.141.132&apos;s password: https.csr 100% 1090 699.6KB/s 00:00 [root@localhost key]# CA根据客户机发过来的证书请求https.csr生产数字签名https.crt123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@localhost ~]# cd /etc/pki/CA[root@localhost CA]# openssl ca -in https.csr -out https.crt -days 365Using configuration from /etc/pki/tls/openssl.cnfEnter pass phrase for /etc/pki/CA/private/cakey.pem:Check that the request matches the signatureSignature okCertificate Details: Serial Number: 1 (0x1) Validity Not Before: Feb 17 08:07:23 2019 GMT Not After : Feb 17 08:07:23 2020 GMT Subject: countryName = CN stateOrProvinceName = js organizationName = feng organizationalUnitName = tech commonName = 192.168.141.69 emailAddress = admin@feng.com X509v3 extensions: X509v3 Basic Constraints: CA:FALSE Netscape Comment: OpenSSL Generated Certificate X509v3 Subject Key Identifier: 5C:83:77:55:09:E6:6F:BF:5A:0E:7A:D4:45:64:8B:28:81:0A:70:6B X509v3 Authority Key Identifier: keyid:A0:D2:8C:72:63:CE:16:D6:EE:DF:B6:5F:85:C1:57:06:D1:A2:CA:98Certificate is to be certified until Feb 17 08:07:23 2020 GMT (365 days)Sign the certificate? [y/n]:y1 out of 1 certificate requests certified, commit? [y/n]yWrite out database with 1 new entriesData Base Updated[root@localhost CA]# lscacert.pem crl https.csr index.txt.attr newcerts serialcerts https.crt index.txt index.txt.old private serial.old[root@localhost CA]# CA自己的私钥文件cakey.pemCA的自签名证书cacert.pem客户机发过来的证书请求https.csrCA根据https.csr产生数字签名https.crt CA将生产好的数字签名再传回客户机123456789[root@localhost CA]# scp https.crt 192.168.141.69:/root/keyThe authenticity of host &apos;192.168.141.69 (192.168.141.69)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:GxQcqZQLnGUvawOktRB9hLYZZA0ScnEsN3USeyTghgU.ECDSA key fingerprint is MD5:d6:d5:c1:df:2b:47:22:55:4d:1a:a3:f2:63:50:d9:b7.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.141.69&apos; (ECDSA) to the list of known hosts.root@192.168.141.69&apos;s password: https.crt 100% 4551 2.7MB/s 00:00 [root@localhost CA]# 切换到客户机，看一下的确传过来了123[root@localhost key]# lshttps.crt https.csr https.key[root@localhost key]# ​ 接下来客户机将自己的密钥https.key传给CA，由CA生成证书cacert.pem传回给客户机。为了不冲突，在CA服务器上新建一个目录/root/test 12[root@localhost ~]# mkdir test[root@localhost ~]# 客户机将自己的密钥https.key传给CA1234[root@localhost key]# scp https.key 192.168.141.132:/root/testroot@192.168.141.132&apos;s password: https.key 100% 1675 447.2KB/s 00:00 [root@localhost key]# 由CA生成证书cacert.pem12345678910111213141516[root@localhost ~]# openssl req -new -x509 -key /root/test/https.key -days 7300 -out /root/test/cacert.pemYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [XX]:CNState or Province Name (full name) []:jsLocality Name (eg, city) [Default City]:zjOrganization Name (eg, company) [Default Company Ltd]:fengOrganizational Unit Name (eg, section) []:techCommon Name (eg, your name or your server&apos;s hostname) []:192.168.141.69Email Address []:admin@feng.com[root@localhost ~]# CA服务器将证书传给客户机1234567[root@localhost ~]# cd test/[root@localhost test]# lscacert.pem https.key[root@localhost test]# scp cacert.pem 192.168.141.69:/etc/pki/CAroot@192.168.141.69&apos;s password: cacert.pem 100% 1375 1.0MB/s 00:00 [root@localhost test]# 切换到客户机，看一下的确传过来了1234[root@localhost key]# cd /etc/pki/CA[root@localhost CA]# lscacert.pem certs crl newcerts private[root@localhost CA]# 客户机使用https保护网站 原理：比如人们访问网站http://test.feng.com，这个网站又搭建在客户机192.168.141.69上，那么客户机就需要向CA服务器申请到数字签名，这样安装了相应证书的电脑就可以访问https://test.feng.com了。刚刚我们的客户机已经成功申请到了数字签名，现在咱们在客户机上搭网站，只有一个默认网页“Testing……”，用来看证书使用效果即可。 安装apache和mod_ssl模块 12[root@localhost key]# cd[root@localhost ~]# yum install httpd mod_ssl -y 修改配置文件12345[root@localhost ~]# vim /etc/httpd/conf.d/ssl.conf100 SSLCertificateFile /root/key/https.crt107 SSLCertificateKeyFile /root/key/https.key122 SSLCACertificateFile /etc/pki/CA/cacert.pem 放行443端口和https服务，关闭selinux，重启apache服务1234567[root@localhost ~]# firewall-cmd --add-port=&#123;443,80&#125;/tcp --permanent success[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# setenforce 0[root@localhost ~]# [root@localhost ~]# systemctl restart httpd 这里重启apache服务要放到最后，否则会报错。 windows导入根CA证书 将根linux的证书（就是CA服务器生成的自签名证书，ca.feng.com的那个cacert.pem）导出到windows上，然后将后缀名改为.crt，打开后点击安装证书 1234[root@localhost ~]# yum install lrzsz -y[root@localhost ~]# sz /etc/pki/CA/cacert.pem[root@localhost ~]# 导出到自己电脑，如下图，改其后缀为crt，双击它开始安装证书。 如上图，打开这个CA的自签名证书后就可以看到，颁发者和颁发给都是ca.feng.com，且不受信任，证书信息的标志那里都是一个大大的红色叉叉，我们需要手动安装这个证书，安装到本地计算机后，就受信任了，表示本地计算机信任了这个证书机构给它自己办法的证书。 选择本地计算机，然后点击下一步 安装证书，最后下一步点完成 查看证书 win+r，输入certmgr.msc点击确定即可 我们安装的证书是CA的自签名证书，名字叫做ca.feng.com，安装好之后，我们的电脑会对这个CA机构产生充分的信任，且对于这个CA机构颁发给任何网站的证书都会信任。之前我们的客户机：192.168.141.69搭建了apache服务，也算是有了一个网站了，虽然其网站主页还是下面这个“Testing 123”的页面，但是这个不妨碍我们的浏览器对其网站证书进行安全分析。 如下图，我们打开https://192.168.141.69，会看到它的证书来自于ca.feng.com。之前我们的客户机192.168.141.69向CA服务器申请到的证书，现在就发挥了它的作用了，让我们的浏览器得以信任这个网站的证书，同时，由于mod_ssl模块是支持”https“中的“s”的，所以也能用https打开这个网址。 访问网站 吊销证书吊销证书是CA机构做的事，我们不用去做，这里只做方法演示。吊销不会立即生效，要等网站重启。 在根CA上根据客户提交的serial与subject信息，对比检验是否与index.txt文件中的信息一致，然后吊销证书 # 吊销子客户端的证书 使用revoke 命令 123456[root@localhost CA]# openssl ca -revoke /etc/pki/CA/https.crtUsing configuration from /etc/pki/tls/openssl.cnfEnter pass phrase for /etc/pki/CA/private/cakey.pem:Revoking Certificate 01.Data Base Updated[root@localhost CA]# 指定第一个吊销证书的编号（指定吊销证书的编号，只有在更新证书吊销列表之前，才需要操作） 123456# 这条命令与生成证书时指定证书serial 号码的作用是一致的。# 就是说，指定下一个证书吊销时的编号。[root@localhost CA]# echo 01 &gt; /etc/pki/CA/crlnumber[root@localhost CA]# cat /etc/pki/CA/crlnumber01[root@localhost CA]# 更新证书吊销列表前面指定了证书吊销列表编号之后，就可以来更新证书吊销列表了。 1234[root@localhost CA]# openssl ca -gencrl -out /etc/pki/CA/crl/crl.pemUsing configuration from /etc/pki/tls/openssl.cnfEnter pass phrase for /etc/pki/CA/private/cakey.pem: #这里提示输入密码[root@localhost CA]# 查看证书吊销列表的文件 123456789101112131415161718192021222324252627282930[root@localhost CA]# openssl crl -in /etc/pki/CA/crl/crl.pem -noout -text Certificate Revocation List (CRL): Version 2 (0x1) Signature Algorithm: sha256WithRSAEncryption Issuer: /C=CN/ST=js/L=zj/O=feng/OU=tech/CN=ca.feng.com/emailAddress=admin@feng.com Last Update: Feb 17 08:55:41 2019 GMT Next Update: Mar 19 08:55:41 2019 GMT CRL extensions: X509v3 CRL Number: 1Revoked Certificates: Serial Number: 01 Revocation Date: Feb 17 08:54:31 2019 GMT Signature Algorithm: sha256WithRSAEncryption 2e:c5:24:2e:00:ec:bb:58:b5:6a:87:49:7a:1d:f9:5d:e6:83: bd:af:51:49:63:96:49:7a:c7:74:6d:bd:5f:fb:87:65:35:9d: 62:98:0a:42:56:19:67:9a:9f:1e:27:e1:dc:70:36:e6:32:c6: 02:e8:e8:25:1c:15:2e:ab:82:af:54:f7:80:bb:d2:dc:84:a3: 6f:b2:72:70:95:81:18:55:7e:c7:fc:fd:8b:5b:b2:d6:ab:c3: 64:64:89:38:86:dd:28:53:ea:36:64:05:84:88:62:77:a3:2f: 0e:ae:d6:76:64:de:ea:f6:8b:fa:eb:63:0e:ff:13:16:bc:b1: 62:bf:32:99:50:e5:86:2d:95:b8:e7:15:93:86:78:6f:b3:22: 6a:af:7b:43:9d:61:33:ac:65:c1:26:a4:6f:6d:74:91:69:69: 04:36:ca:7e:d0:42:45:12:07:37:4a:f1:2a:a8:45:01:a5:5b: 43:77:fb:6e:26:fc:16:09:d1:f3:44:2e:d0:e7:96:0a:75:af: 50:c2:b7:41:f5:9f:d2:0f:58:92:75:0b:81:d2:99:5c:5c:79: 6a:a8:59:b9:0e:cd:0a:e9:4f:f2:a4:8d:5a:d5:71:8d:6c:b4: f2:f8:0b:7a:cf:9f:6e:43:b5:de:2a:15:84:0c:40:c0:3f:5a: 75:fb:f5:9c[root@localhost CA]# 吊销不会立即生效，要等网站重启，这里在客户机重启apache服务 1[root@localhost ~]# systemctl restart httpd 查看吊销后的结果 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-30 KVM]]></title>
    <url>%2Flinux-30%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-30 KVMKVM概念解析 Kernel-based Virtual Machine的简称，是一个开源的系统虚拟化模块，自Linux 2.6.20之后集成在Linux的各个主要发行版本中。它使用Linux自身的调度器进行管理，所以相对于Xen，其核心源码很少。KVM目前已成为学术界的主流VMM（ Virtual Machine Monitor,虚拟机监控器）之一。 检测虚拟化功能 如下图，把这个勾勾上，另外，做实验用的Server处理器和内存调大一些，因为接下来咱们要在虚拟机Server里新建虚拟机，也就是所谓的“虚拟机里的虚拟机”。 ​ 加一张桥接模式的网卡 KVM 是基于 x86 虚拟化扩展(Intel VT 或者 AMD-V) 技术的虚拟机软件，所以查看 CPU 是否支持 VT 技术，就可以判断是否支持KVM。有返回结果，如果结果中有vmx（Intel）或svm(AMD)字样，就说明CPU的支持的。 123[root@localhost ~]# cat /proc/cpuinfo | egrep &apos;vmx|svm&apos;请看下图： ​ 关掉防火墙，关闭SELinux，将 /etc/sysconfig/selinux 中的 SELinux=enforcing 修改为 SELinux=disabled，这里注意，改了重启后才生效。 1234567891011121314151617181920[root@localhost ~]# systemctl stop firewalld[root@localhost ~]# systemctl disable firewalldRemoved symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.[root@localhost ~]# [root@localhost ~]# vim /etc/sysconfig/selinuxSELINUX=disabled保存退出[root@localhost ~]# getenforce Enforcing[root@localhost ~]# reboot重启后再次查看：[root@localhost ~]# getenforce Disabled[root@localhost ~]# 说明已经关闭了selinux 安装kvm环境通过 yum 安装 kvm 基础包和管理工具 kvm相关安装包及其作用: qemu-kvm 主要的KVM程序包 python-virtinst 创建虚拟机所需要的命令行工具和程序库 virt-manager GUI虚拟机管理工具 virt-top 虚拟机统计命令 virt-viewer GUI连接程序，连接到已配置好的虚拟机 libvirt C语言工具包，提供libvirt服务 libvirt-client 为虚拟客户机提供的C语言工具包 virt-install 基于libvirt服务的虚拟机创建命令 bridge-utils 创建和管理桥接设备的工具 12345678910111213141516171819安装kvm基础包和管理工具[root@localhost ~]# yum -y install qemu-kvm python-virtinst libvirt libvirt-python virt-manager libguestfs-tools bridge-utils virt-install python-virtualenv 其中有一个安装包python-virtinst特别坑，以前是可以直接用yum安装成功的，但是现在yum软件仓库里已经没有这个包了，即使是用命令：yum install epel-release安装并启用EPEL源后，也依然会提示没有可用包python-virtinst。yum软件仓库里没有，rpm软件仓库里倒是有，但是我尝试了n个版本，不是与这个冲突就是和那个矛盾，能把人气死，最后利用github开源出来的python-virtinst包安装终于成功了，实验才得以继续下去。 另外，如果你的python-virtinst包没有安装成功的话，后面虚拟机里安装虚拟机的时候，会总是报错：Kernel panic - not syncing: Fatal exception in inter，无论怎么也装不好。关机，保存快照，以防后面实验手滑敲错。[root@localhost ~]# poweroff开机，查看KVM模块是否被正确加载[root@localhost ~]# lsmod | grep kvmkvm_intel 174841 0 kvm 578518 1 kvm_intelirqbypass 13503 1 kvm[root@localhost ~]# 如下图，将上述yum命令再次执行，可以发现其他包都装好了，就python-virtinst最坑，我们后面再来安装它。 开启kvm服务，并且设置其开机自动启动 12[root@localhost ~]# systemctl restart libvirtd[root@localhost ~]# systemctl enable libvirtd 安装Linux虚拟机 安装前要设置环境语言为英文LANG=”en_US.UTF-8”，如果是中文的话某些版本可能会报错。CentOS 7 在这里修改 /etc/locale.conf。 12[root@localhost ~]# vim /etc/locale.conf LANG=&quot;en_US.UTF-8&quot; 准备安装目录和系统镜像 123[root@localhost ~]# mkdir /kvm/[root@localhost ~]# mkdir /kvm/vms[root@localhost ~]# mkdir /kvm/iso 下载centos镜像的网站： https://www.centos.org/download/ 下载个Minimal的就行，迷你版比较小，下载起来比较快嘛！我这里用的是1804版本的。 安装上传下载工具lrzsz，然后上传系统镜像到/kvm/iso目录中 12345678[root@localhost ~]# yum install lrzsz -y[root@localhost ~]# cd /kvm/iso/[root@localhost iso]# ls[root@localhost iso]# rz[root@localhost iso]# lsCentOS-7-x86_64-Minimal-1810.iso[root@localhost iso]# 定义一个储存池，绑定目录，建立并激活存储池，后面会用这个存储池创建虚拟机 12345678[root@localhost iso]# virsh pool-define-as vmspool --type dir --target /kvm/vmsPool vmspool defined[root@localhost iso]# virsh pool-build vmspoolPool vmspool built[root@localhost iso]# virsh pool-start vmspoolPool vmspool started 现在来安装python-virtinst 12345678[root@localhost ~]# yum install git -y[root@localhost ~]# git clone https://github.com/palli/python-virtinst.git[root@localhost ~]# lsanaconda-ks.cfg python-virtinst[root@localhost ~]# cd python-virtinst/[root@localhost python-virtinst]# python setup.py install[root@localhost python-virtinst]# cd[root@localhost ~]# 先安装ntp服务，下面虚拟机里安装虚拟机的时候才方便，不用再另外添加ntp服务器。 1yum install ntp -y 接下来关机保存快照，以防下面实验手滑 1[root@localhost ~]# poweroff 安装linux虚拟机，名字就叫centos7_01吧： 1[root@localhost ~]# virt-install --virt-type=kvm --name=centos7_01 --vcpus=2 --ram=512 --location=/kvm/iso/CentOS-7-x86_64-Minimal-1810.iso --disk path=/kvm/vms/centos7_01.qcow2,device=disk,format=qcow2,bus=virtio,cache=writeback,size=100 --network bridge=virbr0 --graphics none --extra-args=&apos;console=ttyS0&apos; --force 命令说明： –name 指定虚拟机的名称 –ram 指定分配给虚拟机的内存资源大小 maxmemory 指定可调节的最大内存资源大小，因为KVM支持热调整虚拟机的资源 –vcpus 指定分配给虚拟机的CPU核心数量 maxvcpus 指定可调节的最大CPU核心数量 –os-type 指定虚拟机安装的操作系统类型 –os-variant 指定系统的发行版本 –location 指定ISO镜像文件所在的路径，支持使用网络资源路径，也就是说可以使用URL –disk path 指定虚拟硬盘所存放的路径及名称，size 则是指定该硬盘的可用大小，单位是G –bridge 指定使用哪一个桥接网卡，也就是说使用桥接的网络模式 –graphics 指定是否开启图形 –console 定义终端的属性，target_type 则是定义终端的类型 –extra-args 定义终端额外的参数 系统配置 带 [!] 基本都是要配置的，按照顺序往下配置，按对用的数字以此进行设置。配置一下时间时区，第三第四第五第六项会自动检测好，接下来配置一下第八项的密码即可。 此处配置截图太多，可参考这个教程里的截图：http://blog.51cto.com/zero01/2083896 详细步骤： 1.首先，一开始我们看到的是： 这里设置语言建议设置成英文的，不然后面玩虚拟机的时候会有乱码。 2.设置语言，按数字1，回车进入以下界面，例如我要选Chinese就按数字68并回车即可，回车之后会让你选择是中文简体还是繁体，也是按下相应的数字并回车即可： 3.配置完成之后又会再次回到配置界面，这次我们来设置时区： 4.设置成亚洲上海的时区即可。 5.设置系统安装盘： 选择标准分区 6.设置root用户的密码： 7.设置完root密码后，可以看到1到9所有选项都没有感叹号了，这表是要求你设置的选项你都设置完毕了，敲b开始安装系统： 8.安装完成之后就会停止在以下这个界面，按一下回车即可，这时就会重启安装完的系统： 重启成功之后就会入到登录界面，可以看到我这里是成功登录的，登录上去，将它改名为centos。 这时我们是处于一个虚拟终端的，因为安装了虚拟机，如果要退出来的话，应该说是切出来，按 Ctrl + ]即可。然后再次登录，如下图： 1234567891011[root@localhost ~]# #这里按Ctrl + ]，然后回车，就退出了虚拟终端[root@localhost ~]# virsh console --domain centos7_01 #再次连接虚拟终端Connected to domain centos7_01Escape character is ^][root@localhost ~]# hostname #在虚拟终端里查看主机名称centos[root@localhost ~]# #这里再次按Ctrl + ]，然后回车，就退出了虚拟终端[root@localhost ~]# hostname #现在查看咱们虚拟机的主机名称localhost.localdomain[root@localhost ~]# 现在关机保存快照（给宿主机保存快照） 1[root@localhost ~]# poweroff 使用以下命令可以列出当前有多少个虚拟机，以及其状态，但是无法列出关机状态的虚拟机： 123456[root@localhost ~]# virsh list Id Name State---------------------------------------------------- 2 centos7_01 running[root@localhost ~]# 需要列出关机状态的虚拟机需要加多一个–all参数 查看所有虚拟机和进入控制台 123456789101112131415[root@localhost ~]# virsh list --all Id Name State---------------------------------------------------- 6 centos7_01 running[root@localhost ~]# virsh console --domain centos7_01Connected to domain centos7_01Escape character is ^]CentOS Linux 7 (Core)Kernel 3.10.0-862.el7.x86_64 on an x86_64localhost login: rootPassword: Last login: Sun Sep 2 10:34:40 on ttyS0[root@localhost ~]# 以下介绍一下管理虚拟机的一些常用命令： 123456789[root@localhost ~]# virsh console centos7_01 # 进入指定的虚拟机，进入的时候还需要按一下回车[root@localhost ~]# virsh start centos7_01 # 启动虚拟机[root@localhost ~]# virsh shutdown centos7_01 # 关闭虚拟机[root@localhost ~]# virsh destroy centos7_01 # 强制停止虚拟机[root@localhost ~]# virsh undefine centos7_01 # 彻底销毁虚拟机，会删除虚拟机配置文件，但不会删除虚拟磁盘[root@localhost ~]# virsh autostart centos7_01 # 设置宿主机开机时该虚拟机也开机[root@localhost ~]# virsh autostart --disable centos7_01 # 解除开机启动[root@localhost ~]# virsh suspend centos7_01 # 挂起虚拟机[root@localhost ~]# virsh resume centos7_01 # 恢复挂起的虚拟机 以下实验很乱，可以不做 配置宿主机网络1.KVM 虚拟机是基于 NAT 的网络配置； 2.只有同一宿主机的虚拟机之间可以互相访问，跨宿主机是不能访问； 3.虚拟机需要和宿主机配置成桥接模式，以便虚拟机可以在局域网内可见； 4.宿主机指的是我们用VMware Workstation Pro安装的虚拟机，它相对于虚拟机里面的虚拟机就是宿主。 5.我们之前virt install 的时候，有个参数是bridge=virbr0，用的桥接网卡已经指定为virbr0了。 Bridge模式配置 Bridge方式即虚拟网桥的网络连接方式，是客户机和子网里面的机器能够互相通信。可以使虚拟机成为网络中具有独立IP的主机。桥接网络（也叫 物理设备共享）被用作把一个物理设备复制到一台虚拟机。网桥多用作高级设置，特别是主机多个网络接口的情况。 1234567[root@localhost ~]# yum install -y net-tools #装了网络工具才能用命令：ifconfig[root@localhost ~]# systemctl restart libvirtd[root@localhost ~]# virsh iface-bridge ens33 br0[root@localhost ~]# ifconfig 修改宿主机物理网卡配置（UUID不用改，它是设备标识号） 123456789101112[root@localhost ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33删掉其他无用的行，保留下列4行，另外加一行BRIDGE=“virbr0&quot;，保存退出即可TYPE=EthernetBOOTPROTO=noneNAME=&quot;ens33&quot;UUID=&quot;005e11a3-2859-4497-adc1-d531ddc2675f&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;BRIDGE=“virbr0&quot;NM_CONTROLLED=&quot;no&quot; 修改宿主机网桥配置(宿主机里面的虚拟机与宿主机是桥接关系，我的ens33网卡之前是192.168.141.72，这里将virbr0改为这个ip之后，ens33网卡就没有ip了，重启网络后Xshell也会断开，接下来在vmware workstation里继续实验) 123456789101112131415161718192021222324[root@localhost ~]# vim /etc/sysconfig/network-scripts/ifcfg-virbr0TYPE=&quot;Bridge&quot;BOOTPROTO=&quot;static&quot;DEFROUTE=&quot;yes&quot;PEERDNS=&quot;yes&quot;PEERROUTES=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_PEERDNS=&quot;yes&quot;IPV6_PEERROUTES=&quot;yes&quot;IPV6_PRIVACY=&quot;no&quot;IPV6_FAILURE_FATAL=&quot;no&quot;UUID=&quot;005e11a3-2859-4497-adc1-d531ddc2675f&quot;STP=&quot;yes&quot;DELAY=&quot;0&quot;NAME=&quot;virbr0&quot;DEVICE=&quot;virbr0&quot;ONBOOT=&quot;yes&quot;IPADDR=&quot;192.168.141.72&quot;PREFIX=&quot;24&quot;GATEWAY=&quot;192.168.141.2&quot; 两个网卡都修改完成后重启网络 123456789101112131415161718192021222324252627[root@localhost ~]# systemctl restart network现在Xshell断开，我们接下来在vmware workstation里继续实验[root@localhost ~]# ifconfig ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 ether 00:0c:29:d3:48:93 txqueuelen 1000 (Ethernet) RX packets 7606 bytes 649199 (633.9 KiB) RX errors 0 dropped 2 overruns 0 frame 0 TX packets 7392 bytes 1114718 (1.0 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0virbr0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.141.72 netmask 255.255.255.0 broadcast 192.168.9.255 ether 00:0c:29:d3:48:93 txqueuelen 1000 (Ethernet) RX packets 2157 bytes 153841 (150.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1109 bytes 146573 (143.1 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0[root@localhost ~]# brctl showbridge name bridge id STP enabled interfacesvirbr0 8000.000c29d34893 yes ens33 virbr0-nic vnet1 可以看到ens33网卡已经没有ip了，也可以看到virbr0的接口变成ens33了 进入虚拟机centos7_01测试（如果它关机了的话，virsh start centos7_01 # 启动虚拟机） 1234567891011121314[root@localhost ~]# virsh console centos7_01Connected to domain centos7_01Escape character is ^]CentOS Linux 7 (Core)Kernel 3.10.0-862.el7.x86_64 on an x86_64localhost login: rootPassword: Last login: Sun Sep 2 10:35:29 on ttyS0[root@localhost ~]# ping 192.168.141.72PING 192.168.141.72 (192.168.141.72) 56(84) bytes of data.64 bytes from 192.168.141.72: icmp_seq=1 ttl=64 time=0.310 ms64 bytes from 192.168.141.72: icmp_seq=2 ttl=64 time=0.231 ms 如果之前装系统选的是中文简体，这里改回英文，重启虚拟机，注意宿主机不用重启。 12[root@localhost ~]# vim /etc/locale.conf LANG=&quot;en_US.UTF-8&quot; 配置宿主机网络-NAT模式 NAT(Network Address Translation网络地址翻译)，NAT方式是kvm安装后的默认方式。它支持主机与虚拟机的互访，同时也支持虚拟机访问互联网，但不支持外界访问虚拟机。 其中virbr0是由宿主机虚拟机支持模块安装时产生的虚拟网络接口，也是一个switch和bridge，负责把内容分发到各虚拟机。几个虚拟机管理模块产生的接口关系如下图: 从图上可以看出，虚拟接口和物理接口之间没有连接关系，所以虚拟机只能在通过虚拟的网络访问外部世界，无法从网络上定位和访问虚拟主机。 virbr0是一个桥接器，接收所有到网络192.168.122.*的内容。从下面命令可以验证： 123456789101112[root@localhost ~] brctl show# 输出结果# ---------------------# bridge name bridge id STP enabled interfaces# br0 8000.3863bb44cf6c no eno1# vnet0# virbr0 8000.525400193f0f yes virbr0-nicip route# default via 192.168.188.1 dev br0# 169.254.0.0/16 dev br0 scope link metric 1012# 192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1# 192.168.188.0/24 dev br0 proto kernel scope link src 192.168.188.132 同时，虚拟机支持模块会自动修改iptables规则，通过命令可以查看： 12[root@localhost ~] iptables -t nat -L -nv[root@localhost ~] iptables -t filter -L -nv 创建名为management的NAT网络，vi /usr/share/libvirt/networks/management.xml 12345678910&lt;network&gt; &lt;name&gt;management&lt;/name&gt; &lt;bridge name=&quot;virbr1&quot;/&gt; &lt;forward/&gt; &lt;ip address=&quot;192.168.123.1&quot; netmask=&quot;255.255.255.0&quot;&gt; &lt;dhcp&gt; &lt;range start=&quot;192.168.123.2&quot; end=&quot;192.168.123.254&quot;/&gt; &lt;/dhcp&gt; &lt;/ip&gt;&lt;/network&gt; 启用新建的NAT网络 123[root@localhost ~] virsh net-define /usr/share/libvirt/networks/management.xml[root@localhost ~] virsh net-start management[root@localhost ~] virsh net-autostart management 安装windows虚拟机1[root@localhost vms]# virt-install -n windowsxp -r 512 --disk /kvm/vms/winxp.img,format=qcow2,size=5 --network bridge=virbr1 --os-type=windows --os-variant=winxp --cdrom /kvm/iso/winxp.iso --vnc --vncport=5900 --vnclisten=0.0.0.0 windows用vnc远程屏幕 克隆虚拟机 virt-clone 参数介绍 –version 查看版本。 -h，–help 查看帮助信息。 –connect=URI 连接到虚拟机管理程序 libvirt 的URI。 -o 原始虚拟机名称 原始虚拟机名称，必须为关闭或者暂停状态。 -n 新虚拟机名称 –name 新虚拟机名称。 –auto-clone 从原来的虚拟机配置自动生成克隆名称和存储路径。 -u NEW_UUID, –uuid=NEW_UUID 克隆虚拟机的新的UUID，默认值是一个随机生成的 UUID。 -m NEW_MAC, –mac=NEW_MAC 设置一个新的mac地址，默认为随机生成 MAC。 -f NEW_DISKFILE, –file=NEW_DISKFILE 为新客户机使用新的磁盘镜像文件地址。 –force-copy=TARGET 强制复制设备。 –nonsparse 不使用稀疏文件复制磁盘映像。 1234# 暂停原始虚拟机[root@localhost ~] virsh shutdown centos7_01[root@localhost ~] virt-clone -o centos7_01 -n centos7_02 -f /kvm/vms/centos7_02.qcow2 -m 00:00:00:00:00:01[root@localhost ~] virt-clone -o centos7_01 -n centos7_03 --file /kvm/vms/centos7_03.qcow2 --nonsparse 通过镜像创建虚拟机创建虚拟机镜像文件 123456# 复制第一次安装的干净系统镜像，作为基础镜像文件，# 后面创建虚拟机使用这个基础镜像[root@localhost ~]# mkdir /kvm/img[root@localhost ~]# cp /kvm/vms/centos7_01.qcow2 /kvm/img/centos7_base.qcow2# 使用基础镜像文件，创建新的虚拟机镜像[root@localhost ~]# cp /kvm/img/centos7_base.qcow2 /kvm/vms/centos7_05.qcow2 创建虚拟机配置文件 12345678# 复制第一次安装的干净系统镜像，作为基础配置文件。[root@localhost ~] virsh dumpxml centos7_01 &gt; /kvm/img/centos7_base.xml# 使用基础虚拟机镜像配置文件，创建新的虚拟机配置文件[root@localhost ~] cp /kvm/img/centos7_base.xml /kvm/vms/centos7_05.xml# 编辑新虚拟机配置文件[root@localhost ~] vi /kvm/vms/centos7_05.xml 主要是修改虚拟机文件名，UUID，镜像地址和网卡地址，其中 UUID 在 Linux 下可以使用 uuidgen 命令生成 123456789101112&lt;domain type=&apos;kvm&apos;&gt; &lt;name&gt;centos7_05&lt;/name&gt; &lt;uuid&gt;1e86167a-33a9-4ce8-929e-58013fbf9122&lt;/uuid&gt; &lt;devices&gt; &lt;disk type=&apos;file&apos; device=&apos;disk&apos;&gt; &lt;source file=&apos;/kvm/vms/centos7_05.img&apos;/&gt; &lt;/disk&gt; &lt;interface type=&apos;bridge&apos;&gt; &lt;mac address=&apos;00:00:00:00:00:04&apos;/&gt; &lt;/interface&gt; &lt;/devices&gt;&lt;/domain&gt; 12[root@localhost ~] virsh define /kvm/vms/centos7_05.xml# Domain centos7_05 defined from /kvm/vms/centos7_05.xml 挂载磁盘创建镜像文件 1[root@localhost ~] qemu-img create /kvm/vms/centos7_01_1.img 5G 创建普通的qcow2格式镜像文件 1234# 创建 centos7_01_1 所需的磁盘# create 表示创建，-f qcow2 表示创建一个格式为 qcow2 的磁盘， # /kvm/vms/centos7_05.qcow2 表示创建的磁盘名称及磁盘文件，10G 表示该磁盘可用大小。qemu-img create -f qcow2 -o preallocation=metadata /kvm/vms/centos7_05_1.qcow2 5G 挂载方法： 1[root@localhost ~] virsh attach-disk centos7_05 /kvm/vms/centos7_05_1.qcow2 vdb --cache none 常用命令说明virt-install 常用参数说明1 123456789101112–name指定虚拟机名称–memory分配内存大小。–vcpus分配CPU核心数，最大与实体机CPU核心数相同–disk指定虚拟机镜像，size指定分配大小单位为G。–network网络类型，此处用的是默认，一般用的应该是bridge桥接。–accelerate加速–cdrom指定安装镜像iso–vnc启用VNC远程管理，一般安装系统都要启用。–vncport指定VNC监控端口，默认端口为5900，端口不能重复。–vnclisten指定VNC绑定IP，默认绑定127.0.0.1，这里改为0.0.0.0。–os-type=linux,windows–os-variant=rhel6 virt-install 常用参数说明2 12345678910111213141516171819202122--name 指定虚拟机名称--ram 虚拟机内存大小，以 MB 为单位--vcpus 分配CPU核心数，最大与实体机CPU核心数相同–-vnc 启用VNC远程管理，一般安装系统都要启用。–-vncport 指定VNC监控端口，默认端口为5900，端口不能重复。–-vnclisten 指定VNC绑定IP，默认绑定127.0.0.1，这里改为0.0.0.0。--network 虚拟机网络配置 # 其中子选项，bridge=br0 指定桥接网卡的名称。–os-type=linux,windows–os-variant=rhel7.2--disk 指定虚拟机的磁盘存储位置 # size，初始磁盘大小，以 GB 为单位。--location 指定安装介质路径，如光盘镜像的文件路径。--graphics 图形化显示配置 # 全新安装虚拟机过程中可能会有很多交互操作，比如设置语言，初始化 root 密码等等。 # graphics 选项的作用就是配置图形化的交互方式，可以使用 vnc（一种远程桌面软件）进行链接。 # 我们这列使用命令行的方式安装，所以这里要设置为 none，但要通过 --extra-args 选项指定终端信息， # 这样才能将安装过程中的交互信息输出到当前控制台。--extra-args 根据不同的安装方式设置不同的额外选项 virsh 基础命令 12345678910111213141516virsh list # 查看在运行的虚拟机virsh dumpxml vm-name # 查看kvm虚拟机配置文件virsh start vm-name # 启动kvm虚拟机virsh shutdown vm-name # 正常关机virsh destroy vm-name # 非正常关机，强制关闭虚拟机（相当于物理机直接拔掉电源）virsh undefine vm-name # 删除vm的配置文件ls /etc/libvirt/qemu# 查看删除结果，Centos的配置文件被删除，但磁盘文件不会被删除virsh define file-name.xml # 根据配置文件定义虚拟机virsh suspend vm-name # 挂起，终止virsh resumed vm-name # 恢复被挂起的虚拟机virsh autostart vm-name # 开机自启动vmvirsh console &lt;虚拟机名称&gt; # 连接虚拟机 错误解决如果出现以下字符串使用 CTRL+Shift+5或者CTRL+Shift+] 123console testConnected to domain testEscape character is ^] 彻底删除一个虚拟机（以centos7_01为例） 12345678910111213141516171819202122232425[root@localhost ~]# virshWelcome to virsh, the virtualization interactive terminal.Type: &apos;help&apos; for help with commands &apos;quit&apos; to quitvirsh # list Id Name State---------------------------------------------------- 7 windowsxp running 12 centos7_01 runningvirsh # shutdown centos7_01Domain centos7_01 is being shutdownvirsh # destroy centos7_01Domain centos7_01 destroyedvirsh # undefine centos7_01Domain centos7_01 has been undefinedvirsh # exit[root@localhost ~]# rm -rf /kvm/vms/centos7_01.qcow2 [root@localhost ~]# 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-29 负载均衡]]></title>
    <url>%2Flinux-29%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-29 负载均衡概念解析 负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。 负载均衡（Load Balance）其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。 常用开源软件负载均衡器有：Nginx、LVS、Haproxy，这三种负载均衡都要求学会并掌握。 三种负载均衡器特点简介一、LVS： 稳定性、可靠性好，自身有完美的热备方案（如：LVS+Keepalived）；应用范围比较广，可以对所有应用做负载均衡；配置复杂，对网络依赖比较大，稳定性很高。 二、Ngnix： Nginx对网络的依赖比较小，理论上能ping通就就能进行负载功能；Nginx安装和配置比较简单，测试起来比较方便；Nginx还能做Web服务器即Cache功能。 三、HAProxy的特点是： 支持两种代理模式：TCP（四层）和HTTP（七层），支持虚拟主机；更多的负载均衡策略比如：动态加权轮循(Dynamic Round Robin)，加权源地址哈希(Weighted Source Hash)，加权URL哈希和加权参数哈希(Weighted Parameter Hash)已经实现；单纯从效率上来讲HAProxy更会比Nginx有更出色的负载均衡速度；但是不能做Web服务器即Cache。 适用业务场景 网站建设初期，可以选用Nigix/HAproxy作为反向代理负载均衡（或者流量不大都可以不选用负载均衡），因为其配置简单，性能也能满足一般的业务场景。如果考虑到负载均衡器是有单点问题，可以采用Nginx+Keepalived/HAproxy+Keepalived避免负载均衡器自身的单点问题。网站并发达到一定程度之后，为了提高稳定性和转发效率，可以使用LVS、毕竟LVS比Nginx/HAproxy要更稳定，转发效率也更高。不过维护LVS对维护人员的要求也会更高，投入成本也更大。 负载均衡器作为一个代理，通过访问负载均衡器，访问到的网站是nginx1/2两个服务器上网站的内容。网站根目录可以采用共享存储（samba或者nfs或者iscsi或者ftp等），也可以做后端网络存储以通过负载均衡器看到不同服务器上的同一个网站。今天咱们的实验做的效果是看到不同的内容，以证明确实是通过负载均衡器访问到了两台服务器上的网站。 nginx负载均衡准备环境准备三台Linux服务器，打开后查看并且记住它们的ip： 负载均衡器：192.168.141.132 nginx服务器1：192.168.141.53 nginx服务器2：192.168.141.69 在三台linux服务器上分别安装nginx服务 三台服务器上分别执行以下命令安装完成nginx服务 123456[root@localhost ~]# yum install epel-release.noarch -y[root@localhost ~]# yum install nginx –y[root@localhost ~]# firewall-cmd --add-port=8080/tcp --permanent [root@localhost ~]# firewall-cmd --reload[root@localhost ~]# sed -i &apos;s/SELINUX=enforcing/SELINUX=disabled/&apos; /etc/selinux/config[root@localhost ~]# setenforce 0 配置负载均衡服务器（192.168.141.132那台）修改nginx配置，开启nginx轮询负载均衡 123456789101112131415161718192021222324252627282930313233[root@localhost ~]# vim /etc/nginx/nginx.conf 13 events &#123; 14 accept_mutex on; # （设置网路连接序列化，防止惊群现象发生，默认为on） 15 multi_accept on; # （设置一个进程是否同时接受多个网络连接，默认为off） 16 worker_connections 1024; #（一个进程的最大连接数） 17 &#125; 31 gzip on; # 开启压缩 # 设置群集策略和群集主机 40 upstream eagleslab &#123; 41 server 192.168.141.53:8080;# 可以加上weight=5; 这样的语法设置权重 42 server 192.168.141.69:8080; 43 &#125; 46 listen 8080 default_server; #修改服务监听的端口号 # listen [::]:80 default_server; 47 listen localhost; 54 location / &#123; #（ / 表示所有请求，可以自定义来针对不同的域名设定不同负载规则 和服务） 55 proxy_pass http://eagleslab;#（反向代理填负载均衡规则名） 56 proxy_redirect off; 57 proxy_set_header Host $host; 58 proxy_set_header X-Real-IP $remote_addr; 59 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 60 proxy_connect_timeout 90; 61 proxy_send_timeout 90; 62 proxy_read_timeout 90; 63 64 &#125;[root@localhost ~]# systemctl enable nginxCreated symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service.[root@localhost ~]# systemctl restart nginx 配置nginx提供web的服务器1和2 12345678910111213141516两台服务器都要修改端口号[root@client1 ]# vim /etc/nginx/nginx.conf 39 listen 8080 default_server; 40 # listen [::]:80 default_server;nginx服务器1：[root@client1 ~]# rm –rf /usr/share/nginx/html/index.html[root@client1 ~]# echo &quot;192.168.141.53&quot; &gt; /usr/share/nginx/html/index.htmlnginx服务器2：[root@client2 ~]# rm –rf /usr/share/nginx/html/index.html[root@client2 ~]# echo &quot;192.168.141.69&quot; &gt; /usr/share/nginx/html/index.html启动两台服务器的服务[root@localhost ~]# systemctl restart nginx[root@localhost ~]# systemctl enable nginx 现象​ 浏览器打开http://192.168.141.132:8080，然后不断刷新，可以看到显示出来的网页不断地在两个网页中来回切换。如下图： 在上面实验完成后，关机保存快照，然后恢复到干净的快照，接着做下面的实验 LVS实现负载均衡 LVS是Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。 实验环境做好上面的试验后将三台虚拟机恢复到一个干净的快照，接着做下面这个实验 LVS负载均衡器：192.168.141.132 web服务器1：192.168.141.53 web服务器2：192.168.141.69 准备工作三台虚拟机都放行80端口，关闭selinux 1234[root@localhost ~]# firewall-cmd --add-port=80/tcp --permanent [root@localhost ~]# firewall-cmd --reload[root@localhost ~]# sed -i &apos;s/SELINUX=enforcing/SELINUX=disabled/&apos; /etc/selinux/config[root@localhost ~]# setenforce 0 三台虚拟机安装lvs工具包 123[root@localhost ~]# yum install epel-release.noarch -y[root@server ~]# yum install ipvsadm.x86_64 -y[root@localhost ~]# yum install net-tools -y 配置负载均衡器负载均衡服务器写入以下脚本 123456789101112131415[root@server ~]# vim lvs_s.sh[root@server ~]# cat lvs_s.sh#!/bin/bashifconfig ens33:0 192.168.141.100 broadcast 192.168.141.100 netmask 255.255.255.255 upipvsadm -Cipvsadm -A -t 192.168.141.100:80 -s rripvsadm -a -t 192.168.141.100:80 -r 192.168.141.53:80 -gipvsadm -a -t 192.168.141.100:80 -r 192.168.141.69:80 -gipvsadm -Ln# 保存退出[root@server ~]# chmod +x lvs_s.sh[root@server ~]# ./lvs_s.sh 解析： ens33:0表示子接口ip，广播域为本机ip，监听自身ip，32位匹配到的仅仅是它自己这台机器ip，整个广播域就只有192.168.141.100它自己。 -r表示转发给192.168.141.53和192.168.141.69 配置负载均衡客户机两台web服务器分别都要写入和执行以下脚本 1234567891011[root@client ~]# vim lvs_c.sh[root@client ~]# cat lvs_c.sh#!/bin/bashifconfig lo:0 192.168.141.100 broadcast 192.168.141.100 netmask 255.255.255.255 up route add -host 192.168.141.100 dev lo:0echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignoreecho &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announceecho &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignoreecho &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announce[root@client ~]# chmod +x lvs_c.sh [root@client ~]# ./lvs_c.sh 解析： 两台web服务器接受到客户端请求后，将数据返回到192.168.141.100那里，然后192.168.141.100再将数据返回到客户端上。 两台web服务器分别搭建自己的apache服务 123456789[root@localhost ~]# yum install httpd -yweb服务器1：[root@client1 ~]# echo &quot;i am lvs 192.168.141.53&quot; &gt; /var/www/html/index.htmlweb服务器2：[root@client2 ~]# echo &quot;i am lvs 192.168.141.69&quot; &gt; /var/www/html/index.html启动两台服务器的服务[root@localhost ~]# systemctl restart httpd[root@localhost ~]# systemctl enable httpd 现象: 浏览器访问192.168.141.100，不断刷新，可以看到显示的内容在i am lvs 192.168.141.69和i am lvs 192.168.141.53之间来回切换。可以用低轨道离子炮攻击其中一个web服务器（关闭物理机防火墙），然后访问192.168.141.100，发现被攻击的web服务器的主页打不开了，只能打开另一个web服务器的主页了。 不断刷新192.168.141.100基本只能看到i am lvs 192.168.141.69，因为192.168.141.53正在被攻击。 如果关闭了防火墙，试验结束后记得要开回去。另外，LOIC是用C#写的，属于恶意工具，会报毒，网上下载下来的LOIC可能会有恶意代码，所以可以去github上直接下载源码，然后自己编译即可。如下图，找到这个即可，下载量最高的那个：NewEraCraker/LOIC 另外，在以后的运维工作中，尽量不要在网上直接下载软件，有些恶意代码真是防不胜防，被坑是很常见的。可以尽量在github上自己下载源码进行编译，这是最安全的方式。另外，https://sourceforge.net/是全世界最大的开源软件平台，可以在这里下载一些软件，基本无毒。 HAProxy实现负载均衡实验环境做好上面的试验后将三台虚拟机恢复到一个干净的快照，接着做下面这个实验 Haproxy负载均衡器：192.168.141.132 web服务器1：192.168.141.53 web服务器2：192.168.141.69 准备工作三台虚拟机都放行80端口，关闭selinux 1234[root@localhost ~]# firewall-cmd --add-port=80/tcp --permanent [root@localhost ~]# firewall-cmd --reload[root@localhost ~]# sed -i &apos;s/SELINUX=enforcing/SELINUX=disabled/&apos; /etc/selinux/config[root@localhost ~]# setenforce 0 配置负载均衡器在负载均衡器上安装haproxy 12[root@server ~]# yum install epel-release.noarch –y[root@server ~]# yum -y install haproxy.x86_64 修改haproxy配置 12345678910111213141516171819202122[root@server ~]# vim /etc/haproxy/haproxy.cfgglobal ulimit-n 51200defaults log global mode http option dontlognull contimeout 10000 clitimeout 150000 srvtimeout 150000 # 前端请求拦截frontend frontend1 bind *:80 default_backend backend1 #和后端转发地址对应# 后端转发地址 1backend backend1 server server1 192.168.141.53:80 maxconn 20480 server server1 192.168.141.69:80 maxconn 20480# 后端转发地址 2 backend backend2 server server1 127.0.0.1:80 maxconn 20480 解析: 用浏览器访问web服务器的网址时，客户端发出前端请求，到达远端web服务器，其响应后回传给我们。但是我们的请求发到负载均衡器时，会被它拦截下来，接下来由负载均衡器决定该把这个请求转发到哪台web服务器上。 bind *:80表示拦截所有来自80端口的请求default_backend backend1表示转发给后端转发地址backend1maxconn 20480表示最大连接数为20480 12[root@server ~]# systemctl restart haproxy[root@server ~]# systemctl enable haproxy 配置web服务器123456789[root@localhost ~]# yum install httpd -yweb服务器1：[root@client1 ~]# echo &quot;192.168.141.53&quot; &gt; /var/www/html/index.htmlweb服务器2：[root@client2 ~]# echo &quot;192.168.141.69&quot; &gt; /var/www/html/index.html启动两台服务器的服务[root@localhost ~]# systemctl restart httpd[root@localhost ~]# systemctl enable httpd http默认的就是80端口，所以直接敲负载均衡器的ip就可以，效果如下： 不断刷新，可以看到显示的内容在192.168.141.69和192.168.141.53之间来回切换 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-28 LNMP动态网站架构]]></title>
    <url>%2Flinux-28%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-28 LNMP动态网站架构LNMP动态网站架构 LNMP动态网站部署架构是一套由Linux + Nginx + MySQL + PHP组成的动态网站系统解决方案。LNMP中的字母L是Linux系统的意思，不仅可以是RHEL、CentOS、Fedora，还可以是Debian、Ubuntu等系统 开发环境的部署 在使用源码包安装服务程序之前，首先要让安装主机具备编译程序源码的环境，他需要具备C语言、C++语言、Perl语言的编译器，以及各种常见的编译支持函数库程序。因此请先配置妥当Yum软件仓库，然后把下面列出的这些软件包都统统安装上 1[root@localhost src]# yum install -y apr* autoconf automake bc bison bzip2 bzip2* compat* cpp curl curl-devel elfutils-libelf-devel flex fontconfig fontconfig-devel freetype freetype* freetype-devel gcc gcc-c++ gd gettext gettext-devel glibc kernel kernel-headers keyutils keyutils-libs-devel krb5-devel libcom_err-devel libpng libpng-devel libjpeg* libsepol-devel libselinux-devel libstdc++-devel libtool* libgomp libxml2 libxml2-devel libXpm* libtifflibtiff* make mpfr ncurses* ntp ncurses-devel openssl openssl-devel patch pcre-devel perlphp-common php-gd policycoreutils telnet t1lib t1lib* nasm nasm* wget zlib-devel unzip 下载软件包下载安装LNMP动态网站部署架构所需的16个软件源码包和1个用于检查效果的论坛网站系统软件包 123456789101112131415161718192021222324[root@localhost ~]# cd /usr/local/src/[root@localhost src]# wget https://www.linuxprobe.com/Software/cmake-2.8.11.2.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/cmake-2.8.11.2.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/freetype-2.5.3.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/jpegsrc.v9a.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/libgd-2.1.0.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/libmcrypt-2.5.8.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/libpng-1.6.12.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/libvpx-v1.3.0.tar.bz2[root@localhost src]# wget https://www.linuxprobe.com/Software/mysql-5.6.19.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/nginx-1.6.0.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/openssl-1.0.1h.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/php-5.5.14.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/pcre-8.35.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/t1lib-5.1.2.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/tiff-4.0.3.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/yasm-1.2.0.tar.gz[root@localhost src]# wget https://www.linuxprobe.com/Software/zlib-1.2.8.tar.gz[root@localhost src]# lscmake-2.8.11.2.tar.gz libgd-2.1.0.tar.gz mysql-5.6.19.tar.gz php-5.5.14.tar.gz zlib-1.2.8.tar.gzcmake-2.8.11.2.tar.gz.1 libmcrypt-2.5.8.tar.gz nginx-1.6.0.tar.gz t1lib-5.1.2.tar.gzfreetype-2.5.3.tar.gz libpng-1.6.12.tar.gz openssl-1.0.1h.tar.gz tiff-4.0.3.tar.gzjpegsrc.v9a.tar.gz libvpx-v1.3.0.tar.bz2 pcre-8.35.tar.gz yasm-1.2.0.tar.gz[root@localhost src]# 安装cmake CMake是Linux系统中一款常用的编译工具。要想通过源码包安装服务程序，就一定要严格遵守上面总结的安装步骤—下载及解压源码包文件、编译源码包代码、生成二进制安装程序、运行二进制的服务程序安装包。 12345[root@localhost src]# tar xzvf cmake-2.8.11.2.tar.gz [root@localhost src]# cd cmake-2.8.11.2[root@localhost cmake-2.8.11.2]# ./configure [root@localhost cmake-2.8.11.2]# make[root@localhost cmake-2.8.11.2]# make install 配置MySQL服务1234[root@localhost cmake-2.8.11.2]# cd ..[root@localhost src]# useradd mysql -s /sbin/nologin[root@localhost src]# mkdir -p /usr/local/mysql/var[root@localhost src]# chown -Rf mysql:mysql /usr/local/mysql 接下来解压、编译、安装MySQL数据库服务程序。在编译数据库时使用的是cmake命令，其中， -DCMAKE_INSTALL_PREFIX参数用于定义数据库服务程序的保存目录， -DMYSQL_DATADIR参数用于定义真实数据库文件的目录， -DSYSCONFDIR则是定义MySQL数据库配置文件的保存目录。(编译时间较长，为了防止ssh断开，建议screen运行！) 12345[root@localhost src]# tar xzvf mysql-5.6.19.tar.gz[root@localhost src]# cd mysql-5.6.19[root@localhost mysql-5.6.19]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/var -DSYSCONFDIR=/etc[root@localhost mysql-5.6.19]# make[root@localhost mysql-5.6.19]# make install 为了让MySQL数据库程序正常运转起来，需要先删除/etc目录中的默认配置文件。 然后在MySQL数据库程序的保存目录scripts内找到一个名为mysql_install_db的脚本程序。 执行这个脚本程序并使用–user参数指定MySQL服务的对应账号名称（在前面步骤已经创建）。 使用–basedir参数指定MySQL服务程序的保存目录。 使用–datadir参数指定MySQL真实数据库的文件保存目录。 这样即可生成系统数据库文件，也会生成出新的MySQL服务配置文件。 123[root@linuxprobe mysql-5.6.19]# rm -rf /etc/my.cnf[root@linuxprobe mysql-5.6.19]# cd /usr/local/mysql[root@linuxprobe mysql]# ./scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/var 把系统新生成的MySQL数据库配置文件链接到/etc目录中，然后把程序目录中的开机程序文件复制到/etc/rc.d/init.d目录中，以便通过service命令来管理MySQL数据库服务程序。记得把数据库脚本文件的权限修改成755以便于让用户有执行该脚本的权限： 123[root@localhost mysql]# ln -s my.cnf /etc/my.cnf[root@localhost mysql]# cp ./support-files/mysql.server /etc/rc.d/init.d/mysqld[root@localhost mysql]# chmod 755 /etc/rc.d/init.d/mysqld 编辑刚复制的MySQL数据库脚本文件，把第46、47行的basedir与datadir参数分别修改为MySQL数据库程序的保存目录和真实数据库的文件内容。 123[root@localhost mysql]# vim /etc/rc.d/init.d/mysqld 46行 basedir=/usr/local/mysql47行 datadir=/usr/local/mysql/var 启动mysql，并且设置开机启动 123[root@localhost mysql]# service mysqld startStarting MySQL. SUCCESS! [root@localhost mysql]# chkconfig mysqld on 把命令所保存的目录永久性地定义到PATH变量中，需要编辑/etc/profile文件并写入追加的命令目录，这样当物理设备在下一次重启时就会永久生效了。如果不想通过重启设备的方式来生效，也可以使用source命令加载一下/ect/profile文件，此时新的PATH变量也可以立即生效了。 123[root@localhost mysql]# vim /etc/profile74行本来是空行，现在插入： export PATH=$PATH:/usr/local/mysql/bin[root@localhost mysql]# source /etc/profile MySQL数据库服务程序还会调用到一些程序文件和函数库文件。由于当前是通过源码包方式安装MySQL数据库，因此现在也必须以手动方式把这些文件链接过来。 1234[root@linuxprobe mysql]# mkdir /var/lib/mysql[root@linuxprobe mysql]# ln -s /usr/local/mysql/lib/mysql /usr/lib/mysql[root@linuxprobe mysql]# ln -s /tmp/mysql.sock /var/lib/mysql/mysql.sock[root@linuxprobe mysql]# ln -s /usr/local/mysql/include/mysql /usr/include/mysql 初始化数据库 设置root管理员在数据库中的密码值（注意，该密码并非root管理员在系统中的密码，这里的密码值默认应该为空，可直接按回车键）。 设置root管理员在数据库中的专有密码。 随后删除匿名账户，并使用root管理员从远程登录数据库，以确保数据库上运行的业务的安全性。 删除默认的测试数据库，取消测试数据库的一系列访问权限。 刷新授权列表，让初始化的设定立即生效。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263[root@localhost ~]# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&apos;ll need the currentpassword for the root user. If you&apos;ve just installed MariaDB, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] yNew password: Re-enter new password: Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from &apos;localhost&apos;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] y ... Success!By default, MariaDB comes with a database named &apos;test&apos; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you&apos;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB![root@localhost ~]# 登录数据库 1234567891011121314[root@localhost ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 13Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [DBaaa]&gt; exitBye[root@localhost ~]# 配置nginx服务解决相关的软件依赖关系 提供Perl语言兼容的正则表达式库的软件包pcre 123456[root@localhost ~]# cd /usr/local/src[root@localhost src]# tar xzvf pcre-8.35.tar.gz[root@localhost src]# cd pcre-8.35[root@localhost pcre-8.35]# ./configure --prefix=/usr/local/pcre --enable-utf8[root@localhost pcre-8.35]# make[root@localhost pcre-8.35]# make install openssl软件包是用于提供网站加密证书服务的程序文件，在安装该程序时需要自定义服务程序的安装目录，以便于稍后调用它们的时候更可控。 123456[root@localhost pcre-8.35]# cd /usr/local/src[root@localhost src]# tar xzvf openssl-1.0.1h.tar.gz [root@localhost src]# cd openssl-1.0.1h[root@localhost openssl-1.0.1h]# ./config --prefix=/usr/local/openssl[root@localhost openssl-1.0.1h]# make[root@localhost openssl-1.0.1h]# make install openssl软件包安装后默认会在/usr/local/openssl/bin目录中提供很多的可用命令，我们需要像前面的操作那样，将这个目录添加到PATH环境变量中，并写入到配置文件中，最后执行source命令以便让新的PATH环境变量内容可以立即生效 123[root@localhost openssl-1.0.1h]# vim /etc/profile74行改为： export PATH=$PATH:/usr/local/openssl/bin:/usr/local/openssl/bin[root@localhost openssl-1.0.1h]# source /etc/profile zlib软件包是用于提供压缩功能的函数库文件。其实Nginx服务程序调用的这些服务程序无需深入了解，只要大致了解其作用就已经足够了 123456[root@localhost openssl-1.0.1h]# cd /usr/local/src/[root@localhost src]# tar xzvf zlib-1.2.8.tar.gz[root@localhost src]# cd zlib-1.2.8[root@localhost zlib-1.2.8]# ./configure --prefix=/usr/local/zlib[root@localhost zlib-1.2.8]# make[root@localhost zlib-1.2.8]# make install 创建一个用于执行Nginx服务程序的账户。账户名称可以自定义 12[root@localhost zlib-1.2.8]# cd ..[root@localhost src]# useradd www -s /sbin/nologin 其中，–prefix参数用于定义服务程序稍后安装到的位置， –user与–group参数用于指定执行Nginx服务程序的用户名和用户组。 在使用参数调用openssl、zlib、pcre软件包时，请写出软件源码包的解压路径，而不是程序的安装路径 12345[root@localhost src]# tar xzvf nginx-1.6.0.tar.gz [root@localhost src]# cd nginx-1.6.0[root@localhost nginx-1.6.0]# ./configure --prefix=/usr/local/nginx --without-http_memcached_module --user=www --group=www --group=www --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-openssl=/usr/local/src/openssl-1.0.1h --with-zlib=/usr/local/src/zlib-1.2.8 --with-pcre=/usr/local/src/pcre-8.35[root@localhost nginx-1.6.0]# make[root@localhost nginx-1.6.0]# make install 要想启动Nginx服务程序以及将其加入到开机启动项中，也需要有脚本文件。 1234567891011[root@localhost nginx-1.6.0]# curl https://raw.githubusercontent.com/xcracker/linux_shell/master/init.d/nginx &gt; /etc/rc.d/init.d/nginx[root@localhost nginx-1.6.0]# chmod 755 /etc/rc.d/init.d/nginx [root@localhost nginx-1.6.0]# /etc/rc.d/init.d/nginx restartReloading systemd: [ 确定 ]Starting nginx (via systemctl): [ 确定 ][root@localhost nginx-1.6.0]# chkconfig nginx on[root@localhost nginx-1.6.0]# firewall-cmd --add-port=80/tcp --permanent success[root@localhost nginx-1.6.0]# firewall-cmd --reloadsuccess[root@localhost nginx-1.6.0]# 上面curl链接的网址存放着脚本代码，如下图： 浏览器打开服务器ip，查看是否成功 配置PHP服务yasm源码包是一款常见的开源汇编器 123456[root@localhost nginx-1.6.0]# cd ..[root@localhost src]# tar xzvf yasm-1.2.0.tar.gz [root@localhost src]# cd yasm-1.2.0[root@localhost yasm-1.2.0]# ./configure [root@localhost yasm-1.2.0]# make[root@localhost yasm-1.2.0]# make install libmcrypt源码包是用于加密算法的扩展库程序 123456[root@localhost yasm-1.2.0]# cd ..[root@localhost src]# tar xzvf libmcrypt-2.5.8.tar.gz[root@localhost src]# cd libmcrypt-2.5.8[root@localhost libmcrypt-2.5.8]# ./configure[root@localhost libmcrypt-2.5.8]# make[root@localhost libmcrypt-2.5.8]# make install libvpx源码包是用于提供视频编码器的服务程序 123456[root@linuxprobe libmcrypt-2.5.8]# cd ..[root@linuxprobe src]# tar xjvf libvpx-v1.3.0.tar.bz2[root@linuxprobe src]# cd libvpx-v1.3.0[root@linuxprobe libvpx-v1.3.0]# ./configure --prefix=/usr/local/libvpx --enable-shared --enable-vp9[root@linuxprobe libvpx-v1.3.0]# make[root@linuxprobe libvpx-v1.3.0]# make install tiff源码包是用于提供标签图像文件格式的服务程序 123456[root@localhost libvpx-v1.3.0]# cd ..[root@localhost src]# tar xzvf tiff-4.0.3.tar.gz [root@localhost src]# cd tiff-4.0.3[root@localhost tiff-4.0.3]# ./configure --prefix=/usr/local/tiff --enable-shared[root@localhost tiff-4.0.3]# make[root@localhost tiff-4.0.3]# make install libpng源码包是用于提供png图片格式支持函数库的服务程序 123456[root@localhost tiff-4.0.3]# cd ..[root@localhost src]# tar xzvf libpng-1.6.12.tar.gz[root@localhost src]# cd libpng-1.6.12[root@localhost libpng-1.6.12]# ./configure --prefix=/usr/local/libpng --enable-shared[root@localhost libpng-1.6.12]# make[root@localhost libpng-1.6.12]# make install freetype源码包是用于提供字体支持引擎的服务程序 123456[root@localhost libpng-1.6.12]# cd ..[root@localhost src]# tar xzvf freetype-2.5.3.tar.gz [root@localhost src]# cd freetype-2.5.3[root@localhost freetype-2.5.3]# ./configure --prefix=/usr/local/freetype --enable-shared[root@localhost freetype-2.5.3]# make[root@localhost freetype-2.5.3]# make install jpeg源码包是用于提供jpeg图片格式支持函数库的服务程序 123456[root@localhost freetype-2.5.3]# cd ..[root@localhost src]# tar xzvf jpegsrc.v9a.tar.gz [root@localhost src]# cd jpeg-9a[root@localhost jpeg-9a]# ./configure --prefix=/usr/local/jpeg --enable-shared[root@localhost jpeg-9a]# make[root@localhost jpeg-9a]# make install libgd源码包是用于提供图形处理的服务程序,在编译libgd源码包时，请记得写入的是jpeg、libpng、freetype、tiff、libvpx等服务程序在系统中的安装路径，即在上面安装过程中使用–prefix参数指定的目录路径 123456[root@localhost jpeg-9a]# cd ..[root@localhost src]# tar xzvf libgd-2.1.0.tar.gz [root@localhost src]# cd libgd-2.1.0[root@localhost libgd-2.1.0]# ./configure --prefix=/usr/local/libgd --enable-shared --with-jpeg=/usr/local/jpeg --with-png=/usr/local/libpng --with-freetype=/usr/local/freetype --with-fontconfig=/usr/local/freetype --with-xpm=/usr/ --with-tiff=/usr/local/tiff --with-vpx=/usr/local/libvpx[root@localhost libgd-2.1.0]# make[root@localhost libgd-2.1.0]# make install t1lib源码包是用于提供图片生成函数库的服务程序 安装后把/usr/lib64目录中的函数文件链接到/usr/lib目录中，以便系统能够顺利调取到函数文件 12345678[root@localhost libgd-2.1.0]# cd ..[root@localhost src]# tar xzvf t1lib-5.1.2.tar.gz [root@localhost src]# cd t1lib-5.1.2[root@localhost t1lib-5.1.2]# ./configure --prefix=/usr/local/t1lib --enable-shared[root@localhost t1lib-5.1.2]# make[root@localhost t1lib-5.1.2]# make install[root@localhost t1lib-5.1.2]# ln -s /usr/lib64/libltdl.so /usr/lib/libltdl.so[root@localhost t1lib-5.1.2]# cp -frp /usr/lib64/libXpm.so* /usr/lib 此时终于把编译php服务源码包的相关软件包都已经安装部署妥当了。 在开始编译php源码包之前，先定义一个名为LD_LIBRARY_PATH的全局环境变量，该环境变量的作用是帮助系统找到指定的动态链接库文件，这些文件是编译php服务源码包的必须元素之一。 编译php服务源码包时，除了定义要安装到的目录以外，还需要依次定义配置php服务程序配置文件的保存目录、MySQL数据库服务程序所在目录、MySQL数据库服务程序配置文件所在目录，以及libpng、jpeg、freetype、libvpx、zlib、t1lib等服务程序的安装目录路径，并通过参数启动php服务程序的诸多默认功能 1234567[root@localhost t1lib-5.1.2]# cd ..[root@localhost src]# tar -xzvf php-5.5.14.tar.gz [root@localhost src]# cd php-5.5.14[root@localhost php-5.5.14]# export LD_LIBRARY_PATH=/usr/local/libgd/lib[root@localhost php-5.5.14]# ./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-mysql=/usr/local/mysql --with-mysqli=/usr/local/mysql/bin/mysql_config --with-mysql-sock=/tmp/mysql.sock --with-pdo-mysql=/usr/local/mysql --with-gd --with-png-dir=/usr/local/libpng --with-jpeg-dir=/usr/local/jpeg --with-freetype-dir=/usr/local/freetype --with-xpm-dir=/usr/ --with-vpx-dir=/usr/local/libvpx/ --with-zlib-dir=/usr/local/zlib --with-t1lib=/usr/local/t1lib --with-iconv --enable-libxml --enable-xml --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --enable-opcache --enable-mbregex --enable-fpm --enable-mbstring --enable-ftp --enable-gd-native-ttf --with-openssl --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --enable-session --with-mcrypt --with-curl --enable-ctype [root@localhost php-5.5.14]# make[root@localhost php-5.5.14]# make install 在php源码包程序安装完成后，需要删除当前默认的配置文件，然后将php服务程序目录中相应的配置文件复制过来 12345[root@localhost php-5.5.14]# rm -rf /etc/php.ini[root@localhost php-5.5.14]# ln -s /usr/local/php/etc/php.ini /etc/php.ini[root@localhost php-5.5.14]# cp php.ini-production /usr/local/php/etc/php.ini[root@localhost php-5.5.14]# cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf[root@localhost php-5.5.14]# ln -s /usr/local/php/etc/php-fpm.conf /etc/php-fpm.conf php-fpm.conf是php服务程序重要的配置文件之一，我们需要启用该配置文件中第25行左右的pid文件保存目录（去掉那一行备注），然后分别将第148和149行的user与group参数分别修改为www账户和用户组名称 1234[root@localhost php-5.5.14]# vim /usr/local/php/etc/php-fpm.conf25行 pid = run/php-fpm.pid148行 user = www149行 group = www 配置妥当后便可把用于管理php服务的脚本文件复制到/etc/rc.d/init.d中了。为了能够执行脚本，请记得为脚本赋予755权限。最后把php-fpm服务程序加入到开机启动项中 123[root@localhost php-5.5.14]# cp sapi/fpm/init.d.php-fpm /etc/rc.d/init.d/php-fpm[root@localhost php-5.5.14]# chmod 755 /etc/rc.d/init.d/php-fpm[root@localhost php-5.5.14]# chkconfig php-fpm on 为了安全，编辑php.ini配置文件，在305行的disable_functions参数后面追加上要禁止的功能。（注意：disable_functions = 后面直接接那一大串东西，不要回车换行！） 123[root@localhost php-5.5.14]# vim /usr/local/php/etc/php.ini305行 disable_functions = passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restor e,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,escapeshellcmd,dll,popen,disk_free_space,checkdnsrr,checkdnsrr,g etservbyname,getservbyport,disk_total_space,posix_ctermid,posix_get_last_error,posix_getcwd,posix_getegid,posix_geteuid,posix_getgid,po six_getgrgid,posix_getgrnam,posix_getgroups,posix_getlogin,posix_getpgid,posix_getpgrp,posix_getpid,posix_getppid,posix_getpwnam,posix_ getpwuid,posix_getrlimit,posix_getsid,posix_getuid,posix_isatty,posix_kill,posix_mkfifo,posix_setegid,posix_seteuid,posix_setgid,posix_ setpgid,posix_setsid,posix_setuid,posix_strerror,posix_times,posix_ttyname,posix_uname 编辑Nginx服务程序的主配置文件， 把第2行的井号（#）删除，然后在后面写上负责运行Nginx服务程序的账户名称和用户组名称； 在第45行的index参数后面写上网站的首页名称。 最后是将第65～71行参数前的井号（#）删除来启用参数，主要是修改第69行的脚本名称路径参数， 其中$document_root变量即为网站信息存储的根目录路径，若没有设置该变量，则Nginx服务程序无法找到网站信息，因此会提示“404页面未找到”的报错信息。 在确认参数信息填写正确后便可重启Nginx服务与php-fpm服务 12345678910111213[root@localhost php-5.5.14]# vim /usr/local/nginx/conf/nginx.conf2行 user www;44行 root /usr/local/nginx/html;45行 index index.html index.htm index.php;65行 location ~ \.php$ &#123;66行 root /usr/local/nginx/html;67行 fastcgi_pass 127.0.0.1:9000;68行 fastcgi_index index.php;69行 fastcgi_param SCRIPT_FILENAME /usr/local/nginx/html$fastcgi_script_name;70行 include fastcgi_params;71行 &#125;[root@localhost php-5.5.14]# systemctl restart nginx[root@localhost php-5.5.14]# systemctl restart php-fpm 要改动的地方上面也都写了，参考自网上的文章，如果你担心配错要检查的话，看下面配置文件原文： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162user www www;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root /usr/local/nginx/html; #指定索引文件的目录 index index.html index.htm index.php; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \.php$ &#123; #开启php解析 root /usr/local/nginx/html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME script$fastcgi_script_name 改为： fastcgi_param SCRIPT_FILENAME /usr/local/nginx/html$fastcgi_script_name; #指定路径 include fastcgi_params; &#125; # fastcgi_params; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; 搭建Discuz论坛 为了检验LNMP动态网站环境是否配置妥当，可以使用在上面部署Discuz!系统，然后查看结果。如果能够在LNMP动态网站环境中成功安装使用Discuz!论坛系统，也就意味着这套架构是可用的。Discuz! X3.2是国内最常见的社区论坛系统，在经过十多年的研发后已经成为了全球成熟度最高、覆盖率最广的论坛网站系统之一。 Discuz! X3.2软件包的后缀是.zip格式，因此应当使用专用的unzip命令来进行解压。解压后会在当前目录中出现一个名为upload的文件目录，这里面保存的就是Discuz！论坛的系统程序。我们把Nginx服务程序网站根目录的内容清空后，就可以把这些这个目录中的文件都复制进去了。我们已经把Nginx服务程序的网站根目录的所有者和所属组修改为本地的www用户了，并为其赋予755权限以便于能够读、写、执行该论坛系统内的文件。 123456789101112131415[root@localhost php-5.5.14]# cd /usr/local/src/[root@localhost src]# wget http://download.comsenz.com/DiscuzX/3.2/Discuz_X3.2_SC_UTF8.zip[root@localhost src]# unzip Discuz_X3.2_SC_UTF8.zip [root@localhost src]# rm -rf /usr/local/nginx/html/&#123;index.html,50x.html&#125;*[root@localhost src]# mv upload/* /usr/local/nginx/html/[root@localhost src]# chown -Rf www:www /usr/local/nginx/html[root@localhost src]# chmod -Rf 755 /usr/local/nginx/html[root@localhost src]# cd[root@localhost ~]# firewall-cmd --add-port=&#123;80,3306&#125;/tcp --permanentWarning: ALREADY_ENABLED: 80:tcpsuccess[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# setenforce 0[root@localhost ~]# 打开IP地址，加上/install，如果是下面这个样子，那九成九都是你的配置文件配置错了，需要再次检查： 1vim /usr/local/nginx/conf/nginx.conf 如果你的配置文件正确，那么基本上不会有问题，可以开始安装Discuz论坛了。 浏览器敲入ip，它会跳转到http://192.168.141.132/install/，开始安装。 之前初始化mysql的时候你设置的root密码填上，另外再给你的论坛管理员admin想一个密码 论坛登录成功！本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-27 Discuz论坛搭建]]></title>
    <url>%2Flinux-27%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-27 Discuz论坛搭建LAMP动态网站架构关闭selinux，重启才能生效！ 123456[root@localhost ~]# vim /etc/selinux/config 将SELINUX=enforcing那一行改为：SELINUX=disabled保存退出，重启虚拟机[root@localhost ~]# reboot Discuz下载地址简体中文GBKhttp://download.comsenz.com/DiscuzX/3.2/Discuz_X3.2_SC_GBK.zip繁体中文 BIG5http://download.comsenz.com/DiscuzX/3.2/Discuz_X3.2_TC_BIG5.zip简体 UTF8http://download.comsenz.com/DiscuzX/3.2/Discuz_X3.2_SC_UTF8.zip繁体 UTF8http://download.comsenz.com/DiscuzX/3.2/Discuz_X3.2_TC_UTF8.zip 本次实验用的是简体 UTF8 ，如果是简体中文GBK 的话会出现如下图的乱码，就需要改参数了： 用yum安装lamp架构的web服务器（部署discuz论坛为例） 1234567891011121314151617[root@localhost ~]# yum install wget unzip httpd mariadb mariadb-server php php-mysql -y[root@localhost ~]# cd /var/www/html/[root@localhost html]# wget http://download.comsenz.com/DiscuzX/3.2/Discuz_X3.2_SC_UTF8.zip[root@localhost ~]# [root@localhost html]# unzip Discuz_X3.2_SC_UTF8.zip [root@localhost html]# lsDiscuz_X3.2_SC_UTF8.zip readme upload utility[root@localhost html]# chown -R apache:apache *[root@localhost html]# chmod 755 -R *[root@localhost html]# cd[root@localhost ~]# [root@localhost ~]# systemctl restart httpd mariadb[root@localhost ~]# systemctl enable httpd mariadb[root@localhost ~]# firewall-cmd --add-port=&#123;80,3306&#125;/tcp --permanent[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# 初始化数据库 设置root管理员在数据库中的密码值（注意，该密码并非root管理员在系统中的密码，这里的密码值默认应该为空，可直接按回车键）。 设置root管理员在数据库中的专有密码。 随后删除匿名账户，并使用root管理员从远程登录数据库，以确保数据库上运行的业务的安全性。 删除默认的测试数据库，取消测试数据库的一系列访问权限。 刷新授权列表，让初始化的设定立即生效。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677[root@localhost ~]# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&apos;ll need the currentpassword for the root user. If you&apos;ve just installed MariaDB, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.#这里直接敲回车Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] yNew password: Re-enter new password: Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from &apos;localhost&apos;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] y ... Success!By default, MariaDB comes with a database named &apos;test&apos; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you&apos;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB![root@localhost ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 10Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; exitBye[root@localhost ~]# [root@localhost ~]# systemctl restart mariadb.service [root@localhost ~]# 浏览器打开discuz服务器的ip加上/upload/forum.php，例如http://192.168.141.132/upload/forum.php，回车后自动跳转到安装界面http://192.168.141.132/upload/install/，如下图： 数据库密码就是刚刚我们登录mysql的root密码，这里你再想一个discuz论坛管理员的密码填进去即可： 用你刚刚设置的管理员密码登录，管理员指的是admin 登录成功后，你就可以随心所欲地设置你论坛的主题了，自己多玩玩就熟悉了。 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-26 使用phpmyadmin管理数据库]]></title>
    <url>%2Flinux-26%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-26 使用phpmyadmin管理数据库使用phpMyAdmin管理数据库安装必须的组件 1[root@localhost ~]# yum -y install httpd php mariadb mariadb-server php-mysql php-mbstring php-mcrypt unzip 首先，我们到这个网站：https://www.phpmyadmin.net/files，如下图，右键最新版本的压缩包，复制下载链接，下面wget的链接就是现在复制下来的链接。记住往下翻翻，下载旧一点的版本，这里以4.1.0版本为例： 获得phpmyadmin软件包并且解压和移动路径 1234567891011121314[root@localhost ~]# wget https://files.phpmyadmin.net/phpMyAdmin/4.1.0/phpMyAdmin-4.1.0-all-languages.zip[root@localhost ~]# lsanaconda-ks.cfg phpMyAdmin-4.1.0-all-languages.zip[root@localhost ~]# unzip phpMyAdmin-4.1.0-all-languages.zip [root@localhost ~]# lsanaconda-ks.cfg phpMyAdmin-4.1.0-all-languages phpMyAdmin-4.1.0-all-languages.zip[root@localhost ~]# mv phpMyAdmin-4.1.0-all-languages /var/www/html/phpmyadmin[root@localhost ~]# ls /var/www/html/phpmyadmin[root@localhost ~]# [root@localhost ~]# cd /var/www/html/[root@localhost html]# chown -R apache:apache phpmyadmin[root@localhost html]# chmod 755 -R phpmyadmin[root@localhost html]# 配置phpmyadmin 12345678910[root@localhost html]# cd phpmyadmin/[root@localhost phpmyadmin]# cp config.sample.inc.php config.inc.php[root@localhost phpmyadmin]# vim config.inc.php 我们在$cfg[&apos;blowfish_secret&apos;] = &apos;&apos;的引号中任意写入一串字符，大家可以把它理解为一个身份验证码。第17行： 17 $cfg[&apos;blowfish_secret&apos;] = &apos;abcdefg&apos;; 保存退出 运行phpmyadmin 123456789[root@localhost phpmyadmin]# cd[root@localhost ~]# systemctl start httpd[root@localhost ~]# systemctl enable httpdCreated symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd/system/httpd.service.[root@localhost ~]# firewall-cmd --add-port=80/tcp --permanent success[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# setenforce 0 初始化数据库 设置root管理员在数据库中的密码值（注意，该密码并非root管理员在系统中的密码，这里的密码值默认应该为空，可直接按回车键）。 设置root管理员在数据库中的专有密码。 随后删除匿名账户，并使用root管理员从远程登录数据库，以确保数据库上运行的业务的安全性。 删除默认的测试数据库，取消测试数据库的一系列访问权限。 刷新授权列表，让初始化的设定立即生效。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[root@localhost ~]# systemctl restart mariadb.service [root@localhost ~]# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&apos;ll need the currentpassword for the root user. If you&apos;ve just installed MariaDB, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.#这里直接敲回车Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] yNew password: Re-enter new password: Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from &apos;localhost&apos;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] y ... Success!By default, MariaDB comes with a database named &apos;test&apos; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you&apos;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB![root@localhost ~]# 浏览器打开服务器Server的IP地址，如下图： 在后面追加/phpmyadmin，如下图： 用root和刚刚初始化数据库的密码登录上去 在这里，你可以很方便的建表查表等完成对数据库的操作，具体就靠你自己去玩玩熟了。 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-25 常见网站架构]]></title>
    <url>%2Flinux-25%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-25 常见网站架构 网站架构简称 网站架构全称 LAMP Linux+Apache+Mysql/MariaDB+Perl/PHP/Python LNMP Linux+Nginx+MySQL+PHP WAMP Windows+Apache+Mysql/MariaDB+Perl/PHP/Python WNMP Windows+Nginx+Mysql+PHP Apache与Nginx的优缺点比较 在入职面试的时候，面试官可能会问你Apache与Nginx那个比较好，但是其实这个问题是一个陷阱。事实上，二者没有孰优孰劣，只是各有特点而已。 一、nginx相对于apache的优点： 1）轻量级，同样起web 服务，比apache 占用更少的内存及资源。 2）抗并发，nginx 处理请求是异步非阻塞的，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能。即Nginx并发性比较好，CPU、内存占用低。 3）高度模块化的设计，编写模块相对简单。 4）社区活跃，各种高性能模块出品迅速。 5）Nginx 静态处理性能比 Apache 高 3倍以上。 6）Nginx 配置简洁，而Apache 复杂 。 7）Nginx支持7层负载均衡。 8）Nginx 是一个安装非常的简单 , 配置文件非常简洁（还能够支持perl语法）, Bugs 非常少的服务器。 Nginx 启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。现在 Nginx 才是 Web 服务器的首选。 二、apache 相对于nginx 的优点： 1）apache的rewrite比nginx 的rewrite 强大， 如果rewrite频繁，那最好选apache。 2）Apache 的组件和模块比 Nginx 多，基本想到的都可以找到。 3）apache发展时间相对nginx更久，因此apache的bug少，而nginx 的bug 相对较多。 4）apache稳定性比nginx强，可以说超级稳定。 5）Apache 对 PHP 支持比较简单，而Nginx 需要配合其他后端用。 6）Apache在处理动态请求有优势，nginx处理动态请求是鸡肋，一般动态请求要apache去做，nginx只适合静态和反向。 7）Apache有大量成熟的技术和开发社区。 三、应用场景1.通常情况下 存在就是理由，一般来说，需要性能的web 服务，用nginx 。 如果不需要性能只求稳定，那就选择apache吧。apache的各种功能模块实现的比前者好，例如ssl 的模块就比前者好，但配置项多。 这里要注意一点，epoll(freebsd 上是 kqueue )网络IO 模型是nginx 处理性能高的根本理由，但并不是所有的情况下都是epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的select 模型或许比epoll 更高性能。当然，这只是根据网络IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。 2.Nginx作为 Web 服务器 相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。在高连接并发的情况下，Nginx是Apache服务器不错的替代品: Nginx在美国是做虚拟主机生意的老板们经常选择的软件平台之一. 能够支持高达 50,000 个并发连接数的响应, 感谢Nginx为我们选择了 epoll and kqueue 作为开发模型. 3.Nginx作为负载均衡服务器 Nginx 既可以在内部直接支持 Rails 和 PHP 程序对外进行服务, 也可以支持作为 HTTP代理 服务器对外进行服务. Nginx采用C进行编写, 不论是系统资源开销还是CPU使用效率都比 Perlbal 要好很多。 4.Nginx作为邮件代理服务器 Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器）, Last.fm 描述了成功并且美妙的使用经验。 5.二者的核心区别 最核心的区别在于apache是同步多进程模型，一个连接对应一个进程；nginx是异步的，多个连接（万级别）可以对应一个进程。 6.经济角度 nginx处理静态文件好，耗费内存少。但无疑apache仍然是目前的主流，有很多丰富的特性，所以还需要搭配着来。当然如果能确定nginx就适合需求，那么使用nginx会是更经济的方式。 7.可维护性 nginx的负载能力比apache高很多，最新的服务器也改用nginx了，而且nginx改完配置能利用-t测试一下配置有没有问题。apache重启的时候一旦发现配置出错了就会很崩溃，改的时候都会非常小心翼翼。现在看有好多集群站，前端nginx抗并发，后端apache集群，配合的也不错。 8.nginx作为前端服务器 nginx是很不错的前端服务器，负载性能很好，在老奔上开nginx，用webbench模拟10000个静态文件请求毫不吃力，而apache有先天不支持多核心处理、负载鸡肋的缺点。nginx的配置文件写的很简洁，正则配置让很多事情变得简单运行效率高，占用资源少，代理功能强大，很适合做前端响应服务器。 9.nginx常用场景 静态文件处理、PHP-CGI的支持、反向代理功能、前端Cache、维持连接…… 反例：在Apache+PHP（prefork）模式下，如果PHP处理慢或者前端压力很大的情况下，很容易出现Apache进程数飙升，从而拒绝服务的现象。 10.nginx模块比apache少怎么办？ 可以看一下nginx lua模块，百度上搜索 “ nginx 安装 lua-nginx-module ” 即可看到相关教程。apache比nginx多的模块，可直接用lua实现，补齐了nginx在模块方面的短板。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-24 PXE+Kickstart 无人值守安装系统]]></title>
    <url>%2Flinux-24%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-24 PXE+Kickstart无人值守安装系统概念解析一、pxe介绍 PXE(preboot execute environment，预启动执行环境)是由Intel公司开发的最新技术，工作于Client/Server的网络模式，支持工作站通过网络从远端服务器下载映像，并由此支持通过网络启动操作系统，在启动过程中，终端要求服务器分配IP地址再用TFTP或MTFTP协议下载一个启动软件包到本机内存中执行，由这个启动软件包完成终端(客户?)基本软件设置，从而引导预先安装在服务器中的终端操作系统。PXE可以引导多种操作系统。 二、.kickstart介绍 许多系统管理员倾向于使用自动安装方法来安装RedHat企业Linux在他们的机器上。为了满足这个需要，RedHat创建了kickstart安装方法。使用kickstart，系统管理员可以创建一个包含所有在典型的安装过程中通常会被问到的问题的答案的文件。启动文件可以保存在单个服务器系统上，并在运行期间有个人计算机读取安装。这安装方法可以支持使用一个启动文件来安装RedHat企业Linux在多台机器上。kickstart为用户提供了一种自动化的安装方法。 Kickstart是一种无人值守的安装方式。它的工作原理是在安装过程中记录人工干预填写的各种参数，并生成一个名为ks.cfg的文件。如果在自动安装过程中出现要填写参数的情况，安装程序首先会去查找ks.cfg文件，如果找到合适的参数，就采用所找到的参数；如果没有找到合适的参数，便会弹出对话框让安装者手工填写。所以，如果ks.cfg文件涵盖了安装过程中所有需要填写的参数，那么安装者完全可以只告诉安装程序从何处下载ks.cfg文件，然后就去忙自己的事情。等安装完毕，安装程序会根据ks.cfg中的设置重启/关闭系统，并结束安装。 三、应用 刚入职的运维新手经常会被要求去做一些安装操作系统的工作。如果按照第1章讲解的用光盘镜像来安装操作系统，其效率会相当低下。本章将介绍可以实现无人值守安装服务的PXE+Kickstart服务程序，并带领大家动手安装部署PXE + TFTP + FTP + DHCP + Kickstart等服务程序，从而搭建出一套可批量安装Linux系统的无人值守安装系统。在学完本章内容之后，运维新手就可以避免枯燥乏味的重复性工作，大大提供系统安装的效率。 PXE+Kicstart 无人值守安装系统 主机名称 操作系统 IP地址 无人值守系统 CENTOS 7 ens33：192.168.141.132 ens37：192.168.10.10 客户端主机 未安装操作系统 - 客户端主机先不要开机，服务器Server增加一块网卡，设置为仅主机模式，客户机client一块网卡为仅主机模式，尚未安装系统的客户机内存至少大于等于2G，其CD/DVD里不用放置iso系统镜像，如下图： 配置Server服务器直接关闭服务器上防火墙和selinux，省事儿 123[root@localhost ~]# setenforce 0[root@localhost ~]# systemctl stop firewalld[root@localhost ~]# 设置服务器新添加的仅主机模式网卡为固定ip 12345678910111213141516171819202122232425[root@localhost ~]# nmcli connection add con-name ens37 ifname ens37 type ethernet autoconnect yes ipv4.method manual ipv4.addresses 192.168.10.10/24连接“ens37”(4a690975-263e-4f5f-8ba9-d08fb16ff66d) 已成功添加。[root@localhost ~]# systemctl restart network[root@localhost ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:98:66:4e brd ff:ff:ff:ff:ff:ff inet 192.168.141.132/24 brd 192.168.141.255 scope global noprefixroute dynamic ens33 valid_lft 1797sec preferred_lft 1797sec inet6 fe80::5a82:cc9d:de3:b9f0/64 scope link noprefixroute valid_lft forever preferred_lft forever3: ens37: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:98:66:58 brd ff:ff:ff:ff:ff:ff inet 192.168.10.10/24 brd 192.168.10.255 scope global noprefixroute ens37 valid_lft forever preferred_lft forever inet6 fe80::8df1:2a48:abf7:c67b/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@localhost ~]# 可以看到网卡ens37的ip已经成功改为192.168.10.10/24了 配置DHCP服务 123456789101112131415161718192021222324[root@localhost ~]# yum install dhcp -y[root@localhost ~]# vim /etc/dhcp/dhcpd.conf ## DHCP Server Configuration file.# see /usr/share/doc/dhcp*/dhcpd.conf.example# see dhcpd.conf(5) man page#allow booting;allow bootp;ddns-update-style interim;ignore client-updates;subnet 192.168.10.0 netmask 255.255.255.0 &#123; option subnet-mask 255.255.255.0; option domain-name-servers 192.168.10.10; range dynamic-bootp 192.168.10.100 192.168.10.200; default-lease-time 21600; max-lease-time 43200; next-server 192.168.10.10; filename &quot;pxelinux.0&quot;;&#125;保存退出，重启dhcp服务[root@localhost ~]# systemctl restart dhcpd 配置TFTP服务 123456789101112[root@localhost ~]# yum install tftp-server xinetd -y[root@localhost ~]# vim /etc/xinetd.d/tftp 将第14行的 disable = yes改为： disable = no即可。保存退出，重启xinetd服务[root@localhost ~]# systemctl restart xinetd[root@localhost ~]# systemctl enable xinetd 配置syslinux服务程序 1[root@localhost ~]# yum install syslinux -y 在安装好SYSLinux服务程序软件包后，/usr/share/syslinux目录中会出现很多引导文件。 首先需要把SYSLinux提供的引导文件复制到TFTP服务程序的默认目录中，也就是前文提到的文件pxelinux.0，这样客户端主机就能够顺利地获取到引导文件了。 另外在Centos 7系统光盘镜像中也有一些我们需要调取的引导文件。确认光盘镜像已经被挂载到/media/cdrom目录后，使用复制命令将光盘镜像中自带的一些引导文件也复制到TFTP服务程序的默认目录中。 12345678910111213[root@localhost ~]# cd /var/lib/tftpboot/[root@localhost tftpboot]# cp /usr/share/syslinux/pxelinux.0 .[root@localhost tftpboot]# mkdir -p /media/cdrom[root@localhost tftpboot]# mount /dev/cdrom /media/cdrom/mount: /dev/sr0 写保护，将以只读方式挂载[root@localhost tftpboot]# cd /media/cdrom/images/pxeboot/[root@localhost pxeboot]# lsinitrd.img TRANS.TBL vmlinuz[root@localhost pxeboot]# cd -/var/lib/tftpboot[root@localhost tftpboot]# [root@localhost tftpboot]# cp /media/cdrom/images/pxeboot/&#123;vmlinuz,initrd.img&#125; .[root@localhost tftpboot]# cp /media/cdrom/isolinux/&#123;vesamenu.c32,boot.msg&#125; . 然后在TFTP服务程序的目录中新建pxelinux.cfg目录，虽然该目录的名字带有后缀，但依然也是目录，而非文件！将系统光盘中的开机选项菜单复制到该目录中，并命名为default。这个default文件就是开机时的选项菜单 123[root@localhost tftpboot]# mkdir pxelinux.cfg[root@localhost tftpboot]# cp /media/cdrom/isolinux/isolinux.cfg pxelinux.cfg/default[root@localhost tftpboot]# 默认安装系统会对安装介质进行检验，无法做到无人值守，所以修改菜单 123[root@localhost tftpboot]# vi pxelinux.cfg/default1行 default linux64行 append initrd=initrd.img inst.stage2=ftp://192.168.10.10 ks=ftp://192.168.10.10/pub/ks.cfg quiet 配置vsftpd服务 光盘镜像是通过FTP协议传输的，因此要用到vsftpd服务程序 123456[root@localhost tftpboot]# cd [root@localhost ~]# yum install vsftpd -y[root@localhost ~]# systemctl restart vsftpd[root@localhost ~]# systemctl enable vsftpdCreated symlink from /etc/systemd/system/multi-user.target.wants/vsftpd.service to /usr/lib/systemd/system/vsftpd.service.[root@localhost ~]# 在确认系统光盘镜像已经正常挂载到/media/cdrom目录后，把目录中的光盘镜像文件全部复制到vsftpd服务程序的工作目录中。并且添加防火墙策略和设置SELinux安全上下文 12[root@localhost ~]# cp -r /media/cdrom/* /var/ftp/[root@localhost ~]# setsebool -P ftpd_connect_all_unreserved=on 创建KickStart应答文件 Kickstart应答文件中包含了系统安装过程中需要使用的选项和参数信息，系统可以自动调取这个应答文件的内容，从而彻底实现了无人值守安装系统。 在root管理员的家目录中有一个名为anaconda-ks.cfg的文件，它就是应答文件。下面将这个文件复制到vsftpd服务程序的工作目录中（在开机选项菜单的配置文件中已经定义了该文件的获取路径，也就是vsftpd服务程序数据目录中的pub子目录中）。使用chmod命令设置该文件的权限，确保所有人都有可读的权限，以保证客户端主机可以顺利获取到应答文件及里面的内容 123[root@localhost ~]# cp ~/anaconda-ks.cfg /var/ftp/pub/ks.cfg[root@localhost ~]# chmod +r /var/ftp/pub/ks.cfg [root@localhost ~]# 注意，既然应答文件ks.cfg 来自于Server的anaconda-ks.cfg文件，那么之后的客户机装好后root密码和Server的是一样的。 修改这个文件，root密码就不改了，就和Server用一样的吧 123[root@localhost ~]# vi /var/ftp/pub/ks.cfg 5行 url --url=ftp://192.168.10.10 //删除原本的cdrom，把镜像来源定位到Server上30行 clearpart --all --initlabel //意思是清空所有磁盘内容并初始化磁盘 如果觉得系统默认自带的应答文件参数较少，不能满足生产环境的需求，则可以通过Yum软件仓库来安装system-config-kickstart软件包。这是一款图形化的Kickstart应答文件生成工具，可以根据自己的需求生成自定义的应答文件，然后将生成的文件放到/var/ftp/pub目录中并将名字修改为ks.cfg即可。 开启一台没有安装系统的虚拟机（内存至少大于等于2G） 选择否 下图中敲完回车不要急，等~ 可以看到自动安装已经开始了，咱们不用去动它，它自己会装好的，我们耐心等待即可 ​ 它自动给root设置了密码，就是我们之前提到的，和Server一样的root密码。我们不用进行任何操作，等，等蛮久的，等吧~ 终于等到它完成了，点击重启 重启后，用root以及Server的root密码来登录客户机： 可以看到登录成功！ Server关机后保存好快照，以后咱们装新的虚拟机可以找开启Server后关掉防火墙和selinux后，让它自动安装系统。 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-23 MariaDB数据库管理系统]]></title>
    <url>%2Flinux-23%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-23 MariaDB数据库管理系统概念解析MariaDB数据库管理系统初始化MariaDB数据库安装和初始化mariadb数据库服务 12345678[root@localhost ~]# yum -y install mariadb mariadb-server[root@localhost ~]# systemctl restart mariadb[root@localhost ~]# systemctl enable mariadbCreated symlink from /etc/systemd/system/multi-user.target.wants/mariadb.service to /usr/lib/systemd/system/mariadb.service.[root@localhost ~]# firewall-cmd --add-port=3306/tcp --permanent success[root@localhost ~]# firewall-cmd --reloadsuccess 初始化数据库 设置root管理员在数据库中的密码值（注意，该密码并非root管理员在系统中的密码，这里的密码值默认应该为空，可直接按回车键）。 设置root管理员在数据库中的专有密码。 随后删除匿名账户，并使用root管理员从远程登录数据库，以确保数据库上运行的业务的安全性。 删除默认的测试数据库，取消测试数据库的一系列访问权限。 刷新授权列表，让初始化的设定立即生效。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[root@localhost ~]# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&apos;ll need the currentpassword for the root user. If you&apos;ve just installed MariaDB, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] yNew password: Re-enter new password: Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from &apos;localhost&apos;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] y ... Success!By default, MariaDB comes with a database named &apos;test&apos; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you&apos;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB![root@localhost ~]# 登录数据库 1234567891011[root@localhost ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 13Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; 查看数据库 123456789MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema |+--------------------+3 rows in set (0.00 sec) 修改当前用户的密码 1234MariaDB [(none)]&gt; set password = password(&apos;123456&apos;);Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; 管理账户及授权创建一个用户并设置密码 1234567MariaDB [(none)]&gt; create user aaa@localhost identified by &apos;123456&apos; -&gt; ;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; 注意，这里我是忘了敲分号，不过第二行补敲也是可以的。 查看这个用户的指定属性 1234567891011121314MariaDB [(none)]&gt; use mysqlReading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [mysql]&gt; select Host,User,Password from user where User= &apos;aaa&apos;;+-----------+------+-------------------------------------------+| Host | User | Password |+-----------+------+-------------------------------------------+| localhost | aaa | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |+-----------+------+-------------------------------------------+1 row in set (0.00 sec)MariaDB [mysql]&gt; 为用户赋予权限grant命令用于为账户进行授权 命令 作用 GRANT 权限 ON 数据库.表单名称 TO 账户名@主机名 对某个特定数据库中的特定表单给予授权 GRANT权限ON数据库.*TO账户名@主机名 对某个特定数据库中的所有表单给予授权 GRANT权限ON.TO账户名@主机名 对所有数据库及所有表单给予授权 GRANT权限1,权限2 ON 数据库.*TO账户名@主机名 对某个数据库中的所有表单给予多个授权 GRANT ALL PRIVILEGES ON .TO账户名@主机名 对所有数据库及所有表单给予全部授权（需谨慎操作） 为用户aaa授予增、删、改、查的权限 12345678910111213MariaDB [mysql]&gt; grant select,update,insert on mysql.user to aaa@localhost;Query OK, 0 rows affected (0.00 sec)MariaDB [mysql]&gt; show grants for aaa@localhost;+------------------------------------------------------------------------------------------------------------+| Grants for aaa@localhost |+------------------------------------------------------------------------------------------------------------+| GRANT USAGE ON *.* TO &apos;aaa&apos;@&apos;localhost&apos; IDENTIFIED BY PASSWORD &apos;*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9&apos; || GRANT SELECT, INSERT, UPDATE ON `mysql`.`user` TO &apos;aaa&apos;@&apos;localhost&apos; |+------------------------------------------------------------------------------------------------------------+2 rows in set (0.00 sec)MariaDB [mysql]&gt; 移除aaa用户增、删、改、查的权限 12345678910MariaDB [mysql]&gt; revoke select,update,insert on mysql.user from aaa@localhost;Query OK, 0 rows affected (0.00 sec)MariaDB [mysql]&gt; show grants for aaa@localhost;+------------------------------------------------------------------------------------------------------------+| Grants for aaa@localhost |+------------------------------------------------------------------------------------------------------------+| GRANT USAGE ON *.* TO &apos;aaa&apos;@&apos;localhost&apos; IDENTIFIED BY PASSWORD &apos;*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9&apos; |+------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 创建数据库与表单 命令 作用 CREATE DATABASE 数据库名称 创建新的数据库 DESCRIBE 表单名称 描述表单 UPDATE表单名称SET attribute=新值WHERE attribute&gt;原始值 更新表单中的数据 USE数据库名称 指定使用的数据库 SHOW databases 显示当前已有的数据库 SHOW tables 显示当前数据库中的表单 SELECT * FROM表单名称 从表单中选中某个记录值 DELETE FROM表单名WHERE attribute=值 从表单中删除某个记录值 创建数据库123456789101112131415MariaDB [mysql]&gt; create database DBaaa;Query OK, 1 row affected (0.00 sec)MariaDB [mysql]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || DBaaa || mysql || performance_schema |+--------------------+4 rows in set (0.01 sec)MariaDB [mysql]&gt; 使用这个库以及在新建的库里新建数据表，并且查询新建表的结构 1234567891011121314151617181920MariaDB [mysql]&gt; use DBaaa;Database changedMariaDB [DBaaa]&gt; create table student( -&gt; name char(15), -&gt; school char(15), -&gt; age int -&gt; );Query OK, 0 rows affected (0.00 sec)MariaDB [DBaaa]&gt; desc student;+--------+----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+----------+------+-----+---------+-------+| name | char(15) | YES | | NULL | || school | char(15) | YES | | NULL | || age | int(11) | YES | | NULL | |+--------+----------+------+-----+---------+-------+3 rows in set (0.00 sec)MariaDB [DBaaa]&gt; 管理表单及数据——增删改查插入一条学生信息（增） 123456789101112131415MariaDB [DBaaa]&gt; select * from student;Empty set (0.00 sec)MariaDB [DBaaa]&gt; insert into student(name,school,age) values(&apos;zhangsan&apos;,&apos;beida&apos;,18);Query OK, 1 row affected (0.00 sec)MariaDB [DBaaa]&gt; select * from student;+----------+--------+------+| name | school | age |+----------+--------+------+| zhangsan | beida | 18 |+----------+--------+------+1 row in set (0.00 sec)MariaDB [DBaaa]&gt; 修改这条信息（改）如果数据库里只有这一个人，我们可以这样修改他的信息，即修改所有成员的年龄为20 12345678910111213MariaDB [DBaaa]&gt; update student set age=20;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0MariaDB [DBaaa]&gt; select * from student;+----------+--------+------+| name | school | age |+----------+--------+------+| zhangsan | beida | 20 |+----------+--------+------+1 row in set (0.00 sec)MariaDB [DBaaa]&gt; 如果数据库里不只这一个人，如下，我们再加几个，然后我们可以这样修改他的信息，即针对某个人修改其年龄。 123456789101112131415161718192021222324252627282930313233343536MariaDB [DBaaa]&gt; insert into student(name,school,age) values(&apos;lisi&apos;,&apos;qinghua&apos;,16);Query OK, 1 row affected (0.00 sec)MariaDB [DBaaa]&gt; insert into student(name,school,age) values(&apos;wangwu&apos;,&apos;fudan&apos;,17);Query OK, 1 row affected (0.00 sec)MariaDB [DBaaa]&gt; insert into student(name,school,age) values(&apos;zhaoliu&apos;,&apos;zheda&apos;,19);Query OK, 1 row affected (0.00 sec)MariaDB [DBaaa]&gt; select * from student;+----------+---------+------+| name | school | age |+----------+---------+------+| zhangsan | beida | 20 || lisi | qinghua | 16 || wangwu | fudan | 17 || zhaoliu | zheda | 19 |+----------+---------+------+4 rows in set (0.00 sec)MariaDB [DBaaa]&gt; update student set age=50 where name=&apos;zhangsan&apos;;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0MariaDB [DBaaa]&gt; select * from student;+----------+---------+------+| name | school | age |+----------+---------+------+| zhangsan | beida | 50 || lisi | qinghua | 16 || wangwu | fudan | 17 || zhaoliu | zheda | 19 |+----------+---------+------+4 rows in set (0.00 sec)MariaDB [DBaaa]&gt; 删除数据库的信息（删）如果数据库里不只有一个人，我们可以这样删除他的信息，即针对某个人删除其信息 12345678910111213141516171819202122232425MariaDB [DBaaa]&gt; select * from student;+----------+---------+------+| name | school | age |+----------+---------+------+| zhangsan | beida | 50 || lisi | qinghua | 16 || wangwu | fudan | 17 || zhaoliu | zheda | 19 |+----------+---------+------+4 rows in set (0.00 sec)MariaDB [DBaaa]&gt; delete from student where name=&apos;zhangsan&apos;;Query OK, 1 row affected (0.00 sec)MariaDB [DBaaa]&gt; select * from student;+---------+---------+------+| name | school | age |+---------+---------+------+| lisi | qinghua | 16 || wangwu | fudan | 17 || zhaoliu | zheda | 19 |+---------+---------+------+3 rows in set (0.00 sec)MariaDB [DBaaa]&gt; 一次性删除所有表项： 1234567891011121314151617MariaDB [DBaaa]&gt; select * from student;+---------+---------+------+| name | school | age |+---------+---------+------+| lisi | qinghua | 16 || wangwu | fudan | 17 || zhaoliu | zheda | 19 |+---------+---------+------+3 rows in set (0.00 sec)MariaDB [DBaaa]&gt; delete from student;Query OK, 3 rows affected (0.00 sec)MariaDB [DBaaa]&gt; select * from student;Empty set (0.00 sec)MariaDB [DBaaa]&gt; 数据表中插入多条信息 1234567891011121314151617181920212223MariaDB [DBaaa]&gt; select * from student;Empty set (0.00 sec)MariaDB [DBaaa]&gt; insert into student(name,school,age) values(&apos;lisi&apos;,&apos;qinghua&apos;,16);Query OK, 1 row affected (0.00 sec)MariaDB [DBaaa]&gt; insert into student(name,school,age) values(&apos;wangwu&apos;,&apos;fudan&apos;,17);Query OK, 1 row affected (0.00 sec)MariaDB [DBaaa]&gt; insert into student(name,school,age) values(&apos;zhaoliu&apos;,&apos;zheda&apos;,19);Query OK, 1 row affected (0.00 sec)MariaDB [DBaaa]&gt; select * from student;+---------+---------+------+| name | school | age |+---------+---------+------+| lisi | qinghua | 16 || wangwu | fudan | 17 || zhaoliu | zheda | 19 |+---------+---------+------+3 rows in set (0.00 sec)MariaDB [DBaaa]&gt; 查询数据库中的数据——查​ 查找某条信息，要想让查询结果更加精准，就需要结合使用select与where命令了。其中，where命令是在数据库中进行匹配查询的条件命令。通过设置查询条件，就可以仅查找出符合该条件的数据 参数 作用 = 相等 &lt;&gt;或!= 不相等 &gt; 大于 &lt; 小于 &gt;= 大于或等于 &lt;= 小于或等于 BETWEEN 在某个范围内 LIKE 搜索一个例子 IN 在列中搜索多个值 123456789101112131415161718192021222324252627282930MariaDB [DBaaa]&gt; select * from student;+---------+---------+------+| name | school | age |+---------+---------+------+| lisi | qinghua | 16 || wangwu | fudan | 17 || zhaoliu | zheda | 19 |+---------+---------+------+3 rows in set (0.00 sec)MariaDB [DBaaa]&gt; select * from student where age&lt;18;+--------+---------+------+| name | school | age |+--------+---------+------+| lisi | qinghua | 16 || wangwu | fudan | 17 |+--------+---------+------+2 rows in set (0.00 sec)MariaDB [DBaaa]&gt; select * from student where age&gt;18;+---------+--------+------+| name | school | age |+---------+--------+------+| zhaoliu | zheda | 19 |+---------+--------+------+1 row in set (0.00 sec)MariaDB [DBaaa]&gt; exitBye[root@localhost ~]# 数据库的备份和恢复mysqldump命令用于备份数据库数据，格式为“mysqldump [参数] [数据库名称]”。 其中参数与mysql命令大致相同，-u参数用于定义登录数据库的账户名称，-p参数代表密码提示符 123[root@localhost ~]# mysqldump -u root -p DBaaa &gt; /root/DBaaa.dumpEnter password: [root@localhost ~]# 尝试删除eagleslab数据库，然后再恢复 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[root@localhost ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 15Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; drop database DBaaa;Query OK, 1 row affected (0.01 sec)MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema |+--------------------+3 rows in set (0.00 sec)删完库，我们给它加回来，但是事实上加回来的只是一个空壳MariaDB [(none)]&gt; create database DBaaa;Query OK, 1 row affected (0.00 sec)MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || DBaaa || mysql || performance_schema |+--------------------+4 rows in set (0.00 sec)MariaDB [(none)]&gt; use DBaaa;Database changedMariaDB [DBaaa]&gt; select * from student;ERROR 1146 (42S02): Table &apos;DBaaa.student&apos; doesn&apos;t existMariaDB [DBaaa]&gt; exitBye[root@localhost ~]# 可以看到这个空壳数据库里，并没有student表。 将刚刚备份的文件导入数据库 12345678910111213141516171819202122232425262728293031323334353637383940[root@localhost ~]# mysql -u root -p DBaaa &lt; /root/DBaaa.dump Enter password: [root@localhost ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 18Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; use DBaaa;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [DBaaa]&gt; show tables;+-----------------+| Tables_in_DBaaa |+-----------------+| student |+-----------------+1 row in set (0.00 sec)MariaDB [DBaaa]&gt; select * from student;+---------+---------+------+| name | school | age |+---------+---------+------+| lisi | qinghua | 16 || wangwu | fudan | 17 || zhaoliu | zheda | 19 |+---------+---------+------+3 rows in set (0.00 sec)MariaDB [DBaaa]&gt; exitBye[root@localhost ~]# 可以看到我们的数据恢复成功了。 数据库密码泄露不安全的数据库登录方式： 1mysql -uroot -p123456 ​ 这种登录方式可以用history 查看到数据库账户密码，是极不安全的 1234567891011121314151617181920[root@localhost ~]# mysql -uroot -p123456Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 20Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; exitBye[root@localhost ~]# history 1 87 history 1[root@localhost ~]# history 3 86 mysql -uroot -p123456 87 history 1 88 history 3[root@localhost ~]# 注意，history后面的参数是显示历史命令的条数。 建议还是用正常的mysql -u root -p 再输入看不见的密码比较好 1234567891011121314151617181920212223242526272829303132333435363738[root@localhost ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 23Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; create user bbb@localhost identified by &apos;123456&apos; -&gt; ;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [mysql]&gt; select Host,User,Password from user where User= &apos;bbb&apos;;+-----------+------+-------------------------------------------+| Host | User | Password |+-----------+------+-------------------------------------------+| localhost | bbb | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |+-----------+------+-------------------------------------------+1 row in set (0.00 sec)MariaDB [mysql]&gt; MariaDB [mysql]&gt; exitBye[root@localhost ~]# history 2 89 mysql -u root -p 90 history 2[root@localhost ~]# 如上，使用history看不到密码，进到mysql里查看bbb的密码也只是乱码。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-22 iSCSI网络存储服务]]></title>
    <url>%2Flinux-22%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-22 iSCSI网络存储服务概念解析 iSCSI（Internet Small Computer System Interface，发音为/ˈаɪskʌzi/），Internet小型计算机系统接口，又称为IP-SAN，是一种基于因特网及SCSI-3协议下的存储技术，由IETF提出，并于2003年2月11日成为正式的标准。 ​ iSCSI利用了TCP/IP的port 860 和 3260 作为沟通的渠道。透过两部计算机之间利用iSCSI的协议来交换SCSI命令，让计算机可以透过高速的局域网集线来把SAN模拟成为本地的储存装置。 iSCSI使用 TCP/IP 协议（一般使用TCP端口860和3260）。 本质上，iSCSI 让两个主机通过 IP 网络相互协商然后交换SCSI命令。这样一来，iSCSI 就是用广域网仿真了一个常用的高性能本地存储总线，从而创建了一个存储局域网（SAN）。 ​ SCSI 小型计算机系统接口（英语：Small Computer System Interface; 简写：SCSI），一种用于计算机和智能设备之间的系统级接口的独立处理器标准。 SCSI是一种智能的通用接口标准。 为了进一步提升硬盘存储设备的读写速度和性能，人们一直在努力改进物理硬盘设备的接口协议。当前的硬盘接口类型主要有IDE、SCSI和SATA这3种。 IDE是一种成熟稳定、价格便宜的并行传输接口。 SATA是一种传输速度更快、数据校验更完整的串行传输接口。 SCSI是一种用于计算机和硬盘、光驱等设备之间系统级接口的通用标准，具有系统资源占用率低、转速高、传输速度快等优点。 不论使用什么类型的硬盘接口，硬盘上的数据总是要通过计算机主板上的总线与CPU、内存设备进行数据交换，这种物理环境上的限制给硬盘资源的共享带来了各种不便。后来，IBM公司开始动手研发基于TCP/IP协议和SCSI接口协议的新型存储技术，这也就是我们目前能看到的互联网小型计算机系统接口（iSCSI，Internet Small Computer System Interface）。这是一种将SCSI接口与以太网技术相结合的新型存储技术，可以用来在网络中传输SCSI接口的命令和数据。这样，不仅克服了传统SCSI接口设备的物理局限性，实现了跨区域的存储资源共享，还可以在不停机的状态下扩展存储容量。 为了让各位读者做到知其然，知其所以然，以便在工作中灵活使用这项技术，下面将讲解一下iSCSI技术在生产环境中的优势和劣势。首先，iSCSI存储技术非常便捷，在访问存储资源的形式上发生了很大变化，摆脱了物理环境的限制，同时还可以把存储资源分给多个服务器共同使用，因此是一种非常推荐使用的存储技术。但是，iSCSI存储技术受到了网速的制约。以往，硬盘设备直接通过主板上的总线进行数据传输，现在则需要让互联网作为数据传输的载体和通道，因此传输速率和稳定性是iSCSI技术的瓶颈。随着网络技术的持续发展，相信iSCSI技术也会随之得以改善。 既然要通过以太网来传输硬盘设备上的数据，那么数据是通过网卡传入到计算机中的么？这就有必要向大家介绍iSCSI-HBA卡了（见图17-1）。与一般的网卡不同（连接网络总线和内存，供计算机上网使用），iSCSI-HBA卡连接的则是SCSI接口或FC（光纤通道）总线和内存，专门用于在主机之间交换存储数据，其使用的协议也与一般网卡有本质的不同。运行Linux系统的服务器会基于iSCSI协议把硬盘设备命令与数据打包成标准的TCP/IP数据包，然后通过以太网传输到目标存储设备，而当目标存储设备接收到这些数据包后，还需要基于iSCSI协议把TCP/IP数据包解压成硬盘设备命令与数据。 iSCSI网络存储服务创建一个raid磁盘阵列添加4个硬盘 开机，检查硬盘是否添加成功 1234567[root@localhost ~]# ll /dev/sd?brw-rw----. 1 root disk 8, 0 Feb 7 07:08 /dev/sdabrw-rw----. 1 root disk 8, 16 Feb 7 07:08 /dev/sdbbrw-rw----. 1 root disk 8, 32 Feb 7 07:08 /dev/sdcbrw-rw----. 1 root disk 8, 48 Feb 7 07:08 /dev/sddbrw-rw----. 1 root disk 8, 64 Feb 7 07:08 /dev/sde[root@localhost ~]# 创建raid阵列 12345678910111213[root@localhost ~]# yum install mdadm.x86_64 -y[root@localhost ~]# mdadm -Cv /dev/md0 -n 3 -l 5 -x 1 /dev/sd&#123;b,c,d,e&#125;[root@localhost ~]# mdadm -D /dev/md0 /dev/md0: Version : 1.2 Creation Time : Sat Sep 22 14:06:23 2018 Raid Level : raid5 Array Size : 41908224 (39.97 GiB 42.91 GB) Used Dev Size : 20954112 (19.98 GiB 21.46 GB) Raid Devices : 3 Total Devices : 4 Persistence : Superblock is persistent ……………………………………………………………………………………………………略 配置ISCSI服务安装iscsi服务端、iscsi初始化和配置服务所需的工具 1[root@localhost ~]# yum -y install targetd targetcli iscsi-initiator-utils 开启并设置iscsi服务开机启动 1234[root@localhost ~]# systemctl start targetd[root@localhost ~]# systemctl enable targetdCreated symlink from /etc/systemd/system/multi-user.target.wants/targetd.service to /usr/lib/systemd/system/targetd.service.[root@localhost ~]# 进入交互式iSCSI子系统配置iSCSI服务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[root@localhost ~]# targetcliWarning: Could not load preferences file /root/.targetcli/prefs.bin.targetcli shell version 2.1.fb46Copyright 2011-2013 by Datera, Inc and others.For help on commands, type &apos;help&apos;./&gt; lso- / ............................................................................. [...] o- backstores .................................................................. [...] | o- block ...................................................... [Storage Objects: 0] | o- fileio ..................................................... [Storage Objects: 0] | o- pscsi ...................................................... [Storage Objects: 0] | o- ramdisk .................................................... [Storage Objects: 0] o- iscsi ................................................................ [Targets: 0] o- loopback ............................................................. [Targets: 0] # 为ISCSI服务提供资源池 /&gt; cd /backstores/block /backstores/block&gt; create disk0 /dev/md0Created block storage object disk0 using /dev/md0./backstores/block&gt; cd //&gt; lso- / ............................................................................. [...] o- backstores .................................................................. [...] | o- block ...................................................... [Storage Objects: 1] | | o- disk0 ............................. [/dev/md0 (40.0GiB) write-thru deactivated] | | o- alua ....................................................... [ALUA Groups: 1] | | o- default_tg_pt_gp ........................... [ALUA state: Active/optimized] | o- fileio ..................................................... [Storage Objects: 0] | o- pscsi ...................................................... [Storage Objects: 0] | o- ramdisk .................................................... [Storage Objects: 0] o- iscsi ................................................................ [Targets: 0] o- loopback ............................................................. [Targets: 0] # 为iSCSI服务提供主机提供一个主机名，敲完create后将下面的iqn复制下来/&gt; cd iscsi/iscsi&gt; createCreated target iqn.2003-01.org.linux-iscsi.localhost.x8664:sn.70683bd3ee6d.Created TPG 1.Global pref auto_add_default_portal=trueCreated default portal listening on all IPs (0.0.0.0), port 3260.这里cd的就是上面复制下来的iqn/iscsi&gt; cd iqn.2003-01.org.linux-iscsi.localhost.x8664:sn.70683bd3ee6d# 为客户机划分出lun提供存储资源/iscsi/iqn.20....70683bd3ee6d&gt; cd tpg1/luns /iscsi/iqn.20...e6d/tpg1/luns&gt; create /backstores/block/disk0 Created LUN 0./iscsi/iqn.20...e6d/tpg1/luns&gt; cd ..# 设置允许访问服务器控制访问列表，这里的iqn是linux客户端装完iscsi-initiator-utils之后在/etc/iscsi/initiatorname.iscsi 文件中得到的客户机iqn，注意不是上面用过的iqn，为了与之前那个iqn区分，咱们称呼它为iqn2吧。如下图：/iscsi/iqn.20...3bd3ee6d/tpg1&gt; cd acls/iscsi/iqn.20...e6d/tpg1/acls&gt; create iqn.1994-05.com.redhat:0191b6bea67Created Node ACL for iqn.1994-05.com.redhat:0191b6bea67Created mapped LUN 0./iscsi/iqn.20...e6d/tpg1/acls&gt; exitGlobal pref auto_save_on_exit=trueConfiguration saved to /etc/target/saveconfig.json[root@localhost ~]# 咱们在XShell那里复制一个会话，在新的窗口复制下来新的iqn作为iqn2，然后回到原来那个窗口即可粘贴使用。 防火墙放行服务端的3260端口 12345[root@localhost ~]# firewall-cmd --add-port=3260/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# 现在再开一台linux虚拟机作为测试用的客户机，这里以client2为例： Linux客户机挂载服务端上的ISCSI硬盘 1234567891011121314151617181920212223242526[root@localhost ~]# yum -y install iscsi-initiator-utils[root@localhost ~]# vi /etc/iscsi/initiatorname.iscsi 这里将其iqn修改为咱们刚刚复制的iqn2InitiatorName=iqn.1994-05.com.redhat:0191b6bea67保存退出，重启iscsid服务[root@localhost ~]# systemctl restart iscsid[root@localhost ~]# systemctl enable iscsidCreated symlink from /etc/systemd/system/multi-user.target.wants/iscsid.service to /usr/lib/systemd/system/iscsid.service.[root@localhost ~]# # 没有挂载之前我们只有一块硬盘[root@localhost ~]# ll /dev/sd?brw-rw----. 1 root disk 8, 0 2月 7 22:18 /dev/sda[root@localhost ~]# 挂载，再次检查，发现多出来一块硬盘，第二块就是我们挂载上来的iscsi硬盘（这里192.168.141.12是iscsi服务器的ip）[root@localhost ~]# iscsiadm -m discovery -t st -p 192.168.141.12 --login192.168.141.12:3260,1 iqn.2003-01.org.linux-iscsi.localhost.x8664:sn.70683bd3ee6dLogging in to [iface: default, target: iqn.2003-01.org.linux-iscsi.localhost.x8664:sn.70683bd3ee6d, portal: 192.168.141.12,3260] (multiple)Login to [iface: default, target: iqn.2003-01.org.linux-iscsi.localhost.x8664:sn.70683bd3ee6d, portal: 192.168.141.12,3260] successful.[root@localhost ~]# ll /dev/sd?brw-rw----. 1 root disk 8, 0 2月 7 22:18 /dev/sdabrw-rw----. 1 root disk 8, 16 2月 7 22:31 /dev/sdb[root@localhost ~]# windows客户机挂载iSCSI首先，先看看我电脑本来有几个硬盘： 可以看到，本来我的电脑只有俩硬盘，一会咱们挂载成功后，理论上会多出一个硬盘来。 打开windows自带的iSCSI发起程序，在windows10搜索栏即可搜索 目标填上IP地址，选择快速连接点击完成（这里我已经连过一次了，下面那个可以不管，也可以刷新一下即可） 为了能连接上，修改配置中的客户端名，修改成之前我们所谓的iqn2 改完以后选择连接 显示已连接 现在再次看看我电脑上有几个硬盘： 我刚打开，就跳出个消息，说是要让我初始化磁盘2，点击确定即可，如下图： 现在将磁盘管理全屏显示（太小了磁盘2就被遮住了），如下图： 如上图，多出来的磁盘2就是咱们挂载上去的磁盘了。 右键磁盘2，新建简单卷，然后一直点击下一步即可建成。 接下来我们打开文件资源管理器，如下图，可以看到一个新加卷： 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-21 Squid部署代理缓存服务]]></title>
    <url>%2Flinux-21%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-21 Squid部署代理缓存服务概念解析Squid Squid是一个高性能的代理缓存服务器，Squid支持FTP、gopher、HTTPS和HTTP协议。和一般的代理缓存软件不同，Squid用一个单独的、非模块化的、I/O驱动的进程来处理所有的客户端请求。 Squid是一种用来缓冲Internet数据的软件。它是这样实现其功能的，接受来自人们需要下载的目标（object）的请求并适当地处理这些请求。也就是说，如果一个人想下载一web页面，他请求Squid为他取得这个页面。Squid随之连接到远程服务器（比如：http://squid.nlanr.net）并向这个页面发出请求。然后，Squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时，Squid可以简单地从磁盘中读到它，那样数据迅即就会传输到客户机上。当前的Squid可以处理HTTP，FTP，GOPHER，SSL和WAIS等协议。但它不能处理如POP，NNTP，RealAudio以及其它类型的东西。 squid分类按照代理类型的不同，可以将Squid代理分为正向代理和反向代理。 正向代理：根据实现方式的不同，又可以分为普通代理和透明代理。 1）普通代理：需要客户机在浏览器中指定代理服务器的地址、端口； 2）透明代理：适用于企业的网关主机（共享接入Internet）中，客户机不需要指定代理服务器地址、端口等信息，代理服务器需要设置防火墙策略将客户机的Web访问数据转交给代理服务程序处理； 反向代理：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 ​ ​ 代理服务器英文全称是Proxy Server，其功能就是代理网络用户去取得网络信息。 ​ Squid是一个缓存Internet 数据的软件，其接收用户的下载申请，并自动处理所下载的数据。当一个用户想要下载一个主页时，可以向Squid 发出一个申请，要Squid 代替其进行下载，然后Squid 连接所申请网站并请求该主页，接着把该主页传给用户同时保留一个备份，当别的用户申请同样的页面时，Squid 把保存的备份立即传给用户，使用户觉得速度相当快。Squid 可以代理HTTP、FTP、GOPHER、SSL和WAIS等协议并且Squid 可以自动地进行处理，可以根据自己的需要设置Squid，使之过滤掉不想要的东西。 Squid代理服务器工作在TCP/IP的应用层： 实验准备工作实验原理 我们需要两台虚拟机，一台是win10操作系统作为客户端，另一台我们新安装一个Centos 7的虚拟机Server。配置好虚拟机Server后，将Server作为客户端win10的代理服务器，从而让win10能够上网。为了大家能完全理解虚拟机通信原理，我这里将整体上的网络结构拓扑图画出来，如下图： ​ 在之前的文章中，我们讲解过网络适配器三种模式的工作原理，本次实验设置如下： 设置1.虚拟机Server 2.虚拟机WIN10 3.VMware Workstation Pro设置 ​ 点击图中更改设置即可更改，这里放出的图是改好后的图。 通信原理 结合下图，我们的Server网卡1和WIN10 的网卡均是仅主机模式的，所以对应的，他们的ip自然是由VMnet1的虚拟DHCP服务器来分配。我们的Server网卡2是桥接模式的，相当于用一个交换机连着我们电脑的真实电脑，所以我们现在用着的物理机的ip和Server网卡2的ip均由我们的家用路由器分配。我们去到别人家里，连上别人家wifi，就会得到一个ip地址，仔细看的话就会发现家用路由器分配给我们的都是192.168.1.X的ip，在这里也是这个道理。 对了，有一次我将虚拟机网卡设置为桥接模式之后，开机查看ip发现ip竟然不是192.168.1.X了，而是一个奇怪的ip。我当时想了很久也没发现问题，难道是电脑抽风了？后来才想起来，我家断网了，我临时连着的是手机热点，真是很尴尬。 ​ 如下图，由于虚拟机WIN10是仅主机模式的，所以它要访问NET外网，其数据就必须从Server那里经过。 查看本机ip（虚拟机win10） 1C:\Users\zhong&gt;ipconfig 查看Server的ip 1[root@localhost ~]# ip add 由上面两张图我们得知了虚拟机WIN10的ip是192.168.23.53 虚拟机Server的ip分别是192.168.23.52和192.168.1.106 为了实验更加清晰明了，我们把分配好的ip加到拓扑图里，新的拓扑图如下： 保存快照 实验到这里，基本准备已经准备好，记住一定要给上述虚拟机Server关机保存快照，这个快照的名字就叫做“快照1”，待会我们做透明代理实验的时候恢复成这个快照再做。虚拟机WIN10就可以不用弄快照了，反正是测试用的，配置少得可怜。 配置Squid服务程序 检查虚拟机WIN10是否可以和Server通信，这里要注意的是，不同网段不能ping通，同一网段可以ping通，如下图： 检查Server是否可以连接外网和ping通虚拟机WIN10（ping需要手动用ctrl+c打断） 123456789101112131415161718[root@localhost ~]# ping baidu.comPING baidu.com (123.125.115.110) 56(84) bytes of data.64 bytes from 123.125.115.110 (123.125.115.110): icmp_seq=1 ttl=51 time=45.7 ms64 bytes from 123.125.115.110 (123.125.115.110): icmp_seq=2 ttl=51 time=45.8 ms64 bytes from 123.125.115.110 (123.125.115.110): icmp_seq=3 ttl=51 time=101 ms^C--- baidu.com ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2002msrtt min/avg/max/mdev = 45.774/64.315/101.284/26.141 ms[root@localhost ~]# ping 192.169.23.53PING 192.169.23.53 (192.169.23.53) 56(84) bytes of data.^C--- 192.169.23.53 ping statistics ---3 packets transmitted, 0 received, 100% packet loss, time 2001ms[root@localhost ~]# 可以看到，Server可以ping通外网，但是无法ping 虚拟机WIN10的时候没有响应。然鹅，奇怪的是，虚拟机WIN10可以ping通它而它能不能ping通WIN10，其实这是系统差异导致的，对本实验没有影响，Server无法ping通虚拟机WIN10那就ping不通吧，我们往下继续做实验。实验结束后，我们再解析如何让它可以ping通虚拟机WIN10。 安装squid程序，并查看配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384[root@localhost ~]# yum install squid -y[root@localhost ~]# ls /etc/squid/cachemgr.conf errorpage.css mime.conf squid.confcachemgr.conf.default errorpage.css.default mime.conf.default squid.conf.default[root@localhost ~]# [root@localhost ~]# cat /etc/squid/squid.conf以下为其配置文件内容：## Recommended minimum configuration:## Example rule allowing access from your local networks.# Adapt to list your (internal) IP networks from where browsing# should be allowedacl localnet src 10.0.0.0/8 # RFC1918 possible internal networkacl localnet src 172.16.0.0/12 # RFC1918 possible internal networkacl localnet src 192.168.0.0/16 # RFC1918 possible internal networkacl localnet src fc00::/7 # RFC 4193 local private network rangeacl localnet src fe80::/10 # RFC 4291 link-local (directly plugged) machinesacl SSL_ports port 443acl Safe_ports port 80 # httpacl Safe_ports port 21 # ftpacl Safe_ports port 443 # httpsacl Safe_ports port 70 # gopheracl Safe_ports port 210 # waisacl Safe_ports port 1025-65535 # unregistered portsacl Safe_ports port 280 # http-mgmtacl Safe_ports port 488 # gss-httpacl Safe_ports port 591 # filemakeracl Safe_ports port 777 # multiling httpacl CONNECT method CONNECT## Recommended minimum Access Permission configuration:## Deny requests to certain unsafe portshttp_access deny !Safe_ports# Deny CONNECT to other than secure SSL portshttp_access deny CONNECT !SSL_ports# Only allow cachemgr access from localhosthttp_access allow localhost managerhttp_access deny manager# We strongly recommend the following be uncommented to protect innocent# web applications running on the proxy server who think the only# one who can access services on &quot;localhost&quot; is a local user#http_access deny to_localhost## INSERT YOUR OWN RULE(S) HERE TO ALLOW ACCESS FROM YOUR CLIENTS## Example rule allowing access from your local networks.# Adapt localnet in the ACL section to list your (internal) IP networks# from where browsing should be allowedhttp_access allow localnethttp_access allow localhost# And finally deny all other access to this proxyhttp_access deny all# Squid normally listens to port 3128http_port 3128# Uncomment and adjust the following to add a disk cache directory.#cache_dir ufs /var/spool/squid 100 16 256# Leave coredumps in the first cache dircoredump_dir /var/spool/squid## Add any of your own refresh_pattern entries above these.#refresh_pattern ^ftp: 1440 20% 10080refresh_pattern ^gopher: 1440 0% 1440refresh_pattern -i (/cgi-bin/|\?) 0 0% 0refresh_pattern . 0 20% 4320[root@localhost ~]# 可以看到其监听的端口号为3128，一会我们设置客户端代理的时候要用到！ 参数 作用 http_port 3128 监听的端口号 cache_mem 64M 内存缓冲区的大小 cache_dir ufs /var/spool/squid 2000 16 256 硬盘缓冲区的大小 cache_effective_user squid 设置缓存的有效用户 cache_effective_group squid 设置缓存的有效用户组 dns_nameservers [IP地址] 一般不设置，而是用服务器默认的DNS地址 cache_access_log /var/log/squid/access.log 访问日志文件的保存路径 cache_log /var/log/squid/cache.log 缓存日志文件的保存路径 visible_hostname linuxprobe.com 设置Squid服务器的名称 正向代理开启ip forward（路由转发） 1234567891011121314151617181920[root@localhost ~]# echo &quot;net.ipv4.ip_forward = 1&quot; &gt;&gt;/usr/lib/sysctl.d/50-default.conf[root@localhost ~]# grep ip_forward /usr/lib/sysctl.d/50-default.confnet.ipv4.ip_forward = 1[root@localhost ~]# sysctl -a | grep -w ip_forwardsysctl: reading key &quot;net.ipv6.conf.all.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.default.stable_secret&quot;net.ipv4.ip_forward = 0 #0表示未开启sysctl: reading key &quot;net.ipv6.conf.ens33.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.ens37.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.lo.stable_secret&quot;[root@localhost ~]# sysctl -w net.ipv4.ip_forward=1 #我们将之开启net.ipv4.ip_forward = 1[root@localhost ~]# sysctl -a | grep -w ip_forwardsysctl: reading key &quot;net.ipv6.conf.all.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.default.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.ens33.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.ens37.stable_secret&quot;net.ipv4.ip_forward = 1 #1表示已开启sysctl: reading key &quot;net.ipv6.conf.lo.stable_secret&quot;[root@localhost ~]# 放行所有http访问 12345678[root@localhost ~]# vim /etc/squid/squid.conf将第56行改为：http_access allow all保存退出，查看结果[root@localhost ~]# grep -n http /etc/squid/squid.conf |grep -w all56:http_access allow all[root@localhost ~]# 安装openssl 1[root@localhost ~]# yum -y install openssl 关闭防火墙 1[root@localhost ~]# systemctl stop firewalld.service squid加上DNS，重启squid服务 123456[root@localhost ~]# echo &quot;dns_nameservers 114.114.114.114 114.114.115.115&quot; &gt;&gt; /etc/squid/squid.conf[root@localhost ~]# grep nameserver /etc/squid/squid.confdns_nameservers 114.114.114.114 114.114.115.115[root@localhost ~]# systemctl restart squid[root@localhost ~]# systemctl enable squid[root@localhost ~]# 一开始，我们的虚拟机WIN10客户端是无法上网的，所以要设置代理。 虚拟机WIN10设置客户端代理，如下图： 如上图，原本处在仅主机模式的虚拟机WIN10是无法上网的，现在设置了代理就可以访问外网了。 ACL访问控制只允许某个客户端进行代理修改配置文件 1234567891011121314151617[root@localhost ~]# vim /etc/squid/squid.conf将之前改过的56行改回：http_access deny all将下面这行备注掉（大概第10行）： #acl localnet src 192.168.0.0/16 它的作用是让192.168.0.1-192.168.255.254之间所有ip都可以被放行，把它备注掉，方便我们接下来实验的观察。 如下图在合适的地方加入：acl client src 192.168.23.53在合适的地方加入：http_access allow client保存退出，重启squid服务[root@localhost ~]# systemctl restart squid.service ​ 可以看到咱们的虚拟机WIN10仍然可以上外网，这是由于acl client src 192.168.23.53放行了它的ip所致： ​ 为了对比效果，我又装了一台虚拟机WIN10Test用来测试，给它与之前那台虚拟机WIN10同等的待遇，给它的ie浏览器也配置了一样的代理，现在看看它能否上外网： 看看它的ip： 将他的ip也加入放行队列： 1234567891011[root@localhost ~]# vim /etc/squid/squid.conf如下图在合适的地方加入：acl client2 src 192.168.23.55在合适的地方加入：http_access allow client2保存退出，重启squid服务[root@localhost ~]# systemctl restart squid.service 可以看到，这台新加的虚拟机也可以访问外网了 现在开了三台虚拟机，电脑非常卡，可以把这台新的虚拟机关掉了，接下来我们继续回到正题，继续做代理实验。 特别注意： 本次实验特别坑的地方是，不把Server上的防火墙关掉，客户端就无法访问外网！而且，如果实验中途把Server关机了，重新启动后又得再次关闭防火墙！网上大多数的教程都没有说这一步，导致非常多初次做实验的同学们都被坑死在这里。 过滤敏感字修改配置文件(还原上次实验的更改后再做，还原的相关命令也在下面) 1234567891011121314151617181920[root@localhost ~]# vi /etc/squid/squid.conf去掉第10行的注释acl localnet src 192.168.0.0/16 第58行左右，讲我们之前改过的deny改回allowhttp_access allow all如下图，在合适的地方加入如下两行：大概27行：acl deny_keyword url_regex -i nba大概33行：http_access deny deny_keyword保存退出，重启squid服务，关闭防火墙[root@localhost ~]# systemctl restart squid.service [root@localhost ~]# systemctl stop firewalld.service 这里之所以我又关了一次防火墙，是因为实验中途我把Server关机了，重新开机后虚拟机WIN10怎么也访问不了外网，IE浏览器上只提示“代理服务器无响应”，又是被防火墙坑了。这里防火墙一关，那里ie浏览器又就可以正常访问外网了。 效果如下： ​ 如下图，可以正常访问外网，但是无法访问带有敏感字的网站。 禁止访问特定网站修改配置文件(可以接着上述实验的更改继续再做，相当于叠加过滤) 注意，我们平时访问qq官网，是https的网址：https://www.qq.com，但是由于咱们的Server现在针对的是http协议进行过滤的，就连配置文件里也全都是“http_access”的字段，所以我们测试用的是http://www.qq.com。 123456789[root@localhost ~]# vi /etc/squid/squid.conf如下图，在合适的地方加入如下两行：大概28行：acl deny_url url_regex http://www.qq.com大概31行：http_access deny deny_url保存退出，重启squid服务[root@localhost ~]# systemctl restart squid.service 效果如下： ​ 可以正常访问外网，但是无法访问http://www.qq.com 效果对比： 123456789[root@localhost ~]# vi /etc/squid/squid.conf我们把之前加的两行备注掉：大概28行：#acl deny_url url_regex http://www.qq.com大概31行：#http_access deny deny_url保存退出，重启squid服务[root@localhost ~]# systemctl restart squid.service 现在回到刚刚的测试页面，刷新一下，可以看到它自动的从http://www.qq.com跳转到了https://www.qq.com，成功访问了qq官网。 禁止下载特定格式文件修改配置文件((可以接着上述实验的更改继续再做，相当于叠加过滤) 123456789[root@localhost ~]# vi /etc/squid/squid.conf如下图，在合适的地方加入如下两行：大概29行：acl badfile urlpath_regex -i \.exe$ \.msi$大概32行：http_access deny badfile保存退出，重启squid服务[root@localhost ~]# systemctl restart squid.service ​ 如下图，我们这里用下载nodejs软件历史版本的网站https://nodejs.org/dist/v0.6.2/来测试，分别点开三个文件对比测试： node-v0.6.2.msi node.exe node-v0.6.2.tar.gz ​ 理论上，我们禁止下载了msi和exe后缀格式的文件，那么tar.gz是没有禁止的，实际测试效果如下： ​ 可以看到，实际测试效果和理论上是一样的。 透明正向代理 正向代理服务一般是针对企业内部的所有员工设置的，鉴于每位员工所掌握的计算机知识不尽相同，如果您所在的公司不是IT行业的公司，想教会大家如何使用代理服务也不是一件容易的事情。再者，无论是什么行业的公司，公司领导都希望能采取某些措施限制员工在公司内的上网行为，这时就需要用到透明的正向代理模式了。 “透明”二字指的是让用户在没有感知的情况下使用代理服务，这样的好处是一方面不需要用户手动配置代理服务器的信息，进而降低了代理服务的使用门槛；另一方面也可以更隐秘地监督员工的上网行为。 在透明代理模式中，用户无须在浏览器或其他软件中配置代理服务器地址、端口号等信息，而是由DHCP服务器将网络配置信息分配给客户端主机。这样只要用户打开浏览器便会自动使用代理服务了。 准备工作： 删除之前实验配置的客户端浏览器代理配置，如下图： 现在又无法访问外网了，如下图： 接下来我们要用透明正向代理让它恢复访问网络的能力。 使用firewalld配置透明正向代理 这里有很多坑，网上的大多教程不是缺东就是少西，另外在配置的时候要用的明明是ens37和ens33而网上的教程却都是误人子弟的eth0和eth1，为了试验更加清晰明了，这里也不特意还原之前实验的状态了，我们从头开始，把接下来的实验单独拿出来作为另外一个实验！ 恢复快照 之前我们保存了快照叫做“快照1”的那个，现在咱们把Server恢复快照到那个地方，则相当于准备工作已经安排妥当，接下来实验从头开始，只不过这次咱们做的是透明代理。 安装squid程序 1[root@localhost ~]# yum install squid -y 禁用selinux 1[root@localhost ~]setenforce 0 #临时关闭selinux 开启ip forward（路由转发） 1234567891011121314151617181920212223242526[root@localhost ~]# echo &quot;net.ipv4.ip_forward = 1&quot; &gt;&gt;/usr/lib/sysctl.d/50-default.conf[root@localhost ~]# grep ip_forward /usr/lib/sysctl.d/50-default.confnet.ipv4.ip_forward = 1[root@localhost ~]# sysctl -a | grep -w ip_forwardsysctl: reading key &quot;net.ipv6.conf.all.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.default.stable_secret&quot;net.ipv4.ip_forward = 0 #0表示未开启sysctl: reading key &quot;net.ipv6.conf.ens33.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.ens37.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.lo.stable_secret&quot;[root@localhost ~]# sysctl -w net.ipv4.ip_forward=1 #我们将之开启net.ipv4.ip_forward = 1[root@localhost ~]# sysctl -a | grep -w ip_forwardsysctl: reading key &quot;net.ipv6.conf.all.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.default.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.ens33.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.ens37.stable_secret&quot;net.ipv4.ip_forward = 1 #1表示已开启sysctl: reading key &quot;net.ipv6.conf.lo.stable_secret&quot;[root@localhost ~]# [root@localhost ~]# vim /etc/sysctl.conf在文末追加一行：net.ipv4.ip_forward=1保存退出 配置squid配置文件，放行所有http访问，transparent是透明的意思 123456789101112131415161718192021[root@localhost ~]# vim /etc/squid/squid.conf将第56行改为：http_access allow all如下图，在合适的地方修改这两行：大概59行（追加一个transparent即可）：http_port 3128 transparent大概62行（去掉备注即可）：cache_dir ufs /var/spool/squid 100 16 256保存退出检查配置文件是否有误[root@localhost ~]# squid -k parse 初始化透明代理[root@localhost ~]# squid -z初始化完成后敲回车即可。重启squid服务[root@localhost ~]# systemctl restart squid 使用firewalld配置SNAT，然后添加squid服务 12345678910111213141516171819202122232425262728293031323334353637383940414243 //外网网卡添加到外网zone //内网网卡添加到内网zone //将masquerade配置成yes //添加squid服务 //添加squid服务 //列出外网区域信息 //配置端口转发 //重新加载防火墙 //重启firewalld服务[root@localhost ~]# firewall-cmd --zone=external --add-interface=ens37 --permanentThe interface is under control of NetworkManager, setting zone to &apos;external&apos;.success[root@localhost ~]# firewall-cmd --zone=internal --add-interface=ens33 --permanentThe interface is under control of NetworkManager, setting zone to &apos;internal&apos;.success[root@localhost ~]# firewall-cmd --zone=external --add-masquerade --permanentWarning: ALREADY_ENABLED: masqueradesuccess[root@localhost ~]# firewall-cmd --zone=external --add-service=squid --permanentsuccess[root@localhost ~]# firewall-cmd --zone=internal --add-service=squid --permanentsuccess[root@localhost ~]# firewall-cmd --zone=external --list-allexternal (active) target: default icmp-block-inversion: no interfaces: ens37 sources: services: ssh ports: protocols: masquerade: yes forward-ports: source-ports: icmp-blocks: rich rules: [root@localhost ~]# firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.23.0/24&quot; forward-port port=&quot;80&quot; protocol=&quot;tcp&quot; to-port=&quot;3128&quot; to-addr=&quot;192.168.23.52&quot;&quot; --zone=internalsuccess[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# systemctl restart firewalld[root@localhost ~]# 这里注意，如下，有时候手误会少敲一个d，结果命令就可能没敲进去。 123[root@localhost ~]# systemctl restart firewallFailed to restart firewall.service: Unit not found.[root@localhost ~]# 检查客户端可以正常上网 使用iptables配置透明正向代理注意：iptables和firewalld是冲突的，同时只能使用一个防火墙，所以要还原上次实验的更改后再做 放行DNS查询端口，配置IPv4地址转发 使用iptables防火墙管理命令把所有客户端主机对网站80端口的请求转发至Squid服务器本地的3128端口上 1234567891011121314151617181920[root@localhost ~]# systemctl stop firewalld.service [root@localhost ~]# systemctl mask firewalld.service Created symlink from /etc/systemd/system/firewalld.service to /dev/null. # 安装iptables 服务[root@localhost ~]# yum install iptables-services -y # 开启iptables服务[root@localhost ~]# systemctl start iptables[root@localhost ~]# iptables -F[root@localhost ~]# iptables -t nat -A POSTROUTING -p udp --dport 53 -o ens37 -j MASQUERADE[root@localhost ~]# echo &quot;net.ipv4.ip_forward=1&quot; &gt;&gt; /etc/sysctl.conf [root@localhost ~]# sysctl -pnet.ipv4.ip_forward = 1net.ipv4.ip_forward = 1[root@localhost ~]# iptables -t nat -A PREROUTING -p tcp -m tcp --dport 80 -j REDIRECT --to-port 3128[root@localhost ~]# iptables -t nat -A POSTROUTING -s 192.168.23.0/24 -o ens37 -j SNAT --to 192.168.1.105[root@localhost ~]# service iptables saveiptables: Saving firewall rules to /etc/sysconfig/iptables:[ 确定 ][root@localhost ~]# 注意：不要写错网卡和ip，上述ens37为外网网卡，192.168.1.105为外网ip，192.168.23.0/24是内网ip。 现在检查： 反向代理 网站页面是由静态资源和动态资源一起组成的，其中静态资源包括网站架构CSS文件、大量的图片、视频等数据，这些数据相对于动态资源来说更加稳定，一般不会经常发生改变。但是，随着建站技术的更新换代，外加人们不断提升的审美能力，这些静态资源占据的网站空间越来越多。如果能够把这些静态资源从网站页面中抽离出去，然后在全国各地部署静态资源的缓存节点，这样不仅可以提升用户访问网站的速度，而且网站源服务器也会因为这些缓存节点的存在而降低负载。 反向代理是Squid服务程序的一种重要模式，其原理是把一部分原本向网站源服务器发起的用户请求交给Squid服务器缓存节点来处理。但是这种技术的弊端也很明显，如果有心怀不轨之徒将自己的域名和服务器反向代理到某个知名的网站上面，从理论上来讲，当用户访问到这个域名时，也会看到与那个知名网站一样的内容（有些诈骗网站就是这样骗取用户信任的）。因此，当前许多网站都默认禁止了反向代理功能。开启了CDN（内容分发网络）服务的网站也可以避免这种窃取行为。 修改配置文件​ 注意，我的虚拟机Server重启后，作为桥接模式的外网网卡ip有所变化是很正常的，因为它的ip本就是由我家的家用路由器分配的，现在它变成了192.168.1.107，我们就用这个ip来配置。 58.250.26.38是一个网站的ip，这个随意，拿来测试的而已，找个能用的就行。 1234567891011121314151617181920212223242526272829[root@localhost ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:98:66:4e brd ff:ff:ff:ff:ff:ff inet 192.168.23.52/24 brd 192.168.23.255 scope global noprefixroute dynamic ens33 valid_lft 952sec preferred_lft 952sec inet6 fe80::5a82:cc9d:de3:b9f0/64 scope link noprefixroute valid_lft forever preferred_lft forever3: ens37: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:98:66:58 brd ff:ff:ff:ff:ff:ff inet 192.168.1.107/24 brd 192.168.1.255 scope global noprefixroute dynamic ens37 valid_lft 7081sec preferred_lft 7081sec inet6 fe80::ccc:8d0d:490e:7f9f/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@localhost ~]# [root@localhost ~]# vim /etc/squid/squid.conf大概第59行，改为：http_port 192.168.1.107:80 vhost在上面那行下面追加下面这一行：cache_peer 58.250.26.38 parent 80 0 originserver[root@localhost ~]# systemctl restart squid.service 客户端访问我们输入Server外网网卡的ip：192.168.1.107，如下图，可以看到它自动跳转到了目标网站。 实验到此结束 课外拓展仅主机模式下，linux无法ping通windows的解决办法 我们重新弄两台虚拟机，实验准备和上面那个实验一样。Server网卡一为仅主机模式，网卡二为桥接模式。虚拟机WIN10的网卡为仅主机模式。 1.虚拟机Server 2.虚拟机WIN10 3.VMware Workstation Pro设置 ​ 点击图中更改设置即可更改，这里放出的图是改好后的图。 ​ 拓扑图就是和原来一样的拓扑图。 开机，查看各个设备的ip： 1.Server ens33:192.168.23.52 ens37:192.168.1.107 2.虚拟机WIN10 ens33：192.168.23.53 3.物理机WIN10（就是宿主机，我们现在用着的真实电脑） VMnet1:192.168.23.1 VMnet8:192.168.141.1 物理网卡：192.169.1.108 桥接模式与物理网卡相互桥接，故网段均为192.168.1.0/24 仅主机模式对应VMnet1，故网段均为192.168.23.0/24 我们这里没用到VMnet8，也没有NAT模式的虚拟机网卡，就先不管它了。 现象： 按照原理上讲，同一网段的ip是可以互相ping同的。然而在这里，我们可以发现，windows可以ping通linux，但是linux却是无法ping通windows的，如下图： 1.物理机windows去ping虚拟机Server可以ping通 2.虚拟机Server却无法ping通物理机windows（ping无响应，只能手动ctrl+c打断） 3.虚拟机WIN10可以ping通Server： 4.Server却不能ping通虚拟机WIN10： 解决办法： 先在虚拟机WIN10上做如下设置： 然后Server就可以ping通虚拟机WIN10了： 现在在物理机windows上做如下设置： 现在虚拟机Server也可以ping通物理机windows了： 实验完毕 实验做完了记得要把自己物理机的启用网络发现关闭掉。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-20 Postfix与Dovecot部署邮件系统]]></title>
    <url>%2Flinux-20%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-20 Postfix与Dovecot部署邮件系统实验环境配置，Centos7虚拟机两台： Test（192.168.141.12）：提供DNS服务 client2（192.168.141.53）：提供postfix和dovecot服务 测试用的是咱们的物理机 概念解析电子邮件电子邮件系统基于邮件协议来完成电子邮件的传输，常见的邮件协议有下面这些。 • 简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）用于发送和中转发出 的电子邮件，占用服务器的25/TCP端口。 • 邮局协议版本3（Post Office Protocol 3）用于将电子邮件存储到本地主机，占用服 务器的110/TCP端口。 • Internet消息访问协议版本4（Internet Message Access Protocol 4）用于在本地 主机上访问邮件，占用服务器的143/TCP端口。 Postfix Postfix是一种电子邮件服务器，它是由任职于IBM华生研究中心（T.J. Watson Research Center）的荷兰籍研究员Wietse Venema为了改良sendmail邮件服务器而产生的。最早在1990年代晚期出现，是一个开放源代码的软件。 dovecot​ Dovecot 是一个开源的 IMAP 和 POP3 邮件服务器，支持 Linux/Unix 系统。Dovecot 是一个比较新的软件，由 Timo Sirainen 开发，最初发布于 2002年7月。作者将安全性考虑在第一，所以 Dovecot 在安全性方面比较出众。另外，Dovecot 支持多种认证方式，所以在功能方面也比较符合一般的应用。 Test（192.168.141.12）：提供DNS服务 这里几乎和上篇文章中所做一模一样，但是毕竟是新的一片文章，所以我们重新做一遍，也好顺便复习上篇文章中敲过的命令。 Test安装DNS服务软件包 1[root@localhost ~]# yum install bind bind-chroot bind-utils -y 修改主配置文件 1234567891011121314[root@localhost ~]# vim /etc/named.conf将 listen-on port 53那行改为any，将listen-on-v6那行备注掉，将 allow-query 的由localhost改为any即可options &#123; listen-on port 53 &#123; any; &#125;;# listen-on-v6 port 53 &#123; ::1; &#125;; directory &quot;/var/named&quot;; dump-file &quot;/var/named/data/cache_dump.db&quot;; statistics-file &quot;/var/named/data/named_stats.txt&quot;; memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;; recursing-file &quot;/var/named/data/named.recursing&quot;; secroots-file &quot;/var/named/data/named.secroots&quot;; allow-query &#123; any; &#125;;保存退出 正向区域解析区域配置文件 12345678[root@localhost ~]# vim /etc/named.rfc1912.zones 在最后面加上一段：zone &quot;feng.io&quot; IN &#123; type master; file &quot;feng.io.zone&quot;; allow-update &#123; none; &#125;;&#125;;保存退出 配置正向解析数据文件 123456789101112131415161718[root@localhost ~]# cd /var/named/[root@localhost named]# cp -a named.localhost feng.io.zone[root@localhost named]# vim feng.io.zone $TTL 1D@ IN SOA feng.io. root.feng.io. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS ns.feng.io.ns IN A 192.168.141.12 A 192.168.141.53IN MX 10 mail.feng.io.mail IN A 192.168.141.53保存退出 防火墙放行服务 12345[root@localhost named]# firewall-cmd --add-service=dns --permanent success[root@localhost named]# firewall-cmd --reload success[root@localhost named]# 修改反向解析区域配置文件 12345678910[root@localhost named]# vim /etc/named.rfc1912.zones 在尾部加入：zone &quot;141.168.192.in-addr.arpa&quot; IN &#123; type master; file &quot;192.168.141.arpa&quot;; allow-update &#123; none; &#125;;&#125;;保存退出 反向区域解析数据文件 12345678910111213141516171819[root@localhost named]# cp feng.io.zone 192.168.141.arpa[root@localhost named]# vim 192.168.141.arpa$TTL 1D@ IN SOA feng.io. root.feng.io. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS ns.feng.io. A 192.168.141.5353 PTR feng.io.12 PTR ns.feng.io.53 PTR mail.feng.io.保存退出，重启named服务[root@localhost named]# systemctl restart named client2（192.168.141.53）：提供postfix和dovecot服务配置主机域名，需要保证服务器主机名称与发信域名保持一致： 1234[root@localhost ~]# hostnamectl set-hostname mail.feng.io[root@localhost ~]# hostnamemail.feng.io[root@localhost ~]# 修改dns配置 12345678[root@localhost ~]# vi /etc/resolv.conf # Generated by NetworkManagersearch localdomain feng.ionameserver 192.168.141.12nameserver 114.114.114.114保存退出 检查dns服务 123456789101112131415161718192021[root@localhost ~]# nslookup&gt; 192.168.141.12Server: 192.168.141.12Address: 192.168.141.12#5312.141.168.192.in-addr.arpa name = ns.feng.io.&gt; mail.feng.ioServer: 192.168.141.12Address: 192.168.141.12#53Name: mail.feng.ioAddress: 192.168.141.53&gt; 192.168.141.53Server: 192.168.141.12Address: 192.168.141.12#5353.141.168.192.in-addr.arpa name = feng.io.53.141.168.192.in-addr.arpa name = mail.feng.io.&gt; exit[root@localhost ~]# 可以看出，dns服务正常，正反向解析都成功了。 安装邮件服务器需要的软件包 1[root@localhost ~]# yum install postfix dovecot -y 配置postfix服务 参数 作用 myhostname 邮局系统的主机名 mydomain 邮局系统的域名 myorigin 从本机发出邮件的域名名称 inet_interfaces 监听的网卡接口 mydestination 可接收邮件的主机名或域名 mynetworks 设置可转发哪些主机的邮件 relay_domains 设置可转发哪些网域的邮件 12345678910111213141516171819202122[root@localhost ~]# vi /etc/postfix/main.cf 修改为以下内容，记得原来那行的备注符号#号不要忘了去掉！76行：myhostname = mail.feng.io83行：mydomain = feng.io99行：myorigin = $mydomain116行：inet_interfaces = all164行：mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain179行：local_recipient_maps =保存退出 Postfix与vsftpd服务程序一样，都可以调用本地系统的账户和密码，因此在本地系统创建常规账户即可。最后重启配置妥当的postfix服务程序，并将其添加到开机启动项中 1234567[root@localhost ~]# useradd aaa[root@localhost ~]# echo &quot;123456&quot; | passwd --stdin aaa更改用户 aaa 的密码 。passwd：所有的身份验证令牌已经成功更新。[root@localhost ~]# systemctl restart postfix[root@localhost ~]# systemctl enable postfix[root@localhost ~]# 配置dovecot服务修改配置文件 1234567891011[root@localhost ~]# vi /etc/dovecot/dovecot.conf将第24行改为：protocols = imap pop3 lmtp其实也就是去掉了备注而已注意：如果想允许所有人都能使用，则不用修改下面的参数，反正这次实验我是没去改如果想要仅仅允许192.168.141.0/24网段的用户使用dovecot服务，则将第48行改为：login_trusted_networks = 192.168.141.0/24保存退出 允许明文传输内容 12345678910[root@localhost ~]# vi /etc/dovecot/conf.d/10-auth.conf 修改为以下内容，记得原来那行的备注符号#号不要忘了去掉！第10行：disable_plaintext_auth = no第100行：auth_mechanisms = plain login保存退出 取消SSL 12345678910111213[root@localhost ~]# vi /etc/dovecot/conf.d/10-ssl.conf 修改为以下内容第8行：ssl = no将14、15行都备注掉第14行：#ssl_cert = &lt;/etc/pki/dovecot/certs/dovecot.pem第15行：#ssl_key = &lt;/etc/pki/dovecot/private/dovecot.pem保存退出 设置收件箱 12345[root@localhost ~]# vi /etc/dovecot/conf.d/10-mail.conf 将第25行改为： mail_location = mbox:~/mail:INBOX=/var/mail/%u其实也就是去掉备注而已保存退出 然后切换到配置Postfix服务程序时创建的eagle账户，并在家目录中建立用于保存邮件的目录。记得要重启Dovecot服务并将其添加到开机启动项中。至此，对Dovecot服务程序的配置部署步骤全部结束。 12345678[root@localhost ~]# su - aaa[aaa@mail ~]$ mkdir -p mail/.imap/INBOX[aaa@mail ~]$ exit登出[root@localhost ~]# systemctl restart dovecot[root@localhost ~]# systemctl enable dovecotCreated symlink from /etc/systemd/system/multi-user.target.wants/dovecot.service to /usr/lib/systemd/system/dovecot.service.[root@localhost ~]# 设置邮件服务的防火墙放行 12345[root@localhost ~]# firewall-cmd --add-port=&#123;25,110,143&#125;/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# 在本篇文章开始那里，常见的邮件协议介绍的三种协议的端口号分别便是25,110,143，均放行。 在windows上用foxmail客户端测试邮件服务修改window上的dns地址，如下图： 使用foxmail测试邮件服务器是否成功，如下图： 安装完成后打开，选择手动设置，然后如下图： 发送邮件给咱们的client2那台虚拟机的root用户，看看它能不能收到。 首先在client2上安装相关工具包 123456789101112131415161718192021222324252627282930313233[root@localhost ~]# yum install mailx sendmail -y装好后，先敲mail命令，然后直接回车即可[root@localhost ~]# mailHeirloom Mail version 12.5 7/5/10. Type ? for help.&quot;/var/spool/mail/root&quot;: 1 message 1 new&gt;N 1 aaa@feng.io Sun Feb 3 19:07 52/2158 &quot;HelloMail&quot;&amp; Message 1:From aaa@feng.io Sun Feb 3 19:07:47 2019Return-Path: &lt;aaa@feng.io&gt;X-Original-To: root@feng.ioDelivered-To: root@feng.ioDate: Sun, 3 Feb 2019 19:07:45 +0800From: &quot;aaa@feng.io&quot; &lt;aaa@feng.io&gt;To: root &lt;root@feng.io&gt;Subject: HelloMailX-Priority: 3X-Has-Attach: noX-Mailer: Foxmail 7.2.9.156[cn]Content-Type: multipart/alternative; boundary=&quot;----=_001_NextPart407851228804_=----&quot;Status: RContent-Type: text/plain; charset=&quot;GB2312&quot;当您收到这封邮件时，证明我的邮局系统实验已经成功！aaa@feng.io&amp; 可以看到，它的确收到了邮件了，说明咱们的配置成功了！ 至于linux端发邮件给windows，写起来比较麻烦,也不好解释怎么操作，有兴趣的朋友可以自行网上学习，最好是视频形式的教程，那样才听得明白。 题外话 ​ 上面咱们用到的那款软件Foxmail中文名是狐邮，正是在最近热播的电视剧《创业时代》里面的罗维开发的软件，这剧真的挺好看的，主演黄轩演的真的不错，喜欢的朋友们可以去追一追这部剧。 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-19 bind提供域名解析服务]]></title>
    <url>%2Flinux-19%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-19 bind提供域名解析服务概念解析DNS域名解析服务 很早很早之前，人们通过ip地址来上网，后来，人们觉得，相较于由数字构成的IP地址，域名更容易被理解和记忆，所以我们通常更习惯通过域名的方式来访问网络中的资源。但是，网络中的计算机之间只能基于IP地址来相互识别对方的身份，而且要想在互联网中传输数据，也必须基于外网的IP地址来完成。 为了降低用户访问网络资源的门槛，DNS（Domain Name System，域名系统）技术应运而生。这是一项用于管理和解析域名与IP地址对应关系的技术，简单来说，就是能够接受用户输入的域名或IP地址，然后自动查找与之匹配（或者说具有映射关系）的IP地址或域名，即将域名解析为IP地址（正向解析），或将IP地址解析为域名（反向解析）。这样一来，我们只需要在浏览器中输入域名就能打开想要访问的网站了。DNS域名解析技术的正向解析也是我们最常使用的一种工作模式。 鉴于互联网中的域名和IP地址对应关系数据库太过庞大，DNS域名解析服务采用了类似目录树的层次结构来记录域名与IP地址之间的对应关系，从而形成了一个分布式的数据库系统， DNS域名解析服务采用的层次目录结构 如下图，DNS域名解析服务中，一级域名例如.com .net .org等，而二级域名有google taobao等，三级域名如www等。连起来就是www.google.com。 域名后缀一般分为国际域名和国内域名。原则上来讲，域名后缀都有严格的定义，但在实际使用时可以不必严格遵守。目前最常见的域名后缀有.com（商业组织）、.org（非营利组织）、.gov（政府部门）、.net（网络服务商）、.edu（教研机构）、.pub（公共大众）、.cn（中国国家顶级域名）等。 当今世界的信息化程度越来越高，大数据、云计算、物联网、人工智能等新技术不断涌现，全球网民的数量据说也超过了35亿，而且每年还在以10%的速度迅速增长。这些因素导致互联网中的域名数量进一步激增，被访问的频率也进一步加大。假设全球网民每人每天只访问一个网站域名，而且只访问一次，也会产生35亿次的查询请求，如此庞大的请求数量肯定无法被某一台服务器全部处理掉。DNS技术作为互联网基础设施中重要的一环，为了为网民提供不间断、稳定且快速的域名查询服务，保证互联网的正常运转，提供了下面三种类型的服务器。 主服务器 在特定区域内具有唯一性，负责维护该区域内的域名与IP地址之间的对应关系。 从服务器 从主服务器中获得域名与IP地址的对应关系并进行维护，以防主服务器宕机等情况。 缓存服务器 通过向其他域名解析服务器查询获得域名与IP地址的对应关系，并将经常查询的域名信息保存到服务器本地，以此来提高重复查询时的效率。 简单来说，主服务器是用于管理域名和IP地址对应关系的真正服务器，从服务器帮助主服务器“打下手”，分散部署在各个国家、省市或地区，以便让用户就近查询域名，从而减轻主服务器的负载压力。缓存服务器不太常用，一般部署在企业内网的网关位置，用于加速用户的域名查询请求。 DNS域名解析服务采用分布式的数据结构来存放海量的“区域数据”信息，在执行用户发起的域名查询请求时，具有递归查询和迭代查询两种方式。所谓递归查询，是指DNS服务器在收到用户发起的请求时，必须向用户返回一个准确的查询结果。如果DNS服务器本地没有存储与之对应的信息，则该服务器需要询问其他服务器，并将返回的查询结果提交给用户。而迭代查询则是指，DNS服务器在收到用户发起的请求时，并不直接回复查询结果，而是告诉另一台DNS服务器的地址，用户再向这台DNS服务器提交请求，这样依次反复，直到返回查询结果。 用户向就近的一台DNS服务器发起对某个域名的查询大致流程 当用户向网络指定的DNS服务器发起一个域名请求时，通常情况下会有本地由此DNS服务器向上级的DNS服务器发送迭代查询请求；如果该DNS服务器没有要查询的信息，则会进一步向上级DNS服务器发送迭代查询请求，直到获得准确的查询结果为止。其中最高级、最权威的根DNS服务器总共有13台，分布在世界各地。 根域名服务器 根域名服务器是域名解析体系的核心，握有域名的最终解释权，简单来说，如果要查询域名，均需要从根域名服务器开始查询。域名服务器是提供域名解析的服务器，在有基本的知识下，任何人都可以搭建域名服务器，甚至是根域名服务器，有名的软件有：BIND。 全球只有13台根服务器的准确说法 域名服务器就像许多国际组织一样，是需要被承认的，当你的根域名服务器被全世界承认，你的服务器也可以成为这其中的一员。因为互联网起源于美国，域名体系也是诞生于美国，在互联网不断扩张和发展的过程中，逐渐形成了13台服务器为全球根服务器。这13台根服务器由ICANN管理，由12个机构具体运营。13台根服务器如下图所示： 13台根域名服务器从a至m编号，分属12个运营机构运营。 但是，网上新闻中有些说法并不准确，举个反例：“全世界只有13台根域名服务器，名字分别为A至M，其中一个主根服务器在美国，其余12个均为辅根服务器，其中9个在美国，欧洲两个，分别位于英国和瑞典，亚洲一个位于日本” 个人认为比较正确的说法应该是这样：“13台根域名服务器不是一个物理概念，它是一个逻辑概念，根域名服务器可以由分布在全球的多个服务器组成，形成一个集群，对外统一为1台逻辑的根域名服务器。在root-servers网站上，我们能查到所有的真实服务器分布“。 截至2018年9月11日，全球一共分布了937台根域名服务器，可以看到，包含港澳台，中国一共有17台根域名服务器。 在上述反例中，还强调了主辅之分，然鹅，事实上，这几百台除了运营者不同，哪有什么区别，真正的根一直在幕后。我个人比较支持下面的一种说法： 全世界只有13台逻辑根域名服务器，名字分别为A至M，由12个运营者运营，其中8个在美国，欧洲两个位于英国和瑞典，亚洲1个位于日本，而真正的主根服务器并未公开。 DNS解析过程分析如下图 域名DNS解析完整流程（以www.baidu.com为例）：第一步：本地客户机提出域名解析请求，查找本地HOST文件有无该域名记录；如果没有，将该请求发送给本地的域名服务器。 第二步：当本地的域名服务器收到请求后，就先查询本地的缓存，如果有该纪录项，则本地的域名服务器就直接把查询的结果返回。 第三步：如果本地DNS缓存中没有该纪录，则本地域名服务器就直接把请求发给根域名服务器，根域名服务器收到请求后，返回该域名对应的顶级域名服务器，比如这次请求返回.com的服务器地址。 第四步：本地域名服务器接到顶级域名服务器地址后，向该顶级域名服务器请求；然后，接受请求的顶级域名服务器查询自己的缓存；如果有该纪录项，则顶级域名域名服务器就直接把查询的结果返回；如果没有该记录，则顶级域名服务器返回该域名的二级域名务器地址，即返回.baidu.com对应的二级服务器地址。 第五步：本地域名服务器获得该地址后，发请求到该域名的二级域名服务器；二级域名服务器开始解析www.baidu.com，并将解析结果返回给本地域名服务器。 第六步：本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时还将结果返回给客户机，解析到此完成。 DNS解析模式递归查询：在该模式下DNS服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果DNS服务器本地没有存储查询DNS信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。 迭代查询：DNS所在服务器若没有可以响应的结果，会向客户机提供其他能够解析查询请求的DNS服务器地址，当客户机发送查询请求时，DNS服务器并不直接回复查询结果，而是告诉客户机另一台DNS服务器地址，客户机再向这台DNS服务器提交请求，依次循环直到返回查询的结果为止。 可以看到，上面的DNS解析六个步骤使用的是迭代查询模式。 常用DNS服务器地址国内：114.114.114.114 备用：114.114.114.115国外：8.8.8.8 备用：8.8.4.4 BIND BIND（Berkeley Internet Name Domain，伯克利网络域名）服务是全球范围内使用最广泛、最安全可靠且高效的域名解析服务程序。DNS域名解析服务作为互联网基础设施服务，其责任之重可想而知，因此建议大家在生产环境中安装部署bind服务程序时加上chroot（俗称牢笼机制）扩展包，以便有效地限制bind服务程序仅能对自身的配置文件进行操作，以确保整个服务器的安全。 准备工作CentOS7安装DNS服务软件包 1[root@localhost ~]# yum install bind bind-chroot bind-utils -y 在bind服务程序中有下面这三个比较关键的文件。 主配置文件（/etc/named.conf）：只有58行，而且在去除注释信息和空行之后，实际有效的参数仅有30行左右，这些参数用来定义bind服务程序的运行。 区域配置文件（/etc/named.rfc1912.zones）：用来保存域名和IP地址对应关系的所在位置。类似于图书的目录，对应着每个域和相应IP地址所在的具体位置，当需要查看或修改时，可根据这个位置找到相关文件。 数据配置文件目录（/var/named）：该目录用来保存域名和IP地址真实对应关系的数据配置文件。 修改主配置文件 1234567891011121314[root@localhost ~]# vim /etc/named.conf将 listen-on port 53那行改为any，将listen-on-v6那行备注掉，将 allow-query 的由localhost改为any即可options &#123; listen-on port 53 &#123; any; &#125;;# listen-on-v6 port 53 &#123; ::1; &#125;; directory &quot;/var/named&quot;; dump-file &quot;/var/named/data/cache_dump.db&quot;; statistics-file &quot;/var/named/data/named_stats.txt&quot;; memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;; recursing-file &quot;/var/named/data/named.recursing&quot;; secroots-file &quot;/var/named/data/named.secroots&quot;; allow-query &#123; any; &#125;;保存退出 正向解析实验修改区域配置文件 12345678[root@localhost ~]# vim /etc/named.rfc1912.zones 在最后面加上一段：zone &quot;feng.io&quot; IN &#123; type master; file &quot;feng.io.zone&quot;; allow-update &#123; none; &#125;;&#125;;保存退出 配置解析数据文件 12345678910111213141516171819[root@localhost ~]# cd /var/named/[root@localhost named]# cp -a named.localhost feng.io.zone[root@localhost named]# vim feng.io.zone $TTL 1D@ IN SOA feng.io. root.feng.io. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS ns.feng.io.ns IN A 192.168.141.12 A 192.168.141.12www IN A 192.168.141.12IN MX 10 mail.feng.iomail IN A 192.168.141.12保存退出 启动named服务，防火墙放行服务 123456[root@localhost named]# systemctl restart named[root@localhost named]# firewall-cmd --add-service=dns --permanent success[root@localhost named]# firewall-cmd --reload success[root@localhost named]# windows客户端测试，用咱们的电脑物理机测试 如下图： 正向解析成功。 反向解析实验修改区域配置文件 12345678910[root@localhost named]# vim /etc/named.rfc1912.zones 在尾部加入：zone &quot;141.168.192.in-addr.arpa&quot; IN &#123; type master; file &quot;192.168.141.arpa&quot;; allow-update &#123; none; &#125;;&#125;;保存退出 配置解析数据文件 12345678910111213141516171819[root@localhost named]# cp feng.io.zone 192.168.141.arpa[root@localhost named]# vim 192.168.141.arpa$TTL 1D@ IN SOA feng.io. root.feng.io. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS feng.io.ns A 192.168.141.1212 PTR ns.feng.io.38 PTR www.feng.io.12 PTR mail.feng.io.保存退出，重启named服务[root@localhost named]# systemctl restart named 注意：上述文件配置中，12 38 12 值得是192.168.141.12 192.168.141.38 192.168.141.12三个ip，意思是对这三个ip的反向解析的结果分别对应什么域名。下面测试就用的上述ip。 用linux客户端测试dns 12345678910111213141516171819202122[root@localhost ~]# vim /etc/resolv.conf # Generated by NetworkManagersearch localdomainnameserver 192.168.141.12保存退出[root@localhost ~]# yum install bind-utils -y[root@localhost ~]# nslookup&gt; 192.168.141.12Server: 192.168.141.12Address: 192.168.141.12#5312.141.168.192.in-addr.arpa name = mail.feng.io.12.141.168.192.in-addr.arpa name = ns.feng.io.&gt; 192.168.141.38Server: 192.168.141.12Address: 192.168.141.12#5338.141.168.192.in-addr.arpa name = www.feng.io.&gt; 可以看到，反向解析成功了 部署dns的主从服务器做dns服务器的故障备份服务器，当主服务器故障，我们就可以用从服务器的地址继续进行解析 配置主服务器1234567891011121314151617咱们上面配好的就是主服务器，但是这里为了与从服务器配合工作，咱们还需要添加一些配置：[root@localhost ~]# vim /etc/named.rfc1912.zones 在文件尾部，将前面咱们添加的两个代码块修改为以下内容zone &quot;feng.io&quot; IN &#123; type master; file &quot;feng.io.zone&quot;; allow-update &#123; 192.168.141.53; &#125;;&#125;;zone &quot;141.168.192.in-addr.arpa&quot; IN &#123; type master; file &quot;192.168.141.arpa&quot;; allow-update &#123; 192.168.141.53; &#125;;&#125;;其实也就是将原本的none改成了从服务器client2的ip而已保存退出，重启named服务[root@localhost named]# systemctl restart named 配置从服务器现在我们新安装一台虚拟机client2作为咱们的从服务器。 从服务器的主配置文件和主服务器一样，只要修改区域文件就可以 12345678910111213141516171819202122[root@localhost ~]# yum install bind bind-chroot bind-utils -y[root@localhost ~]# vi /etc/named.rfc1912.zones 在文件尾部加入下列内容zone &quot;feng.io&quot; IN &#123; type slave; masters&#123; 192.168.141.12; &#125;; file &quot;slaves/feng.io.zone&quot;;&#125;;zone &quot;141.168.192.in-addr.arpa&quot; IN &#123; type slave; masters&#123; 192.168.141.12; &#125;; file &quot;slaves/192.168.141.arpa&quot;;&#125;;保存退出[root@localhost ~]# firewall-cmd --add-service=dns --permanentsuccess[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# 注意：上述参数中，slave（奴隶）指的是从服务，master（主人）指的是主服务 从服务器的主配置文件和主服务器一样 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253[root@localhost ~]# vim /etc/named.conf将 listen-on port 53那行改为any，将listen-on-v6那行备注掉，将 allow-query 的由localhost改为any即可options &#123; listen-on port 53 &#123; any; &#125;;# listen-on-v6 port 53 &#123; ::1; &#125;; directory &quot;/var/named&quot;; dump-file &quot;/var/named/data/cache_dump.db&quot;; statistics-file &quot;/var/named/data/named_stats.txt&quot;; memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;; recursing-file &quot;/var/named/data/named.recursing&quot;; secroots-file &quot;/var/named/data/named.secroots&quot;; allow-query &#123; any; &#125;;保存退出[root@localhost ~]# cd /var/named/[root@localhost named]# cp -a named.localhost feng.io.zone[root@localhost named]# vim feng.io.zone $TTL 1D@ IN SOA feng.io. root.feng.io. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS ns.feng.io.ns IN A 192.168.141.12 A 192.168.141.12www IN A 192.168.141.12IN MX 10 mail.feng.iomail IN A 192.168.141.12保存退出[root@localhost named]# vim 192.168.141.arpa$TTL 1D@ IN SOA feng.io. root.feng.io. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS feng.io.ns A 192.168.141.1212 PTR ns.feng.io.38 PTR www.feng.io.12 PTR mail.feng.io.保存退出，重启named服务[root@localhost named]# systemctl restart named 检查同步结果将客户机/etc/resolv.conf 的IP改为从服务器ip，用nslookup测试就可以了，此处仍然以client来测试 从服务器client2上： 12345678910111213141516[root@localhost ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:fc:9f:8d brd ff:ff:ff:ff:ff:ff inet 192.168.141.53/24 brd 192.168.141.255 scope global noprefixroute dynamic ens33 valid_lft 1618sec preferred_lft 1618sec inet6 fe80::1440:45a7:228d:4942/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@localhost ~]# 记住ip：192.168.141.53 测试用的客户机client上： 123456789101112131415161718192021222324252627[root@localhost ~]# vim /etc/resolv.conf # Generated by NetworkManagersearch localdomainnameserver 192.168.141.53保存退出测试:[root@localhost ~]# nslookup&gt; mail.feng.ioServer: 192.168.141.53Address: 192.168.141.53#53Name: mail.feng.ioAddress: 192.168.141.12&gt; 192.168.141.12Server: 192.168.141.53Address: 192.168.141.53#5312.141.168.192.in-addr.arpa name = ns.feng.io.12.141.168.192.in-addr.arpa name = mail.feng.io.&gt; 192.168.141.38Server: 192.168.141.53Address: 192.168.141.53#5338.141.168.192.in-addr.arpa name = www.feng.io.&gt; 如上图，客户端通过从服务器的正反向解析都成功了 安全的加密传输同步主从服务器主服务器配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354生成密钥文件[root@localhost ~]# [root@localhost ~]# cd /var/named/chroot/etc/[root@localhost etc]# dnssec-keygen -a HMAC-MD5 -b 128 -n HOST master-slaveKmaster-slave.+157+61793复制上面弄出来的文件名Kmaster-slave.+157+61793，加上.private 就可以cat出来了：修改配置文件并且设置文件安全[root@localhost etc]# cat Kmaster-slave.+157+61793.private Private-key-format: v1.3Algorithm: 157 (HMAC_MD5)Key: 5U4NAMvTT0RfK2TvNu/jUw==Bits: AAA=Created: 20190203024817Publish: 20190203024817Activate: 20190203024817复制上面cat出来的Key的内容5U4NAMvTT0RfK2TvNu/jUw==，一会儿填入下面这个文件secret的里面[root@localhost etc]# vim transfer.keykey &quot;master-slave&quot;&#123; algorithm hmac-md5; secret &quot;5U4NAMvTT0RfK2TvNu/jUw==&quot;;&#125;;保存退出 [root@localhost etc]# chown root:named transfer.key[root@localhost etc]# chmod 640 transfer.key [root@localhost etc]# ln transfer.key /etc/transfer.key[root@localhost etc]# 开启bind服务的密钥验证功能[root@localhost etc]# vim /etc/named.conf 在文件第11行插入这一行：include &quot;/etc/transfer.key&quot;;在文件第22行左右插入这一行：allow-transfer &#123; key master-slave; &#125;;保存退出，重启named服务[root@localhost etc]# setenforce 0[root@localhost etc]# systemctl restart named 从服务器上观察： 123456做到这步，现在由于从服务器尚未做相关配置，所以现在从服务器无法同步信息了[root@localhost slaves]# rm -rf /var/named/slaves/*[root@localhost slaves]# systemctl restart named[root@localhost slaves]# ls[root@localhost slaves]# 配置从服务器12345678910111213141516171819202122232425262728293031323334[root@localhost ~]# cd /var/named//chroot/etc/我们把上面主服务器transfer.key的内容一模一样地复制到这里：[root@localhost etc]# vi transfer.keykey &quot;master-slave&quot;&#123; algorithm hmac-md5; secret &quot;5U4NAMvTT0RfK2TvNu/jUw==&quot;;&#125;;保存退出[root@localhost etc]# chown root:named transfer.key[root@localhost etc]# chmod 640 transfer.key [root@localhost etc]# ln transfer.key /etc/transfer.key[root@localhost etc]# 修改主配置文件[root@localhost etc]# vi /etc/named.conf 在文件尾部将原本的include &quot;/etc/named.rfc1912.zones&quot;;include &quot;/etc/named.root.key&quot;;改为下列内容：server 192.168.141.12&#123;keys &#123; master-slave; &#125;;&#125;;include &quot;/etc/named.rfc1912.zones&quot;;include &quot;/etc/named.root.key&quot;;include &quot;/etc/transfer.key&quot;;保存退出，重启named服务[root@localhost etc]# setenforce 0[root@localhost etc]# systemctl restart named[root@localhost etc]# 检查结果检查同步，查看/var/named/slaves目录下有没有同步过来的区域数据文件 123[root@localhost etc]# ls /var/named/slaves/192.168.141.arpa feng.io.zone[root@localhost etc]# 如上图，现在/var/named/slaves目录下又有文件了，说明从服务器和主服务器又可以同步信息了。 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-18 DHCP动态管理主机地址]]></title>
    <url>%2Flinux-18%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-18 DHCP动态管理主机地址配置实验环境 有Test和client两台虚拟机，Test用作服务器，client用作客户端，客户端的ip由服务器分配而来。举个栗子，就是你连上了别人家wifi后，那么他家的路由器会给你的电脑或者手机分配一个ip，这样你的电脑或手机才能上网。 做实验之前，最好把用过的虚拟机恢复到比较干净的快照，或者重新装两台虚拟机。例如我的虚拟机Test在前面的章节中，就改了网卡ip，至今它的ens33网卡还有192.168.141.12 、13、14、15多个ip呢，而且ens37我们之前也配置过静态ip，这样会影响本实验的观察，因此我是恢复到之前改网卡配置之前的快照后再进行下面的实验的。 Server硬件配置 Client硬件配置 VMware Workstation Pro 软件设置 在软件上找到“编辑”-&gt;”虚拟网络编辑器”-&gt;”更改设置”，做如下图的设置 注意：ip不用改，例如我的VMnet1的ip是192.168.23.0网段，VMnet8的ip是192.168.141.0网段，那就让它保持原样，不用去改。 下图中，如图选择即可。注意，不要勾选“使用本地DHCP服务将ip分配给虚拟机”，如果你勾选了，那分配ip给client的就不是Test这台服务器，而是VMware Workstation Pro软件分配的了。 两台虚拟机开机，开始配置。 Test配置DHCP服务配置网络 Test中能上网的网卡（NAT模式的网卡，也就是网络适配器1，也就是ens33）不用管，给新增的网卡（仅主机模式的网卡，也就是网络适配器2，也就是ens37）配置一个跟默认网卡不同网段的固定IP，此处以网段192.168.10.0/24为例。 123456789101112131415161718192021222324[root@localhost ~]# nmcli connection add con-name ens37 ifname ens37 type ethernet autoconnect yes ipv4.method manual ipv4.addresses 192.168.10.254/24Connection &apos;ens37&apos; (cae18d83-b6d8-4945-b704-aaf9b918ef04) successfully added.[root@localhost ~]# systemctl restart network[root@localhost ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:9b:23:d9 brd ff:ff:ff:ff:ff:ff inet 192.168.141.173/24 brd 192.168.141.255 scope global noprefixroute dynamic ens33 valid_lft 1798sec preferred_lft 1798sec inet6 fe80::be8c:1227:c5b2:e66d/64 scope link noprefixroute valid_lft forever preferred_lft forever3: ens37: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:9b:23:e3 brd ff:ff:ff:ff:ff:ff inet 192.168.10.254/24 brd 192.168.10.255 scope global noprefixroute ens37 valid_lft forever preferred_lft forever inet6 fe80::81bc:c746:2ead:eb30/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@localhost ~]# 可以看到，ens37的ip已经变成了192.168.10.254/24 安装dhcp服务1[root@localhost ~]# yum install dhcp -y 查看参考示例1[root@localhost ~]# cat /usr/share/doc/dhcp*/dhcpd.conf.example | grep -v &quot;^$&quot; | grep -v &quot;#&quot; 参数 作用 ddns-update-style [类型] 定义DNS服务动态更新的类型，类型包括none（不支持动态更新）、interim（互动更新模式）与ad-hoc（特殊更新模式） [allow \ ignore] client-updates 允许/忽略客户端更新DNS记录 default-lease-time [21600] 默认超时时间 max-lease-time [43200] 最大超时时间 option domain-name-servers [8.8.8.8] 定义DNS服务器地址 option domain-name [“domain.org”] 定义DNS域名 range 定义用于分配的IP地址池 option subnet-mask 定义客户端的子网掩码 option routers 定义客户端的网关地址 broadcase-address[广播地址] 定义客户端的广播地址 ntp-server[IP地址] 定义客户端的网络时间服务器（NTP） nis-servers[IP地址] 定义客户端的NIS域服务器的地址 Hardware[网卡物理地址] 指定网卡接口的类型与MAC地址 server-name[主机名] 向DHCP客户端通知DHCP服务器的主机名 fixed-address[IP地址] 将某个固定的IP地址分配给指定主机 time-offset[偏移误差] 指定客户端与格林尼治时间的偏移差 配置dhcp服务1234567891011121314151617181920[root@localhost ~]# vim /etc/dhcp/dhcpd.conf ## DHCP Server Configuration file.# see /usr/share/doc/dhcp*/dhcpd.conf.example# see dhcpd.conf(5) man page#ddns-update-style none;ignore client-updates;subnet 192.168.10.0 netmask 255.255.255.0&#123;range 192.168.10.50 192.168.10.150;option subnet-mask 255.255.255.0;option routers 192.168.10.254;option domain-name &quot;feng.io&quot;;option domain-name-servers 8.8.8.8;default-lease-time 21600;default-lease-time 43200;&#125; 保存退出 PS：如果要将某个固定的IP分配给指定的主机,需要在主配置文件追加如下（实际上是将MAC地址和IP做了一个映射）： 123456host subnet1&#123; hardware ethernet 00:0c:29:66:3d:fd; #机器的mac地址 fixed-address 192.168.10.88; #提供的独立IP&#125; 参数作用 参数 解析 ddns-update-style none; 设置DNS服务不自动进行动态更新 ignore client-updates; 忽略客户端更新DNS记录 subnet 192.168.1.0 netmask 255.255. 255.0 作用域为192.168.1.0/24网段 range 192.168.1.50 192.168.1.150; IP地址池为192.168.1.50-150（约100个IP地址） option subnet-mask 255.255.255.0; 定义客户端默认的子网掩码 option routers 192.168.1.1; 定义客户端的网关地址 option domain-name “test.com”; 定义默认的搜索域 option domain-name-servers 192.168. 1.1; 定义客户端的DNS地址 default-lease-time 21600; 定义默认租约时间（单位：秒） max-lease-time 43200; 定义最大预约时间（单位：秒） } 结束符 启动dhcp服务12345678[root@localhost ~]# firewall-cmd --add-service=dhcp --permanent success[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# systemctl restart dhcpd[root@localhost ~]# systemctl enable dhcpdCreated symlink from /etc/systemd/system/multi-user.target.wants/dhcpd.service to /usr/lib/systemd/system/dhcpd.service.[root@localhost ~]# client客户端设置成自动获取ip（默认就是），测试12[root@localhost ~]# systemctl restart network[root@localhost ~]# ip add 可以看到，client获取到的ip是192.168.10.50/24，恰恰是我们IP地址池为192.168.1.50-150（约100个IP地址）的第一个地址，说明我们的DHCP服务配置成功了。 这时，我们试试在Test上关掉DHCP服务 Test上： 12[root@localhost ~]# systemctl stop dhcpd[root@localhost ~]# client上： 12[root@localhost ~]# systemctl restart network[root@localhost ~]# ip add 可以看到，一旦Tset上面的DHCP服务关掉了，那么client重启网络服务就会直接报错，再次查看其ip发现，它连IP地址都没了，只能看到其物理地址（Mac地址），上图中我的Mac地址就是00:0c:29:98:66:4e。 接下来，我们把它的ens33网卡的Mac地址记下来，加入到Test的DHCP配置中（Mac地址这么长不要敲错了哈,那个冒号:是英文的冒号，容易敲错）： Test上： 123456789101112131415161718192021222324252627[root@localhost ~]# vim /etc/dhcp/dhcpd.conf ## DHCP Server Configuration file.# see /usr/share/doc/dhcp*/dhcpd.conf.example# see dhcpd.conf(5) man page#ddns-update-style none;ignore client-updates;subnet 192.168.10.0 netmask 255.255.255.0&#123;range 192.168.10.50 192.168.10.150;option subnet-mask 255.255.255.0;option routers 192.168.10.254;option domain-name &quot;feng.io&quot;;option domain-name-servers 8.8.8.8;default-lease-time 21600;default-lease-time 43200;&#125;host subnet1&#123; hardware ethernet 00:0c:29:98:66:4e; #机器的mac地址 fixed-address 192.168.10.88; #提供的独立IP&#125; 保存退出，重启DHCP服务[root@localhost ~]# systemctl restart dhcpd[root@localhost ~]# client上： 12[root@localhost ~]# systemctl restart network[root@localhost ~]# ip add ​ 可以看到，它的ip已经变成了我们指定分配给它的192.168.10.88/24了，配置成功！ ​ 实验到此结束！ ​ 虚拟机和虚拟网卡的通信原理host-only（仅主机）模式与VMnet1虚拟网卡进行通信NAT模式与VMnet8虚拟网卡进行通信桥接使用的是你机器的真实网卡进行上网 1.仅主机模式 此模式下，虚拟机与VMnet1虚拟网卡进行通信，咱们做一下测试： 在虚拟网络编辑器中，我们将VMnet1如下图设置，给它设置一个DHCP地址池192.168.23.50-150。这样一来，我们的虚拟机网络适配器但凡是使用仅主机模式且以DHCP方式获取ip的，就能从这个地址池中获取到ip。 这样设置以后，只要你的虚拟机网卡是仅主机模式且网卡配置文件里设置的ip获取方式是DHCP（默认就是DHCP），则其ip就会从上图中那个DHCP地址池中选取。例如，我新安装的一台虚拟机，网卡设置为仅主机模式后，打开后其ip如下图： 可以看到它的ip为192.168.23.50，恰恰是上述地址池的第一个ip。那么上述地址池的最后一个ip用来干嘛了呢？如下图，打开控制面板，查看VMnet1的详细信息，可以看到上述地址池最后一个ip：192.168.23.150充当的是DHCP服务器的ip。 2.NAT模式​ 此模式下，虚拟机与VMnet8虚拟网卡进行通信，咱们做一下测试： 在虚拟网络编辑器中，我们将VMnet8如下图设置，给它设置一个DHCP地址池192.168.100.50-150。这样一来，我们的虚拟机网络适配器但凡是使用NAT模式且以DHCP方式获取ip的，就能从这个地址池中获取到ip。 这样设置以后，只要你的虚拟机网卡是NAT模式且网卡配置文件里设置的ip获取方式是DHCP（默认就是DHCP），则其ip就会从上图中那个DHCP地址池中选取。例如，刚刚那台虚拟机，网卡设置为NAT模式后，打开后其ip如下图： 可以看到它的ip为192.168.100.50，恰恰是上述地址池的第一个ip。要注意的是，在日常使用电脑的过程中，偶尔可能会把虚拟网卡VMnet1和VMnet8改动，出现下面这种情况： 本来我的电脑VMnet8网卡采用的是192.168.100.X网段的ip，但是某一次更改配置之后就自动变成了下面这个网段。 这时候只需要将属性配置为自动获取ip地址，那么就会变回原样了。 3.桥接模式 桥接模式使用的是你机器的真实网卡进行上网，也就是说，如果你的虚拟机网络适配器设置为桥接模式的话，则相当于虚拟机与你的电脑物理主机桥接，桥指的是网桥，就是交换机。所以，桥接模式下，你的虚拟机和你的物理机是在同一个网段的，如下图： ​ 我们将刚刚那台虚拟机设置为桥接模式，查看其ip： 可以看到它的ip为192.168.1.105，那么我们看看我的物理机ip： 可以看到我的物理机ip是192.168.1.108，与之确实是同一个网段的。 我们常用的是NAT模式的虚拟机，所以我们按刚刚的NAT那样设置就好。 本篇到此结束。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-17 Samba服务与NFS]]></title>
    <url>%2Flinux-17%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-17 Samba服务与NFS概念解析 Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。通过设置“NetBIOS over TCP/IP”使得Samba不但能与局域网络主机分享资源，还能与全世界的电脑分享资源。 NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。 samba安装samba服务1[root@localhost ~]# yum install samba -y [global] 参数 作用 workgroup = MYGROUP #工作组名称 server string = Samba Server Version %v #服务器介绍信息，参数%v为显示SMB版本号 log file = /var/log/samba/log.%m #定义日志文件的存放位置与名称，参数%m为来访的主机名 max log size = 50 #定义日志文件的最大容量为50KB security = user #安全验证的方式，总共有4种 #share：来访主机无需验证口令；比较方便，但安全性很差 #user：需验证来访主机提供的口令后才可以访问；提升了安全性 #server：使用独立的远程主机验证来访主机提供的口令（集中管理账户） #domain：使用域控制器进行身份验证 passdb backend = tdbsam #定义用户后台的类型，共有3种 #smbpasswd：使用smbpasswd命令为系统用户设置Samba服务程序的密码 #tdbsam：创建数据库文件并使用pdbedit命令建立Samba服务程序的用户 #ldapsam：基于LDAP服务进行账户验证 load printers = yes #设置在Samba服务启动时是否共享打印机设备 cups options = raw #打印机的选项 [homes] #共享参数 comment = Home Directories #描述信息 browseable = no #指定共享信息是否在“网上邻居”中可见 writable = yes #定义是否可以执行写入操作，与“read only”相反 [printers] #打印机共享参数 去掉配置文件中的注释 12345678910111213141516171819202122232425262728293031[root@localhost ~]# mv /etc/samba/smb.conf /etc/samba/smb.conf.bak[root@localhost ~]# cat /etc/samba/smb.conf.bak | grep -v &quot;#&quot; | grep -v &quot;;&quot; | grep -v &quot;^$&quot; &gt; /etc/samba/smb.conf[root@localhost ~]# cat /etc/samba/smb.conf[global] workgroup = SAMBA security = user passdb backend = tdbsam printing = cups printcap name = cups load printers = yes cups options = raw[homes] comment = Home Directories valid users = %S, %D%w%S browseable = No read only = No inherit acls = Yes[printers] comment = All Printers path = /var/tmp printable = Yes create mask = 0600 browseable = No[print$] comment = Printer Drivers path = /var/lib/samba/drivers write list = @printadmin root force group = @printadmin create mask = 0664 directory mask = 0775[root@localhost ~]# 配置一个共享 123456789101112131415[root@localhost ~]# vim /etc/samba/smb.conf在文件首部插入下列代码，保存退出即可[database]comment = Do not arbitrarily modify the database file path = /home/databasepath = /home/databasepublic = nowritable = yes上述配置含义：共享名称为database警告用户不要随意修改数据库共享目录为/home/database关闭“所有人可见”允许写入操作 新建共享所需要的目录 1[root@localhost ~]# mkdir /home/database 新建访问共享使用的用户（注意：此用户并非本地用户，但是本地要有一个用户与之对应） 12345678910111213141516171819202122232425262728293031新建本地用户aaa[root@localhost ~]# useradd aaa新建访问共享使用的用户aaa[root@localhost ~]# pdbedit -a -u aaanew password:retype new password:Unix username: aaaNT username: Account Flags: [U ]User SID: S-1-5-21-2065519308-1855748627-1460656783-1000Primary Group SID: S-1-5-21-2065519308-1855748627-1460656783-513Full Name: Home Directory: \\localhost\aaaHomeDir Drive: Logon Script: Profile Path: \\localhost\aaa\profileDomain: LOCALHOSTAccount desc: Workstations: Munged dial: Logon time: 0Logoff time: Wed, 06 Feb 2036 10:06:39 ESTKickoff time: Wed, 06 Feb 2036 10:06:39 ESTPassword last set: Wed, 30 Jan 2019 04:27:29 ESTPassword can change: Wed, 30 Jan 2019 04:27:29 ESTPassword must change: neverLast bad password : 0Bad password count : 0Logon hours : FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF[root@localhost ~]# 对共享的目录配置相应的权限 123456789安装semanage管理工具[root@localhost ~]# yum install policycoreutils-python.x86_64 -y 对共享的目录配置相应的权限[root@localhost ~]# chown -Rf aaa:aaa /home/database/[root@localhost ~]# semanage fcontext -a -t samba_share_t /home/database[root@localhost ~]# restorecon -Rv /home/database/restorecon reset /home/database context unconfined_u:object_r:home_root_t:s0-&gt;unconfined_u:object_r:samba_share_t:s0[root@localhost ~]# 启动samba服务，配置防火墙 123456[root@localhost ~]# systemctl restart smb[root@localhost ~]# firewall-cmd --add-port=445/tcp --permanent success[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# 在windows上访问samba共享,win+r 输入 1234\\ip例如我的就是：\\192.168.141.12 输入账号aaa和你刚刚设置的密码即可 在linux客户端上访问samba共享 我们现在另外开一台虚拟机，用作客户端client，没有第二台虚拟机的可以现装一个 安装客户端需要的软件包 1[root@localhost ~]# yum install samba-client cifs-utils -y 访问samba的共享 注意ip不要输错了，我的samba服务器ip是192.168.141.12，但是你的可不一定，用户名也是如此 12345678910[root@localhost ~]# smbclient //192.168.141.12/database -U aaaEnter SAMBA\aaa&apos;s password: Try &quot;help&quot; to get a list of possible commands.smb: \&gt; ls . D 0 Wed Jan 30 17:19:02 2019 .. D 0 Wed Jan 30 17:27:16 2019 17811456 blocks of size 1024. 16474020 blocks availablesmb: \&gt; exit[root@localhost ~]# 客户端开机自动挂载samba的共享 客户端配置： 12345[root@localhost ~]# vim auth.smbusername=aaapassword=123456保存退出 编辑/etc/fstab文件 12345[root@localhost ~]# vim /etc/fstab在文件最后面加入以下内容//192.168.141.12/database /database cifs credentials=/root/auth.smb 0 0保存退出 创建挂载文件夹/database，重载fstab测试挂载是否成功 12345[root@localhost ~]# mkdir /database[root@localhost ~]# mount -a[root@localhost ~]# mount | grep database//192.168.141.12/database on /database type cifs (rw,relatime,vers=1.0,cache=strict,username=aaa,domain=,uid=0,noforceuid,gid=0,noforcegid,addr=192.168.141.12,soft,unix,posixpaths,serverino,mapposix,acl,rsize=1048576,wsize=65536,echo_interval=60,actimeo=1)[root@localhost ~]# 看到有内容说明挂载成功 NFS现在我们可以关掉客户端，回到samba服务器继续接下来的实验 安装nfs工具包 1[root@localhost ~]# yum install nfs-utils.x86_64 -y 创建共享的目录，并为目录设置权限 12345[root@localhost ~]# mkdir /nfsfile[root@localhost ~]# chmod -Rf 777 /nfsfile/[root@localhost ~]# echo &quot;hello nfs&quot; /nfsfile/readme.txthello nfs /nfsfile/readme.txt[root@localhost ~]# 编辑nfs共享配置文件 12345[root@localhost ~]# vim /etc/exports[root@localhost ~]# 就写一行即可：/nfsfile *(rw,sync,root_squash)保存退出 启动nfs服务 123456[root@localhost ~]# systemctl restart rpcbind[root@localhost ~]# systemctl enable rpcbind[root@localhost ~]# systemctl start nfs-server.service [root@localhost ~]# systemctl enable nfs-server.service Created symlink from /etc/systemd/system/multi-user.target.wants/nfs-server.service to /usr/lib/systemd/system/nfs-server.service.[root@localhost ~]# nfs客户端配置 123456789101112[root@localhost ~]# showmount -e 192.168.141.12Export list for 192.168.141.12:/nfsfile *[root@localhost ~]# [root@localhost ~]# showmount -e 192.168.141.12Export list for 192.168.141.12:/nfsfile *[root@localhost ~]# mkdir /nfs[root@localhost ~]# mount -t nfs 192.168.141.12:/nfsfile /nfs[root@localhost ~]# cat /nfs/readmehello nfs[root@localhost ~]# echo &quot;192.168.141.12:/nfsfile /nfs nfs defaults 0 0&quot; &gt;&gt; /etc/fstab autofs自动挂载服务当检测到用户视图访问一个尚未挂载的文件系统时，autofs将自动挂载该文件系统 安装autofs 1[root@localhost ~]# yum install autofs -y autofs主配置文件中需要按照“挂载目录 子配置文件”的格式进行填写。 挂载目录是设备挂载位置的上一级目录。 例如，光盘设备一般挂载到/media/cdrom目录中，那么挂载目录写成/media即可。 12345[root@localhost ~]# vim /etc/auto.master将原本的/misc /etc/auto.misc改为/misc /etc/iso.misc 在子配置文件中，应按照“挂载目录 挂载文件类型及权限 :设备名称”的格式进行填写。 例如，要把光盘设备挂载到/media/iso目录中， 可将挂载目录写为iso， 而-fstype为文件系统格式参数， iso9660为光盘设备格式， ro、nosuid及nodev为光盘设备具体的权限参数， /dev/cdrom则是定义要挂载的设备名称。配置完成后再顺手将autofs服务程序启动并加入到系统启动项中： 123456789[root@localhost ~]# vi /etc/iso.misc写入以下内容iso -fstype=iso9660,ro,nosuid,nodev :/dev/cdrom保存退出[root@localhost ~]# systemctl restart autofs[root@localhost ~]# systemctl enable autofsCreated symlink from /etc/systemd/system/multi-user.target.wants/autofs.service to /usr/lib/systemd/system/autofs.service.[root@localhost ~]# 检查是否一开始没有挂载iso,但是一旦访问iso子目录，就立马被挂载上 123456789101112131415[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/centos-root 17G 1.3G 16G 8% /devtmpfs 476M 0 476M 0% /devtmpfs 488M 0 488M 0% /dev/shmtmpfs 488M 7.7M 480M 2% /runtmpfs 488M 0 488M 0% /sys/fs/cgroup/dev/sda1 1014M 130M 885M 13% /boottmpfs 98M 0 98M 0% /run/user/0192.168.141.12:/nfsfile 17G 1.3G 16G 8% /nfs11. [root@localhost ~]# cd /media12. [root@localhost media]# ls13. [root@localhost media]# cd iso14. [root@localhost iso]# ls15. manifest.txt run_upgrader.sh VMwareTools-10.2.0-7259539.tar.gz vmware-tools-upgrader-32 vmware-tools-upgrader-64 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-16 vsftpd服务]]></title>
    <url>%2Flinux-16%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-16 vsftpd服务文件传输协议FTP协议有下面两种工作模式。 主动模式：FTP服务器主动向客户端发起连接请求。 被动模式：FTP服务器等待客户端发起连接请求（FTP的默认工作模式） 安装并启动vsftpd 123456789[root@localhost ~]# yum install vsftps -y[root@localhost ~]# systemctl restart vsftpd[root@localhost ~]# systemctl enable vsftpdCreated symlink from /etc/systemd/system/multi-user.target.wants/vsftpd.service to /usr/lib/systemd/system/vsftpd.service.[root@localhost ~]# firewall-cmd --add-service=ftp --permanent success[root@localhost ~]# firewall-cmd --reloadsuccess[root@localhost ~]# 备份配置文件 1234[root@localhost ~]# mv /etc/vsftpd/vsftpd.conf&#123;,.bak&#125;[root@localhost ~]# ls /etc/vsftpd/ftpusers user_list vsftpd.conf.bak vsftpd_conf_migrate.sh[root@localhost ~]# 创建新的没有注释的配置文件 1234[root@localhost ~]# grep -v &quot;#&quot; /etc/vsftpd/vsftpd.conf.bak &gt; /etc/vsftpd/vsftpd.conf[root@localhost ~]# ls /etc/vsftpd/ftpusers user_list vsftpd.conf vsftpd.conf.bak vsftpd_conf_migrate.sh[root@localhost ~]# 查看默认配置文件中的选项 12345678910111213141516[root@localhost ~]# cat /etc/vsftpd/vsftpd.confanonymous_enable=YESlocal_enable=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=NOlisten_ipv6=YESpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YES[root@localhost ~]# Vsftpd服务程序vsftpd作为更加安全的文件传输的服务程序，允许用户以三种认证模式登录到FTP服务器上。 vsftpd使用三大模式： 匿名用户模式 是一种最不安全的认证模式，任何人都可以无需密码验证而直接登录到FTP服务器。 本地用户模式 是通过Linu系统本地的账户密码信息进行认证的模式，相较于匿名开放模式更安全，而且配置起来也很简单。但是如果被黑客破解了账户的信息，就可以畅通无阻地登录FTP服务器，从而完全控制整台服务器。 虚拟用户模式 是这三种模式中最安全的一种认证模式，它需要为FTP服务单独建立用户数据库文件，虚拟出用来进行口令验证的账户信息，而这些账户信息在服务器系统中实际上是不存在的，仅供FTP服务程序进行认证使用。这样，即使黑客破解了账户信息也无法登录服务器，从而有效降低了破坏范围和影响。 匿名开放模式修改配置文件 123456789101112131415161718192021222324252627[root@localhost ~]# vim /etc/vsftpd/vsftpd.confanonymous_enable=YESanon_umask=022anonymous_enable=YESanon_umask=022anon_upload_enable=Yesanon_mkdir_write_enable=Yesanon_other_write_enable=Yeslocal_enable=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=NOlisten_ipv6=YESpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YES保存退出 [root@localhost ~]# systemctl restart vsftpd[root@localhost ~]# chown -Rf ftp /var/ftp/pub[root@localhost ~]# setsebool -P ftpd_full_access=on[root@localhost ~]# 接下来就可以用windows资源管理器登录上去上传下载文件 本地用户模式修改配置文件 1234567891011121314151617[root@localhost ~]# vim /etc/vsftpd/vsftpd.confanonymous_enable=NOlocal_enable=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=NOlisten_ipv6=YESpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YES保存退出[root@localhost ~]# systemctl restart vsftpd 再次用windows资源管理器登录服务器： 按理来讲，现在已经完全可以本地用户的身份登录FTP服务器了。但是在使用root管理员登录后，发现登陆失败： 可见，我们已经被系统拒绝访问了。这是因为vsftpd服务程序所在的目录中默认存放着两个名为“用户名单”的文件（ftpusers和user_list）。vsftpd服务程序目录中的这两个文件只要里面写有某位用户的名字，就不再允许这位用户登录到FTP服务器上。分别打开 ftpusers 和 user_list 这两个文件，删除里面的root，然后保存并退出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182[root@localhost ~]# cat /etc/vsftpd/ftpusers # Users that are not allowed to login via ftprootbindaemonadmlpsyncshutdownhaltmailnewsuucpoperatorgamesnobody[root@localhost ~]# vim /etc/vsftpd/ftpusers 删除root，保存退出。[root@localhost ~]# cat /etc/vsftpd/ftpusers # Users that are not allowed to login via ftpbindaemonadmlpsyncshutdownhaltmailnewsuucpoperatorgamesnobody[root@localhost ~]# [root@localhost ~]# cat /etc/vsftpd/user_list # vsftpd userlist# If userlist_deny=NO, only allow users in this file# If userlist_deny=YES (default), never allow users in this file, and# do not even prompt for a password.# Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers# for users that are denied.rootbindaemonadmlpsyncshutdownhaltmailnewsuucpoperatorgamesnobody[root@localhost ~]# [root@localhost ~]# vim /etc/vsftpd/user_list 删除root，保存退出。[root@localhost ~]# cat /etc/vsftpd/user_list # vsftpd userlist# If userlist_deny=NO, only allow users in this file# If userlist_deny=YES (default), never allow users in this file, and# do not even prompt for a password.# Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers# for users that are denied.bindaemonadmlpsyncshutdownhaltmailnewsuucpoperatorgamesnobody[root@localhost ~]# 现在就可以用本地用户root登录了，本地用户登录上去之后，登录的目录是本地用户的家目录，如下图 虚拟用户模式创建一个本地用户，用于映射虚拟用户在本地的代理，为了安全起见，禁止这个用户登录linux服务器 1[root@localhost ~]# useradd -d /var/ftproot -s /sbin/nologin virtual 创建用于进行FTP认证的用户数据库文件，其中奇数行为账户名，偶数行为密码。 1234567891011[root@localhost ~]# cd /etc/vsftpd/[root@localhost vsftpd]# vim vuser.listaaa123456bbb123456ccc123456保存退出 使用db_load命令用哈希（hash）算法将原始的明文信息文件转换成数据库文件 降低数据库文件的权限（避免其他人看到数据库文件的内容） 把原始的明文信息文件删除。 123456[root@localhost vsftpd]# db_load -T -t hash -f vuser.list vuser.db[root@localhost vsftpd]# file vuser.dbvuser.db: Berkeley DB (Hash, version 9, native byte-order)[root@localhost vsftpd]# chmod 600 vuser.db[root@localhost vsftpd]# rm -f vuser.list[root@localhost vsftpd]# 建立用于支持虚拟用户的PAM文件 12345[root@localhost vsftpd]# vim /etc/pam.d/vsftpd.vuauth required pam_userdb.so db=/etc/vsftpd/vuseraccount required pam_userdb.so db=/etc/vsftpd/vuser保存退出 修改vsftpd配置文件 12345678910111213141516171819202122[root@localhost vsftpd]# vim /etc/vsftpd/vsftpd.confanonymous_enable=NOlocal_enable=YESguest_enable=YESguest_username=virtualallow_writeable_chroot=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=NOlisten_ipv6=YES pam_service_name=vsftpd.vuuserlist_enable=YEStcp_wrappers=YES保存退出，重启vsftpd服务[root@localhost vusers_dir]# systemctl restart vsftpd 再次用windows资源管理器登录服务器，这次我们用bbb用户登录： 登录成功，到了bbb用户的家目录，不过这里什么文件也木有 tftp服务安装tftp服务 12345678[root@localhost ~]# yum install xinetd tftp-server.x86_64 tftp -y[root@localhost ~]# firewall-cmd --add-port=69/udp --permanent success[root@localhost ~]# firewall-cmd --reload success[root@localhost ~]# 这里tftp的对应端口号69 修改配置文件 1234567[root@localhost ~]# vim /etc/xinetd.d/tftp 将 disable = yes改为disable = no保存退出 重启服务 123[root@localhost ~]# systemctl restart xinetd.service [root@localhost ~]# systemctl enable xinetd[root@localhost ~]# 命令 作用 ? 帮助信息 put 上传文件 get 下载文件 verbose 显示详细的处理信息 status 显示当前的状态信息 binary 使用二进制进行传输 ascii 使用ASCII码进行传输 timeout 设置重传的超时时间 quit 退出 测试 1234567[root@localhost ~]# echo &quot;hello,tftp&quot; &gt; /var/lib/tftpboot/readme.txt[root@localhost ~]# tftp 192.168.141.12tftp&gt; get readme.txttftp&gt; quit[root@localhost ~]# cat readme.txt hello,tftp[root@localhost ~]# 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-15 Apache服务]]></title>
    <url>%2Flinux-15%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-15 Apache服务基本步骤1.安装启动Apache服务，防火墙放行相应的端口1234567[root@localhost ~]# yum install httpd -y[root@localhost ~]# systemctl restart httpd[root@localhost ~]# firewall-cmd --add-port=80/tcp --permanent success[root@localhost ~]# firewall-cmd --reload success[root@localhost ~]# 接下来在自己电脑浏览器上访问虚拟机的ip地址，例如我的ip是192.168.141.12，打开后可以看到这个测试页面： 2.编写第一个网页文件123456[root@localhost ~]# cd /var/www/html/[root@localhost html]# ls[root@localhost html]# vim index.html[root@localhost html]# cat index.html hello world ![root@localhost html]# 此时就可以在浏览器上输入ip看到这个网页了 如果你刚刚重启了虚拟机，有可能会看不到网页效果，此时需要重启httpd服务 1systemctl restart httpd 此时就又可以在浏览器上输入ip看到这个hello world ! 的网页了 3.开启selinux，并配置selinux1234567[root@localhost ~]# vim /etc/selinux/config 将selinux设置为enforcing将SELINUXTYPE设置为targeted如下：SELINUX=enforcingSELINUXTYPE=targeted 4.重启虚拟机，查看selinux状态1234[root@localhost ~]# reboot[root@localhost ~]# getenforce Enforcing 5.查看网站服务的系统文件123[root@localhost ~]# ls -Zd /var/www/htmldrwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www/html[root@localhost ~]# 用户段system_u代表系统进程的身份 角色段object_r代表文件目录的角色 类型段httpd_sys_content_t代表网站服务的系统文件 例如上述网站服务的系统文件角为/var/www/html 6.新建一个目录，后面我们会把网站根目录改到这个新建目录下1234[root@localhost ~]# mkdir /home/wwwroot[root@localhost ~]# ls -Zd /home/wwwroot/drwxr-xr-x. root root unconfined_u:object_r:home_root_t:s0 /home/wwwroot/[root@localhost ~]# semanage工具semanage命令用于管理SELinux的策略，格式为“semanage [选项] [文件]” 经常用到的几个参数及其功能如下所示： -l参数用于查询； -a参数用于添加； -m参数用于修改； -d参数用于删除。 安装semanage管理工具1[root@localhost ~]# yum install policycoreutils-python.x86_64 -y PS: 如果安装不了就换个yum源 修改网站根目录，为新设置的网站根目录配置SELinux安全上下文1234567891011首先在新的网站目录下也弄一个默认网页[root@localhost ~]# cd /home/wwwroot/[root@localhost wwwroot]# touch index.html[root@localhost wwwroot]# vim index.html [root@localhost wwwroot]# cat index.html /home/wwwroot/ have hello world too ![root@localhost wwwroot]# 修改配置文件,在第119/124/131行将原本的/var/www/html修改为/home/wwwroot/vim编辑文件时，：set nu即可查看行号[root@localhost ~]# vim /etc/httpd/conf/httpd.conf 修改为： 然后保存退出即可 接下来重启httpd服务，为新设置的网站根目录配置SELinux安全上下文 1234567[root@localhost ~]# systemctl restart httpd.service [root@localhost ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/[root@localhost ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/*[root@localhost ~]# restorecon -Rv /home/wwwroot/restorecon reset /home/wwwroot context unconfined_u:object_r:home_root_t:s0-&gt;unconfined_u:object_r:user_home_dir_t:s0restorecon reset /home/wwwroot/index.html context unconfined_u:object_r:home_root_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0[root@localhost ~]# 再次到浏览器访问自己的ip，可以看到自己放在新的网站根目录地下的index.html的内容 个人用户主页修改配置文件1[root@localhost ~]# vim /etc/httpd/conf.d/userdir.conf 将该配置文件第17行的内容由disabled改为public_html 修改成： 保存退出，重启httpd服务，将httpd_enable_homedirs 的状态由 off改为on 1234567[root@localhost ~]# systemctl restart httpd.service [root@localhost ~]# getsebool -a | grep http | grep homehttpd_enable_homedirs --&gt; off[root@localhost ~]# setsebool -P httpd_enable_homedirs=on[root@localhost ~]# getsebool -a | grep http | grep homehttpd_enable_homedirs --&gt; on[root@localhost ~]# 新建一个用户，设置这个用户的主页12345678910111213[root@localhost ~]# cd /home[root@localhost home]# lswwwroot[root@localhost home]# useradd aaa[root@localhost home]# lsaaa wwwroot[root@localhost home]# chmod o+x /home/aaa[root@localhost home]# su aaa[aaa@localhost home]$ cd ~[aaa@localhost ~]$ mkdir public_html[aaa@localhost ~]$ echo &quot;hello ,i am aaa&quot; &gt; public_html/index.html[aaa@localhost ~]$ chmod 755 public_html/[aaa@localhost ~]$ 到浏览器访问自己虚拟机的ip加上/~用户名/看看效果： 例如我访问的就是：192.168.141.12/~aaa/ 如下图: 密码认证为个人用户主页加上密码认证（密码认证也可以直接用作正常网站） 12345678910111213141516171819202122在交互模式下为用户aaa设置httpd服务的密码，我这里设置的是123456[aaa@localhost root]$ su rootPassword: [root@localhost ~]# htpasswd -c /etc/httpd/passwd aaaNew password: Re-type new password: Adding password for user aaa[root@localhost ~]# 修改配置文件，将&lt;Directory &quot;/home/*/public_html&quot;&gt;和&lt;/Directory&gt;之间的内容修改为如下形式，有代码，也有截图供您参考：[root@localhost ~]# vim /etc/httpd/conf.d/userdir.conf &lt;Directory &quot;/home/*/public_html&quot;&gt; AllowOverride all authuserfile &quot;/etc/httpd/passwd&quot; authname &quot;My privately website&quot; authtype basic require user aaa # Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec# Require method GET POST OPTIONS&lt;/Directory&gt; 原来的文件是这样的： 修改后的文件是这样的： 保存退出，重启httpd服务 12[root@localhost ~]# systemctl restart httpd[root@localhost ~]# 再次到浏览器访问自己虚拟机的ip加上/~用户名/看看效果： 例如我访问的就是：192.168.141.12/~aaa/ 如下图: 登录上去后是这样的： 虚拟主机基于IP地址划分虚拟主机首先，为虚拟机再添加三个IP地址123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@localhost ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33如下，我给网卡新加了.13 .14 .15三个ip，这里以此三个ip为例TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot;DEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;9c86a9bc-0939-4790-8580-274041e5eff3&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;yIPADDR=192.168.141.12NETMASK=255.255.255.0IPADDR0=192.168.141.13NETMASK0=255.255.255.0IPADDR1=192.168.141.14NETMASK1=255.255.255.0IPADDR2=192.168.141.15NETMASK2=255.255.255.0GATEWAY1=192.168.141.2DNS1=114.114.114.114DNS2=8.8.8.8保存退出，重启网络服务[root@localhost ~]# systemctl restart network[root@localhost ~]# ip add | grep inet | grep brd inet 192.168.141.12/24 brd 192.168.141.255 scope global noprefixroute ens33 inet 192.168.141.13/24 brd 192.168.141.255 scope global secondary noprefixroute ens33 inet 192.168.141.14/24 brd 192.168.141.255 scope global secondary noprefixroute ens33 inet 192.168.141.15/24 brd 192.168.141.255 scope global secondary noprefixroute ens33 inet 192.168.141.1 创建网页 为不同站点创建不同网站根目录 12345678[root@localhost ~]# cd /home/wwwroot/[root@localhost wwwroot]# mkdir 10[root@localhost wwwroot]# mkdir 20[root@localhost wwwroot]# mkdir 30[root@localhost wwwroot]# echo &quot;i am 192.168.141.13&quot; &gt; /home/wwwroot/10/index.html[root@localhost wwwroot]# echo &quot;i am 192.168.141.14&quot; &gt; /home/wwwroot/20/index.html[root@localhost wwwroot]# echo &quot;i am 192.168.141.15&quot; &gt; /home/wwwroot/30/index.html[root@localhost wwwroot]# 修改配置文件123456789101112131415161718192021222324252627282930313233[root@localhost wwwroot]# cd [root@localhost ~]# vim /etc/httpd/conf/httpd.conf 在该文件尾部加上三个虚拟主机配置：&lt;VirtualHost 192.168.141.13&gt;DocumentRoot /home/wwwroot/10ServerName 10&lt;Directory /home/wwwroot/10&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.141.14&gt;DocumentRoot /home/wwwroot/20ServerName 20&lt;Directory /home/wwwroot/20&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.141.15&gt;DocumentRoot /home/wwwroot/30ServerName 30&lt;Directory /home/wwwroot/30&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;保存退出，重启httpd服务[root@localhost ~]# systemctl restart httpd.service 分别在浏览器打开ip，此处以192.168.141.15为例，看看如下图的效果： 可以看到报403错，服务器（咱们的虚拟机）拒绝浏览器访问这个网站，原因很简单，就是咱们创建了三个新的网站，却没有为三个新的网站根目录配置SELinux安全上下文，就会导致这种情况，接下来咱们来一一设置一下即可： 12345678910111213[root@localhost ~]# systemctl restart httpd[root@localhost ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/10/[root@localhost ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/20/[root@localhost ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/30/[root@localhost ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/10/*[root@localhost ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/20/*[root@localhost ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/30/*[root@localhost ~]# restorecon -Rv /home/wwwroot/restorecon reset /home/wwwroot/10/index.html context unconfined_u:object_r:user_home_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0restorecon reset /home/wwwroot/20/index.html context unconfined_u:object_r:user_home_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0restorecon reset /home/wwwroot/30/index.html context unconfined_u:object_r:user_home_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0[root@localhost ~]# systemctl restart httpd.service [root@localhost ~]# 设置完成后重新启动httpd服务，然后浏览器就可以看到如下效果了 效果截图： 咱们可以把之前弄的网站一起看看，都是可以顺利访问的： 看着上面这张图，顿时就有了一丢丢成就感。 基于主机域名划分的虚拟主机创建网页文件1234[root@localhost ~]# echo &quot;i am 10&quot; &gt; /home/wwwroot/10/index.html [root@localhost ~]# echo &quot;i am 20&quot; &gt; /home/wwwroot/20/index.html [root@localhost ~]# echo &quot;i am 30&quot; &gt; /home/wwwroot/30/index.html [root@localhost ~]# 修改http配置文件12345678910111213141516171819202122232425262728293031323334[root@localhost ~]# vim /etc/httpd/conf/httpd.conf #仅仅修改一下ServerName即可：&lt;VirtualHost 192.168.141.13&gt;DocumentRoot /home/wwwroot/10ServerName 10.feng.io&lt;Directory /home/wwwroot/10&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.141.14&gt;DocumentRoot /home/wwwroot/20ServerName 20.feng.io&lt;Directory /home/wwwroot/20&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.141.15&gt;DocumentRoot /home/wwwroot/30ServerName 30.feng.io&lt;Directory /home/wwwroot/30&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;保存退出，重启httpd服务[root@localhost ~]# systemctl restart httpd.service [root@localhost ~]# 由于网站根目录没变，所以网站根目录无需再次配置selinux安全上下文 接下来在自己电脑上修改一个文件 C:\Windows\System32\drivers\etc的目录下，有个叫hosts的文件，咱们可以用notepad++打开编辑，保存的时候回提示以管理员身份才能保存。咱们在该文件尾部，加上三行配置保存退出即可。 ​ ps：这个文件用于域名重定向，很多病毒也经常来改你这个文件，让你在浏览器敲入“taobao.com”等网址的时候，ip其实已经重定向到黑客指定的服务器上了，这样你就会上一个假的淘宝网站，造成你的困扰甚至经济损失。 123192.168.141.13 10.feng.io192.168.141.14 20.feng.io192.168.141.15 30.feng.io 前面的是服务器ip，后面的是对应域名 接下来咱们打开电脑的cmd，刷新一下dns，ping一下10.feng.io看看是哪个ip在相应我们 12ipconfig /flushdnsping 10.feng.io 如下图，可以看到ping 10.feng.io的话，就相当于直接ping 192.168.141.13，说明配置成功 接下来咱们在浏览器上访问域名，效果如下： 咱们改了host文件，这个实验做完了之后可以把我们的改动删掉或者备注掉，也可以留在那，一般情况下不会出问题。 基于端口号划分的虚拟主机修改配置文件123456789101112131415161718192021222324252627282930313233[root@localhost ~]# vim /etc/httpd/conf/httpd.conf Listen 30010Listen 30020Listen 30030&lt;VirtualHost 192.168.141.12:30010&gt;DocumentRoot /home/wwwroot/10ServerName 10.feng.io&lt;Directory /home/wwwroot/10&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.141.12:30020&gt;DocumentRoot /home/wwwroot/20ServerName 20.feng.io&lt;Directory /home/wwwroot/20&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.141.12:30030&gt;DocumentRoot /home/wwwroot/30ServerName 30.feng.io&lt;Directory /home/wwwroot/30&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt; 相应端口做好相应协议、防火墙配置 123456789[root@localhost ~]# semanage port -a -t http_port_t -p tcp 30010[root@localhost ~]# semanage port -a -t http_port_t -p tcp 30020[root@localhost ~]# semanage port -a -t http_port_t -p tcp 30030[root@localhost ~]# firewall-cmd --add-port=&#123;30010,30020,30030&#125;/tcp --permanentsuccess[root@localhost ~]# firewall-cmd --reload success[root@localhost ~]# systemctl restart httpd.service [root@localhost ~]# 接下来在浏览器访问ip加端口，效果如下： 阻止特定浏览器特征访问例如：VirtualHost 192.168.141.12:30010阻止firefox访问 VirtualHost 192.168.141.12:30020和VirtualHost 192.168.141.12:30030不阻止firefox访问 12345678910111213141516171819202122232425262728293031323334353637383940[root@localhost ~]# vim /etc/httpd/conf/httpd.conf Listen 30010Listen 30020Listen 30030&lt;VirtualHost 192.168.141.12:30010&gt;DocumentRoot /home/wwwroot/10ServerName 10.feng.io&lt;Directory /home/wwwroot/10&gt;SetEnvif User-Agent &quot;Firefox&quot; ff=1Order deny,allowDeny from env=ffAllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.141.12:30020&gt;DocumentRoot /home/wwwroot/20ServerName 20.feng.io&lt;Directory /home/wwwroot/20&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.141.12:30030&gt;DocumentRoot /home/wwwroot/30ServerName 30.feng.io&lt;Directory /home/wwwroot/30&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;保存退出，重启httpd服务[root@localhost ~]# systemctl restart httpd.service 接下来咱们看看效果，如下图： 可以看到，咱们的VirtualHost 192.168.141.12:30010阻止firefox访问后，再次访问已经看不到其网页内容了 ，然而其他主机却仍然可以正常访问 好了，本篇到此结束，Apache服务在以后咱们运维实战的时候，搭建在服务器上也是很好用的，可以用作网站下分设多个子网站。]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-14 SSH远程访问服务]]></title>
    <url>%2Flinux-14%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-14 SSH远程访问服务概念解析 提示：SSH远程访问服务会在后续章节“linux-运维实战”中，在远程控制腾讯云服务器时使用到，是保证你的服务器不被别人轻易黑掉的重要知识点，所以必须牢牢掌握。 SSH（22端口）是Secure Shell Protocol的简写，由IETF网络工作小组（Network Working Group）制定；在进行数据传输之前，SSH先对联机数据包通过加密技术进行加密处理，加密后在进行数据传输。确保了传递的数据安全。 SSH是专为远程登录会话和其他网络服务提供的安全性协议。利用SSH协议可以有效的防止远程管理过程中的信息泄露问题，在当前的生产环境运维工作中，绝大多数企业普通采用SSH协议服务来代替传统的不安全的远程联机服务软件，如telnet（23端口，非加密的）等。 相比较于telnet，ssh可以更好的应对中间人攻击，更加安全，所以现在基本都是通过ssh协议去操作服务器的。 SSH远程登录原理1、密码口令登录 这种登录方式说白了就是用户名加密码就可以登录，安全级别低。譬如你在未做任何修改之前，别人便可轻易通过用户名root加密码爆破来登录你的服务器。但是无论如何，自己输的密码是加密之后再传送给服务器的，传输过程中即使被截获，那也不会像telnet一样直接看到密码。 主要流程： 1、客户端连接上服务器之后，服务器把自己的公钥传给客户端 2、客户端输入服务器密码通过公钥加密之后传给服务器 3、服务器根据自己的私钥解密登录密码，如果正确那么就让客户端登录 2、公钥登录密码口令登录 公钥登录的使用相对会比较少，之所以用公钥登录是为了解决安全问题和每次登录服务器都要输入密码的问题，这里比较流行使用RSA加密方案，主要流程包含： 1、客户端生成RSA公钥和私钥 2、客户端将自己的公钥存放到服务器 3、客户端请求连接服务器，服务器将一个随机字符串用公钥加密后发送给客户端 4、客户端根据自己的私钥解密这个随机字符串之后，对随机字符串生成摘要并将摘要发送给服务器 5、服务器对自己生成的随机字符串也生成摘要，然后与客户端发过来的摘要两相对比，若一致则登录成功。 公钥登录： 知识回顾带端口和不带端口ssh远程连接服务器（这里以虚拟机为例，下一章咱们再去腾讯云买服务器玩儿） 12345[C:\~]$ ssh root@192.168.141.12[C:\~]$ ssh root@192.168.141.12 22PS：不带端口时，就是默认采用了22端口 nmcli网络管理命令查看当前网络设备12345[root@localhost ~]# nmcli connection showNAME UUID TYPE DEVICE Wired connection 1 e574440b-5a39-3a2b-a14d-ea6a2d920a7e ethernet ens37 ens33 9c86a9bc-0939-4790-8580-274041e5eff3 ethernet ens33 [root@localhost ~]# 查看指定网络设备的详细信息1[root@localhost ~]# nmcli connection show ens33 给网卡绑定多个配置文件12345678910111213# 给网卡ens33增加一个名为ens60的配置文件[root@localhost ~]# nmcli connection add con-name ens60 ifname ens33 autoconnect no type ethernet ipv4.addresses 192.168.141.200/24 gw4 192.168.141.2Connection &apos;ens60&apos; (8ad23f3d-e490-48a8-bc9f-273ae773435a) successfully added.[root@localhost ~]# nmcli connection showNAME UUID TYPE DEVICE Wired connection 1 e574440b-5a39-3a2b-a14d-ea6a2d920a7e ethernet ens37 ens33 9c86a9bc-0939-4790-8580-274041e5eff3 ethernet ens33 ens60 8ad23f3d-e490-48a8-bc9f-273ae773435a ethernet -- # 启用ens60配置文件[root@localhost ~]# nmcli connection up ens60# 启用了这个配置之后，IP就可以ping通，但ifconfig可能看不到这个配置，同时ens33的ip会变化，xshell会断开，这个先不用着急。 验证： 由于xshell、4已经断开，咱们在直接虚拟机里查看当前网卡ip 可以看到ip 192.168.141.200已经加上去了 那么咱们用nmcli网络管理命令管理网路的配置就到此结束 接下来咱们在虚拟机里重启网络服务，继续下面的实验 12[root@localhost ~]# systemctl restart network[root@localhost ~]# ip add 可以看到原先的ip又回来了，现在又可以用xshell连接192.168.141.12这个ip，接着做下面的实验。 SSH远程访问服务保证Linux服务器开启ssh之后的基本安全，要做到以下四点： 禁止root使用ssh访问远程Linux服务器 禁止使用密码登录ssh服务 使用非对称密钥登录ssh服务 修改ssh服务的默认端口号 解析：1.禁止root使用ssh访问远程Linux服务器 有效防止黑客利用暴力破解工具，在已知用户名root的情况下，轻易将你的root密码破解。 2.禁止使用密码登录ssh服务 即使你禁止了root使用ssh访问远程Linux服务器，但是依然存在这样一种可能：黑客可能通过社交软件了解了一些你的个人信息，了解到你可能用你的英文名或者社交昵称等作为你的服务器用户名，然后暴力破解出你的用户名和密码，黑掉你的服务器。所以用密码登录服务器，始终是不安全的。 3.使用非对称密钥登录ssh服务 不用密码登录，那咱们怎么验证身份呢？这里我们可以采用比密码安全不知道几万倍的非对称密钥登录ssh服务，别人没有你的秘钥，就无法ssh远程操控你的服务器。 4.修改ssh服务的默认端口号​ ssh的默认端口号是22，咱们之前用的命令： 1234[C:\~]$ ssh root@192.168.141.12[C:\~]$ ssh root@192.168.141.12 22PS：不带端口时，就是默认采用了22端口 这两条命令就是通常我们ssh远程访问服务器所使用的命令，许多小白级别的运维人员，用的root加密码123456就可以登录上去，话说就算小白同学多个心眼改一下ssh端口号，黑客也相对没那么容易攻破你的服务器哇！ 步骤：1.新建一个用户组afeng，然后新建一个用户aaa，用来代替root的使用，加入到afeng组，可以使用sudo命令借用root的权限来管理Linux服务器 123456789101112131415161718192021[root@localhost ~]# groupadd afeng[root@localhost ~]# useradd aaa -G afeng [root@localhost ~]# cat /etc/group | grep aaaafeng:x:1000:aaaaaa:x:1001:[root@localhost ~]# [root@localhost ~]# cat /etc/passwd | grep aaaaaa:x:1000:1001::/home/aaa:/bin/bash[root@localhost ~]# 可以看到，用户aaa的UID是1000，GID是1001对应的也就是aaa，所以其主组是aaa从/etc/group下的afeng:x:1000:aaa也可以看出afeng是aaa的附属组设置用户aaa的密码[root@localhost ~]# passwd aaaChanging password for user aaa.New password: BAD PASSWORD: The password is shorter than 8 charactersRetype new password: passwd: all authentication tokens updated successfully.[root@localhost ~]# 2.锁定root用户的密码 12345678[root@localhost ~]# passwd -l rootLocking password for user root.passwd: Success# 查看root用户密码的状态[root@localhost ~]# passwd -S rootroot LK 2018-09-24 0 99999 7 -1 (Password locked.)[root@localhost ~]# 这时候，我们已经可以用普通用户登录到Linux服务器，用sudo su root切换到root用户继续使用root。 可以用xshell另外多开一个会话来验证一下 123456789[C:\~]$ ssh aaa@192.168.141.12Connecting to 192.168.141.12:22...Connection established.To escape to local shell, press &apos;Ctrl+Alt+]&apos;.WARNING! The remote SSH server rejected X11 forwarding request.[aaa@localhost ~]$ 发现咱们现在确实可以登陆上来，接下来验证一下咱们能否用sudo su root切换到root用户继续使用root。 123456789101112[aaa@localhost ~]$ sudo su rootWe trust you have received the usual lecture from the local SystemAdministrator. It usually boils down to these three things: #1) Respect the privacy of others. #2) Think before you type. #3) With great power comes great responsibility.[sudo] password for aaa: aaa is not in the sudoers file. This incident will be reported.[aaa@localhost ~]$ 结果咱们被拒绝了，因为现在aaa用户尚未在sudoers file里。 那咱们回到原来的会话（xshell一个窗口就是一个会话），也就是root登录着的那个会话，先把aaa添加进sudoers file里。 123456[root@localhost ~]# visudo 找到root ALL=(ALL) ALL在上面这一行下面新加一行：aaa ALL=(ALL) ALL保存退出 现在切换回aaa那个会话，再次验证咱们能否用sudo su root切换到root用户继续使用root 12345[aaa@localhost ~]$ sudo su root[sudo] password for aaa: [root@localhost aaa]# 这回可以了 3.设置ssh服务，禁止root使用ssh访问远程Linux服务器，禁止使用密码登录ssh服务器，改变服务端口号为10022 1234567891011121314151617181920212223242526272829303132[root@localhost ~]# vim /etc/ssh/sshd_config 禁止Root使用ssh远程登录38行将#PermitRootLogin yes改成PermitRootLogin no别忘了#号也要去掉，#号是备注的意思开启证书登录的功能43行将 #PubkeyAuthentication yes去掉注释改成PubkeyAuthentication yes禁止使用密码登录ssh服务器65行将PasswordAuthentication yes改为PasswordAuthentication no改变ssh服务端口号17行将#Port 22改成Port 10022保存后退出，重启ssh服务（sshd就是ssh device的意思）[root@localhost ~]# systemctl restart sshd如果这里报错了，那一定是上面/etc/ssh/sshd_config 这个配置文件你哪里写错了 4.向防火墙中添加修改的端口，如果开启了selinux，在修改端口号的时候会失败，我们直接关闭selinux 123456789101112131415161718192021222324252627282930313233[root@localhost ~]# firewall-cmd --zone=public --add-port=10022/tcp --permanent success[root@localhost ~]# firewall-cmd --reload success查看端口是否添加成功:[root@localhost ~]# firewall-cmd --zone=public --query-port=10022/tcpyes[root@localhost ~]# [root@localhost ~]# vim /etc/selinux/config 将SELINUX=enforcing改为SELINUX=disabled检查一下[root@localhost ~]# cat /etc/selinux/config # This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=disabled# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection.SELINUXTYPE=targeted [root@localhost ~]# 5.生成证书： 注意：新的用户需要生成新的密钥来用来登录 1234xshell的新会话中先切换回aaa[root@localhost aaa]# su aaa[aaa@localhost ~]$ ssh-keygen 此处一直敲回车即可 ​ 命令敲完后，系统会自动生成~/.ssh目录，这个目录下会保存Linux的公钥和私钥以及存放客户端公钥的文件.ssh/authorized_keys 6.windows生成客户端公钥： 此处一直点下一步，直到进入如下选项时，我们设一个密钥名称，密码和确认那俩框不用填，点击完成即可 7.将复制的内容写入到Linux系统中我们新建用户aaa的~/.ssh/authorized_keys文件中 1234567[aaa@localhost ~]$ whoamiaaa[aaa@localhost ~]$ vim ~/.ssh/authorized_keys[aaa@localhost ~]$ cat ~/.ssh/authorized_keysssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAurKiTVI2mKJswDThaEYNF/DiBOJZeMTCofxFXw0ZjD0fisnKmLmnBQKEna1NArHFVn42RcwRYM3o5KezSNz9dcj0QB2KB9Rby7N5RBL6WQP5HhhclY5ldHI8AIrMDKtzd+IbZYoMknIXWt0iQ9Z069YmQB4dQlQrq9ZUxEdgz5mhusjoSZxVu2kf14/qhuK28/Mo5NLATvTIbN04D8bXX2Jh9vlhhhK8XCnvyuIxV2lNvfU5K88CgM+utOAvELjKhsiMlmrhvNs4kh5o3JSpmIyJfayFpnLvdrGn9w6u1ndzoTE29oTCUKllwD3BZRqPmdVGDF+koBLzipNMCjk21w== rsa 2048-013019[aaa@localhost ~]$ chmod 600 ~/.ssh/authorized_keys[aaa@localhost ~]$ 8.重启sshd服务，让ssh配置生效（改/etc/sshd/目录下的文件需要重新服务，添加删除用户密钥并不需要重启sshd服务） 12345[root@localhost ssh]# systemctl restart sshd[root@localhost ssh]# netstat -ntlp | grep 10022tcp 0 0 0.0.0.0:10022 0.0.0.0:* LISTEN 6110/sshd tcp6 0 0 :::10022 :::* LISTEN 6110/sshd [root@localhost ssh]# 9.用xshell远程登录Linux服务器 用户aaa成功登录啦！ 情况一：现在假设黑客猜到了你的ssh端口号是10022，又把你的密钥也搞到了手，现在他尝试用root用户登录 1[C:\~]$ ssh root@192.168.141.12 10022 结果如下图，黑客登录失败，失败的原因就是我们拒绝了root登录 情况二：假设黑客搞到了你的用户名aaa和ssh端口号10022，但是服务器是拒绝用密码登陆的，也就是他没法爆破，只能用密钥登录，可惜他没有你的aaa用户的密钥feng_system，所以也登录不上 情况三：这是99.99%的情况 别人不知道你的端口号，也不知道你的用户名，更没有你的用户密钥，所以服务器很安全。但是服务器ip很容易就会被知道，ping一下咱网站域名就可以看到服务器ip了，比如ping一下我的个人博客https://xiaoxingzone.coding.me/如下图 黑客仅仅知道你的服务器ip的话，是无法ssh远程控制你的服务器的。但是黑客可以搞一个低轨道粒子炮之类的工具，对你的服务器一直轰炸，或者搞一些其他的攻击方式，让你的服务器很难受，这就涉及到网络安全方面的知识了。 ​ 此外，我们后续章节中还会介绍如何禁止别人ping咱们的服务器。 另外，HEXO个人博客利用coding和github开源仓库搭建，并没有搭建在我自己的服务器上，所以无需多虑。关于ssh的配置后面我们会在运维实战章节再次用到。 不间断会话服务（虚拟终端） 因为在执行一些脚本的时候，可能要使用的时间很长，而我们电脑可能不会开那么久的终端软件，那么这时候，就要有一个虚拟的终端来帮助我们执行长时间的任务 安装screen 1234[aaa@localhost ~]$ sudo su root[sudo] password for aaa: [root@localhost aaa]# [root@localhost aaa]# yum install screen -y 新建一个终端任务 1234[root@localhost ~]# screen -S lnmp回车之后进入到新的终端开始一个任务[root@localhost aaa]# wget http://soft.vpser.net/lnmp/lnmp1.5.tar.gz -cO lnmp1.5.tar.gz &amp;&amp; tar zxf lnmp1.5.tar.gz &amp;&amp; cd lnmp1.5 &amp;&amp; ./install.sh lnmp 如果任务没有执行完，我们需要关闭终端，可以直接关掉终端（千万不要用CTRL+Z或者CTRL+C），也可以用ctrl+a，松开a再按一下d（ctrl不要放开）临时退出虚拟终端 恢复最近的一个终端，用screen -r命令 1[root@localhost aaa]# screen -r 如果有多个虚拟终端，我们可以使用命令查看后台运行的虚拟终端 123456[root@localhost aaa]# screen -listThere is a screen on: 6327.lnmp (Detached)1 Socket in /var/run/screen/S-root.[root@localhost aaa]# 要恢复指定的虚拟终端 1[root@localhost aaa]# screen -r lnmp 退出虚拟终端的话，进入虚拟中断（ctrl+c）之后用exit退出就行啦 1[root@localhost lnmp1.5]# exit 虚拟终端这个不好演示，截图的话也没啥意义，上面的命令行足矣 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-13 iptables与firewalld防火墙]]></title>
    <url>%2Flinux-13%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-13 iptables与firewalld防火墙iptablesiptables是centos6以及之前版本的默认防火墙工具，在centos7中默认防火墙工具已经替换为firewalld。 区别iptables防火墙的底层是netfiter firewalld防火墙的底层是iptables 注意：iptables和firewalld是冲突的，同时只能使用一个防火墙 netfilter模块 在centos6上，我们用的是iptables服务，而在centos7上，我们用的是firewalld服务。同样的，centos6上安装的是iptables包，而centos7上安装的是firewalld包。不管是centos6还是centos7，核心其实都是netfilter，netfilter是linux的一个内核模块，iptables命令是linux内核自带的。centos6上的iptables服务和centos7上的firewalld服务，其实都是用来定义防火墙规则功能的防火墙管理工具。它们都是将定义好的规则交由内核中的netfilter即网络过滤器来读取，从而真正实现防火墙功能，所以其实在配置规则的思路上是完全一致的。 Iptables的Forward链、Input链和Output链Input链 如果数据包的目的地址是本机，则系统将数据包送往Input链。如果通过规则检查，则该包被发给相应的本地进程处理；如果没有通过规则检查，系统就会将这个包丢掉。 Forward链 如果数据包的目的地址不是本机，也就是说，这个包将被转发，则系统将数据包送往Forward链。如果通过规则检查，则该包被发给相应的本地进程处理;如果没有通过规则检查，系统就会将这个包丢掉。 Output链 如果数据包是由本地系统进程产生的，则系统将其送往Output链。如果通过规则检查，则该包被发给相应的本地进程处理；如果没有通过规则检查，系统就会将这个包丢掉。 区别 input只对要访问本机的包有效，forward只对不是访问本机，但是要通过这台机器转发的包有效，制定规则的时候有个原则就是放行的要先放在前面, 禁止的要放在最后。 在centos7中开启iptables的使用12345678910# 禁用firewalld防火墙[root@localhost ~]# systemctl stop firewalld.service [root@localhost ~]# systemctl mask firewalld.service Created symlink from /etc/systemd/system/firewalld.service to /dev/null. # 安装iptables 服务[root@localhost ~]# yum install iptables-services -y # 开启iptables服务[root@localhost ~]# systemctl start iptables 注意：systemctl mask firewalld.service 是注销firewalld服务的意思。 注销服务意味着： 1）该服务在系统重启的时候不会启动 2）该服务无法进行做systemctl start/stop/restart操作 3）该服务无法进行systemctl enable/disable操作 取消firewalld的注销状态：systemctl unmask firewalld iptables命令的基本参数 参数 作用 -P 设置默认策略 -F 清空规则链 -L 查看规则链 -A 在规则链的末尾加入新规则 -I num 在规则链的头部加入新规则 -D num 删除某一条规则 -s 匹配来源地址IP/MASK，加叹号“!”表示除这个IP外 -d 匹配目标地址 -i网卡名称 匹配从这块网卡流入的数据 -o网卡名称 匹配从这块网卡流出的数据 -p 匹配协议，如TCP、UDP、ICMP –dport num 匹配目标端口号 使用iptables123456789101112131415161718192021222324252627282930# 清除iptables中所有的规则[root@localhost ~]# iptables -F # 查看iptables防火墙中所有的规则[root@localhost ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination Chain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination [root@localhost ~]# iptables -P INPUT DROP #默认INPUT全部允许 禁止所有人ping服务器[root@localhost ~]# iptables -I INPUT -p icmp -j DROP [root@localhost ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination DROP icmp -- anywhere anywhere Chain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination # 这个是服务器接收到icmp的包之后丢弃 接下来在宰门物理机上验证能否ping通虚拟机： 1C:\Users\zhong&gt;ping 192.168.141.12 结果是ping不通 接下来咱们删掉丢失包的规则，也就是刚刚咱们创建的那条禁止ping的规则 12[root@localhost ~]# iptables -D INPUT 1[root@localhost ~]# 现在又可以ping通了 接下来咱们创建一条拒绝ping的规则 123456789101112[root@localhost ~]# iptables -I INPUT -p icmp -j REJECT [root@localhost ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination REJECT icmp -- anywhere anywhere reject-with icmp-port-unreachableChain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination [root@localhost ~]# 现在再用物理机来ping虚拟机： 1C:\Users\zhong&gt;ping 192.168.141.12 显示不可达。 查看iptables中的防火墙规则1234567891011[root@localhost ~]# iptables -L -n --line-numbers Chain INPUT (policy ACCEPT)num target prot opt source destination 1 REJECT icmp -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-port-unreachableChain FORWARD (policy ACCEPT)num target prot opt source destination Chain OUTPUT (policy ACCEPT)num target prot opt source destination [root@localhost ~]# 可以看到，拒绝ping的那条规则的规则号是1（ping是属于icmp协议的），待会咱们把这条规则删掉 删除规则1iptables -D [INPUT | OUTPUT | FORWARD] 规则号 删除input表中的第一个规则 1234567891011[root@localhost ~]# iptables -D INPUT 1[root@localhost ~]# iptables -L -n --line-numbers Chain INPUT (policy ACCEPT)num target prot opt source destination Chain FORWARD (policy ACCEPT)num target prot opt source destination Chain OUTPUT (policy ACCEPT)num target prot opt source destination [root@localhost ~]# 可以看到那条规则以及删除了 于是物理机又可以ping通虚拟机了 添加规则iptables -I 插入一条规则，默认加在最前面（注意别看错了，这是字母i的大写） iptables -A增加一条规则，默认增加在最后 举例：注意下面我的虚拟机和物理机的VM网卡是192.168.141网段的，不同电脑网段可能不同 1234567891011121314151617181920212223[root@localhost ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination Chain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination [root@localhost ~]# iptables -A INPUT -s 192.168.141.0/24 -p tcp --dport 22 -j ACCEPT[root@localhost ~]# iptables -A INPUT -p tcp --dport 22 -j REJECT [root@localhost ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination ACCEPT tcp -- 192.168.141.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachableChain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination [root@localhost ~]# 如果现在要增加一条规则，使172.25.0.0/24这个网段允许访问本机的22端口，那么不能使用-A参数增加，只能使用 -I 插入规则 iptables -I INPUT 2 -s 172.25.0.0/24 -p tcp –dport 22 -j ACCEPT 中，INPUT 2表示插入的是Chain INPUT 的规则号为2的规则 12345678910111213141516171819202122232425[root@localhost ~]# iptables -L -n --line-numbers Chain INPUT (policy ACCEPT)num target prot opt source destination 1 ACCEPT tcp -- 192.168.141.0/24 0.0.0.0/0 tcp dpt:222 REJECT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:22 reject-with icmp-port-unreachableChain FORWARD (policy ACCEPT)num target prot opt source destination Chain OUTPUT (policy ACCEPT)num target prot opt source destination [root@localhost ~]# iptables -I INPUT 2 -s 172.25.0.0/24 -p tcp --dport 22 -j ACCEPT [root@localhost ~]# iptables -L -n --line-numbers Chain INPUT (policy ACCEPT)num target prot opt source destination 1 ACCEPT tcp -- 192.168.141.0/24 0.0.0.0/0 tcp dpt:222 ACCEPT tcp -- 172.25.0.0/24 0.0.0.0/0 tcp dpt:223 REJECT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:22 reject-with icmp-port-unreachableChain FORWARD (policy ACCEPT)num target prot opt source destination Chain OUTPUT (policy ACCEPT)num target prot opt source destination [root@localhost ~]# 保存防火墙状态12345678910111213141516[root@localhost ~]# service iptables saveiptables: Saving firewall rules to /etc/sysconfig/iptables:[ OK ]# 防火墙保存了之后，在/etc/sysconfig/iptables文件中就会出现相应的规则[root@localhost ~]# cat /etc/sysconfig/iptables# Generated by iptables-save v1.4.21 on Thu Jan 24 23:42:17 2019*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [30:3540]-A INPUT -s 192.168.141.0/24 -p tcp -m tcp --dport 22 -j ACCEPT-A INPUT -s 172.25.0.0/24 -p tcp -m tcp --dport 22 -j ACCEPT-A INPUT -p tcp -m tcp --dport 22 -j REJECT --reject-with icmp-port-unreachableCOMMIT# Completed on Thu Jan 24 23:42:17 2019[root@localhost ~]# 保存出错时的解决方案如果保存命令执行失败报出： 1The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl. 解决方案： 1234567systemctl stop firewalld 关闭防火墙yum install iptables-services 安装或更新服务再使用systemctl enable iptables 启动iptables最后 systemctl start iptables 打开iptables再执行service iptables save 重启iptables服务service iptables restart 执行完毕之后/etc/syscofig/iptables文件就有规则了 firewalld firewalls是centos7的默认防火墙，安装完centos7 默认开启，默认开放22端口（所以用xshell的ssh能连上）和dhcpv6-client端口 开启firewalld防火墙 1234567[root@localhost ~]# systemctl stop iptables.service [root@localhost ~]# systemctl mask iptables.service Created symlink from /etc/systemd/system/iptables.service to /dev/null.[root@localhost ~]# systemctl unmask firewalld.service Removed symlink /etc/systemd/system/firewalld.service.[root@localhost ~]# systemctl restart firewalld.service [root@localhost ~]# 如果你之前没有启动iptables是不需要做上面的操作的，直接systemctl restart firewalld.service 即可。 防火墙一般只关心进来的流量，不关心出去的流量。 注意：出去之后再回来的流量定义为出去的流量 九大区域firewalld防火墙默认定义了9大区域： drop：除非与传出流量相关，否则拒绝所有传入流量（不产生包含ICMP的错误响应） block：除非与传出流量相关，否则拒绝所有传入流量。 dmz：除非与传出流量相关或者与ssh预定义服务匹配，否则拒绝传入流量 external：除非与传出流量相关或者与ssh预定义服务匹配，否则拒绝传入流量。通过此区域转发的IPv4传出流量将进行伪装，使其看起来像传出网络接口的IPv4地址而不是主机的源IP internel：初始状态与home相同 home：除非与传出流量相关或者与ssh、mdns、ipp-client、dhcpv6-client、samba-client预定义服务匹配，否则拒绝传入流量 work：除非与传出流量相关或者与ssh、ipp-client、dhcpv6-client预定义的服务匹配，否则拒绝传入流量。此区域为网络接口的默认区域 public：除非与传出流量相关或者与ssh、dhcpv6-client预定义的服务匹配，否则拒绝传入流量。此区域为网络接口的默认区域 trusted：允许所有流量传入 配置firewalld防火墙的三种方法： 使用图形工具firwalld-config 使用命令行工具firewalld-cmd 查看区域中的规则查看public区域中的所有信息 12345678910111213141516[root@localhost ~]# firewall-cmd --list-all --zone=publicpublic (active) target: default icmp-block-inversion: no interfaces: ens33 ens37 sources: services: ssh dhcpv6-client #可以看到这里默认只放行ssh和dhcpv6-client ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@localhost ~]# 允许访问本机的http服务第一种方法：添加服务名允许访问，要求http服务使用默认端口80，不然规则无效 123456789101112131415161718[root@localhost ~]# yum install httpd -y[root@localhost ~]# systemctl restart httpd[root@localhost ~]# firewall-cmd --add-service=httpsuccess[root@localhost ~]# firewall-cmd --list-allpublic (active)target: defaulticmp-block-inversion: nointerfaces: ens33 ens37sources: services: ssh dhcpv6-client http #可以看到这里除了默认放行的ssh和dhcpv6-client，多了个httpports: protocols: masquerade: noforward-ports: source-ports: icmp-blocks: rich rules: 第二种方法：放行端口号80（http协议对应端口号为80） 1234567891011121314151617181920212223242526272829303132333435[root@localhost ~]# firewall-cmd --remove-service=http #先把上面放行的http移除掉success[root@localhost ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 ens37 sources: services: ssh dhcpv6-client ports: #可以看到本来没有通过端口号放行的协议 protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@localhost ~]# firewall-cmd --add-port=80/tcpsuccess[root@localhost ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 ens37 sources: services: ssh dhcpv6-client ports: 80/tcp #可以看到现在多了个放行的使用80端口号的http协议 protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@localhost ~]# 保存已经设置的规则 防火墙使用firewall-cmd添加实时生效的规则之后，重启Linux系统或者重启防火墙服务之后，运行时修改的规则都会丢失，如果要保存规则，有以下几种方式： 方式1.在规则后面添加 –permanent，这时这条命令不会实时生效，但会把规则号添加到配置文件中 12[root@localhost ~]# firewall-cmd --add-port=8080/tcp --permanent success 这条命令敲完后，我们查看防火墙规则，发现并没有实时生效 12345678910111213141516[root@localhost ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 ens37 sources: services: ssh dhcpv6-client ports: 80/tcp protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@localhost ~]# 让其生效的三种方法 12345678910111213141516171819202122[root@localhost ~]# firewall-cmd --reload success[root@localhost ~]# systemctl restart firewalld.service [root@localhost ~]# firewall-cmd --add-port=8080/tcp验证：[root@localhost ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 ens37 sources: services: ssh dhcpv6-client ports: 8080/tcp protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@localhost ~]# 方式2.让runtime时配置的规则永久保存 12345678910111213141516171819202122232425262728[root@localhost ~]# firewall-cmd --add-port=10000/tcpsuccess[root@localhost ~]# firewall-cmd --add-port=10001/tcpsuccess[root@localhost ~]# firewall-cmd --add-port=10086/tcpsuccess# 下面的命令可以将上面的规则在运行时永久保存到防火墙配置中[root@localhost ~]# firewall-cmd --runtime-to-permanentsuccess验证：[root@localhost ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 ens37 sources: services: ssh dhcpv6-client ports: 8080/tcp 10000/tcp 10001/tcp 10086/tcp protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@localhost ~]# 富规则拒绝所有172.25.0.0/24网段的ip访问本机的ssh服务 123456789101112131415161718[root@localhost ~]# firewall-cmd --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;172.25.0.0/24&quot; service name=&quot;ssh&quot; reject&quot;success[root@localhost ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 ens37 sources: services: ssh dhcpv6-client ports: 8080/tcp 10000/tcp 10001/tcp 10086/tcp protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: rule family=&quot;ipv4&quot; source address=&quot;172.25.0.0/24&quot; service name=&quot;ssh&quot; reject[root@localhost ~]# TCP Wrapper应用层流量控制工具 TCP Wrappers是RHEL 7系统中默认启用的一款流量控制程序，它能够根据来访主机的地址与本机的目标服务程序作出允许或拒绝的操作。 系统将会先检查允许控制列表文件（/etc/hosts.allow），如果匹配到相应的允许策略则放行流量；如果没有匹配，则去进一步匹配拒绝控制列表文件（/etc/hosts.deny），若找到匹配项则拒绝该流量。如果这两个文件全都没有匹配到，则默认放行流量。 在配置TCP Wrappers服务时需要遵循两个原则： 编写拒绝策略规则时，填写的是服务名称，而非协议名称； 建议先编写拒绝策略规则，再编写允许策略规则，以便直观地看到相应的效果。 格式为： 服务名:规则 规则 客户端类型 示例 满足示例的客户端列表 单一主机 192.168.10.10 IP地址为192.168.10.10的主机 指定网段 192.168.10. IP段为192.168.10.0/24的主机 指定网段 192.168.10.0/255.255.255.0 IP段为192.168.10.0/24的主机 指定DNS后缀 .aaa.com 所有DNS后缀为.aaa.com的主机 指定主机名称 www.aaa.com 主机名称为www.aaa.com的主机 指定所有客户端 ALL 所有主机全部包括在内 利用tcp wrapper控制应用层数据的流量 123456789101112131415161718192021222324252627282930313233[root@localhost ~]# systemctl stop firewalld[root@localhost ~]# vim /etc/hosts.allow 1 # 2 # hosts.allow This file contains access rules which are used to 3 # allow or deny connections to network services that 4 # either use the tcp_wrappers library or that have been 5 # started through a tcp_wrappers-enabled xinetd. 6 # 7 # See &apos;man 5 hosts_options&apos; and &apos;man 5 hosts_access&apos; 8 # for information on rule syntax. 9 # See &apos;man tcpd&apos; for information on tcp_wrappers 10 # 在最后一行添加： 11 sshd:192.168.9. 172.25.0.1 表示上述两个网段的用户使用本虚拟机的sshd服务 [root@localhost ~]# vim /etc/hosts.deny 1 # 2 # hosts.deny This file contains access rules which are used to 3 # deny connections to network services that either use 4 # the tcp_wrappers library or that have been 5 # started through a tcp_wrappers-enabled xinetd. 6 # 7 # The rules in this file can also be set up in 8 # /etc/hosts.allow with a &apos;deny&apos; option instead. 9 # 10 # See &apos;man 5 hosts_options&apos; and &apos;man 5 hosts_access&apos; 11 # for information on rule syntax. 12 # See &apos;man tcpd&apos; for information on tcp_wrappers 13 # 在最后一行添加： 14 sshd:ALL 表示拒绝所有网段的用户使用sshd服务 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-12 RAID和LVM]]></title>
    <url>%2Flinux-12%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-12 RAID和LVMRAID RAID是英文Redundant Array of Independent Disks的缩写，中文简称为独立冗余磁盘阵列。简单的说，RAID是一种把多块独立的硬盘（物理硬盘）按不同的方式组合起来形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据备份技术。 ​ 组成磁盘阵列的不同方式称为RAID级别（RAID Levels）。在用户看起来，组成的磁盘组就像是一个硬盘，用户可以对它进行分区，格式化等等。总之，对磁盘阵列的操作与单个硬盘一模一样。不同的是，磁盘阵列的存储速度要比单个硬盘高很多，而且可以提供自动数据备份。数据备份的功能是在用户数据一旦发生损坏后，利用备份信息可以使损坏数据得以恢复，从而保障了用户数据的安全性。 RAID分类​ RAID技术经过不断的发展，现在已拥有了从 RAID 0 到 7 八种基本的RAID 级别。另外，还有一些基本RAID级别的组合形式，如RAID 10（RAID 0与RAID 1的组合），RAID 50（RAID 0与RAID 5的组合）等。不同RAID 级别代表着不同的存储性能、数据安全性和存储成本。但我们最为常用的是下面的几种RAID形式。 RAID级别的选择有三个主要因素：可用性（数据冗余）、性能和成本。如果不要求可用性，选择RAID0以获得最佳性能。如果可用性和性能是重要的而成本不是一个主要因素，则根据硬盘数量选择RAID 1。如果可用性、成本和性能都同样重要，则根据一般的数据传输和硬盘的数量选择RAID3、RAID5。 下面以几张图来举例 RAID0 RAID1 RAID5 RAID10（不是读作十，而是一零） 部署磁盘阵列mdadm用于管理Linux系统中的软件RAID硬盘阵列，格式为 1mdadm [模式] &lt;RAID设备名称&gt; [选项] [成员设备名称] 安装Linux 软阵列管理工具mdadm 1[root@localhost ~]# yum install mdadm -y 题目：添加4块20G的硬盘，将硬盘用工具组合成软RAID10（上面有图RAID10） 生成磁盘阵列 参数 作用 -a 检测设备名称 -n 指定设备数量 -l 指定RAID级别 -C 创建 -v 显示过程 -f 模拟设备损坏 -r 移除设备 -Q 查看摘要信息 -D 查看详细信息 -S 停止RAID磁盘阵列 -x 指定备份盘数量 首先用fdisk -l查看系统中的磁盘信息 生成磁盘阵列123456789[root@localhost ~]# mdadm -Cv /dev/md0 -a yes -n 4 -l 10 /dev/sd&#123;b,c,d,e&#125;mdadm: layout defaults to n2mdadm: layout defaults to n2mdadm: chunk size defaults to 512Kmdadm: size set to 20954112Kmdadm: Fail create md0 when using /sys/module/md_mod/parameters/new_arraymdadm: Defaulting to version 1.2 metadatamdadm: array /dev/md0 started.[root@localhost ~]# 查看阵列信息1234567891011121314151617181920212223242526272829303132333435[root@localhost ~]# mdadm -D /dev/md0 /dev/md0: Version : 1.2 Creation Time : Thu Jan 24 21:29:53 2019 Raid Level : raid10 Array Size : 41908224 (39.97 GiB 42.91 GB) Used Dev Size : 20954112 (19.98 GiB 21.46 GB) Raid Devices : 4 Total Devices : 4 Persistence : Superblock is persistent Update Time : Thu Jan 24 21:30:20 2019 State : clean, resyncing Active Devices : 4 Working Devices : 4 Failed Devices : 0 Spare Devices : 0 Layout : near=2 Chunk Size : 512KConsistency Policy : resync Resync Status : 17% complete Name : localhost.localdomain:0 (local to host localhost.localdomain) UUID : 681083d9:0b891154:c4a4358f:3511a208 Events : 2 Number Major Minor RaidDevice State 0 8 16 0 active sync set-A /dev/sdb 1 8 32 1 active sync set-B /dev/sdc 2 8 48 2 active sync set-A /dev/sdd 3 8 64 3 active sync set-B /dev/sde[root@localhost ~]# 使用磁盘阵列使用制作出来的md0，将磁盘分出一个5G大小的分区，格式化为xfs，挂载到/mnt/raid使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344[root@localhost ~]# mkdir /mnt/raid[root@localhost ~]# fdisk /dev/md0Welcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Device does not contain a recognized partition tableBuilding a new DOS disklabel with disk identifier 0x48492670.Command (m for help): nPartition type: p primary (0 primary, 0 extended, 4 free) e extendedSelect (default p): pPartition number (1-4, default 1): First sector (2048-83816447, default 2048): Using default value 2048Last sector, +sectors or +size&#123;K,M,G&#125; (2048-83816447, default 83816447): +5GPartition 1 of type Linux and of size 5 GiB is setCommand (m for help): pDisk /dev/md0: 42.9 GB, 42914021376 bytes, 83816448 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 524288 bytes / 1048576 bytesDisk label type: dosDisk identifier: 0x48492670 Device Boot Start End Blocks Id System/dev/md0p1 2048 10487807 5242880 83 LinuxCommand (m for help): wThe partition table has been altered!Calling ioctl() to re-read partition table.Syncing disks.[root@localhost ~]# partprobe Warning: Unable to open /dev/sr0 read-write (Read-only file system). /dev/sr0 has been opened read-only.[root@localhost ~]# mount /dev/md0p1 /mnt/raid/mount: /dev/md0p1 is write-protected, mounting read-onlymount: unknown filesystem type &apos;(null)&apos;[root@localhost ~]# 损坏磁盘阵列及修复12345678[root@localhost ~]# mdadm /dev/md0 -f /dev/sdb…………[root@localhost ~]# mdadm -D /dev/md0…………[root@localhost ~]# umount /raid[root@localhost ~]# mount –a[root@localhost ~]# df –h………… 停止磁盘阵列umount卸载已经挂载的分区，用fdisk删除阵列硬盘上的分区 12345[root@localhost ~]# mdadm -S /dev/md0mdadm: stopped /dev/md0[root@localhost ~]# partprobe Warning: Unable to open /dev/sr0 read-write (Read-only file system). /dev/sr0 has been opened read-only.[root@localhost ~]# LVM​ LVM是 Logical Volume Manager（逻辑卷管理）的简写，它是Linux环境下对磁盘分区进行管理的一种机制，它由Heinz Mauelshagen在Linux 2.4内核上实现，目前最新版本为：稳定版1.0.5，开发版 1.1.0-rc2，以及LVM2开发版。Linux用户安装Linux操作系统时遇到的一个常见的难以决定的问题就是如何正确地评估各分区大小，以分配合适的硬盘空间。普通的磁盘分区管理方式在逻辑分区划分好之后就无法改变其大小，当一个逻辑分区存放不下某个文件时，这个文件因为受上层文件系统的限制，也不能跨越多个分区来存放，所以也不能同时放到别的磁盘上。而遇到出现某个分区空间耗尽时，解决的方法通常是使用符号链接，或者使用调整分区大小的工具，但这只是暂时解决办法，没有从根本上解决问题。随着Linux的逻辑卷管理功能的出现，这些问题都迎刃而解，用户在无需停机的情况下可以方便地调整各个分区大小。 什么是逻辑卷管理器？ LVM 是逻辑盘卷管理（Logical Volume Manager）的简称，它是 Linux 环境下对卷进行方便操作的抽象层。 LVM 是建立在硬盘和分区之上的一个逻辑层，来为文件系统屏蔽下层磁盘分区布局，从而提高磁盘分区管理的灵活性。 LVM允许在多个物理设备间重新组织文件系统，包括重新设定文件系统的大小。 概念区分PV（物理卷）： 物理卷(physical volume, PV)在 LVM 系统中处于最底层 物理卷可以是整个硬盘、硬盘上的分区或从逻辑上与磁盘分区具有同样功能的设备（如：RAID） 物理卷是 LVM 的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有与 LVM 相关的管理参数 VG（卷组）： 卷组(Volume Group, VG)建立在物理卷之上，它由一个或多个物理卷组成 卷组创建之后，可以动态添加物理卷到卷组中，在卷组上可以创建一个或多个“LVM 分区”（逻辑卷） 一个 LVM 系统中可以只有一个卷组，也可以包含多个卷组 LVM 的卷组类似于非LVM系统中的物理硬盘 LV（逻辑卷）： 逻辑卷(Logical Volume, LV)建立在卷组之上，它是从卷组中“切出”的一块空间 逻辑卷创建之后，其大小可以伸缩 LVM 的逻辑卷类似于非 LVM 系统中的硬盘分区，在逻辑卷之上可以建立文件系统 （比如 /home 或者 /usr 等） 创建逻辑卷过程添加一块20G和一块10G的硬盘（物理卷大小不需要一样，没有硬性要求） 物理卷操作将两块硬盘变为物理卷 1234[root@localhost ~]# pvcreate /dev/sd&#123;b,c&#125; Physical volume &quot;/dev/sdb&quot; successfully created. Physical volume &quot;/dev/sdc&quot; successfully created.[root@localhost ~]# 查看系统中的物理卷 12345[root@localhost ~]# pvs PV VG Fmt Attr PSize PFree /dev/sda2 centos lvm2 a-- &lt;19.00g 0 /dev/sdb lvm2 --- 10.00g 10.00g /dev/sdc lvm2 --- 20.00g 20.00g 扫描系统中的物理卷 12345[root@localhost ~]# pvscan PV /dev/sda2 VG centos lvm2 [&lt;19.00 GiB / 0 free] PV /dev/sdb lvm2 [10.00 GiB] PV /dev/sdc lvm2 [20.00 GiB] Total: 3 [&lt;49.00 GiB] / in use: 1 [&lt;19.00 GiB] / in no VG: 2 [30.00 GiB] 查看物理卷详细信息 1234567891011121314[root@localhost ~]# pvdisplay /dev/sdb &quot;/dev/sdb&quot; is a new physical volume of &quot;10.00 GiB&quot; --- NEW Physical volume --- PV Name /dev/sdb VG Name PV Size 10.00 GiB Allocatable NO PE Size 0 Total PE 0 Free PE 0 Allocated PE 0 PV UUID R1Tcud-WHmk-JfIV-0Zh3-0bg3-enz0-SK81CJ [root@localhost ~]# pvdisplay后面不加某一块物理卷，那么显示的就是系统中所有的物理卷的详细信息 卷组操作创建卷组aaa，将两个物理卷加入到卷组里 123[root@localhost ~]# vgcreate aaa /dev/sd&#123;b,c&#125; Volume group &quot;aaa&quot; successfully created[root@localhost ~]# 查看系统中卷组用命令vgs，扫描用vgscan，查看详细信息用vgdisplay，用法和pv那套命令一样 1234567891011121314151617181920212223[root@localhost ~]# vgdisplay aaa --- Volume group --- VG Name aaa System ID Format lvm2 Metadata Areas 2 Metadata Sequence No 1 VG Access read/write VG Status resizable MAX LV 0 Cur LV 0 Open LV 0 Max PV 0 Cur PV 2 Act PV 2 VG Size 29.99 GiB PE Size 4.00 MiB Total PE 7678 Alloc PE / Size 0 / 0 Free PE / Size 7678 / 29.99 GiB VG UUID sIRezl-w3K2-9o2i-wDjV-szxH-7mbY-5RW0jW [root@localhost ~]# 逻辑卷操作创建一个逻辑卷system，大小为1G，要求指定大小的时候使用基本单元 123456789101112131415161718192021[root@localhost ~]# lvcreate -n system -l 250 aaa Logical volume &quot;system&quot; created.[root@localhost ~]# lvdisplay /dev/aaa/system --- Logical volume --- LV Path /dev/aaa/system LV Name system VG Name aaa LV UUID Qnfuv6-a0lS-WRy6-s0Uo-4pFS-Y1yf-y4Jd9v LV Write Access read/write LV Creation host, time localhost.localdomain, 2019-01-24 21:52:17 -0500 LV Status available # open 0 LV Size 1000.00 MiB Current LE 250 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:2 [root@localhost ~]# 创建逻辑卷network，大小为3G，不需要用基本单元指定大小 123456789101112131415161718192021[root@localhost ~]# lvcreate -n network -L 3G aaa Logical volume &quot;network&quot; created.[root@localhost ~]# lvdisplay /dev/aaa/network --- Logical volume --- LV Path /dev/aaa/network LV Name network VG Name aaa LV UUID pga3dS-2S08-dit2-2Wm1-ZA7x-OPa8-tLxUtr LV Write Access read/write LV Creation host, time localhost.localdomain, 2019-01-24 21:54:51 -0500 LV Status available # open 0 LV Size 3.00 GiB Current LE 768 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:3 [root@localhost ~]# 将system格式化为xfs，挂载到/mnt/aaa_system 12345678910111213141516171819202122232425[root@localhost ~]# mkfs.xfs /dev/aaa/system meta-data=/dev/aaa/system isize=512 agcount=4, agsize=64000 blks = sectsz=512 attr=2, projid32bit=1 = crc=1 finobt=0, sparse=0data = bsize=4096 blocks=256000, imaxpct=25 = sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=1log =internal log bsize=4096 blocks=855, version=2 = sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0[root@localhost ~]# partprobe Warning: Unable to open /dev/sr0 read-write (Read-only file system). /dev/sr0 has been opened read-only.[root@localhost ~]# mkdir /mnt/aaa_system[root@localhost ~]# mount /dev/aaa/system /mnt/aaa_system/[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/centos-root 17G 1.3G 16G 8% /devtmpfs 476M 0 476M 0% /devtmpfs 488M 0 488M 0% /dev/shmtmpfs 488M 7.7M 480M 2% /runtmpfs 488M 0 488M 0% /sys/fs/cgroup/dev/sda1 1014M 130M 885M 13% /boottmpfs 98M 0 98M 0% /run/user/0/dev/mapper/aaa-system 997M 33M 965M 4% /mnt/aaa_system[root@localhost ~]# 逻辑卷在系统中的两种表示方式第一种：/dev/[卷组名]/[逻辑卷] 12[root@localhost ~]# ll /dev/aaa/system lrwxrwxrwx. 1 root root 7 Jan 24 21:55 /dev/aaa/system -&gt; ../dm-2 第二种：/dev/mapper/[卷组名]-[逻辑卷] 123[root@localhost ~]# ll /dev/mapper/aaa-system lrwxrwxrwx. 1 root root 7 Jan 24 21:55 /dev/mapper/aaa-system -&gt; ../dm-2[root@localhost ~]# 逻辑卷扩容 发现system只有1G大小远远不够用，至少要有5G的空间才够用，所以要将system扩容到5G 12345[root@localhost ~]# umount /mnt/aaa_system[root@localhost ~]# e2fsck -f /dev/aaa/system [root@localhost ~]# lvextend -L 10G /dev/aaa/system[root@localhost ~]# resize2fs /dev/aaa/system[root@localhost ~]# mount /dev/aaa/system /mnt/aaa_system 逻辑卷快照相当于是磁盘的备份 123456789101112131415[root@localhost ~]# echo &quot;helloworld&quot; &gt; /mnt/aaa_system/hello.txt创建快照：[root@localhost ~]# lvcreate -L 10G -s -n SNAP /dev/aaa/system Reducing COW size 10.00 GiB down to maximum usable size 1004.00 MiB. Logical volume &quot;SNAP&quot; created.[root@localhost ~]# lvdisplay ......[root@localhost ~]# rm -f /mnt/aaa_system/hello.txt [root@localhost ~]# 还原快照：[root@localhost ~]# umount /mnt/eagle_system[root@localhost ~]# lvconvert --merge /dev/eagleslab/SNAP 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-11 存储结构与磁盘划分]]></title>
    <url>%2Flinux-11%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-11 存储结构与磁盘划分Linux文件结构 Linux 文件系统是一个目录树的结构，文件系统结构从一个根目录开始，根目录下可以有任意多个文件和子目录，子目录中又可以有任意多个文件和子目录。Linux 的这种文件系统结构使得一个目录和它包含的文件/子目录之间形成一种层次关系。 物理设备的命名规则 硬件设备 文件名称 IDE设备 /dev/hd[a-d] SCSI/SATA/U盘 /dev/sd[a-p] 软驱 /dev/fd[0-1] 打印机 /dev/lp[0-15] 光驱 /dev/cdrom 鼠标 /dev/mouse 磁带机 /dev/st0或/dev/ht0 主分区或扩展分区的编号从1开始，到4结束； •逻辑分区从编号5开始。 文件系统Ext3​ 一款日志文件系统，能够在系统异常宕机时避免文件系统资料丢失，并能自动修复数据的不一致与错误。然而，当硬盘容量较大时，所需的修复时间也会很长，而且也不能百分之百地保证资料不会丢失。它会把整个磁盘的每个写入动作的细节都预先记录下来，以便在发生异常宕机后能回溯追踪到被中断的部分，然后尝试进行修复。 Ext4​ Ext3的改进版本，作为RHEL 6系统中的默认文件管理系统，它支持的存储容量高达1EB（1EB=1,073,741,824GB），且能够有无限多的子目录。另外，Ext4文件系统能够批量分配block块，从而极大地提高了读写效率。 XFS​ 一种高性能的日志文件系统，而且是RHEL 7中默认的文件管理系统，它的优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大的日志功能只用花费极低的计算和存储性能。并且它最大可支持的存储容量为18EB，这几乎满足了所有需求。 挂载 在windows操作系统中， 挂载通常是指给磁盘分区（包括被虚拟出来的磁盘分区）分配一个盘符。 第三方软件，如磁盘分区管理软件、虚拟磁盘软件等，通常也附带挂载功能。 ​ 在linux操作系统中， 挂载是指将一个设备（通常是存储设备）挂接到一个已存在的目录上。 我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上， 然后通过访问这个目录来访问存储设备。 在linux 操作系统中，挂载是一个非常重要的功能，使用非常频繁。它指将一个设备（通常是存储设备）挂接到一个已存在的目录上。（这个目录可以不为空，但挂载后这个目录下以前的内容将不可用。）需要理解的是，linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。 举个栗子：123456[root@localhost ~]# cd /dev[root@localhost dev]# ll cdromlrwxrwxrwx. 1 root root 3 Jan 24 04:37 cdrom -&gt; sr0[root@localhost dev]# cd cdrom-bash: cd: cdrom: Not a directory[root@localhost dev]# 如上，我们的/dev目录下有个叫做cdrom的文件（就是指设备，设备也是一种文件），但是我们没办法cd到这个文件（设备）里面去看它究竟包含了哪些东西。所以呢，我们可以新建一个目录/mnt/cdrom/，然后把原来的cdrom文件（设备）挂载到/mnt/cdrom/这个目录底下，此时你可以cd到/mnt/cdrom/目录下看看，多出来一堆东西就是原来的cdrom文件（设备）里包含的东西了。 12345678[root@localhost dev]# mkdir -p /mnt/cdrom[root@localhost dev]# ls /mnt/cdrom/[root@localhost dev]# mount /dev/cdrom /mnt/cdrom/mount: /dev/sr0 is write-protected, mounting read-only[root@localhost dev]# ls /mnt/cdrom/CentOS_BuildTag EULA images LiveOS repodata RPM-GPG-KEY-CentOS-Testing-7EFI GPL isolinux Packages RPM-GPG-KEY-CentOS-7 TRANS.TBL[root@localhost dev]# 挂载条件1、挂载点必须是一个目录。 2、一个分区挂载在一个已存在的目录上，这个目录可以不为空，但挂载后这个目录下以前的内容将不可用。对于其他操作系统建立的文件系统的挂载也是这样。 挂载硬件设备mountmount命令用于挂载文件系统，格式为 1mount 文件系统 挂载目录 临时挂载、使用mount命令来查看mount的挂载情况举例：1234567891011121314151617181920[root@localhost ~]# cd /mnt[root@localhost mnt]# mkdir cdrom[root@localhost mnt]# cd /[root@localhost /]# mount /dev/cdrom /mnt/cdrom/mount: /dev/sr0 is write-protected, mounting read-only[root@localhost /]# ls /mnt/cdromCentOS_BuildTag EULA images LiveOS repodata RPM-GPG-KEY-CentOS-Testing-7EFI GPL isolinux Packages RPM-GPG-KEY-CentOS-7 TRANS.TBL我们可以使用mount命令来查看mount的挂载情况[root@localhost /]# cd /mnt/cdrom/[root@localhost cdrom]# mount | grep /mnt/cdrom #注意这里cdrom后面没有//dev/sr0 on /mnt/cdrom type iso9660 (ro,relatime)[root@localhost cdrom]# 注意：这样挂载的文件系统是临时的，会在重启之后消失！重启后：[root@localhost ~]# ls /mnt/cdrom/[root@localhost ~]# 可以看到，重启后咱们挂载的文件的确消失了！ 卸载文件系统（取消挂载）的两种方法12345678910111213[root@localhost ~]# ls /mnt/cdrom/CentOS_BuildTag EULA images LiveOS repodata RPM-GPG-KEY-CentOS-Testing-7EFI GPL isolinux Packages RPM-GPG-KEY-CentOS-7 TRANS.TBL[root@localhost ~]# umount /mnt/cdrom/ #也可以 umount /dev/sr0[root@localhost ~]# ls /mnt/cdrom/[root@localhost ~]# mount /dev/cdrom /mnt/cdrom/mount: /dev/sr0 is write-protected, mounting read-only[root@localhost ~]# ls /mnt/cdrom/CentOS_BuildTag EULA images LiveOS repodata RPM-GPG-KEY-CentOS-Testing-7EFI GPL isolinux Packages RPM-GPG-KEY-CentOS-7 TRANS.TBL[root@localhost ~]# umount /dev/sr0[root@localhost ~]# ls /mnt/cdrom/[root@localhost ~]# umount 的时候要求目标设备没有在使用中，比如当前没有用户cd到这个目录 123[root@localhost ~]# cd /mnt/cdrom/[root@localhost cdrom]# umount /mnt/cdrom/umount: /mnt/cdrom/: not mounted 开机自动挂载 注意：现在咱们是继续上面的实验继续做，也就是说，上面咱们已经把挂载好的卸载掉了，/mnt/cdrom/现在仅仅是空目录，现在先让它空着就好！呐： 12[root@localhost ~]# ls /mnt/cdrom/[root@localhost ~]# 接下来咱们开始做开机自动挂载 在/etc目录下有个fstab文件，它里面列出了linux开机时自动挂载的文件系统的列表。 编辑/etc/fstab文件使分区开机自动挂载 123[root@localhost cdrom]# vim /etc/fstab 在文件最后一行加上如下内容：/dev/sr0 /mnt/cdrom ext4 defaults 0 0 字段 意义 设备文件 一般为设备的路径+设备名称，也可以写唯一识别码（UUID，Universally Unique Identifier） 挂载目录 指定要挂载到的目录，需在挂载前创建好 格式类型 指定文件系统的格式，比如Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等 权限选项 若设置为defaults，则默认权限为：rw, suid, dev, exec, auto, nouser, async 是否备份 若为1则开机后使用dump进行磁盘备份，为0则不备份 是否自检 若为1则开机后自动进行磁盘自检，为0则不自检 mount -a命令可以重新加载fstab文件测试此文件是否修改成功且配置生效,如果哪里出错它会显示出来 12345678[root@localhost ~]# mount -amount: /dev/sr0 is write-protected, mounting read-onlymount: wrong fs type, bad option, bad superblock on /dev/sr0, missing codepage or helper program, or other error In some cases useful info is found in syslog - try dmesg | tail or so.[root@localhost ~]# 如上，哎，出错了 QAQ。如果刚刚没有用mount -a检查一下就重启，后面就会遇到一系列问题。 解决思路：把你出错的提示复制下来，百度一下即可。我了个去，刚刚百度花了快十分钟，才找到问题所在，其实虽然从报错字面wrong fs type可以看出是我的文件格式类型写错了，也就是不能写ext4，关键是我也不知道写啥呀。万能的百度上搜到的，原来就是咱们上面敲过的命令： 12[root@localhost cdrom]# mount | grep /mnt/cdrom #注意这里cdrom后面没有符号//dev/sr0 on /mnt/cdrom type iso9660 (ro,relatime) 我刚刚没有认真看它的type是iso9660，于是后面就写错了，现在改正： 123[root@localhost ~]# vim /etc/fstab 最后一行改为：/dev/sr0 /mnt/cdrom iso9660 defaults 0 0 然后再检查一下，就没有报错了！同时顺带检查了一下挂载情况，的确挂载成功了！ 1234567891011121314151617[root@localhost ~]# mount -amount: /dev/sr0 is write-protected, mounting read-only[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/centos-root 17G 1.3G 16G 8% /devtmpfs 476M 0 476M 0% /devtmpfs 488M 0 488M 0% /dev/shmtmpfs 488M 7.7M 480M 2% /runtmpfs 488M 0 488M 0% /sys/fs/cgroup/dev/sda1 1014M 130M 885M 13% /boottmpfs 98M 0 98M 0% /run/user/0/dev/sr0 906M 906M 0 100% /mnt/cdrom[root@localhost ~]# [root@localhost ~]# ls /mnt/cdrom/CentOS_BuildTag EULA images LiveOS repodata RPM-GPG-KEY-CentOS-Testing-7EFI GPL isolinux Packages RPM-GPG-KEY-CentOS-7 TRANS.TBL[root@localhost ~]# 重启 1[root@localhost ~]# reboot 再次检查 12345678910111213[root@localhost ~]# ls /mnt/cdrom/CentOS_BuildTag EULA images LiveOS repodata RPM-GPG-KEY-CentOS-Testing-7EFI GPL isolinux Packages RPM-GPG-KEY-CentOS-7 TRANS.TBL[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/centos-root 17G 1.3G 16G 8% /devtmpfs 476M 0 476M 0% /devtmpfs 488M 0 488M 0% /dev/shmtmpfs 488M 7.6M 480M 2% /runtmpfs 488M 0 488M 0% /sys/fs/cgroup/dev/sr0 906M 906M 0 100% /mnt/cdrom/dev/sda1 1014M 130M 885M 13% /boottmpfs 98M 0 98M 0% /run/user/0 可以看到，上面的挂载并未消失，所以这个开机自动挂载是成功滴！ 磁盘分区fdisk工具： 在Linux系统中，管理硬盘设备最常用的方法就当属fdisk命令了。fdisk命令用于管理磁盘分区它提供了集添加、删除、转换分区等功能于一身的“一站式分区服务”，格式为 1fdisk [磁盘名称] 题目：添加一块20G硬盘，分出一个5G大小的分区，分区格式分别为xfs，将分区通过UUID永久挂载到/mnt/note目录 首先，查看硬盘及分区信息 12345678910111213141516171819202122232425[root@localhost ~]# fdisk -l Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x000bf707 Device Boot Start End Blocks Id System/dev/sda1 * 2048 2099199 1048576 83 Linux/dev/sda2 2099200 41943039 19921920 8e Linux LVMDisk /dev/mapper/centos-root: 18.2 GB, 18249416704 bytes, 35643392 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytes[root@localhost ~]# 可以看出，Disk /dev/sda: 21.5 GB说明只有一块磁盘，我们现在给它加上第二块磁盘： 然后再次查看硬盘及分区信息： 12345678910111213141516171819202122232425262728293031[root@localhost ~]# fdisk -l Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x000bf707 Device Boot Start End Blocks Id System/dev/sda1 * 2048 2099199 1048576 83 Linux/dev/sda2 2099200 41943039 19921920 8e Linux LVMDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk /dev/mapper/centos-root: 18.2 GB, 18249416704 bytes, 35643392 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytes[root@localhost ~]# 可以看到多出了Disk /dev/sdb: 21.5 GB的另一块磁盘。咱们接下来就在这个新磁盘上完成题目要求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 1.使用fdisk分出一个大小为5G的分区 [root@localhost ~]# fdisk /dev/sdb欢迎使用 fdisk (util-linux 2.23.2)。 更改将停留在内存中，直到您决定将更改写入磁盘。使用写入命令前请三思。 命令(输入 m 获取帮助)：nPartition type: p primary (0 primary, 0 extended, 4 free) e extendedSelect (default p): p分区号 (1-4，默认 1)：起始 扇区 (2048-41943039，默认为 2048)：将使用默认值 2048Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-41943039，默认为 41943039)：+5G分区 1 已设置为 Linux 类型，大小设为 5 GiB 命令(输入 m 获取帮助)：p 磁盘 /dev/sdb：21.5 GB, 21474836480 字节，41943040 个扇区Units = 扇区 of 1 * 512 = 512 bytes扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：dos磁盘标识符：0x802025ce 设备 Boot Start End Blocks Id System/dev/sdb1 2048 10487807 5242880 83 Linux 命令(输入 m 获取帮助)：wThe partition table has been altered! Calling ioctl() to re-read partition table.正在同步磁盘。 # 2.格式化磁盘为xfs格式[root@localhost ~]# mkfs.xfs /dev/sdb1meta-data=/dev/sdb1 isize=512 agcount=4, agsize=327680 blks = sectsz=512 attr=2, projid32bit=1 = crc=1 finobt=0, sparse=0data = bsize=4096 blocks=1310720, imaxpct=25 = sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=1log =internal log bsize=4096 blocks=2560, version=2 = sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0 # 3.用partprobe命令将修改写入硬盘[root@localhost ~]# partprobe # 4.用blkid命令查看分区的UUID[root@localhost ~]# blkid | grep /dev/sdb1/dev/sdb1: UUID=&quot;081fb70a-c886-4926-bc0d-0e94a9c31687&quot; TYPE=&quot;xfs&quot; # 5.修改/etc/fstab达到开机挂载的目的[root@localhost ~]# tail -n 1 /etc/fstab UUID=&quot;081fb70a-c886-4926-bc0d-0e94a9c31687&quot; /mnt/note xfs defaults 0 0# 6.使用mount -a命令测试fstab挂载是否成功[root@localhost ~]# mount | grep /dev/sdb1[root@localhost ~]# mount -a[root@localhost ~]# mount | grep /dev/sdb1/dev/sdb1 on /mnt/note type xfs (rw,relatime,seclabel,attr2,inode64,noquota)[root@localhost ~]# df -h用于查看文件系统的使用情况 123456789101112[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/centos-root 17G 1.3G 16G 8% /devtmpfs 476M 0 476M 0% /devtmpfs 488M 0 488M 0% /dev/shmtmpfs 488M 7.7M 480M 2% /runtmpfs 488M 0 488M 0% /sys/fs/cgroup/dev/sr0 906M 906M 0 100% /mnt/cdrom/dev/sda1 1014M 130M 885M 13% /boottmpfs 98M 0 98M 0% /run/user/0/dev/sdb1 5.0G 33M 5.0G 1% /mnt/note[root@localhost ~]# du -sh用于查看文件数据占用量的du命令，其格式为 1du [选项] [文件] 1234[root@localhost ~]# cd /[root@localhost /]# du -sh /root4.9M /root[root@localhost /]# 交换分区 题目：添加一个3G大小的交换分区，删除原先系统里的交换分区fstab挂载（如下图有“swap”的那一行），然后再用mount -a命令重新挂载fstab文件，还要敲下面的命令关闭当前系统生效的交换分区 123456[root@localhost ~]# swapoff /dev/mapper/centos-swap [root@localhost ~]# free -m total used free shared buff/cache availableMem: 974 126 693 7 155 680Swap: 0 0 0[root@localhost ~]# 1.首先添加一块3G的分区sdb2 123456789101112131415161718192021222324252627282930313233343536373839404142[root@localhost ~]# fdisk /dev/sdbWelcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help): nPartition type: p primary (1 primary, 0 extended, 3 free) e extendedSelect (default p): Using default response pPartition number (2-4, default 2): First sector (10487808-41943039, default 10487808): Using default value 10487808Last sector, +sectors or +size&#123;K,M,G&#125; (10487808-41943039, default 41943039): +3GPartition 2 of type Linux and of size 3 GiB is setCommand (m for help): wThe partition table has been altered!Calling ioctl() to re-read partition table.WARNING: Re-reading the partition table failed with error 16: Device or resource busy.The kernel still uses the old table. The new table will be used atthe next reboot or after you run partprobe(8) or kpartx(8)Syncing disks.[root@localhost ~]# fdisk -l /dev/sdbDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0xbfd160d1 Device Boot Start End Blocks Id System/dev/sdb1 2048 10487807 5242880 83 Linux/dev/sdb2 10487808 16779263 3145728 83 Linux[root@localhost ~]# partprobe 注意：最后一条命令别忘了敲！ 2.将分区格式化为交换分区 123456789[root@localhost ~]# mkswap /dev/sdb2Setting up swapspace version 1, size = 3145724 KiBno label, UUID=3060761d-8f1b-4222-96ba-2d2a101864ae[root@localhost ~]# swapon /dev/sdb2[root@localhost ~]# free -m total used free shared buff/cache availableMem: 974 128 687 7 158 675Swap: 3071 0 3071[root@localhost ~]# 3.让交换分区能开机启动生效 12345678910[root@localhost ~]# blkid | grep /dev/sdb2/dev/sdb2: UUID=&quot;3060761d-8f1b-4222-96ba-2d2a101864ae&quot; TYPE=&quot;swap&quot; [root@localhost ~]# vim /etc/fstab [root@localhost ~]# init 6重启后：[root@localhost ~]# free -m total used free shared buff/cache availableMem: 976 119 718 6 138 695Swap: 3071 0 3071# 看到我们设置的虚拟内存，生效 磁盘配额 为了限制用户在分区上使用磁盘的容量，利用磁盘限额技术来限制，一般应用场景有网盘、邮箱，还有网络论坛用户上传文件限制等等。 修改/etc/fstab中的类型字段来开启分期的磁盘配额功能 12345678910111213141516171819202122232425262728293031[root@localhost ~]# vim /etc/fstab [root@localhost ~]# grep note /etc/fstab UUID=&quot;081fb70a-c886-4926-bc0d-0e94a9c31687&quot; /mnt/note xfs defaults,uquota 0 0# 重启使分区的磁盘配额功能[root@localhost ~]# reboot[root@localhost ~]# xfs_quota -x -c &apos;limit bsoft=3m bhard=6m isoft=3 ihard=6 aaa&apos; /mnt/note/# 其中软限制为3m，硬限制为6m [aaa@localhost root]$ cd /mnt/note/# 生成一个4M的文件[aaa@localhost note]$ dd if=/dev/zero of=4mfile bs=1M count=4记录了4+0 的读入记录了4+0 的写出4194304字节(4.2 MB)已复制，0.00425314 秒，986 MB/秒[eagle@localhost note]$ ll总用量 4096-rw-rw-r--. 1 aaa afeng 4194304 8月 14 17:18 4mfile[aaa@localhost note]$ ll -h总用量 4.0M-rw-rw-r--. 1 aaa afeng 4.0M 8月 14 17:18 4mfile[aaa@localhost note]$ # 生成一个3M的文件，报错失败，最终这个文件只生成出来2M[aaa@localhost note]$ dd if=/dev/zero of=3mfile bs=1M count=3dd: 写入&quot;3mfile&quot; 出错: 超出磁盘限额记录了3+0 的读入记录了2+0 的写出2097152字节(2.1 MB)已复制，0.00378417 秒，554 MB/秒[aaa@localhost note]$ ll -h总用量 6.0M-rw-rw-r--. 1 aaa afeng 2.0M 8月 14 17:19 3mfile-rw-rw-r--. 1 aaa afeng 4.0M 8月 14 17:18 4mfile 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-10 用户权限与文件权限]]></title>
    <url>%2Flinux-10%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-10 用户权限与文件权限用户权限uid（user id）和gid(group id)root用户的uid和gid都是0 系统用户uid为1-999 普通用户的uid从1000开始：由管理员创建的日常使用的用户 （UID和GID不需要一一对应） 将普通用户的UID设置为0 ，那这个用户也就是root用户了 用户操作1useradd [username] 新建一个用户zhangsan 新建一个用户lisi，指定其家目录为/home/userlisi，指定他的登录shell为zsh 从passwd文件中查看出上述两个用户的uid、git、家目录、登录shell信息 用id命令可以查看用户的基本信息 使用usermod命令修改已有用户的信息（其参数和useradd几乎一样），例如将李四的登录shell改为bash 1234567891011121314[root@localhost ~]# useradd zhangsan[root@localhost ~]# grep zhangsan /etc/passwdzhangsan:x1009:1009::/home/zhangsan:/bin/bash[root@localhost ~]# useradd lisi -d /home/userlisi -s /bin/zsh[root@localhost ~]# grep lisi /etc/passwdlisi:x1010:1010::/home/userlisi:/bin/zsh[root@localhost ~]# id zhangsanuid=1009(zhangsan) gid=1009(zhangsan) groups=1009(zhangsan)[root@localhost ~]# id lisiuid=1010(lisi) gid=1010(lisi) groups=1010(lisi)[root@localhost ~]# usermod lisi -d /home/userlisi -s /bin/bash[root@localhost ~]# grep lisi /etc/passwdlisi:x:1010:1010::/home/userlisi:/bin/bash[root@localhost ~]# 参数 useradd 参数 作用 -d 指定用户的家目录（默认为/home/username） -e 账户的到期时间，格式为YYYY-MM-DD. -u 指定该用户的默认UID -g 指定一个初始的用户基本组（必须已存在） -G 指定一个或多个扩展用户组 -N 不创建与用户同名的基本用户组 -s 指定该用户的默认Shell解释器 查看用户id、uid、主组和附属组12345id 用户名例如[root@node2 ~]# id fenguid=1024(feng) gid=0(root) 组=0(root) 目录/目录 、/home目录 、~目录的区别/ ：根目录 /home ：家目录（可以理解为用户列表目录），你创建的所有用户的家目录默认会在/home目录下 ~ ：当前用户的家目录 查看这台虚拟机有哪些用户，到家目录/home下即可1234[root@localhost ~]# cd /home[root@localhost home]# lsaaa aaawww bbb bbbwww ccc cccwww ddd dddwww testuser userlisi zhangsan[root@localhost home]# 或者使用上面的命令查看某一用户是否存在，查看用户id、uid、主组和附属组，若用户不存在那肯定是报错的。 12345id 用户名例如[root@node2 ~]# id fenguid=1024(feng) gid=0(root) 组=0(root) 删除用户 注意：不要小看删除用户，很多时候咱们都会忘了敲参数-r，以导致该用户的其他信息未能被一起彻底删除，于是再次添加该用户的时候就无法添加上去了，所以两种删用户的方式都要掌握！ 完全删除用户账号（也就是删除所有与该用户相关的文件） 注意：判断你删除是否彻底是否成功的标准是，如果你删除了还能给它加回来那就是成功的，加不回来的话那你的删除就是失败的或者说不彻底的！ 方式一： 1userdel -r 用户名 以用户zzz为例： 123456789101112[root@localhost ~]# cd /home/[root@localhost home]# ls[root@localhost home]# useradd zzz[root@localhost home]# lszzz[root@localhost home]# userdel -r zzz[root@localhost home]# ls[root@localhost home]# useradd zzz[root@localhost home]# lszzz你看，删掉了用户zzz，还能加回来，这次删除就是成功的！ 方式二： 12userdel 用户名 #删除账户和组的信息，但是/home下还能看到该用户的家目录find / -name &quot;*用户名*&quot; | xargs rm -rf #彻底删除用户其他信息 接着上面的命令继续以用户zzz为例： 1234567891011[root@localhost home]# userdel zzz[root@localhost home]# lszzz[root@localhost home]# find / -name &quot;*zzz*&quot; | xargs rm -rf[root@localhost home]# ls[root@localhost home]# useradd zzz[root@localhost home]# lszzz[root@localhost home]# 你看，删掉了用户zzz，还能加回来，这次删除就是成功的！ 失败案例（删除不彻底导致删除后无法再加回来） 接着上面的命令以用户qqq为例： 123456789101112131415161718192021[root@localhost home]# useradd qqq[root@localhost home]# userdel qqq[root@localhost home]# useradd qqquseradd: warning: the home directory already exists.Not copying any file from skel directory into it.Creating mailbox file: File exists[root@localhost home]# find / -name &quot;*qqq*&quot; | xargs rm -rf[root@localhost home]# lszzz[root@localhost home]# useradd qqquseradd: user &apos;qqq&apos; already exists注意：失败了之后，那你可以参考下述命令补救，然后彻底将该用户删除。[root@localhost home]# userdel qqq[root@localhost home]# find / -name &quot;*qqq*&quot; | xargs rm -rf[root@localhost home]# useradd qqq[root@localhost home]# lsqqq zzz[root@localhost home]# 补救成功！ 用户组主组创建用户的时候系统会同时创建一个和这个用户名同名的组，这个组就是主组，不可以把用户从主组中删除。 当然，在创建用户的时候如果你使用使用了-g参数，该用户就可加入和用户不同名的用户组作为该用户的主组。 也可以创建用户之后，再使用usermod -g来改变用户的主组，然鹅这样和用户同名的组依然会存在，并不会被删除。 附属组除了主组之外，用户所在的其他组，都是附属组。用户是可以从附属组中被删除的。 用户的从属组，并不会影响主组，useradd时用-G参数来加入，同时用户主组默认是那个和用户同名的组。 创建用户之后，可以用usermod -G加入其他的附属组，而且之前加入的组不会退掉。 主组与附属组的区别与联系一个用户可以属于多个附属组。但是一个用户只能有一个主组。 创建一个用户组feng，在/etc/group下可看到该组，然后把它删除掉，然后再加回来。可以看到删组可以不用加参数。 123456789101112[root@localhost ~]# groupadd feng[root@localhost ~]# grep feng /etc/groupfeng:x:1000:[root@localhost ~]# groupdel feng[root@localhost ~]# grep feng /etc/group[root@localhost ~]# groupadd feng[root@localhost ~]# grep feng /etc/groupfeng:x:1000:[root@localhost ~]# grep feng /etc/groupfeng:x:1000:[root@localhost ~]# 创建用户组afeng，bfeng，cfeng 123[root@localhost ~]# groupadd afeng[root@localhost ~]# groupadd bfeng[root@localhost ~]# groupadd cfeng 创建用户aaa，并且其主组设置为afeng 12345678[root@localhost ~]# useradd aaa -g afeng[root@localhost ~]# cat /etc/passwd | grep aaaaaa:x:1000:1001::/home/aaa:/bin/bash #可以看到aaa的GID为1001，对应的组为afeng[root@localhost ~]# cat /etc/group | grep fengfeng:x:1000:afeng:x:1001:bfeng:x:1002:cfeng:x:1003: 创建用户bbb，本来默认其主组是bbb，修改其主组为bfeng 1234567891011121314[root@localhost ~]# cat /etc/group | grep feng #先看看各个附属组的GIDfeng:x:1000:afeng:x:1001:bfeng:x:1002:cfeng:x:1003:[root@localhost ~]# useradd bbb[root@localhost ~]# cat /etc/passwd | grep bbbbbb:x:1001:1004::/home/bbb:/bin/bash #可以看到本来bbb的GID是1004，对应的组是bbb[root@localhost ~]# cat /etc/group | grep bbbbbb:x:1004:[root@localhost ~]# usermod bbb -g bfeng[root@localhost ~]# cat /etc/passwd | grep bbbbbb:x:1001:1002::/home/bbb:/bin/bash #现在bbb的GID是1002，对应的组也就是bfeng[root@localhost ~]# 创建用户ccc，其主组设置为cfeng，其附属组有：afeng、bfeng 123456789[root@localhost ~]# useradd ccc -g cfeng -G afeng,bfeng[root@localhost ~]# cat /etc/group | grep fengfeng:x:1000:afeng:x:1001:ccc #可以看到afeng、bfeng下附属有cccbfeng:x:1002:ccccfeng:x:1003:[root@localhost ~]# cat /etc/passwd | grep cccccc:x:1002:1003::/home/ccc:/bin/bash #可以看到ccc的GID为1003，对应的组为cfeng[root@localhost ~]# 用户的主组在/etc/passwd文件中的gid字段体现，并不会在/etc/group文件中体现出来 用户的附属组在/etc/group文件中体现，并不会在/etc/passwd文件中体现 设置用户密码12passwd 用户名交互式输入密码 为用户aaa设置密码 1234567[root@localhost ~]# passwd aaaChanging password for user aaa.New password: BAD PASSWORD: The password is shorter than 8 charactersRetype new password: passwd: all authentication tokens updated successfully.[root@localhost ~]# 上述密码设置已经成功，至于BAD PASSWORD:忽略掉即可，想要了解可以浏览我博客的另一篇文章：linux-基础学习-02 Linux系统介绍和安装，这篇文章详细讲解了设置密码时遇到的N种情况。 锁定用户密码1234567891011[root@localhost ~]# passwd -l aaaLocking password for user aaa.passwd: Success[root@localhost ~]# passwd -S aaa #查看密码状态aaa LK 2019-01-18 0 99999 7 -1 (Password locked.)[root@localhost ~]# passwd -u aaa #解锁密码Unlocking password for user aaa.passwd: Success[root@localhost ~]# passwd -S aaaaaa PS 2019-01-18 0 99999 7 -1 (Password set, SHA512 crypt.)[root@localhost ~]# 使用非交互式（系统标准输入）设置用户密码（不安全） 12345678910[root@localhost ~]# echo &quot;123456&quot; | passwd --stdin aaaChanging password for user aaa.passwd: all authentication tokens updated successfully.[root@localhost ~]# history 5 #用history查看最近输入该的5条命令 81 passwd -S aaa 82 echo &quot;123456&quot; | passwd aaa 83 echo &quot;123456&quot; | passwd --stdin aaa #完了，密码露馅了 84 history -5 85 history 5[root@localhost ~]# 文件权限文件的分类 Linux系统使用了不同的字符来加以区分，常见的字符如下所示。 -：普通文件。 d：目录文件。 l：链接文件。 b：块设备文件。 c：字符设备文件。 p：管道文件。 权限分配 文件所有者 文件所有者 文件所有者 文件所属组 文件所属组 文件所属组 其他用户 其他用户 其他用户 权限项 读 执行 写 读 写 执行 读 写 执行 字符表示 r x w r w x r w x 数字表示 4 1 2 4 2 1 4 2 1 chmod修改文件权限的命令 用法 12chmod [user]+[ r | w| x ] file chmod [user] -[ r | w| x ] file 注意： 如果不加user的话，那么所有的用户的执行权限都会被加上，其他权限只对当前用户生效 例如： 12chmod 755 filechmod 750 file 更改一个文件的归属权1chown [user] file 例如： 1234567891011121314151617181920[root@localhost ~]# ll#一开始，hello.sh是root组下的root用户的文件-rw-r--r--. 1 root root 0 Jan 23 04:14 hello.sh[root@localhost ~]# chown aaa hello.sh[root@localhost ~]# ll#改成aaa用户的文件-rw-r--r--. 1 aaa root 0 Jan 23 04:14 hello.sh[root@localhost ~]# chown bbb:bfeng hello.sh [root@localhost ~]# ll#改成bfeng组下的bbb用户的文件-rw-r--r--. 1 bbb bfeng 0 Jan 23 04:14 hello.sh[root@localhost ~]# chgrp afeng hello.sh[root@localhost ~]# ll#改成归属afeng组的文件-rw-r--r--. 1 bbb afeng 0 Jan 23 04:14 hello.sh[root@localhost ~]# 文件特殊权限SUID让二进制程序的执行者临时拥有属主的权限（仅对拥有执行权限的二进制程序有效） 123456[root@localhost ~]# ll hello.sh -rw-r--r--. 1 bbb afeng 0 Jan 23 04:14 hello.sh[root@localhost ~]# chmod u+s hello.sh [root@localhost ~]# ll hello.sh -rwSr--r--. 1 bbb afeng 0 Jan 23 04:14 hello.sh[root@localhost ~]# SGID和SUID同理 SBID当对某个目录设置了SBIT粘滞位权限后，那么该目录中的文件就只能被其所有者执行删除操作。 当目录被设置SBIT特殊权限位后，文件的其他人权限部分的x执行权限就会被替换成t或者T，原本有x执行权限则会写成t，原本没有x执行权限则会被写成T。 12345678910111213[root@localhost ~]# mkdir test[root@localhost ~]# cd test[root@localhost test]# touch hello.sh[root@localhost test]# lltotal 0-rw-r--r--. 1 root root 0 Jan 23 04:33 hello.sh[root@localhost test]# chmod -R o+t hello.sh [root@localhost test]# lltotal 0-rw-r--r-T. 1 root root 0 Jan 23 04:33 hello.sh[root@localhost test]# su aaa[aaa@localhost test]$ rm -f hello.shrm: cannot remove ‘hello.sh’: Permission denied 文件的隐藏属性chattrchattr命令用于设置文件的隐藏权限，格式为 1chattr [参数] 文件 参数 作用 i 无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件 a 仅允许补充（追加）内容，无法覆盖/删除内容（Append Only） S 文件内容在变更后立即同步到硬盘（sync） s 彻底从硬盘中删除，不可恢复（用0填充原文件所在硬盘区域） b 不再修改文件或目录的存取时间 D 检查压缩文件中的错误 d 使用dump命令备份时忽略本文件/目录 c 默认将文件或目录进行压缩 u 当删除该文件后依然保留其在硬盘中的数据，方便日后恢复 t 让文件系统支持尾部合并（tail-merging） X 可以直接访问压缩文件中的内容 lsattr1234567[root@localhost test]# chattr +a hello.sh [root@localhost test]# lsattr hello.sh -----a---------- hello.sh[root@localhost test]# chattr -a hello.sh [root@localhost test]# lsattr hello.sh ---------------- hello.sh[root@localhost test]# 文件权限扩展权限设置setfacl题目： 创建文件/root/testfacl，其文件所属者和组都是root 系统中有aaa，bbb和ccc三个用户， root用户对testfacl有最高权限 aaa用户对testfacl有可读可写可执行权限 bbb用户对testfacl有可读可写权限 ccc用户对testfacl有可读权限 用户组中的用户对testfacl文件有可读可执行权限 用户组cfeng对testfacl有可读权限 其他用户对testfacl没有任何权限 命令： 1234567[root@localhost ~]# touch testfacl[root@localhost ~]# ll testfacl -rw-r--r--. 1 root root 0 Jan 23 04:49 testfacl[root@localhost ~]# setfacl -m u:root:rwx,u:aaa:rwx,u:bbb:rw-,u:ccc:r--,g::r-x,g:cfeng:r--,o::--- testfacl [root@localhost ~]# ll testfacl -rw-rwx---+ 1 root root 0 Jan 23 04:49 testfacl[root@localhost ~]# getfacl查看文件扩展属性 123456789101112131415[root@localhost ~]# getfacl testfacl # file: testfacl# owner: root# group: rootuser::rw-user:root:rwxuser:aaa:rwxuser:bbb:rw-user:ccc:r--group::r-xgroup:cfeng:r--mask::rwxother::---[root@localhost ~]# 切换用户su​ su命令可以解决切换用户身份的需求，使得当前用户在不退出登录的情况下，顺畅地切换到其他用户。su命令与用户名之间有一个减号（-），这意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。强烈建议在切换用户身份时添加这个减号（-）。 12345678910[root@localhost ~]# su aaa[aaa@localhost root]$ iduid=1000(aaa) gid=1001(afeng) groups=1001(afeng) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023[aaa@localhost root]$ su rootPassword: [root@localhost ~]# su - aaaLast login: Wed Jan 23 04:56:46 EST 2019 on pts/0[aaa@localhost ~]$ iduid=1000(aaa) gid=1001(afeng) groups=1001(afeng) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023[aaa@localhost ~]$ 尴尬的是，root和aaa恰好环境变量信息是一样的，唉算了就这样吧，加个减号也不费事 sudosudo命令用于给普通用户提供额外的权限来完成原本root管理员才能完成的任务，格式为 1sudo [参数] 命令名称 sudo命令具有如下功能： 限制用户执行指定的命令： 记录用户执行的每一条命令； 配置文件（/etc/sudoers）提供集中的用户管理、权限与主机等参数； 验证密码的后5分钟内（默认值）无须再让用户再次验证密码。 参数 作用 -h 列出帮助信息 -l 列出当前用户可执行的命令 -u用户名或UID值 以指定的用户身份执行命令 -k 清空密码的有效时间，下次执行sudo时需要再次进行密码验证 -b 在后台执行指定的命令 -p 更改询问密码的提示语 visudo举例：使用visudo命令配置sudo命令的配置文件 [root@localhost ~]# visudo 98 ## Allows people in group wheel to run all commands 99 %wheel ALL=(ALL) ALL 100 root ALL=(ALL) ALL]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-运维进阶-09 编写Shell脚本]]></title>
    <url>%2Flinux-09%2F</url>
    <content type="text"><![CDATA[linux-运维进阶-09 编写Shell脚本 可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。 交互式（Interactive）：用户每输入一条命令就立即执行。 批处理（Batch）：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。 指定解释器脚本的第一行用于指定脚本使用哪个shell程序做为脚本中命令的解释器 使用bash做为脚本命令的解释器 1#!/bin/bash 使用zsh做为脚本的命令解释器 1#!/bin/zsh 创建一个脚本123456[root@localhost ~]# vim hello.sh里面输入：#!/bin/bashecho &quot;helloworld&quot;保存退出 执行一个脚本123[root@localhost ~]# ./hello.sh-bash: ./hello.sh: Permission denied #发现你的权限不够[root@localhost ~]# 添加执行权限 脚本写完后运行，利用./执行发现权限不够。Linux文件创建之后默认是没有可执行权限的，可以用chmod给文件或目录添加上可执行权限 123456[root@localhost ~]# ll[root@localhost ~]# chmod +x ./hello.sh [root@localhost ~]# ll[root@localhost ~]# ./hello.sh helloworld[root@localhost ~]# 注意，一定要写成 ./hello.sh ，而不是 hello.sh，运行其它二进制的程序也一样，直接写 hello.sh，linux 系统会去 PATH 里寻找有没有叫 hello.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 hello.sh 是会找不到命令的，要用 ./hello.sh 告诉系统说，就在当前目录找。 上面两次ll出来的文件列表，是为了对比出添加权限前后文件权限的变化，x表示可执行。 没有执行权限情况下想要执行脚本的两种方式12345678910首先咱们在新建一个脚本[root@localhost ~]# vim aaa.sh里面输入：#!/bin/bashecho &quot;hello aaa&quot;保存退出验证它无权限被执行[root@localhost ~]# ./aaa.sh-bash: ./aaa.sh: Permission denied 解释器后面跟上脚本12[root@localhost ~]# bash aaa.sh hello aaa 点加空格后面跟上脚本或者脚本的全路径12[root@localhost ~]# . aaa.sh hello aaa Shell脚本执行的几种方法 在脚本拥有可执行权限之后，我们就可以去执行脚本，执行脚本有以下几种方式： 在脚本所在目录下时 123456789[root@localhost ~]# ./hello.sh helloworld[root@localhost ~]# . hello.sh helloworld[root@localhost ~]# bash hello.sh helloworld[root@localhost ~]# sh hello.sh helloworld[root@localhost ~]# 不在脚本所在目录下时 12345678910[root@localhost ~]# mkdir -p a/b/c/d[root@localhost ~]# cd a[root@localhost a]# bash /root/hello.sh helloworld[root@localhost a]# cd b/c/d[root@localhost d]# pwd/root/a/b/c/d[root@localhost d]# ./../../../../hello.sh helloworld[root@localhost d]# 接受用户的参数脚本的参数就是脚本后面跟的用户输入的选项或者是变量 在脚本中 脚本的名字使用$0来表示 脚本的参数个数使用$#表示 脚本的第N个参数使用$N表示（例如脚本第三个参数$3） 12345678910[root@localhost ~]# vim hello.sh 输入：#!/bin/bashecho &quot;脚本名称：$0&quot;echo &quot;参数个数：$#&quot;echo &quot;第一个参数：$1&quot;echo &quot;第二个参数：$2&quot;echo &quot;第三个参数：$3&quot;echo &quot;第四个参数：$4&quot;echo &quot;第五个参数：$5&quot; 执行该脚本： 1[root@localhost ~]# bash hello.sh 1 2 3 4 5 判断用户参数（下面两种写法）123456789101112[root@localhost ~]# vim isroot.sh输入：#!/bin/bashif [ $USER == root ];then echo &quot;当前用户是管理员&quot;else echo &quot;当前用户不是管理员&quot; fi[ $USER = root ] &amp;&amp; echo &quot;当前用户是管理员&quot; || echo &quot;当前用户不是管理员&quot;exit 0 执行该脚本： 1234[root@localhost ~]# bash isroot.sh 当前用户是管理员当前用户是管理员[root@localhost ~]# 可用的整数比较运算符 运算符 作用 -eq 是否等于 -ne 是否不等于 -gt 是否大于 -lt 是否小于 -le 是否等于或小于 -ge 是否大于或等于 常见的字符串比较运算符 运算符 作用 = 比较字符串内容是否相同 != 比较字符串内容是否不同 -z 判断字符串内容是否为空 123 [root@localhost ~]# [ $LANG=&quot;EN.US.UTF-8&quot; ]&amp;&amp;echo &quot;is English&quot;is English[root@localhost ~]# Shell中的四则运算注意：方括号外取值符号$不能少，方括号内一定要用空格把方括号和里面的命令隔开 123456[root@localhost ~]# i=$[10 * 10][root@localhost ~]# echo $i100[root@localhost ~]# echo $[999 + 999]1998[root@localhost ~]# 写一个判断内存是否够用的脚本 1[root@localhost ~]# vim isfree.sh 输入： 123456789101112#!/bin/bash# 此脚本用于判断内存是否够用，标准为空闲内存大于总内存的20%（说明脚本功能）# bash isfree.sh （说明脚本的用法）# 作者：feng（说明脚本作者）# qq:略（说明作者的联系方式） # 可能有些脚本里有复杂参数或者函数，请在最下面进行说明 Totalmem=`free -m | grep Mem | awk &apos;&#123;print $2&#125;&apos;`Freemem=`free -m | grep Mem | awk &apos;&#123;print $4&#125;&apos;`i=$[ $Totalmem/5 ][ $Freemem -gt $i ] &amp;&amp; echo &quot;内存够用&quot; || echo &quot;内存紧缺，请抓紧清理内存&quot; 执行： 123[root@localhost ~]# bash isfree.sh 内存够用[root@localhost ~]# if流程控制语句上面判断用户参数时，我们已经使用过了if语句 现在再来一次 linux shell 中判断文件、目录是否存在-e filename 如果 filename存在，则为真-d filename 如果 filename为目录，则为真-f filename 如果 filename为常规文件，则为真-L filename 如果 filename为符号链接，则为真-r filename 如果 filename可读，则为真-w filename 如果 filename可写，则为真-x filename 如果 filename可执行，则为真-s filename 如果文件长度不为0，则为真 1[root@localhost ~]# vim 1.sh 输入: 12345678910#!/bin/bashDIR=&quot;/root/test&quot;if [ ! -d $DIR ]then echo &quot;目录不存在&quot; mkdir /root/testelse echo &quot;目录已经存在&quot;fiexit 0 1234[root@localhost ~]# bash 1.sh 目录不存在[root@localhost ~]# bash 1.sh 目录已经存在 结果如下图： 判断主机是否能正常访问百度的脚本1[root@localhost ~]# vim baidu.sh 输入： 1234567891011121314151617#!/bin/bash# example： ./testhost.sh www.baidu.comif [ $# -eq 1 ] then ping -c 4 -i 0.2 -W 3 $1 &amp;&gt; /dev/nullelse echo &quot;example: $0 www.baidu.com&quot;fi if [ $? -eq 0 ] then echo &quot;主机$1能正常访问&quot; exit 0else echo &quot;主机$1无法访问&quot; exit 1fi 1234[root@localhost ~]# bash baidu.sh example: baidu.sh www.baidu.com主机能正常访问[root@localhost ~]# 判断成绩的脚本1[root@localhost ~]# vim result.sh 123456789101112 #!/bin/bashread -p &quot;Enter your score(0-100): &quot; scif [ $sc -gt 100 ] || [ $sc -lt 0 ] ; then echo &quot;Error,Please input score 0~100!&quot; exit 2elif [ $sc -ge 85 ] &amp;&amp; [ $sc -le 100 ]; then echo &quot;$sc is Excellent&quot;elif [ $sc -ge 60 ] &amp;&amp; [ $sc -le 84 ]; then echo &quot;$sc is Pass&quot;else echo &quot;$sc is Fail&quot;fi 1234[root@localhost ~]# bash result.sh Enter your score(0-100): 9090 is Excellent[root@localhost ~]# for循环 题目：在linux上创建一个脚本，名为/root/makeusers，此脚本能实现为系统创建本地用户，并且这些用户的用户名来自一个包含用户名列表的文件。 同时满足下列要求： 此脚本要求提供一个参数，此参数就是包含用户列表的文件 如果没有提供参数，此脚本应该给出下面的提示信息 Usage:/root/makeusers ，然后退出并返回相应的值 如果提供一个不存在的文件名，此脚本应该给出下面的提示信息 Input file not found 然后退出并返回相应的值 创建的用户登录 shell 为/bin/false，此脚本不需要为用户设置密码 首先，了解一下新建用户的命令： 12[root@localhost ~]# useradd -s /bin/fasle &quot;testuser&quot;[root@localhost ~]# cat /etc/passwd 通过cat命令查看所有用户信息，可以看到如下图，用户testuser已经成功创建出来了 现在开始写脚本： 1[root@localhost ~]# vim foruser.sh 123456789101112#!/bin/bashif [ $# -ne 1 ];then echo &apos;Usage: $0 &lt;userfile&gt;&lt;&gt;&apos; exit 1elif [ ! -f &quot;$1&quot; ];then echo &quot;input file not found&quot; exit 2else for USER in $(cat &quot;$1&quot;);do useradd -s /bin/false $USER donefi 新建一个包含用户名的文件，里面随便设置几个用户 1[root@localhost ~]# vim user.txt 1234aaabbbcccddd 执行脚本 12[root@localhost ~]# bash foruser.sh user.txt [root@localhost ~]# cat /etc/passwd 如下图，几个用户已经被成功添加了！ 把for循环改成wheel循环的写法 另外再写一个脚本： 1[root@localhost ~]# vim wheeluser.sh 123456789101112#!/bin/bashif [ $# -eq 1 ];then if [ -f &quot;$1&quot; ];then while read username;do useradd -s /bin/false $username &amp;&gt;/dev/null done&lt;$1 #跳出循环 else echo &quot;Input file not found&quot; fi else echo &quot;Usage: $0 &lt;userfile&gt;&quot;fi 重新编辑一下user.txt 1[root@localhost ~]# vim user.txt 1234aaawwwbbbwwwcccwwwdddwww 执行脚本 12[root@localhost ~]# bash wheeluser.sh user.txt [root@localhost ~]# cat /etc/passwd 如下图，几个用户已经被成功添加了！ case语句在 linux上创建一个名为/root/script.sh 的脚本，让其提供下列特性： 当运行/root/script.sh all，输出为 none 当运行/root/script.sh none，输出为 all 当没有任何参数或参数不是 all 或者 none 时，其错误输出产生以下的信息： 1/root/script.sh all|none 开始写脚本 1[root@localhost ~]# vim script.sh 123456789101112#!/bin/bashcase $1 in all) echo &quot;none&quot; ;; none) echo &quot;all&quot; ;; *) echo &quot;Usage: $0 all|none&quot; ;; esac 执行脚本： 1234567[root@localhost ~]# bash script.sh allnone[root@localhost ~]# bash script.sh noneall[root@localhost ~]# bash script.sh abcUsage: script.sh all|none[root@localhost ~]# 如下图 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-运维进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础学习-08 管道符、重定向与环境变量]]></title>
    <url>%2Flinux-08%2F</url>
    <content type="text"><![CDATA[linux-基础学习-08 管道符、重定向与环境变量重定向输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。 标准输入重定向（STDIN，文件描述符为0）：默认从键盘输入，也可从其他文件或命令中输入。 标准输出重定向（STDOUT，文件描述符为1）：默认输出到屏幕。 错误输出重定向（STDERR，文件描述符为2）：默认输出到屏幕。 输入重定向中用到的符号以及作用 符号 作用 命令 &lt; 文件 将文件作为命令的标准输入 命令 &lt;&lt; 分界符 从标准输入中读入，直到遇见分界符才停止 命令 &lt; 文件1 &gt; 文件2 将文件1作为命令的标准输入并将标准输出到文件2 输出重定向中用到的符号及其作用 符号 作用 命令 &gt; 文件 将标准输出重定向到一个文件中（清空原有文件的数据） 命令 2&gt; 文件 将错误输出重定向到一个文件中（清空原有文件的数据） 命令 &gt;&gt; 文件 将标准输出重定向到一个文件中（追加到原有内容的后面） 命令 2&gt;&gt; 文件 将错误输出重定向到一个文件中（追加到原有内容的后面） 命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面） 将当前的网络信息保存到当前目录中的network_info.txt文件中（输出重定向） 12[root@localhost ~]# ifconfig &gt; network_info.txt[root@localhost ~]# cat network_info.txt 追加一个日期到network_info.txt文件中（输出重定向） 12[root@localhost ~]# date &gt;&gt; network_info.txt [root@localhost ~]# cat network_info.txt 管道符命令用于把前一个命令原本要输出到屏幕的标准正常数据当作是后一个命令的标准输入案例：统计当前Linux系统中有多少用户不能交互式登录系统 123[root@localhost ~]# grep nologin /etc/passwd | wc -l16[root@localhost ~]# 命令行通配符 通配符就是通用的匹配信息的符号，比如星号（*）代表匹配零个或多个字符，问号（?）代表匹配单个字符，中括号内加上数字[0-9]代表匹配0～9之间的单个数字的字符，而中括号内加上字母[abc]则是代表匹配a、b、c三个字符中的任意一个字符。 案例1： 查看系统中有哪些硬盘1234[root@localhost ~]# ll /dev/sd*[root@localhost ~]# ll /dev/sd?[root@localhost ~]# ll /dev/sd[a-z][root@localhost ~]# 案例2： 查看系统中有哪些分区1[root@localhost ~]# ll /dev/sd*[0-9] 常用转义字符Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据 反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。 单引号（’’）：转义其中所有的变量为单纯的字符串。 双引号（””）：保留其中的变量属性，不进行转义处理。 反引号（）：把其中的命令执行后返回结果。 在一串字符串中输出$符号 1234567直接echo无法输出$符号，而且对其他的字符和字符串还会造成影响[root@localhost ~]# echo hello$worldhello[root@localhost ~]# echo hello\$worldhello$world[root@localhost ~]# alias命令别名临时让命令别名生效 12345678 [root@localhost ~]# curl myip.ipip.net当前 IP：112.24.12.22 来自于：中国 江苏 镇江 移动[root@localhost ~]# myip-bash: myip: command not found[root@localhost ~]# alias myip=&apos;curl myip.ipip.net&apos;[root@localhost ~]# myip当前 IP：112.24.12.22 来自于：中国 江苏 镇江 移动[root@localhost ~]# 永久对当前用户生效 12345[root@localhost ~]# vim ~/.bashrc在下图所示处加上一行alias myip=&apos;curl myip.ipip.net&apos;保存退出 修改了~/.bashrc文件后必须使用source命令刷新才会生效 1234[root@localhost ~]# source ~/.bashrc[root@localhost ~]# myip当前 IP：112.24.12.22 来自于：中国 江苏 镇江 移动[root@localhost ~]# Linux系统中最重要的10个环境变量 变量名称 作用 HOME 用户的主目录（即家目录） SHELL 用户在使用的Shell解释器名称 HISTSIZE 输出的历史命令记录条数 HISTFILESIZE 保存的历史命令记录条数 MAIL 邮件保存路径 LANG 系统语言、语系名称 RANDOM 生成一个随机数字 PS1 Bash解释器的提示符 PATH 定义解释器搜索用户执行命令的路径 EDITOR 用户默认的文本编辑器 本篇到此结束，这是linux基础学习章节的最后一篇，下一篇linux-09将进入到新的章节：运维进阶]]></content>
      <categories>
        <category>linux</category>
        <category>linux-基础学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础学习-07 Linux系统上传下载命令rz和sz]]></title>
    <url>%2Flinux-07%2F</url>
    <content type="text"><![CDATA[linux-基础学习-07 Linux系统上传下载命令rz和sz 在部署项目时，我们经常需要从本地电脑和linux服务器间上传或下载项目包，所以今天来个好用的命令，sz， rz命令 安装lrzsz 1[root@localhost ~]# yum install -y lrzsz 我们上传一个aaa.txt测试一下（aaa.txt最好有内容，大小不要是0字节）： 下载测试： 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-基础学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础学习-06 炫酷的zsh]]></title>
    <url>%2Flinux-06%2F</url>
    <content type="text"><![CDATA[linux-基础学习-06 炫酷的zsh概念：cmd cmd是command的缩写，即命令提示符。命令提示符（CMD）是在操作系统中，提示进行命令输入的一种工作提示符。在不同的操作系统环境下，命令提示符各不相同。 在windows环境下，命令行程序为cmd.exe，是一个32位的命令行程序，微软Windows系统基于Windows上的命令解释程序，类似于微软的DOS操作系统。输入一些命令，cmd.exe可以执行，比如输入shutdown -s -t 30就会在30秒后关机。总之，它非常有用。 打开方法：开始-所有程序-附件 或 开始-寻找-输入：cmd/cmd.exe 回车。用户可以在命令提示符直接输入中文调用文件。 Shell Shell基本上是一个命令解释器，类似于DOS下的command和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序。 Xshell Xshell 是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。Xshell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。除此之外，其还有丰富的外观配色方案以及样式选择。 PowerShell Windows PowerShell 是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以利用 .NET Framework的强大功能。PowerShell跟cmd有什么关系呢？可以简单地说，PowerShell可以看作是cmd的升级版、补充版，但其背后的实现方式却有很大的不同，PowerShell基于面向对象。PowerShell是运行在Windows操作系统上实现对系统以及应用程序进行管理自动化的命令行脚本环境，PowerShell需要.NET环境的支持，借助.NET Framework平台强大的类库，几乎让一切都成为可能。微软起“PowerShell”这个名字并不是夸夸其谈，它完全支持对象，其可读性，易用性，毫不夸张的说可以居所有Shell之首。 打开方法：windows的win+R输入powershell回车即可打开powershell Bash Bash (GNU Bourne-Again Shell) 是许多Linux发行版的默认Shell Zsh Zsh是一个Linux用户很少使用的shell，这是由于大多数Linux产品安装，以及默认使用bash shell。几乎每一款Linux产品都包含有zsh，通常可以用apt-get、urpmi或yum等包管理器进行安装。（CentOS用yum） 安装zsh安装 oh-my-zsh 套件123[root@localhost ~]# yum install zsh -y[root@localhost ~]# yum -y install git[root@localhost ~]# sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; .oh-my-zsh 点开头，表示这是个隐藏文件！ 查看当前使用的SHELL123➜ ~ echo $SHELL/bin/bash➜ ~ 退出当前状态1➜ ~ exit 切换用户登录Shell的方法想用zsh的话就把指定用户最后登录shell设置为/bin/zsh* 12[root@localhost ~]# vim /etc/passwdroot:x0:0:root:/root:/bin/zsh 想用zsh的话就把指定用户最后登录shell设置为/bin/bash* 12[root@localhost ~]# vim /etc/passwdroot:x0:0:root:/root:/bin/bash 再打开一个xhell窗口验证一下： 修改zsh主题修改zsh主题为每次登录随机主题* 12[root@localhost ~]# vim .zshrc ZSH_THEME=&quot;random&quot; *#random就是随机主题 所有主题文件存放的位置 1[root@localhost ~]# ls ~/.oh-my-zsh/themes/ 修改zsh主题为每次登录主题为ys 12[root@localhost ~]# vim .zshrc ZSH_THEME=&quot;ys&quot; 再打开一个xhell窗口验证一下，ys主题如下图，还自带时间的呢（图中是下午三点哈）！ zsh安装智能补全插件12345678[root@localhost ~]# mkdir ~/.oh-my-zsh/plugins/incr[root@localhost ~]# cd ~/.oh-my-zsh/plugins/incr[root@localhost incr]# wget http://mimosa-pudica.net/src/incr-0.2.zsh[root@localhost incr]# chmod +x incr-0.2.zsh[root@localhost incr]# vim ~/.zshrc#在最后加上这一行，保存退出source ~/.oh-my-zsh/plugins/incr/incr*.zsh 如何切换到隐藏目录参考上面一行命令即可 1[root@localhost ~]# cd ~/.oh-my-zsh/plugins/incr 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-基础学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础学习-05 服务器基础环境配置和Yum软件仓库]]></title>
    <url>%2Flinux-05%2F</url>
    <content type="text"><![CDATA[linux-基础学习-05 服务器基础环境配置和Yum软件仓库查看和配置Linux系统的主机名：12345[root@localhost ~]# hostnamelocalhost.localdomain[root@localhost ~]# hostnamectl set-hostname abc[root@localhost ~]# hostnameabc 查看软件仓库列表1[root@localhost ~]# yum repolist 如下图，我的yum源都是阿里云仓库的源。 将Yum仓库替换成中科大的仓库（Centos 7）12345678910[root@localhost ~]# cd /etc/yum.repos.d/[root@localhost yum.repos.d]# mv CentOS-Base.repo CentOS-Base.repo.backup //备份[root@localhost yum.repos.d]# wget -O CentOS-Base.repo https://lug.ustc.edu.cn/wiki/_export/code/mirrors/help/centos?codeblock=3查看yum源名称，可以看到已经不是阿里云的了[root@localhost yum.repos.d]# yum repolist 清空之前的yum缓存和生成新的yum软件列表元数据[root@localhost yum.repos.d]# cd ~[root@localhost ~]# yum clean all &amp;&amp; yum makecache 配置网卡信息（配置固定IP地址）1[root@localhost ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33 将ens33网卡配置如下（备注可以不写）： 1234567891011121314151617181920TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot; # 设备获得IP的方式设置为静态获取，固定ipDEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;9c86a9bc-0939-4790-8580-274041e5eff3&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;y # 设备是否随着network的启动而启动IPADDR=192.168.141.12 # 设备的默认IPNETMASK=255.255.255.0 # 设备的默认掩码GATEWAY=192.168.141.2 # 设备的默认网关DNS1=114.114.114.114 # 设备DNSDNS2=8.8.8.8 重启网络服务（你改了网卡ip，xshell远程连接就会断掉，需要重新连接） 12345678910111213141516171819202122232425262728[root@localhost ~]# systemctl restart networkSocket error Event: 32 Error: 10053.Connection closing...Socket close.Connection closed by foreign host.Disconnected from remote host(Test) at 09:46:57.Type `help&apos; to learn how to use Xshell prompt.你可以手动重新连接：[C:\~]$ ssh root@192.168.141.12 Connecting to 192.168.141.12:22...Connection established.To escape to local shell, press &apos;Ctrl+Alt+]&apos;.WARNING! The remote SSH server rejected X11 forwarding request.Last login: Thu Jan 17 20:41:17 2019 from 192.168.141.1[root@localhost ~]# 连接成功！[root@localhost ~]# ip add可以看到ens33的ip已经变成192.168.141.12了！ 给网卡配置多个IP地址1[root@localhost ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33 将ens33网卡配置如下（备注可以不写）： 12345678910111213141516171819202122232425262728293031TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot; # 设备获得IP的方式设置为静态获取，固定ipDEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;9c86a9bc-0939-4790-8580-274041e5eff3&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;yIPADDR=192.168.141.12 # 第1个IPNETMASK=255.255.255.0 # 设备的默认掩码IPADDR0=192.168.141.13 # 第2个IP（secondary）NETMASK0=255.255.255.0IPADDR1=192.168.141.14 # 第3个IP（secondary）NETMASK1=255.255.255.0IPADDR2=192.168.141.15 # 第4个IP（secondary）NETMASK2=255.255.255.0GATEWAY1=192.168.141.2DNS1=114.114.114.114DNS2=8.8.8.8 注意事项（考试易错）： 首个ip是从IPADDR开始的，而从IPADDR0开始以及其之后的都是secondary 的网卡ip！这里一定要记住！ 有同学在考红帽认证的时候犯过这个错，望引以为戒！ 重启网络服务，查看网卡ip 12[root@localhost ~]# systemctl restart network[root@localhost ~]# ip add | grep inet 如下图，可以看到多出来3个新的ip 给Linux增加一块网卡，并且配置静态IP：在VMware里点虚拟机设置，给虚拟机添加一块网卡（不用将虚拟机关机） 查看网卡： 1[root@localhost ~]# ifconfig 如下图，多出来的end37网卡就是我们新增加的网卡，其ip目前还是它dhcp自动获取到的 新增的ens37是dhcp得到的IP，我们想自己配制成静态的IP，去/etc/sysconfig/network-scripts/目录下找ifcfg-ens37，发现没有这个配置文件，那里只有ens33的文件，哎！ 12[root@localhost ~]# cd /etc/sysconfig/network-scripts/[root@localhost network-scripts]# ls 因此，我们需要复制ens33的配置文件ifcfg-ens33为ifcfg-ens37，重新编辑其内容 1234[root@localhost network-scripts]# cp ifcfg-ens33 ifcfg-ens37[root@localhost network-scripts]# ls[root@localhost network-scripts]# vim ifcfg-ens37 其内容改为以下的形式： 123456789101112131415161718192021TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot;DEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens37&quot; # 修改网卡名UUID=&quot;9c86a9bc-0939-4790-8580-274041e5eff3&quot;DEVICE=&quot;ens37&quot; # 修改设备名ONBOOT=&quot;yes&quot;yIPADDR=192.168.141.111 #设置一个与之前ens33网卡的三个ip不同的ip NETMASK=255.255.255.0GATEWAY1=192.168.141.2DNS1=114.114.114.114DNS2=8.8.8.8 修改完成保存退出,重启网络服务 12[root@localhost network-scripts]# systemctl restart network[root@localhost network-scripts]# ifconfig ens37 如下图，网卡设置成功啦！ 注意事项： 将虚拟机关机再打开后，发现ens37的ip又变成了自动获取到的192.168.141.163，甚至有时候会发现ens37同时出现了两个ip：192.168.141.163和192.168.141.111 这种情况，并不是配错了，只要再次重启网络服务即可！ 12[root@localhost network-scripts]# systemctl restart network[root@localhost network-scripts]# ifconfig ens37 另外，在某些极端特殊的情况下，有时候，在重启虚拟机之后，两个网卡ens33和ens37都挂掉了，没有ip了，遇到这种情况，先尝试以下命令： 12ifup ens33ifup ens37 敲完之后网卡立马就up了，ip也有了。 ​ 之前没有ip是你的网卡down的原因，在以后玩虚拟机的时候，可能会由于某些操作失误导致网卡down掉，这时候只要敲上述的ifup命令就好了。 本篇到此结束，注意配置网卡的时候不要敲错了]]></content>
      <categories>
        <category>linux</category>
        <category>linux-基础学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础学习-04 Vim编辑器]]></title>
    <url>%2Flinux-04%2F</url>
    <content type="text"><![CDATA[linux-基础学习-04 Vim编辑器 Vim是一个类似于Vi的著名的功能强大、高度可定制的文本编辑器，在Vi的基础上改进和增加了很多特性。 系统里面会自带vi编辑器，但VIM是VI的扩展版本，所以需要手动安装 1[root@localhost ~]# yum install vim -y VIM编辑器三大模式：普通模式（命令模式）：进入VIM编辑器后默认的模式是普通模式（此时无法对文本进行改动） 输入模式（插入模式）：在普通模式下按insert键、a、i、o、O进入到输入模式，用Esc键可以从插入模式返回到普通模式 末行模式（底行命令模式）：在普通模式下按“:”进入末行模式，末行模式主要是各种搜索替换以及保存退出功能 搜索模式：在普通模式下按“/”,然后输入想要搜索的内容，按回车；在搜索模式下向下搜索直接按“/”回车，也可以在普通模式下用“n”向下搜索，大写的“N”为向上搜索 命令 作用 dd 删除（剪切）光标所在整行 5dd 删除（剪切）从光标处开始的5行 yy 复制光标所在整行 5yy 复制从光标处开始的5行 n 显示搜索命令定位到的下一个字符串 N 显示搜索命令定位到的上一个字符串 u 撤销上一步的操作 p 将之前删除（dd）或复制（yy）过的数据粘贴到光标后面 x 删除光标所在位置的字符 [n]x 删除光标所在位置以及之后的n个字符 G 快速到达文档尾部 Vim键盘功能表： 末行模式中可用的命令： 命令 作用 :w 保存 :q 退出 :q! 强制退出（放弃对文档的修改内容） :wq! 强制保存退出 :set nu 显示行号 :set nonu 不显示行号 :命令 执行该命令 :s/one/two 将当前光标所在行的第一个one替换成two :s/one/two/g 将当前光标所在行的所有one替换成two :%s/one/two/g 将全文中的所有one替换成two ?字符串 在文本中从下至上搜索该字符串 /字符串 在文本中从上至下搜索该字符串 使末行模式下配置的VIM环境永久生效1.修改/etc/vimrc让VIM配置对所有用户永久生效 2.修改~/.vimrc 用户家目录下的vimrc对当前用户永久生效 隐藏文件以”.”开头 1234[root@localhost ~]# vim .vimrc[root@localhost ~]# cat .vimrc set nuset ts=4 快速清空文档我们新建并编辑一个文档，里面随便敲几行字母，如下： 12345678[root@localhost ~]# vim test.txt[root@localhost ~]# cat test.txt osifhisudfsdufhisudsidfhisudsudhfisudhfsudhfsudfi[root@localhost ~]# 接下来vim打开test.txt，打开后默认是在命令行模式 1[root@localhost ~]# vim test.txt 此时在文档尾部还能看到文件名，如果是插入模式，那就会显示“插入”两个字 此时你按下gg，可以看到光标跳到了首行 此时你按下dG，可以看到文档内容被瞬间清空 然后你按下i，可以看到变成了插入模式，输入hello world 保存退出，再次查看文档内容，可以看到修改成功 利用可视块去除文本前面的行号 有时候，我们会从网上粘贴一些代码，但是由于一些配置文件修改时为了方便找到修改的内容在哪一行，许多作者都是习惯将行号也写出来的。那么，如何快速去除文本前面的行号呢？ 我们新建一个文本来演示一下，里面放5行，接下来尝试删掉11~15这5个行号 1234567[root@localhost ~]# vim hello.txt[root@localhost ~]# cat hello.txt 11 hello12 hello13 hello14 hello15 hello 用vim打开这个文件，此时默认就是命令行模式，底部还可以看到文件名 1[root@localhost ~]# vim hello.txt 按下ctrl+v，可以看到底部文字变成了“可视块”。 接下来按右方向键和上方向键，选中你要删除的部分内容块 接下来按下小写的x键，可以看到你选中的那些内容块直接被你删除了 接下来照常保存退出，再次查看hello.txt的内容，可以看到修改成功 撤销与恢复撤销 在使用VIM的时候，难免会有输错的情况，这个时候我们应该如何撤销，然后回到输错之前的状态呢？答案：使用u（小写，且在命令模式下）命令。 但如果有时我们一不小心在命令模式下输入了u，然后刚输入的一大片代码都不见了，这个时候我们应该如何恢复刚才的撤销操作呢？答案：使用Ctrl + r命令。 总结： 撤销：u 恢复撤销：Ctrl + r 现在来演示一遍 继续以上一个文档为例，我们在 12345678[root@localhost ~]# vim hello.txt[root@localhost ~]# cat hello.txt hellohellohellohellohello[root@localhost ~]# 首先用vim打开这个文件，按i进入插入模式，然后在文档底部随便加上一行字母 然后按Esc键，切换到命令行模式 此时，按下小写字母u，可以看到我们刚刚加上去的一大串字母不见了，这说明我们成功撤销掉了刚刚对文档的编辑修改。 现在再按下ctrl+r，可以看到，我们撤销掉的内容又回来了，说明恢复撤销成功了 然后保存退出即可 有了上面教的这几招，基本上就可以熟练使用vim了 本篇到此结束]]></content>
      <categories>
        <category>linux</category>
        <category>linux-基础学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础学习-03 linux必知必会的命令]]></title>
    <url>%2Flinux-03%2F</url>
    <content type="text"><![CDATA[linux-基础学习-03 linux必知必会的命令获取命令帮助123date --help //date查看系统时间，加了--help以看后面可以跟什么参数等date -hman date echoecho命令用于在终端输出字符串或变量提取后的值，格式为“echo [字符串 | $变量]”。1234567[root@localhost ~]# echo helloworldhelloworld[root@localhost ~]# echo &quot;helloworld&quot;helloworld[root@localhost ~]# i=&quot;helloworld&quot;[root@localhost ~]# echo $ihelloworld datedate查看时间以及设置时间相关命令，-s参数表示set设置 1234[root@localhost ~]# dateWed Jan 16 07:48:36 EST 2019[root@localhost ~]# date -s &quot;19961001 1:01:00&quot;Tue Oct 1 01:01:00 EDT 1996 ntpdate将系统的当前时间同步回网络时间1234[root@localhost ~]# ntpdate -u ntp.api.bz16 Jan 07:54:58 ntpdate[1494]: step time server 47.96.136.13 offset 703496889.865151 sec[root@localhost ~]# dateWed Jan 16 07:55:09 EST 2019 wget （Linux上的下载命令）12yum -y install wgetwget 链接地址 ps（静态任务管理器）用于查看系统中的进程状态，命令格式为：1ps [参数] 常用ps命令组合：1ps -aux -a：显示所有进程 -u：用户以及其他详细信息 -x：显示没有控制终端的进程 备注: 状态栏中，R表示正在运行的进程，S表示中断的进程，D表示不可终端的进程，Z表示僵尸进程，T表示停止的进程 TOP命令（动态任务管理器） TOP命令用于动态地监视进程活动与系统负载等信息，其格式为top。能够动态地查看系统运维状态，完全将它看作Linux中的“强化版的Windows任务管理器”。 第1行：系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。 第2行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。 第3行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。 第4行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。 第5行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量。 kill命令：结束后台进程为1的进程1[root@localhost ~]# kill %[后台进程号] 结束进程pid为1234的进程1[root@localhost ~]# kill 1234 结束进程pid为1234的进程树1[root@localhost ~]# kill -9 1234 pkill格式：pkill [进程名或者进程名的一部分连续字符串] 1[root@localhost ~]# pkill ss 系统状态检测命令查看和IP地址1ifconfig 临时修改IP地址1ifconfig ens33 192.168.9.101 netmask 255.255.255.0 free查看内存相关信息12[root@localhost ~]# free[root@localhost ~]# free -h who查看当前登入主机的用户终端信息：1[root@localhost ~]# who [参数] last：用于查看所有系统的登录记录：1[root@localhost ~]# last [参数] history用于显示历史执行过的命令，最多一千条：1[root@localhost ~]# history [-c] sosreport用于收集系统配置及架构信息并输出诊断文档：12[root@localhost ~]# yum install sos -y[root@localhost ~]# sosreport cd用于切换目录pwd用于显示当前所在目录123456789101112131415161718192021222324252627282930#切换到根目录*[root@localhost etc]# cd /[root@localhost /]# pwd#切换到/etc/yum.repos.d目录*[root@localhost /]# cd /etc/yum.repos.d/[root@localhost yum.repos.d]# pwd/etc/yum.repos.d#切换到当前目录的上一级目录*[root@localhost yum.repos.d]# cd .. *#“.”代表当前目录，两个“.”代表上一级目录*[root@localhost etc]# pwd/etc#切换到家目录*[root@localhost etc]# cd[root@localhost ~]# pwd/root[root@localhost ~]# cd ~[root@localhost ~]# pwd/root *#回到切换目录之前所在的目录* [root@localhost ~]# pwd /root [root@localhost ~]# cd /var/tmp/ [root@localhost tmp]# cd - /root [root@localhost ~]# pwd /root ls命令ls命令用于显示目录中的文件信息（Linux中一切皆文件），格式为“ls [选项] [文件] ”。在CentOS系列系统中，ls -l 默认别名有ll查看目录下文件的详细信息 1[root@localhost ~]# ls -l 查看目录下的隐藏文件 1[root@localhost ~]# ls -a 只查看目录本身的信息，不显示目录中的文件 12[root@localhost ~]# cd /[root@localhost /]# ls -ld /root/ tail命令tail命令用于查看纯文本文档的后N行或持续刷新内容，格式为“tail [选项] [文件]”。 动态追踪文本更新 123tail -f或者tailf 1[root@localhost ~]# tailf /var/log/messages cat文本输出命令,通常是用于观看某个文件的内容的1[root@localhost ~]# cat anaconda-ks.cfg trtr命令用于替换文本文件中的字符，格式为“tr [原始字符] [目标字符]”。1[root@localhost ~]# cat anaconda-ks.cfg | tr [a-z] [A-Z] stat查看文件或者文件系统的状态touchtouch命令用于创建空白文件或设置文件的时间，格式为“touch [选项] [文件]” 创建文件filea，查看该文件的状态 12[root@localhost ~]# touch filea[root@localhost ~]# stat filea 修改filea的最近访问和最近改动的时间 12[root@localhost ~]# touch -d &quot;19990101 01:01:01&quot; filea[root@localhost ~]# stat filea wc命令wc命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本” 统计系统中一共有多少个用户 1[root@localhost ~]# wc -l /etc/passwd 统计/etc/yum.repos.d/CentOS-Base.repo文件一共有多少字数 1[root@localhost ~]# wc -c /etc/yum.repos.d/CentOS-Base.repo 统计/etc/yum.repos.d/CentOS-Base.repo文件一共有多少个单词 1[root@localhost ~]# wc -w /etc/yum.repos.d/CentOS-Base.repo mkdir用于创建目录相对路径：相对于当前目录的路径 绝对路径：以/开头的路径（相对于根目录的路径） 在/root目录下新建目录aaa 1[root@localhost ~]# mkdir aaa 在/root目录下新建目录bbb(当你还在另一个目录时，利用../命令切换式创建) 12[root@localhost ~]# cd /var/tmp[root@localhost tmp]# mkdir ../../root/bbb 在/root目录下新建目录ccc（当你还在另一个目录时，利用绝对路径创建） 1[root@localhost tmp]# mkdir /root/ccc 递归创建目录 12[root@localhost tmp]# cd /root[root@localhost ~]# mkdir -p ddd/eee cp用于复制文件或目录格式为“cp [选项] 源文件 目标文件” 复制操作具体分为3种情况： 如果目标文件是目录，则会把源文件复制到该目录中； 如果目标文件也是普通文件，则会询问是否要覆盖它； 如果目标文件不存在，则执行正常的复制操作。 将家目录（/root目录）下的hello.c文件复制到/var/tmp目录下 12[root@localhost ~]# touch hello.c[root@localhost ~]# cp hello.c /var/tmp cp命令的参数及其作用 参数 作用 -p 保留原始文件的属性aa* -d 若对象为“链接文件”，则保留该“链接文件”的属性 -r 递归持续复制（用于目录）* -i 若目标文件存在则询问是否覆盖 -a 相当于-pdr（p、d、r为上述参数）*** mv用于剪切文件或将文件重命名格式为“mv [选项] 源文件 [目标路径|目标文件名]” 将hello.c重命名为 helloworld.c 1[root@localhost ~]# mv hello.c helloworld.c 将 helloworld.c剪切到/var/tmp目录下 1[root@localhost ~]# mv helloworld.c /var/tmp rm用于删除文件或目录格式为“rm [选项] 文件” 删除/var/tmp的hello.c文件（需要确认，敲y加回车） 1234[root@localhost ~]# cd /var/tmp[root@localhost tmp]# rm hello.crm: remove regular empty file ‘hello.c’? y[root@localhost tmp]# 不用确认（敲y加回车）直接删除helloworld.c 1[root@localhost tmp]# rm -f helloworld.c 删除家目录（/root目录）下的aaa目录（需要确认，敲y加回车） 1234[root@localhost tmp]# cd -[root@localhost ~]# rm -r aaarm: remove directory ‘aaa’? y[root@localhost ~]# 删除家目录（/root目录）下的bbb目录（不需要确认，不用敲y加回车） 1[root@localhost ~]# rm -rf bbb dd用于按照指定大小和个数的数据块来复制文件或转换文件格式为“dd [参数]” 生成一个大小为128M的空文件1dd if=/dev/zero of=128M_file count=1M bs=128 可以参考以下教程： http://www.runoob.com/linux/linux-comm-dd.html 将光盘中的文件制作成为光盘镜像（.ISO）1.插入光盘到Linux系统中 2.将光盘/dev/cdrom挂载到指定的目录，检查光盘是否能读取 12345[root@localhost ~]# mkdir /mnt/cdrom[root@localhost ~]# ls /mnt/cdrom[root@localhost ~]# mount /dev/cdrom /mnt/cdrom/mount: /dev/sr0 is write-protected, mounting read-only[root@localhost ~]# ls /mnt/cdrom 3.卸载已经挂载的目录，将光盘中的内容制作成虚拟光盘（ISO镜像文件） 123456789[root@localhost ~]# umount /mnt/cdrom[root@localhost ~]# ls /mnt/cdrom[root@localhost ~]# cd ~[root@localhost ~]# lsanaconda-ks.cfg[root@localhost ~]# dd if=/dev/cdrom of=/root/CentOS.iso[root@localhost ~]# lsanaconda-ks.cfg CentOS.iso[root@localhost ~]# 如下图，看到了CentOS.iso文件，这就是制作出来的光盘镜像 意外情况： ​ 如果你到挂在目录下卸载绝对会卸载失败，因为你在他的目录下占用着，卸载肯定失败！ 12345[root@localhost ~]# cd /mnt/cdrom/[root@localhost cdrom]# umount /mnt/cdrom/umount: /mnt/cdrom: target is busy. (In some cases useful info about processes that use the device is found by lsof(8) or fuser(1)) File用于查看文件的类型格式为“file 文件名” 12345678[root@localhost ~]#[root@localhost ~]# file CentOS.isoCentOS.iso: # ISO 9660 CD-ROM filesystem data &apos;CentOS 7 x86_64&apos; (bootable)[root@localhost ~]# file /dev/cdrom/dev/cdrom: symbolic link to `sr0&apos;[root@localhost ~]# file /dev/sr0/dev/sr0: block special[root@localhost ~]# tar用于打包压缩与搜索格式为“tar [选项] [文件]” 将/root目录打包为root.tar 123[root@localhost ~]# cd ..[root@localhost /]# tar -cvf root.tar /root/[root@localhost /]# ls 将/root目录打包并且使用gzip压缩算法打包到文件/root.tar.gz中 12[root@localhost /]# tar -czvf root.tar.gz /root[root@localhost /]# ls 加压缩算法和不加压缩算法对同一个目录打包的文件大小进行对比 12[root@localhost /]# ll -h root.tar[root@localhost /]# ll -h root.tar.gz 可以看出加了压缩算法后，压出来的包明显更小更节省空间！ .tar文件的解压命令 12[root@localhost /]# rm -rf /root/*[root@localhost /]# tar -xvf root.tar .tar.gz文件的解压命令 12345[root@localhost /]# rm -rf /root/*[root@localhost /]# ls /root[root@localhost /]# tar -xzvf root.tar.gz[root@localhost /]# ls /rootaaa.txt anaconda-ks.cfg text grep用于在文本中执行关键词搜索，并显示匹配的结果格式为“grep [选项] [文件]” 匹配所有不能登录系统的用户 1[root@localhost ~]# grep nologin /etc/passwd 匹配出所有没有被注释的行，且不是空行的行 1[root@localhost ~]# grep -v &quot;^#&quot; /etc/selinux/config | grep -v &quot;^$&quot; find用于按照指定条件来查找文件格式为“find [查找路径] 寻找条件 操作” 搜索/dev目录下所有硬盘和分区设备 1[root@localhost ~]# find /dev/ -name sd* 搜索磁盘中所有.conf格式的文件 1[root@localhost ~]# find / -name *.conf 本篇到此结束，这篇文章真长QAQ]]></content>
      <categories>
        <category>linux</category>
        <category>linux-基础学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础学习-02 Linux系统介绍和安装]]></title>
    <url>%2Flinux-02%2F</url>
    <content type="text"><![CDATA[linux-基础学习-02 Linux系统介绍和安装一、安装软件，新建虚拟机 在360软件管家下载安装VMware Workstation Pro，点击创建新的虚拟机即可。现在最新版本的是VMware Workstation Pro 15版本，然而这玩意儿竟然要付费，很多人就望而却步。 其实网上还是可以搜索到许多激活密钥的，如下，任选一个即可。 1234567891011YG5H2-ANZ0H-M8ERY-TXZZZ-YKRV8UG5J2-0ME12-M89WY-NPWXX-WQH88UA5DR-2ZD4H-089FY-6YQ5T-YPRX6GA590-86Y05-4806Y-X4PEE-ZV8E0ZF582-0NW5N-H8D2P-0XZEE-Z22VAYA18K-0WY8P-H85DY-L4NZG-X7RAD ​ 创建新的虚拟机很简单，此处不再赘述，但是虚拟机处理器的内核总数必须≤物理机逻辑处理器总数。 可以在任务管理器查看到自己的物理机逻辑处理器数量： centos镜像下载地址https://www.centos.org/download/ VMware Workstation Pro快捷键Ctrl+Alt+Enter：从物理机进入到全屏的虚拟机 Ctrl+Alt：将鼠标光标从虚拟机释放出来 二、Centos开机密码破解（救援模式）第一步：重启Linux，在系统boot引导界面迅速按键e键进入boot编辑模式 第二步：找到linux16开头的行，将内容删除至ro（ro不要删），在ro后面添加空格和“rd.break” 修改为： 第三步：按ctrl+x键进入到救援模式 键入以下命令： 123456switch_root:/# mount -o remount,rw /sysrootswitch_root:/# chroot /sysrootsh-4.2# passwd root //在交互模式下输入两次密码（提示BAD PASSWORD不用管）sh-4.2# touch /.autorelabel //初学linux时，特别多的人会忘了敲这条命令或者label写错！sh-4.2# exitswitch_root:/# exit 注意：如果你的密码带有数字，登录系统的时候如果你敲的是小键盘，一定要注意小键盘有没有没被你NumLock掉！初学者容易被坑，说老是登录不上去。 PS: 意外情况1： ​ 有时候会出现乱码，用命令行改语言为english即可。 命令： 1LANG=en 意外情况2： ​ 有时候会有提示密码长度不得小于8位，不过短密码也是可以使用的，不一定非得长于8位！ 意外情况3： ​ 有时候会有提示密码是一个回文数，不过其实回文数密码也是可以使用的。 意外情况4： ​ 如果你设置的密码不是回文数，不是短密码，比如设置为123456789，它还是提醒你BAD PASSWORD 因为它太简单了，但是同上，即使简单，也是不妨碍咱们使用的。 意外情况5：​ 密码字典检查失败，密码字典内没有该词 意外情况N： ​ 至于其他意外情况诸如此类，基本套路就是BAD PASSWORD可以用但是不安全。如下图，我把上述所有种类的所谓BAD PASSWORD均尝试了一遍，都可以登录上去！ 三、远程登录Linux1.下载安装XShell或者SecureCRT，这里以XShell为例，在360软件管家就能下载到。然后根据自己的喜好设置一下XShell的颜色、字体、透明度等。 2.查看虚拟机ip地址： 1ip address 3.在windows上打开终端软件（推荐XShell或者SecureCRT）远程连接到Linux系统，输入root密码即可。 命令： 1ssh root@ip 4.建议把会话保存起来，下次再打开的时候就不用再输入命令打开了,记住在用户登录验证那里输入密码。 5.关键操作之后，一定要记得拍快照（关机之后快照） 6.意外情况： ​ 如果在虚拟机里发现有ip，但windows和虚拟机无法通信，ssh连接不上去，在虚拟机里ping一下当前的网关地址， 然后windows再ping虚拟机，就应该能通信，这时候ssh就没有问题了。 四、基本命令介绍RPM（redhat package managment）安装命令rpm软件商店：http://rpmfind.net/linux/RPM/ 安装rpm包，你需要到上述软件商店下载相应的rpm包到虚拟机里，然后用下列安装命令进行安装。但是这个听起来就很麻烦，而且很多时候安装a包往往都根据其依赖关系，要求先安装c包、d包、e包……，非常不人性化。所以yum安装命令才是主流，只有当yum命令装不了，或者说yum软件仓库里没有你要装的包时，再来考虑用rpm安装。 安装软件的命令格式 rpm -ivh filename.rpm 升级软件的命令格式 rpm -Uvh filename.rpm 卸载软件的命令格式 rpm -e filename.rpm 查询软件描述信息的命令格式 rpm -qpi filename.rpm 列出软件文件信息的命令格式 rpm -qpl filename.rpm 查询文件属于哪个RPM的命令格式 rpm -qf filename Yum （黄狗更新管理器，yellow update managment）安装代码补全工具1[root@localhost ~]# yum install bash-completion -y 注意：代码补全工具安装好之后并不能立即生效，要重启bash。如果用的XShell远程连接虚拟机的话，关掉连接窗口，再次连接一下之后即可自动补全命令了。 安装常用工具1[root@localhost ~]# yum install vim screen unzip net-tools -y 安装扩展yum源1[root@localhost ~]# yum install epel-release -y 有时候很多包域名软件仓库里没有，可以安装扩展源，然后再次安装，就能安装成功了。 下表笔记中加星号的是目前必须掌握的 命令 作用 yum repolist all 列出所有仓库 yum list all 列出仓库中所有软件包 yum info 软件包名称 查看软件包信息 *yum install 软件包名称 安装软件包 yum reinstall 软件包名称 重新安装软件包 yum update 软件包名称 升级软件包 *yum remove 软件包名称 移除软件包 *yum clean all 清除所有仓库缓存 yum check-update 检查可更新的软件包 yum grouplist 查看系统中已经安装的软件包组 yum groupinstall 软件包组 安装指定的软件包组 yum groupremove 软件包组 移除指定的软件包组 yum groupinfo 软件包组 查询指定的软件包组信息 清理yum源缓存1yum clean all 建立yum源缓存1yum makecache 搜索软件仓库中的软件12yum search 软件名或者软件名的一部分yum list | grep 软件名或者软件名的一部分 systemctl系统管理命令重启 [root@localhost ~]# systemctl reboot [root@localhost ~]# reboot [root@localhost ~]# init 6 关机 [root@localhost ~]# systemctl poweroff [root@localhost ~]# poweroff [root@localhost ~]# init 0 参数作用：-i：安装软件install -U：升级软件update -e：卸载软件 -v：显示详细信息 -h：显示操作的进度 修改主机名1234567891011121314151617181920[root@localhost ~]# hostnamectl set-hostname test[root@localhost ~]# exit登出Connection closing...Socket close.Connection closed by foreign host.Disconnected from remote host(client) at 12:51:54.Type `help&apos; to learn how to use Xshell prompt.[C:\~]$ ssh root@192.168.141.69Connecting to 192.168.141.69:22...Connection established.To escape to local shell, press &apos;Ctrl+Alt+]&apos;.WARNING! The remote SSH server rejected X11 forwarding request.Last login: Thu Mar 7 12:37:53 2019 from 192.168.141.1[root@test ~]# 可以看到，重新登录后主机名称变成了test linux文件系统（Centos）]]></content>
      <categories>
        <category>linux</category>
        <category>linux-基础学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础学习-01 课程大纲思维导图]]></title>
    <url>%2Flinux-01%2F</url>
    <content type="text"><![CDATA[linux-基础学习-01 课程大纲思维导图课程大纲思维导图 目标：学好所有知识点，考取红帽认证（RHCE），进阶运维工程师！]]></content>
      <categories>
        <category>linux</category>
        <category>linux-基础学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos</tag>
        <tag>RedHat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO-08 微博图床限制外链问题]]></title>
    <url>%2Fhexo-08%2F</url>
    <content type="text"><![CDATA[HEXO-08 微博图床限制外链问题解决误删环境变量导致的报错1、问题描述：使用所有与hexo相关的命令，均报错： 1/c/Users/zhong/AppData/Roaming/npm/hexo: line 12: node: command not found 2、原因：环境变量被删除 3、解决办法：在系统变量和用户变量的path里，新建如下三条 1C:\Users\zhong\AppData\Roaming\npm 1D:\software\NODEJS 1C:\Users\zhong\AppData\Roaming\npm\node_modules\hexo\bin 4、问题已解决]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO-07-微博图床限制外链问题]]></title>
    <url>%2Fhexo-07%2F</url>
    <content type="text"><![CDATA[HEXO-07-微博图床限制外链问题 2019-4-26日左右，好多人惊恐地发现自己hexo博客上图片无法显示了，但是图片链接单独在网页上还能打开。这是由于微博图床开始限制外链了，建议将图片转移到其他图床，否则后面如果微博做出更加严格的外链限制，那可真就神仙难救了。 但是就目前来说，暂时的补救办法还是有的。按照下面的步骤即可让微博图床图片恢复显示。 方法：给head文件里面添加no-ferrer避免微博服务器发现你的网站引用了它的图片。 步骤1.以next主题为例，编辑下面这个文件： 1D:\Blog\themes\next\layout\_partials\head\head.swig 在文件中增加一行 1&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; 这样所有页面都会以no-referrer这样方法加载了，微博服务器也就不会发现你的网站引用了它的图片，外链限制解决。但是切记后面可能会有更加严格的限制，真是提心吊胆，建议趁早换个图床吧。 本篇到此结束]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO-06-coding 认证问题]]></title>
    <url>%2Fhexo-06%2F</url>
    <content type="text"><![CDATA[HEXO-06-coding 认证问题 由于coding的安全机制，它会不定时选择某一天，当你敲下hexo d时弹出一个窗口，让你输入coding的用户名和密码，万一你输错了，那么后面这个窗口直接不弹出来，然后每次你敲hexo d是都会报错，关机重启也没用，连一个给你改过的机会都不给，实在有违人道！ 但是，其实解决办法还是有的。 在控制面板打开凭据管理器 找到这个coding的凭据，点击编辑 在这里输入你的coding的用户名和密码，再次hexo d的时候就不会再报错了。 coding的用户名不是你的coding账号名，而是用户名，不要搞错了。 后来想想，每个一段时间就要这样认证一次，估计是电脑里保存的那个凭据有一定时长的有效期，到期了就得重新认证。 本篇到此结束]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO-05-博客部署]]></title>
    <url>%2Fhexo-05%2F</url>
    <content type="text"><![CDATA[HEXO-05-博客部署首先，以部署到github为例 GitHub官网: https://github.com Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。 123$ hexo deploy或者$ hexo d 在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如： 12deploy: type: git 您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。 12345deploy:- type: git repo:- type: git repo: 缩进YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。 修改配置 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 参数 描述 repo 仓库（Repository）地址 branch 分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。 message 自定义提交信息 默认为当前时间 具体步骤1.在github注册账号，登录，然后新建一个仓库，仓库名称格式：github用户名.github.io 如下图中，我的github用户名是ZhongEagles，于是我就创建了仓库：ZhongEagles.github.io 2.创建好后复制github用户名.github.io仓库的链接，至于复制链接的地方很好找，比如下面这个aaa仓库的连接如下图： 3.将复制下来的连接粘贴到Blog根目录下的_config.yml的文档底部，按ctrl+s保存，如下图： 4.在根目录git bash，敲入以下命令，将网站部署到服务器上。 123$ hexo deploy或者$ hexo d 5.部署好之后，可以看到自己本地的文件以及上传到github仓库里了 6.点击settings选项，往下找，找到GitHub Pages，点击连接即可访问你的博客网站了！ 7.同样的道理，可以部署到coding，这里不再赘述，但是一定要记得coding上新建的仓库名称和仓库地址格式： coding用户名.coding.me 否则你就需要另外配置_config.yml了，涉及到子目录操作。 8.至于如何将本地博客同时部署到github和coding，按照上述教程，写两个deployer即可。 1234567deploy:type: gitrepo:type: gitrepo:]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO-04-文章写作]]></title>
    <url>%2Fhexo-04%2F</url>
    <content type="text"><![CDATA[HEXO-04-文章写作我们之前利用命令行 1hexo new aaa 创建好了一个aaa.md的文件，而且也安装好了PicGO图床神器和Atom+Typora两款编辑器，现在咱们开始研究如何写文章。 PS：Atom+Typora虽然都是编辑器，但是Typora主要用于编辑markdown文档，而Atom主要用于编辑HEXO的相关配置文件，虽然二者角色可以互换，但是各有所长，还是各尽其能的好。 利用Atom编辑文档我们用Atom打开aaa.md进行编辑： 可以看到创建文档时就自动生成好了的文档头部：Front-matter Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： 123title: Hello Worlddate: 2013/7/13 20:46:25--- 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 分类和标签 只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 12345categories:- Diarytags:- PS3- Games 分类方法的分歧 如果您有过使用WordPress的经验，就很容易误解Hexo的分类方式。WordPress支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是Hexo不支持指定多个同级分类。下面的指定方法：categories:- Diary- Life会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分 插入本地图片本地图片统一放在source/images文件夹中例如: source/images/test.jpg 12![](/images/test.jpg)&lt;img src="/images/test.jpg"&gt; 插入网络图片12![](网络图片地址)&lt;img src="网络图片地址"&gt; 我们可以随便在文档里写一些东西，插入一个我们之前用PicGO上传到微博图床上的图片，按ctrl+s保存。 接下来我们到HEXO根目录也就是Blog文件夹下git bash 即在Blog文件夹里右键git bash here打开命令行窗口，依次敲下列命令： 命令行 注释 hexo g hexo generate的简写，生成静态文件 hexo s hexo server的简写，启动本地服务器 浏览器打开http://localhost:4000查看效果！ 利用Typora编辑文档Typora是markdown文档编辑神器，简洁的界面无需任何教学，打开就能使用。这里依然以aaa.md为例： 我们在PicGO相册里随便照一张图片，复制链接，将这个链接粘贴到用Typora打开的aaa.md文档里： 可以看到，链接粘过去直接就显示出图片来了，然鹅你讲链接粘贴到记事本、word、Atom等编辑器那是显示不出图片来的，它只是链接而已。 所以用Typora来编辑markdown文档比用Atom好，Atom还是留着专门用于编辑和修改HEXO的配置文件吧。 利用Editor.md编辑文档 接下来介绍一款开源在线 Markdown 编辑器：Editor.md 我们已经安装了Typora+PicGO+Atom三款神器了，按理来说也够用了，但是尺有所短，寸有所长，Typora简洁而且功能强大，但是Editor.md这款编辑器也具有Typora所没有的特点，那就是“在线编辑” Editor.md的网址： https://pandao.github.io/editor.md/ 在里面查看完整实例，可以找到各种段落格式标题等，如果哪天发现自己在Typora上编辑一个自己想要的文本格式却到处都找不到的如何设置时，可以到这个在线编辑网站直接找到那种格式的文本粘贴过来用。 所以，最好的搭配是Editor.md+Typora搭配使用，至于哪个用的多，就是萝卜青菜各有所爱了。 下回分解：HEXO博客部署]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO-03-写作工具准备]]></title>
    <url>%2Fhexo-03%2F</url>
    <content type="text"><![CDATA[HEXO-03-写作工具准备hexo文章支持采用markdown标记语言写作，上一节中新建的hexo文章aaa也是.md后缀的文件。 本节主要任务是准备两个写作工具：PicGo+Typora 介绍：PicGo PicGo是一款图床神器，我们平时在写markdown文档时肯定会引用很多的图片，然后这些图片是不可以直接贴上去的，我们就会通过一些网站的引用进而使用这些图片。 之前我们在调用照片的时候，先是将其上传到微博或者github等网站上，再通过该图片在网站上对应的路径地址来获取到图片。为了简化该过程，某大神将该流程写成了一套自动化应用。 简单来讲，就是把自己电脑上的本地图片放到了网络图床上，以后自己写markdown文档时，只需要将图片链接粘贴到文档里即可看到该图片了！ PicGo基本操作示例： Typora Typora是一款既接近程序员码字风格，又可以用于普通文本排版的编辑器，堪称用来写markdown文档的神器，PicGo+Typora的搭配更是绝配！ 具体步骤1.官网下载Typora： https://www.typora.io/ 2.下载安装包 https://github.com/Molunerfinn/PicGo/releases PS：如果条件允许，尽量翻墙下载，否则下载速度可能会很慢 3.安装PicGo、Typora，这个很简单，安装完成后Typora可以直接使用了，但是PicGo还需要做如下配置。 4.右键打开PicGo详细窗口，此处以微博图床为例，写好微博用户名和密码，启用使用cookie上传的功能，接下来要去找你的cookie： （1）用浏览器打开微博网址，登录上去： https://weibo.com/ （2）然后进入微博的minipublish页面，可以用浏览器输入以下网址后按F12，找到网络（network） https://weibo.com/minipublish （3）刷新页面，找到minipublish的头部（head），找到cookie，将cookie：后面的东西复制下来，注意不要将“cookie：”这个标识也复制下来了。 （4）将复制下来的内容粘贴到PicGO-&gt;微博图床设置-&gt;设定cookie那里，点击确定即可。 （5）接下来你就可以用PicGO上传图片到相册里了，PicGO里的相册指的是微博图床，而不是你的微博相册，所以不必担心图片会乱窜。 下回分解：HEXO文章写作]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO-02-文章创建]]></title>
    <url>%2Fhexo-02%2F</url>
    <content type="text"><![CDATA[HEXO-02-文章创建你可以执行下列命令来创建一篇新文章 1$ hexo new [layout] &lt;title&gt; 您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 布局（Layout） Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局 路径 post source/_posts page source draft source/_drafts 不要处理我的文章 如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false 。 文件名称Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。 变量 描述 :title 标题（小写，空格将会被替换为短杠） :year 建立的年份，比如， 2015 :month 建立的月份（有前导零），比如， 04 :i_month 建立的月份（无前导零），比如， 4 :day 建立的日期（有前导零），比如， 07 :i_day 建立的日期（无前导零），比如， 7 草稿 刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，您可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。 1$ hexo publish [layout] &lt;title&gt; 草稿默认不会显示在页面中，您可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。 模版（Scaffold）在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： 1$ hexo new photo &quot;My Gallery&quot; 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期 创建文章举例 至此，文章创建成功！ 下回分解：HEXO文章写作]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO-01-本地服务]]></title>
    <url>%2Fhexo-01%2F</url>
    <content type="text"><![CDATA[HEXO-01-本地服务参考自HEXO官网：https://hexo.io/zh-cn/ 什么是 Hexo？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 HEXO安装准备安装 Hexo 只需几分钟时间，利用git bash键入命令行即可。 安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 1$ npm install -g hexo-cli 如果您的电脑中尚未安装所需要的程序，可以参考以下安装指示完成安装。 HEXO安装教程1.下载安装旧版node.js，本次我用的是v6.9.0，下面这个网址那里有历史版本的node.js可以下载 下载地址：https://nodejs.org/dist/ 记住下载.msi后缀名的安装包即可。 PS:之所以用历史版本，是因为最新版或较新的版本会出错。 2.下载安装git和Atom（文件编辑器），二者均可在360软件管家下载，也可以在相应官网下载。 3.在D盘新建HEXO文件夹用作本地仓库，里面的东西可以使用相关命令行上传到github和coding的仓库里。 4.在Blog文件夹里右键git bash here打开命令行窗口，依次敲下列命令，执行完一条再敲下一条命令。 PS:记住用git bash安装东西最好翻个墙，那样速度会快很多。 命令行 注释 npm install hexo -g 全局安装hexo npm install hexo-cli -g 全局安装hexo-cli hexo init 新建一个网站 npm install hexo-deployer-git –save 安装hexo-deployer-git hexo generate 生成静态文件 hexo serve 启动本地服务器 5.右键如下图网址打开本地网站，先预览一下网站效果 6.也可以在浏览器手动输入网址：http://localhost:4000/ 至此，本地的HEXO安装成功！ 上图显示的是HEXO默认主题，接下来咱们可以先挑个好看的主题，主题官网：https://hexo.io/themes/ 此处以NEXT主题为例 NEXT主题安装1.进入HEXO主题官网：https://hexo.io/themes/，搜索并点击NexT，进入其github源码页面 2.下载next主题压缩包 3.将下载好的压缩包解压到themes目录下，原来的压缩包就没用了，可以删除掉 4.将解压出来的文件夹重命名为next 5.接下来修改HEXO根目录下的配置文件，其名称是_config.yml 6.初始时HEXO用的是默认主题landscape，现在将它改成next，改好后记得按ctrl+s进行保存，否则改动不会生效！ 7.接下来在Blog文件夹里右键git bash here打开命令行窗口，依次敲下列命令： 命令行 注释 hexo g hexo generate的简写，生成静态文件 hexo s hexo server的简写，启动本地服务器 8.浏览器打开http://localhost:4000可以看到主题更换成功！ 但是这个主题貌似不怎么漂亮，那是因为现在看到的只是next主题的三个样式里的其中一个默认样式，接下来到next目录下修改_config.yml配置文件，不要进错目录！ 10.将默认样式注释掉，启用Pisces样式，别忘了按ctrl+s保存，否则改动不会生效！ 11.浏览器打开http://localhost:4000可以看到主题样式更换成功！接下来可以参考网上教程美化主题，给自己加个头像等。 下回分解：HEXO文章创建]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[testmd]]></title>
    <url>%2Ftestmd%2F</url>
    <content type="text"><![CDATA[Editor.md 目录 (Table of Contents) [TOCM] [TOC] Heading 1Heading 2Heading 3Heading 4Heading 5Heading 6Heading 1 link Heading linkHeading 2 link Heading linkHeading 3 link Heading linkHeading 4 link Heading link Heading link Heading linkHeading 5 link Heading linkHeading 6 link Heading link标题（用底线的形式）Heading (underline)This is an H1This is an H2字符效果和横线等 删除线 删除线（开启识别HTML标签时）斜体字 斜体字粗体 粗体粗斜体 粗斜体 上标：X2，下标：O2 缩写(同HTML的abbr标签) 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启 The HTML specification is maintained by the W3C. 引用 Blockquotes 引用文本 Blockquotes 引用的行内混合 Blockquotes 引用：如果想要插入空白换行即&lt;br /&gt;标签，在插入处先键入两个以上的空格然后回车即可，普通链接。 锚点与链接 Links普通链接 普通链接带标题 直接链接：https://github.com 锚点链接 mailto:test.test@gmail.com GFM a-tail link @pandao 邮箱地址自动链接 test.test@gmail.com www@vip.qq.com @pandao 多语言代码高亮 Codes行内代码 Inline code执行命令：npm install marked 缩进风格即缩进四个空格，也做为实现类似 &lt;pre&gt; 预格式化文本 ( Preformatted Text ) 的功能。 &lt;?php echo &quot;Hello world!&quot;; ?&gt; 预格式化文本： | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | JS代码 123456789101112131415161718192021222324252627282930313233343536function test() &#123; console.log("Hello world!");&#125;(function()&#123; var box = function() &#123; return box.fn.init(); &#125;; box.prototype = box.fn = &#123; init : function()&#123; console.log('box.init()'); return this; &#125;, add : function(str) &#123; alert("add", str); return this; &#125;, remove : function(str) &#123; alert("remove", str); return this; &#125; &#125;; box.fn.init.prototype = box.fn; window.box =box;&#125;)();var testBox = box();testBox.add("jQuery").remove("jQuery"); HTML 代码 HTML codes1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest="utf-8" /&gt; &lt;meta name="keywords" content="Editor.md, Markdown, Editor" /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;style type="text/css"&gt; body&#123;font-size:14px;color:#444;font-family: "Microsoft Yahei", Tahoma, "Hiragino Sans GB", Arial;background:#fff;&#125; ul&#123;list-style: none;&#125; img&#123;border:none;vertical-align: middle;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class="text-xxl"&gt;Hello world!&lt;/h1&gt; &lt;p class="text-green"&gt;Plain text&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 图片 ImagesImage: Follow your heart. 图为：厦门白城沙滩 图片加链接 (Image + Link)： 图为：李健首张专辑《似水流年》封面 列表 Lists无序列表（减号）Unordered Lists (-) 列表一 列表二 列表三 无序列表（星号）Unordered Lists (*) 列表一 列表二 列表三 无序列表（加号和嵌套）Unordered Lists (+) 列表一 列表二 列表二-1 列表二-2 列表二-3 列表三 列表一 列表二 列表三 有序列表 Ordered Lists (-) 第一行 第二行 第三行 GFM task list GFM task list 1 GFM task list 2 GFM task list 3 GFM task list 3-1 GFM task list 3-2 GFM task list 3-3 GFM task list 4 GFM task list 4-1 GFM task list 4-2 绘制表格 Tables 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 First Header Second Header Content Cell Content Cell Content Cell Content Cell First Header Second Header Content Cell Content Cell Content Cell Content Cell Function name Description help() Display the help window. destroy() Destroy your computer! Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 Item Value Computer $1600 Phone $12 Pipe $1 特殊符号 HTML Entities Codes&copy; &amp; &uml; &trade; &iexcl; &pound;&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot; X&sup2; Y&sup3; &frac34; &frac14; &times; &divide; &raquo; 18&ordm;C &quot; &apos; [========] Emoji表情 :smiley: Blockquotes :star: GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x: :smiley: @mentions, :smiley: #refs, links, formatting, and tags supported :editormd-logo:; list syntax required (any unordered or ordered list supported) :editormd-logo-3x:; [ ] :smiley: this is a complete item :smiley:; []this is an incomplete item test link :fa-star: @pandao; [ ]this is an incomplete item :fa-star: :fa-gear:; :smiley: this is an incomplete item test link :fa-star: :fa-gear:; :smiley: this is :fa-star: :fa-gear: an incomplete item test link; 反斜杠 Escape*literal asterisks* [========] 科学公式 TeX(KaTeX)$$E=mc^2$$ 行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。 $$x &gt; y$$ $$(\sqrt{3x-1}+(1+x)^2)$$ $$\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))$$ 多行公式： 12345\displaystyle\left( \sum\_&#123;k=1&#125;^n a\_k b\_k \right)^2\leq\left( \sum\_&#123;k=1&#125;^n a\_k^2 \right)\left( \sum\_&#123;k=1&#125;^n b\_k^2 \right) 123456789\displaystyle \frac&#123;1&#125;&#123; \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123; \frac25 \pi&#125;&#125; = 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123; 1+\frac&#123;e^&#123;-6\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125; &#123;1+\cdots&#125; &#125; &#125; &#125; 123f(x) = \int_&#123;-\infty&#125;^\infty \hat f(\xi)\,e^&#123;2 \pi i \xi x&#125; \,d\xi 分页符 Page break Print Test: Ctrl + P [========] 绘制流程图 Flowchart12345678st=&gt;start: 用户登陆op=&gt;operation: 登陆操作cond=&gt;condition: 登陆成功 Yes or No?e=&gt;end: 进入后台st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op [========] 绘制序列图 Sequence Diagram1234Andrew-&gt;China: Says HelloNote right of China: China thinks\nabout itChina--&gt;Andrew: How are you?Andrew-&gt;&gt;China: I am good thanks! End]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo!参考教程：documentation参考教程：troubleshooting参考教程：GitHub. 新建文章：1$ hexo new "文章标题" 参考教程: Writing 运行本地服务1$ hexo server 参考教程: Server 生成静态文件1$ hexo generate 参考教程: Generating 部署到远程站点1$ hexo deploy 参考教程: Deployment]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>helloworld</tag>
      </tags>
  </entry>
</search>
